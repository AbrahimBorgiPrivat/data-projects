C˜ú‚¸Š;º&*¦¶ˆ\¶ÓN‰ò:4e|ã6
"•¬àvar Yt = Object.defineProperty;
var Xt = (u, l, f) => l in u ? Yt(u, l, { enumerable: !0, configurable: !0, writable: !0, value: f }) : u[l] = f;
var me = (u, l, f) => (Xt(u, typeof l != "symbol" ? l + "" : l, f), f), bt = (u, l, f) => {
  if (!l.has(u))
    throw TypeError("Cannot " + f);
};
var ge = (u, l, f) => (bt(u, l, "read from private field"), f ? f.call(u) : l.get(u)), Oe = (u, l, f) => {
  if (l.has(u))
    throw TypeError("Cannot add the same private member more than once");
  l instanceof WeakSet ? l.add(u) : l.set(u, f);
}, Be = (u, l, f, p) => (bt(u, l, "write to private field"), p ? p.call(u, f) : l.set(u, f), f);
var Ne = (u, l, f) => (bt(u, l, "access private method"), f);
function noop$4() {
}
const identity$5 = (u) => u;
function assign(u, l) {
  for (const f in l)
    u[f] = l[f];
  return (
    /** @type {T & S} */
    u
  );
}
function is_promise(u) {
  return !!u && (typeof u == "object" || typeof u == "function") && typeof /** @type {any} */
  u.then == "function";
}
function add_location(u, l, f, p, m) {
  u.__svelte_meta = {
    loc: { file: l, line: f, column: p, char: m }
  };
}
function run(u) {
  return u();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(u) {
  u.forEach(run);
}
function is_function(u) {
  return typeof u == "function";
}
function safe_not_equal(u, l) {
  return u != u ? l == l : u !== l || u && typeof u == "object" || typeof u == "function";
}
let src_url_equal_anchor;
function src_url_equal(u, l) {
  return u === l ? !0 : (src_url_equal_anchor || (src_url_equal_anchor = document.createElement("a")), src_url_equal_anchor.href = l, u === src_url_equal_anchor.href);
}
function split_srcset(u) {
  return u.split(",").map((l) => l.trim().split(" ").filter(Boolean));
}
function srcset_url_equal(u, l) {
  const f = split_srcset(u.srcset), p = split_srcset(l || "");
  return p.length === f.length && p.every(
    ([m, b], y) => b === f[y][1] && // We need to test both ways because Vite will create an a full URL with
    // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
    // relative URLs inside srcset are not automatically resolved to absolute URLs by
    // browsers (in contrast to img.src). This means both SSR and DOM code could
    // contain relative or absolute URLs.
    (src_url_equal(f[y][0], m) || src_url_equal(m, f[y][0]))
  );
}
function not_equal(u, l) {
  return u != u ? l == l : u !== l;
}
function is_empty(u) {
  return Object.keys(u).length === 0;
}
function validate_store(u, l) {
  if (u != null && typeof u.subscribe != "function")
    throw new Error(`'${l}' is not a store with a 'subscribe' method`);
}
function subscribe(u, ...l) {
  if (u == null) {
    for (const p of l)
      p(void 0);
    return noop$4;
  }
  const f = u.subscribe(...l);
  return f.unsubscribe ? () => f.unsubscribe() : f;
}
function get_store_value(u) {
  let l;
  return subscribe(u, (f) => l = f)(), l;
}
function component_subscribe(u, l, f) {
  u.$$.on_destroy.push(subscribe(l, f));
}
function create_slot(u, l, f, p) {
  if (u) {
    const m = get_slot_context(u, l, f, p);
    return u[0](m);
  }
}
function get_slot_context(u, l, f, p) {
  return u[1] && p ? assign(f.ctx.slice(), u[1](p(l))) : f.ctx;
}
function get_slot_changes(u, l, f, p) {
  if (u[2] && p) {
    const m = u[2](p(f));
    if (l.dirty === void 0)
      return m;
    if (typeof m == "object") {
      const b = [], y = Math.max(l.dirty.length, m.length);
      for (let v = 0; v < y; v += 1)
        b[v] = l.dirty[v] | m[v];
      return b;
    }
    return l.dirty | m;
  }
  return l.dirty;
}
function update_slot_base(u, l, f, p, m, b) {
  if (m) {
    const y = get_slot_context(l, f, p, b);
    u.p(y, m);
  }
}
function update_slot(u, l, f, p, m, b, y) {
  const v = get_slot_changes(l, p, m, b);
  update_slot_base(u, l, f, p, v, y);
}
function get_all_dirty_from_scope(u) {
  if (u.ctx.length > 32) {
    const l = [], f = u.ctx.length / 32;
    for (let p = 0; p < f; p++)
      l[p] = -1;
    return l;
  }
  return -1;
}
function exclude_internal_props(u) {
  const l = {};
  for (const f in u)
    f[0] !== "$" && (l[f] = u[f]);
  return l;
}
function compute_rest_props(u, l) {
  const f = {};
  l = new Set(l);
  for (const p in u)
    !l.has(p) && p[0] !== "$" && (f[p] = u[p]);
  return f;
}
function compute_slots(u) {
  const l = {};
  for (const f in u)
    l[f] = !0;
  return l;
}
function once$1(u) {
  let l = !1;
  return function(...f) {
    l || (l = !0, u.call(this, ...f));
  };
}
function null_to_empty(u) {
  return u ?? "";
}
function set_store_value(u, l, f) {
  return u.set(f), l;
}
const has_prop = (u, l) => Object.prototype.hasOwnProperty.call(u, l);
function action_destroyer(u) {
  return u && is_function(u.destroy) ? u.destroy : noop$4;
}
function split_css_unit(u) {
  const l = typeof u == "string" && u.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return l ? [parseFloat(l[1]), l[2] || "px"] : [
    /** @type {number} */
    u,
    "px"
  ];
}
const contenteditable_truthy_values = ["", !0, 1, "true", "contenteditable"], is_client = typeof window < "u";
let now = is_client ? () => window.performance.now() : () => Date.now(), raf = is_client ? (u) => requestAnimationFrame(u) : noop$4;
function set_now(u) {
  now = u;
}
function set_raf(u) {
  raf = u;
}
const tasks = /* @__PURE__ */ new Set();
function run_tasks(u) {
  tasks.forEach((l) => {
    l.c(u) || (tasks.delete(l), l.f());
  }), tasks.size !== 0 && raf(run_tasks);
}
function clear_loops() {
  tasks.clear();
}
function loop(u) {
  let l;
  return tasks.size === 0 && raf(run_tasks), {
    promise: new Promise((f) => {
      tasks.add(l = { c: u, f });
    }),
    abort() {
      tasks.delete(l);
    }
  };
}
const globals$1 = typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);
class ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(l) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    me(this, "_listeners", "WeakMap" in globals$1 ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    me(this, "_observer");
    /** @type {ResizeObserverOptions} */
    me(this, "options");
    this.options = l;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(l, f) {
    return this._listeners.set(l, f), this._getObserver().observe(l, this.options), () => {
      this._listeners.delete(l), this._observer.unobserve(l);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    return this._observer ?? (this._observer = new ResizeObserver((l) => {
      var f;
      for (const p of l)
        ResizeObserverSingleton.entries.set(p.target, p), (f = this._listeners.get(p.target)) == null || f(p);
    }));
  }
}
ResizeObserverSingleton.entries = "WeakMap" in globals$1 ? /* @__PURE__ */ new WeakMap() : void 0;
let is_hydrating = !1;
function start_hydrating() {
  is_hydrating = !0;
}
function end_hydrating() {
  is_hydrating = !1;
}
function upper_bound(u, l, f, p) {
  for (; u < l; ) {
    const m = u + (l - u >> 1);
    f(m) <= p ? u = m + 1 : l = m;
  }
  return u;
}
function init_hydrate(u) {
  if (u.hydrate_init)
    return;
  u.hydrate_init = !0;
  let l = (
    /** @type {ArrayLike<NodeEx2>} */
    u.childNodes
  );
  if (u.nodeName === "HEAD") {
    const k = [];
    for (let S = 0; S < l.length; S++) {
      const $ = l[S];
      $.claim_order !== void 0 && k.push($);
    }
    l = k;
  }
  const f = new Int32Array(l.length + 1), p = new Int32Array(l.length);
  f[0] = -1;
  let m = 0;
  for (let k = 0; k < l.length; k++) {
    const S = l[k].claim_order, $ = (m > 0 && l[f[m]].claim_order <= S ? m + 1 : upper_bound(1, m, (T) => l[f[T]].claim_order, S)) - 1;
    p[k] = f[$] + 1;
    const w = $ + 1;
    f[w] = k, m = Math.max(w, m);
  }
  const b = [], y = [];
  let v = l.length - 1;
  for (let k = f[m] + 1; k != 0; k = p[k - 1]) {
    for (b.push(l[k - 1]); v >= k; v--)
      y.push(l[v]);
    v--;
  }
  for (; v >= 0; v--)
    y.push(l[v]);
  b.reverse(), y.sort((k, S) => k.claim_order - S.claim_order);
  for (let k = 0, S = 0; k < y.length; k++) {
    for (; S < b.length && y[k].claim_order >= b[S].claim_order; )
      S++;
    const $ = S < b.length ? b[S] : null;
    u.insertBefore(y[k], $);
  }
}
function append$1(u, l) {
  u.appendChild(l);
}
function append_styles(u, l, f) {
  const p = get_root_for_style(u);
  if (!p.getElementById(l)) {
    const m = element("style");
    m.id = l, m.textContent = f, append_stylesheet(p, m);
  }
}
function get_root_for_style(u) {
  if (!u)
    return document;
  const l = u.getRootNode ? u.getRootNode() : u.ownerDocument;
  return l && /** @type {ShadowRoot} */
  l.host ? (
    /** @type {ShadowRoot} */
    l
  ) : u.ownerDocument;
}
function append_empty_stylesheet(u) {
  const l = element("style");
  return l.textContent = "/* empty */", append_stylesheet(get_root_for_style(u), l), l.sheet;
}
function append_stylesheet(u, l) {
  return append$1(
    /** @type {Document} */
    u.head || u,
    l
  ), l.sheet;
}
function append_hydration(u, l) {
  if (is_hydrating) {
    for (init_hydrate(u), (u.actual_end_child === void 0 || u.actual_end_child !== null && u.actual_end_child.parentNode !== u) && (u.actual_end_child = u.firstChild); u.actual_end_child !== null && u.actual_end_child.claim_order === void 0; )
      u.actual_end_child = u.actual_end_child.nextSibling;
    l !== u.actual_end_child ? (l.claim_order !== void 0 || l.parentNode !== u) && u.insertBefore(l, u.actual_end_child) : u.actual_end_child = l.nextSibling;
  } else
    (l.parentNode !== u || l.nextSibling !== null) && u.appendChild(l);
}
function insert(u, l, f) {
  u.insertBefore(l, f || null);
}
function insert_hydration(u, l, f) {
  is_hydrating && !f ? append_hydration(u, l) : (l.parentNode !== u || l.nextSibling != f) && u.insertBefore(l, f || null);
}
function detach(u) {
  u.parentNode && u.parentNode.removeChild(u);
}
function destroy_each(u, l) {
  for (let f = 0; f < u.length; f += 1)
    u[f] && u[f].d(l);
}
function element(u) {
  return document.createElement(u);
}
function element_is(u, l) {
  return document.createElement(u, { is: l });
}
function object_without_properties(u, l) {
  const f = (
    /** @type {Pick<T, Exclude<keyof T, K>>} */
    {}
  );
  for (const p in u)
    has_prop(u, p) && // @ts-ignore
    l.indexOf(p) === -1 && (f[p] = u[p]);
  return f;
}
function svg_element(u) {
  return document.createElementNS("http://www.w3.org/2000/svg", u);
}
function text$2(u) {
  return document.createTextNode(u);
}
function space() {
  return text$2(" ");
}
function empty$1() {
  return text$2("");
}
function comment(u) {
  return document.createComment(u);
}
function listen(u, l, f, p) {
  return u.addEventListener(l, f, p), () => u.removeEventListener(l, f, p);
}
function prevent_default(u) {
  return function(l) {
    return l.preventDefault(), u.call(this, l);
  };
}
function stop_propagation(u) {
  return function(l) {
    return l.stopPropagation(), u.call(this, l);
  };
}
function stop_immediate_propagation(u) {
  return function(l) {
    return l.stopImmediatePropagation(), u.call(this, l);
  };
}
function self$1(u) {
  return function(l) {
    l.target === this && u.call(this, l);
  };
}
function trusted(u) {
  return function(l) {
    l.isTrusted && u.call(this, l);
  };
}
function attr(u, l, f) {
  f == null ? u.removeAttribute(l) : u.getAttribute(l) !== f && u.setAttribute(l, f);
}
const always_set_through_set_attribute = ["width", "height"];
function set_attributes(u, l) {
  const f = Object.getOwnPropertyDescriptors(u.__proto__);
  for (const p in l)
    l[p] == null ? u.removeAttribute(p) : p === "style" ? u.style.cssText = l[p] : p === "__value" ? u.value = u[p] = l[p] : f[p] && f[p].set && always_set_through_set_attribute.indexOf(p) === -1 ? u[p] = l[p] : attr(u, p, l[p]);
}
function set_svg_attributes(u, l) {
  for (const f in l)
    attr(u, f, l[f]);
}
function set_custom_element_data_map(u, l) {
  Object.keys(l).forEach((f) => {
    set_custom_element_data(u, f, l[f]);
  });
}
function set_custom_element_data(u, l, f) {
  const p = l.toLowerCase();
  p in u ? u[p] = typeof u[p] == "boolean" && f === "" ? !0 : f : l in u ? u[l] = typeof u[l] == "boolean" && f === "" ? !0 : f : attr(u, l, f);
}
function set_dynamic_element_data(u) {
  return /-/.test(u) ? set_custom_element_data_map : set_attributes;
}
function xlink_attr(u, l, f) {
  u.setAttributeNS("http://www.w3.org/1999/xlink", l, f);
}
function get_svelte_dataset(u) {
  return u.dataset.svelteH;
}
function get_binding_group_value(u, l, f) {
  const p = /* @__PURE__ */ new Set();
  for (let m = 0; m < u.length; m += 1)
    u[m].checked && p.add(u[m].__value);
  return f || p.delete(l), Array.from(p);
}
function init_binding_group(u) {
  let l;
  return {
    /* push */
    p(...f) {
      l = f, l.forEach((p) => u.push(p));
    },
    /* remove */
    r() {
      l.forEach((f) => u.splice(u.indexOf(f), 1));
    }
  };
}
function init_binding_group_dynamic(u, l) {
  let f = m(u), p;
  function m(v) {
    for (let k = 0; k < l.length; k++)
      v = v[l[k]] = v[l[k]] || [];
    return v;
  }
  function b() {
    p.forEach((v) => f.push(v));
  }
  function y() {
    p.forEach((v) => f.splice(f.indexOf(v), 1));
  }
  return {
    /* update */
    u(v) {
      l = v;
      const k = m(u);
      k !== f && (y(), f = k, b());
    },
    /* push */
    p(...v) {
      p = v, b();
    },
    /* remove */
    r: y
  };
}
function to_number(u) {
  return u === "" ? null : +u;
}
function time_ranges_to_array(u) {
  const l = [];
  for (let f = 0; f < u.length; f += 1)
    l.push({ start: u.start(f), end: u.end(f) });
  return l;
}
function children(u) {
  return Array.from(u.childNodes);
}
function init_claim_info(u) {
  u.claim_info === void 0 && (u.claim_info = { last_index: 0, total_claimed: 0 });
}
function claim_node(u, l, f, p, m = !1) {
  init_claim_info(u);
  const b = (() => {
    for (let y = u.claim_info.last_index; y < u.length; y++) {
      const v = u[y];
      if (l(v)) {
        const k = f(v);
        return k === void 0 ? u.splice(y, 1) : u[y] = k, m || (u.claim_info.last_index = y), v;
      }
    }
    for (let y = u.claim_info.last_index - 1; y >= 0; y--) {
      const v = u[y];
      if (l(v)) {
        const k = f(v);
        return k === void 0 ? u.splice(y, 1) : u[y] = k, m ? k === void 0 && u.claim_info.last_index-- : u.claim_info.last_index = y, v;
      }
    }
    return p();
  })();
  return b.claim_order = u.claim_info.total_claimed, u.claim_info.total_claimed += 1, b;
}
function claim_element_base(u, l, f, p) {
  return claim_node(
    u,
    /** @returns {node is Element | SVGElement} */
    (m) => m.nodeName === l,
    /** @param {Element} node */
    (m) => {
      const b = [];
      for (let y = 0; y < m.attributes.length; y++) {
        const v = m.attributes[y];
        f[v.name] || b.push(v.name);
      }
      b.forEach((y) => m.removeAttribute(y));
    },
    () => p(l)
  );
}
function claim_element(u, l, f) {
  return claim_element_base(u, l, f, element);
}
function claim_svg_element(u, l, f) {
  return claim_element_base(u, l, f, svg_element);
}
function claim_text(u, l) {
  return claim_node(
    u,
    /** @returns {node is Text} */
    (f) => f.nodeType === 3,
    /** @param {Text} node */
    (f) => {
      const p = "" + l;
      if (f.data.startsWith(p)) {
        if (f.data.length !== p.length)
          return f.splitText(p.length);
      } else
        f.data = p;
    },
    () => text$2(l),
    !0
    // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements
  );
}
function claim_space(u) {
  return claim_text(u, " ");
}
function claim_comment(u, l) {
  return claim_node(
    u,
    /** @returns {node is Comment} */
    (f) => f.nodeType === 8,
    /** @param {Comment} node */
    (f) => {
      f.data = "" + l;
    },
    () => comment(l),
    !0
  );
}
function get_comment_idx(u, l, f) {
  for (let p = f; p < u.length; p += 1) {
    const m = u[p];
    if (m.nodeType === 8 && m.textContent.trim() === l)
      return p;
  }
  return -1;
}
function claim_html_tag(u, l) {
  const f = get_comment_idx(u, "HTML_TAG_START", 0), p = get_comment_idx(u, "HTML_TAG_END", f + 1);
  if (f === -1 || p === -1)
    return new HtmlTagHydration(l);
  init_claim_info(u);
  const m = u.splice(f, p - f + 1);
  detach(m[0]), detach(m[m.length - 1]);
  const b = m.slice(1, m.length - 1);
  if (b.length === 0)
    return new HtmlTagHydration(l);
  for (const y of b)
    y.claim_order = u.claim_info.total_claimed, u.claim_info.total_claimed += 1;
  return new HtmlTagHydration(l, b);
}
function set_data(u, l) {
  l = "" + l, u.data !== l && (u.data = /** @type {string} */
  l);
}
function set_data_contenteditable(u, l) {
  l = "" + l, u.wholeText !== l && (u.data = /** @type {string} */
  l);
}
function set_data_maybe_contenteditable(u, l, f) {
  ~contenteditable_truthy_values.indexOf(f) ? set_data_contenteditable(u, l) : set_data(u, l);
}
function set_input_value(u, l) {
  u.value = l ?? "";
}
function set_input_type(u, l) {
  try {
    u.type = l;
  } catch {
  }
}
function set_style(u, l, f, p) {
  f == null ? u.style.removeProperty(l) : u.style.setProperty(l, f, p ? "important" : "");
}
function select_option(u, l, f) {
  for (let p = 0; p < u.options.length; p += 1) {
    const m = u.options[p];
    if (m.__value === l) {
      m.selected = !0;
      return;
    }
  }
  (!f || l !== void 0) && (u.selectedIndex = -1);
}
function select_options(u, l) {
  for (let f = 0; f < u.options.length; f += 1) {
    const p = u.options[f];
    p.selected = ~l.indexOf(p.__value);
  }
}
function select_value(u) {
  const l = u.querySelector(":checked");
  return l && l.__value;
}
function select_multiple_value(u) {
  return [].map.call(u.querySelectorAll(":checked"), (l) => l.__value);
}
let crossorigin;
function is_crossorigin() {
  if (crossorigin === void 0) {
    crossorigin = !1;
    try {
      typeof window < "u" && window.parent && window.parent.document;
    } catch {
      crossorigin = !0;
    }
  }
  return crossorigin;
}
function add_iframe_resize_listener(u, l) {
  getComputedStyle(u).position === "static" && (u.style.position = "relative");
  const p = element("iframe");
  p.setAttribute(
    "style",
    "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;"
  ), p.setAttribute("aria-hidden", "true"), p.tabIndex = -1;
  const m = is_crossorigin();
  let b;
  return m ? (p.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>", b = listen(
    window,
    "message",
    /** @param {MessageEvent} event */
    (y) => {
      y.source === p.contentWindow && l();
    }
  )) : (p.src = "about:blank", p.onload = () => {
    b = listen(p.contentWindow, "resize", l), l();
  }), append$1(u, p), () => {
    (m || b && p.contentWindow) && b(), detach(p);
  };
}
const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "content-box"
}), resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "border-box"
}), resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(
  { box: "device-pixel-content-box" }
);
function toggle_class(u, l, f) {
  u.classList.toggle(l, !!f);
}
function custom_event(u, l, { bubbles: f = !1, cancelable: p = !1 } = {}) {
  return new CustomEvent(u, { detail: l, bubbles: f, cancelable: p });
}
function query_selector_all(u, l = document.body) {
  return Array.from(l.querySelectorAll(u));
}
function head_selector(u, l) {
  const f = [];
  let p = 0;
  for (const m of l.childNodes)
    if (m.nodeType === 8) {
      const b = m.textContent.trim();
      b === `HEAD_${u}_END` ? (p -= 1, f.push(m)) : b === `HEAD_${u}_START` && (p += 1, f.push(m));
    } else
      p > 0 && f.push(m);
  return f;
}
class HtmlTag {
  constructor(l = !1) {
    /**
     * @private
     * @default false
     */
    me(this, "is_svg", !1);
    /** parent for creating node */
    me(this, "e");
    /** html tag nodes */
    me(this, "n");
    /** target */
    me(this, "t");
    /** anchor */
    me(this, "a");
    this.is_svg = l, this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(l) {
    this.h(l);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(l, f, p = null) {
    this.e || (this.is_svg ? this.e = svg_element(
      /** @type {keyof SVGElementTagNameMap} */
      f.nodeName
    ) : this.e = element(
      /** @type {keyof HTMLElementTagNameMap} */
      f.nodeType === 11 ? "TEMPLATE" : f.nodeName
    ), this.t = f.tagName !== "TEMPLATE" ? f : (
      /** @type {HTMLTemplateElement} */
      f.content
    ), this.c(l)), this.i(p);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(l) {
    this.e.innerHTML = l, this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(l) {
    for (let f = 0; f < this.n.length; f += 1)
      insert(this.t, this.n[f], l);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(l) {
    this.d(), this.h(l), this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
}
class HtmlTagHydration extends HtmlTag {
  constructor(f = !1, p) {
    super(f);
    /** @type {Element[]} hydration claimed nodes */
    me(this, "l");
    this.e = this.n = null, this.l = p;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(f) {
    this.l ? this.n = this.l : super.c(f);
  }
  /**
   * @returns {void} */
  i(f) {
    for (let p = 0; p < this.n.length; p += 1)
      insert_hydration(this.t, this.n[p], f);
  }
}
function attribute_to_object(u) {
  const l = {};
  for (const f of u)
    l[f.name] = f.value;
  return l;
}
const escaped = {
  '"': "&quot;",
  "&": "&amp;",
  "<": "&lt;"
}, regex_attribute_characters_to_escape = /["&<]/g;
function escape_attribute(u) {
  return String(u).replace(regex_attribute_characters_to_escape, (l) => escaped[l]);
}
function stringify_spread(u) {
  let l = " ";
  for (const f in u)
    u[f] != null && (l += `${f}="${escape_attribute(u[f])}" `);
  return l;
}
function get_custom_elements_slots(u) {
  const l = {};
  return u.childNodes.forEach(
    /** @param {Element} node */
    (f) => {
      l[f.slot || "default"] = !0;
    }
  ), l;
}
function construct_svelte_component(u, l) {
  return new u(l);
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash(u) {
  let l = 5381, f = u.length;
  for (; f--; )
    l = (l << 5) - l ^ u.charCodeAt(f);
  return l >>> 0;
}
function create_style_information(u, l) {
  const f = { stylesheet: append_empty_stylesheet(l), rules: {} };
  return managed_styles.set(u, f), f;
}
function create_rule(u, l, f, p, m, b, y, v = 0) {
  const k = 16.666 / p;
  let S = `{
`;
  for (let P = 0; P <= 1; P += k) {
    const L = l + (f - l) * b(P);
    S += P * 100 + `%{${y(L, 1 - L)}}
`;
  }
  const $ = S + `100% {${y(f, 1 - f)}}
}`, w = `__svelte_${hash($)}_${v}`, T = get_root_for_style(u), { stylesheet: E, rules: R } = managed_styles.get(T) || create_style_information(T, u);
  R[w] || (R[w] = !0, E.insertRule(`@keyframes ${w} ${$}`, E.cssRules.length));
  const O = u.style.animation || "";
  return u.style.animation = `${O ? `${O}, ` : ""}${w} ${p}ms linear ${m}ms 1 both`, active += 1, w;
}
function delete_rule(u, l) {
  const f = (u.style.animation || "").split(", "), p = f.filter(
    l ? (b) => b.indexOf(l) < 0 : (b) => b.indexOf("__svelte") === -1
    // remove all Svelte animations
  ), m = f.length - p.length;
  m && (u.style.animation = p.join(", "), active -= m, active || clear_rules());
}
function clear_rules() {
  raf(() => {
    active || (managed_styles.forEach((u) => {
      const { ownerNode: l } = u.stylesheet;
      l && detach(l);
    }), managed_styles.clear());
  });
}
function create_animation(u, l, f, p) {
  if (!l)
    return noop$4;
  const m = u.getBoundingClientRect();
  if (l.left === m.left && l.right === m.right && l.top === m.top && l.bottom === m.bottom)
    return noop$4;
  const {
    delay: b = 0,
    duration: y = 300,
    easing: v = identity$5,
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: k = now() + b,
    // @ts-ignore todo:
    end: S = k + y,
    tick: $ = noop$4,
    css: w
  } = f(u, { from: l, to: m }, p);
  let T = !0, E = !1, R;
  function O() {
    w && (R = create_rule(u, 0, 1, y, b, v, w)), b || (E = !0);
  }
  function P() {
    w && delete_rule(u, R), T = !1;
  }
  return loop((L) => {
    if (!E && L >= k && (E = !0), E && L >= S && ($(1, 0), P()), !T)
      return !1;
    if (E) {
      const M = L - k, B = 0 + 1 * v(M / y);
      $(B, 1 - B);
    }
    return !0;
  }), O(), $(0, 1), P;
}
function fix_position(u) {
  const l = getComputedStyle(u);
  if (l.position !== "absolute" && l.position !== "fixed") {
    const { width: f, height: p } = l, m = u.getBoundingClientRect();
    u.style.position = "absolute", u.style.width = f, u.style.height = p, add_transform(u, m);
  }
}
function add_transform(u, l) {
  const f = u.getBoundingClientRect();
  if (l.left !== f.left || l.top !== f.top) {
    const p = getComputedStyle(u), m = p.transform === "none" ? "" : p.transform;
    u.style.transform = `${m} translate(${l.left - f.left}px, ${l.top - f.top}px)`;
  }
}
let current_component;
function set_current_component(u) {
  current_component = u;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function beforeUpdate(u) {
  get_current_component().$$.before_update.push(u);
}
function onMount(u) {
  get_current_component().$$.on_mount.push(u);
}
function afterUpdate(u) {
  get_current_component().$$.after_update.push(u);
}
function onDestroy(u) {
  get_current_component().$$.on_destroy.push(u);
}
function createEventDispatcher() {
  const u = get_current_component();
  return (l, f, { cancelable: p = !1 } = {}) => {
    const m = u.$$.callbacks[l];
    if (m) {
      const b = custom_event(
        /** @type {string} */
        l,
        f,
        { cancelable: p }
      );
      return m.slice().forEach((y) => {
        y.call(u, b);
      }), !b.defaultPrevented;
    }
    return !0;
  };
}
function setContext(u, l) {
  return get_current_component().$$.context.set(u, l), l;
}
function getContext$1(u) {
  return get_current_component().$$.context.get(u);
}
function getAllContexts() {
  return get_current_component().$$.context;
}
function hasContext(u) {
  return get_current_component().$$.context.has(u);
}
function bubble(u, l) {
  const f = u.$$.callbacks[l.type];
  f && f.slice().forEach((p) => p.call(this, l));
}
const dirty_components = [], intros = { enabled: !1 }, binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [], resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = !1;
function schedule_update() {
  update_scheduled || (update_scheduled = !0, resolved_promise.then(flush));
}
function tick() {
  return schedule_update(), resolved_promise;
}
function add_render_callback(u) {
  render_callbacks.push(u);
}
function add_flush_callback(u) {
  flush_callbacks.push(u);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0)
    return;
  const u = current_component;
  do {
    try {
      for (; flushidx < dirty_components.length; ) {
        const l = dirty_components[flushidx];
        flushidx++, set_current_component(l), update(l.$$);
      }
    } catch (l) {
      throw dirty_components.length = 0, flushidx = 0, l;
    }
    for (set_current_component(null), dirty_components.length = 0, flushidx = 0; binding_callbacks.length; )
      binding_callbacks.pop()();
    for (let l = 0; l < render_callbacks.length; l += 1) {
      const f = render_callbacks[l];
      seen_callbacks.has(f) || (seen_callbacks.add(f), f());
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  for (; flush_callbacks.length; )
    flush_callbacks.pop()();
  update_scheduled = !1, seen_callbacks.clear(), set_current_component(u);
}
function update(u) {
  if (u.fragment !== null) {
    u.update(), run_all(u.before_update);
    const l = u.dirty;
    u.dirty = [-1], u.fragment && u.fragment.p(u.ctx, l), u.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(u) {
  const l = [], f = [];
  render_callbacks.forEach((p) => u.indexOf(p) === -1 ? l.push(p) : f.push(p)), f.forEach((p) => p()), render_callbacks = l;
}
let promise;
function wait() {
  return promise || (promise = Promise.resolve(), promise.then(() => {
    promise = null;
  })), promise;
}
function dispatch(u, l, f) {
  u.dispatchEvent(custom_event(`${l ? "intro" : "outro"}${f}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  outros.r || run_all(outros.c), outros = outros.p;
}
function transition_in(u, l) {
  u && u.i && (outroing.delete(u), u.i(l));
}
function transition_out(u, l, f, p) {
  if (u && u.o) {
    if (outroing.has(u))
      return;
    outroing.add(u), outros.c.push(() => {
      outroing.delete(u), p && (f && u.d(1), p());
    }), u.o(l);
  } else
    p && p();
}
const null_transition = { duration: 0 };
function create_in_transition(u, l, f) {
  const p = { direction: "in" };
  let m = l(u, f, p), b = !1, y, v, k = 0;
  function S() {
    y && delete_rule(u, y);
  }
  function $() {
    const {
      delay: T = 0,
      duration: E = 300,
      easing: R = identity$5,
      tick: O = noop$4,
      css: P
    } = m || null_transition;
    P && (y = create_rule(u, 0, 1, E, T, R, P, k++)), O(0, 1);
    const L = now() + T, M = L + E;
    v && v.abort(), b = !0, add_render_callback(() => dispatch(u, !0, "start")), v = loop((B) => {
      if (b) {
        if (B >= M)
          return O(1, 0), dispatch(u, !0, "end"), S(), b = !1;
        if (B >= L) {
          const j = R((B - L) / E);
          O(j, 1 - j);
        }
      }
      return b;
    });
  }
  let w = !1;
  return {
    start() {
      w || (w = !0, delete_rule(u), is_function(m) ? (m = m(p), wait().then($)) : $());
    },
    invalidate() {
      w = !1;
    },
    end() {
      b && (S(), b = !1);
    }
  };
}
function create_out_transition(u, l, f) {
  const p = { direction: "out" };
  let m = l(u, f, p), b = !0, y;
  const v = outros;
  v.r += 1;
  let k;
  function S() {
    const {
      delay: $ = 0,
      duration: w = 300,
      easing: T = identity$5,
      tick: E = noop$4,
      css: R
    } = m || null_transition;
    R && (y = create_rule(u, 1, 0, w, $, T, R));
    const O = now() + $, P = O + w;
    add_render_callback(() => dispatch(u, !1, "start")), "inert" in u && (k = /** @type {HTMLElement} */
    u.inert, u.inert = !0), loop((L) => {
      if (b) {
        if (L >= P)
          return E(0, 1), dispatch(u, !1, "end"), --v.r || run_all(v.c), !1;
        if (L >= O) {
          const M = T((L - O) / w);
          E(1 - M, M);
        }
      }
      return b;
    });
  }
  return is_function(m) ? wait().then(() => {
    m = m(p), S();
  }) : S(), {
    end($) {
      $ && "inert" in u && (u.inert = k), $ && m.tick && m.tick(1, 0), b && (y && delete_rule(u, y), b = !1);
    }
  };
}
function create_bidirectional_transition(u, l, f, p) {
  let b = l(u, f, { direction: "both" }), y = p ? 0 : 1, v = null, k = null, S = null, $;
  function w() {
    S && delete_rule(u, S);
  }
  function T(R, O) {
    const P = (
      /** @type {Program['d']} */
      R.b - y
    );
    return O *= Math.abs(P), {
      a: y,
      b: R.b,
      d: P,
      duration: O,
      start: R.start,
      end: R.start + O,
      group: R.group
    };
  }
  function E(R) {
    const {
      delay: O = 0,
      duration: P = 300,
      easing: L = identity$5,
      tick: M = noop$4,
      css: B
    } = b || null_transition, j = {
      start: now() + O,
      b: R
    };
    R || (j.group = outros, outros.r += 1), "inert" in u && (R ? $ !== void 0 && (u.inert = $) : ($ = /** @type {HTMLElement} */
    u.inert, u.inert = !0)), v || k ? k = j : (B && (w(), S = create_rule(u, y, R, P, O, L, B)), R && M(0, 1), v = T(j, P), add_render_callback(() => dispatch(u, R, "start")), loop((x) => {
      if (k && x > k.start && (v = T(k, P), k = null, dispatch(u, v.b, "start"), B && (w(), S = create_rule(
        u,
        y,
        v.b,
        v.duration,
        0,
        L,
        b.css
      ))), v) {
        if (x >= v.end)
          M(y = v.b, 1 - y), dispatch(u, v.b, "end"), k || (v.b ? w() : --v.group.r || run_all(v.group.c)), v = null;
        else if (x >= v.start) {
          const N = x - v.start;
          y = v.a + v.d * L(N / v.duration), M(y, 1 - y);
        }
      }
      return !!(v || k);
    }));
  }
  return {
    run(R) {
      is_function(b) ? wait().then(() => {
        b = b({ direction: R ? "in" : "out" }), E(R);
      }) : E(R);
    },
    end() {
      w(), v = k = null;
    }
  };
}
function handle_promise(u, l) {
  const f = l.token = {};
  function p(m, b, y, v) {
    if (l.token !== f)
      return;
    l.resolved = v;
    let k = l.ctx;
    y !== void 0 && (k = k.slice(), k[y] = v);
    const S = m && (l.current = m)(k);
    let $ = !1;
    l.block && (l.blocks ? l.blocks.forEach((w, T) => {
      T !== b && w && (group_outros(), transition_out(w, 1, 1, () => {
        l.blocks[T] === w && (l.blocks[T] = null);
      }), check_outros());
    }) : l.block.d(1), S.c(), transition_in(S, 1), S.m(l.mount(), l.anchor), $ = !0), l.block = S, l.blocks && (l.blocks[b] = S), $ && flush();
  }
  if (is_promise(u)) {
    const m = get_current_component();
    if (u.then(
      (b) => {
        set_current_component(m), p(l.then, 1, l.value, b), set_current_component(null);
      },
      (b) => {
        if (set_current_component(m), p(l.catch, 2, l.error, b), set_current_component(null), !l.hasCatch)
          throw b;
      }
    ), l.current !== l.pending)
      return p(l.pending, 0), !0;
  } else {
    if (l.current !== l.then)
      return p(l.then, 1, l.value, u), !0;
    l.resolved = /** @type {T} */
    u;
  }
}
function update_await_block_branch(u, l, f) {
  const p = l.slice(), { resolved: m } = u;
  u.current === u.then && (p[u.value] = m), u.current === u.catch && (p[u.error] = m), u.block.p(p, f);
}
function ensure_array_like(u) {
  return (u == null ? void 0 : u.length) !== void 0 ? u : Array.from(u);
}
function destroy_block(u, l) {
  u.d(1), l.delete(u.key);
}
function outro_and_destroy_block(u, l) {
  transition_out(u, 1, 1, () => {
    l.delete(u.key);
  });
}
function fix_and_destroy_block(u, l) {
  u.f(), destroy_block(u, l);
}
function fix_and_outro_and_destroy_block(u, l) {
  u.f(), outro_and_destroy_block(u, l);
}
function update_keyed_each(u, l, f, p, m, b, y, v, k, S, $, w) {
  let T = u.length, E = b.length, R = T;
  const O = {};
  for (; R--; )
    O[u[R].key] = R;
  const P = [], L = /* @__PURE__ */ new Map(), M = /* @__PURE__ */ new Map(), B = [];
  for (R = E; R--; ) {
    const D = w(m, b, R), V = f(D);
    let W = y.get(V);
    W ? p && B.push(() => W.p(D, l)) : (W = S(V, D), W.c()), L.set(V, P[R] = W), V in O && M.set(V, Math.abs(R - O[V]));
  }
  const j = /* @__PURE__ */ new Set(), x = /* @__PURE__ */ new Set();
  function N(D) {
    transition_in(D, 1), D.m(v, $), y.set(D.key, D), $ = D.first, E--;
  }
  for (; T && E; ) {
    const D = P[E - 1], V = u[T - 1], W = D.key, F = V.key;
    D === V ? ($ = D.first, T--, E--) : L.has(F) ? !y.has(W) || j.has(W) ? N(D) : x.has(F) ? T-- : M.get(W) > M.get(F) ? (x.add(W), N(D)) : (j.add(F), T--) : (k(V, y), T--);
  }
  for (; T--; ) {
    const D = u[T];
    L.has(D.key) || k(D, y);
  }
  for (; E; )
    N(P[E - 1]);
  return run_all(B), P;
}
function validate_each_keys(u, l, f, p) {
  const m = /* @__PURE__ */ new Map();
  for (let b = 0; b < l.length; b++) {
    const y = p(f(u, l, b));
    if (m.has(y)) {
      let v = "";
      try {
        v = `with value '${String(y)}' `;
      } catch {
      }
      throw new Error(
        `Cannot have duplicate keys in a keyed each: Keys at index ${m.get(
          y
        )} and ${b} ${v}are duplicates`
      );
    }
    m.set(y, b);
  }
}
function get_spread_update(u, l) {
  const f = {}, p = {}, m = { $$scope: 1 };
  let b = u.length;
  for (; b--; ) {
    const y = u[b], v = l[b];
    if (v) {
      for (const k in y)
        k in v || (p[k] = 1);
      for (const k in v)
        m[k] || (f[k] = v[k], m[k] = 1);
      u[b] = v;
    } else
      for (const k in y)
        m[k] = 1;
  }
  for (const y in p)
    y in f || (f[y] = void 0);
  return f;
}
function get_spread_object(u) {
  return typeof u == "object" && u !== null ? u : {};
}
const _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
), boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]), ATTR_REGEX = /[&"<]/g, CONTENT_REGEX = /[&<]/g;
function escape$2(u, l = !1) {
  const f = String(u), p = l ? ATTR_REGEX : CONTENT_REGEX;
  p.lastIndex = 0;
  let m = "", b = 0;
  for (; p.test(f); ) {
    const y = p.lastIndex - 1, v = f[y];
    m += f.substring(b, y) + (v === "&" ? "&amp;" : v === '"' ? "&quot;" : "&lt;"), b = y + 1;
  }
  return m + f.substring(b);
}
const void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
function is_void(u) {
  return void_element_names.test(u) || u.toLowerCase() === "!doctype";
}
const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
function spread(u, l) {
  const f = Object.assign({}, ...u);
  if (l) {
    const m = l.classes, b = l.styles;
    m && (f.class == null ? f.class = m : f.class += " " + m), b && (f.style == null ? f.style = style_object_to_string(b) : f.style = style_object_to_string(
      merge_ssr_styles(f.style, b)
    ));
  }
  let p = "";
  return Object.keys(f).forEach((m) => {
    if (invalid_attribute_name_character.test(m))
      return;
    const b = f[m];
    b === !0 ? p += " " + m : boolean_attributes.has(m.toLowerCase()) ? b && (p += " " + m) : b != null && (p += ` ${m}="${b}"`);
  }), p;
}
function merge_ssr_styles(u, l) {
  const f = {};
  for (const p of u.split(";")) {
    const m = p.indexOf(":"), b = p.slice(0, m).trim(), y = p.slice(m + 1).trim();
    b && (f[b] = y);
  }
  for (const p in l) {
    const m = l[p];
    m ? f[p] = m : delete f[p];
  }
  return f;
}
function escape_attribute_value(u) {
  return typeof u == "string" || u && typeof u == "object" ? escape$2(u, !0) : u;
}
function escape_object(u) {
  const l = {};
  for (const f in u)
    l[f] = escape_attribute_value(u[f]);
  return l;
}
function each$1(u, l) {
  u = ensure_array_like(u);
  let f = "";
  for (let p = 0; p < u.length; p += 1)
    f += l(u[p], p);
  return f;
}
const missing_component = {
  $$render: () => ""
};
function validate_component(u, l) {
  if (!u || !u.$$render)
    throw l === "svelte:component" && (l += " this={...}"), new Error(
      `<${l}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${l}>.`
    );
  return u;
}
function debug(u, l, f, p) {
  return console.log(`{@debug} ${u ? u + " " : ""}(${l}:${f})`), console.log(p), "";
}
let on_destroy;
function create_ssr_component(u) {
  function l(f, p, m, b, y) {
    const v = current_component, k = {
      on_destroy,
      context: new Map(y || (v ? v.$$.context : [])),
      // these will be immediately discarded
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$: k });
    const S = u(f, p, m, b);
    return set_current_component(v), S;
  }
  return {
    render: (f = {}, { $$slots: p = {}, context: m = /* @__PURE__ */ new Map() } = {}) => {
      on_destroy = [];
      const b = { title: "", head: "", css: /* @__PURE__ */ new Set() }, y = l(b, f, {}, p, m);
      return run_all(on_destroy), {
        html: y,
        css: {
          code: Array.from(b.css).map((v) => v.code).join(`
`),
          map: null
          // TODO
        },
        head: b.title + b.head
      };
    },
    $$render: l
  };
}
function add_attribute(u, l, f) {
  if (l == null || f && !l)
    return "";
  const p = f && l === !0 ? "" : `="${escape$2(l, !0)}"`;
  return ` ${u}${p}`;
}
function add_classes(u) {
  return u ? ` class="${u}"` : "";
}
function style_object_to_string(u) {
  return Object.keys(u).filter((l) => u[l] != null && u[l] !== "").map((l) => `${l}: ${escape_attribute_value(u[l])};`).join(" ");
}
function add_styles(u) {
  const l = style_object_to_string(u);
  return l ? ` style="${l}"` : "";
}
function bind(u, l, f) {
  const p = u.$$.props[l];
  p !== void 0 && (u.$$.bound[p] = f, f(u.$$.ctx[p]));
}
function create_component(u) {
  u && u.c();
}
function claim_component(u, l) {
  u && u.l(l);
}
function mount_component(u, l, f) {
  const { fragment: p, after_update: m } = u.$$;
  p && p.m(l, f), add_render_callback(() => {
    const b = u.$$.on_mount.map(run).filter(is_function);
    u.$$.on_destroy ? u.$$.on_destroy.push(...b) : run_all(b), u.$$.on_mount = [];
  }), m.forEach(add_render_callback);
}
function destroy_component(u, l) {
  const f = u.$$;
  f.fragment !== null && (flush_render_callbacks(f.after_update), run_all(f.on_destroy), f.fragment && f.fragment.d(l), f.on_destroy = f.fragment = null, f.ctx = []);
}
function make_dirty(u, l) {
  u.$$.dirty[0] === -1 && (dirty_components.push(u), schedule_update(), u.$$.dirty.fill(0)), u.$$.dirty[l / 31 | 0] |= 1 << l % 31;
}
function init$1(u, l, f, p, m, b, y = null, v = [-1]) {
  const k = current_component;
  set_current_component(u);
  const S = u.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: b,
    update: noop$4,
    not_equal: m,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(l.context || (k ? k.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty: v,
    skip_bound: !1,
    root: l.target || k.$$.root
  };
  y && y(S.root);
  let $ = !1;
  if (S.ctx = f ? f(u, l.props || {}, (w, T, ...E) => {
    const R = E.length ? E[0] : T;
    return S.ctx && m(S.ctx[w], S.ctx[w] = R) && (!S.skip_bound && S.bound[w] && S.bound[w](R), $ && make_dirty(u, w)), T;
  }) : [], S.update(), $ = !0, run_all(S.before_update), S.fragment = p ? p(S.ctx) : !1, l.target) {
    if (l.hydrate) {
      start_hydrating();
      const w = children(l.target);
      S.fragment && S.fragment.l(w), w.forEach(detach);
    } else
      S.fragment && S.fragment.c();
    l.intro && transition_in(u.$$.fragment), mount_component(u, l.target, l.anchor), end_hydrating(), flush();
  }
  set_current_component(k);
}
let SvelteElement;
typeof HTMLElement == "function" && (SvelteElement = class extends HTMLElement {
  constructor(l, f, p) {
    super();
    /** The Svelte component constructor */
    me(this, "$$ctor");
    /** Slots */
    me(this, "$$s");
    /** The Svelte component instance */
    me(this, "$$c");
    /** Whether or not the custom element is connected */
    me(this, "$$cn", !1);
    /** Component props data */
    me(this, "$$d", {});
    /** `true` if currently in the process of reflecting component props back to attributes */
    me(this, "$$r", !1);
    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    me(this, "$$p_d", {});
    /** @type {Record<string, Function[]>} Event listeners */
    me(this, "$$l", {});
    /** @type {Map<Function, Function>} Event listener unsubscribe functions */
    me(this, "$$l_u", /* @__PURE__ */ new Map());
    this.$$ctor = l, this.$$s = f, p && this.attachShadow({ mode: "open" });
  }
  addEventListener(l, f, p) {
    if (this.$$l[l] = this.$$l[l] || [], this.$$l[l].push(f), this.$$c) {
      const m = this.$$c.$on(l, f);
      this.$$l_u.set(f, m);
    }
    super.addEventListener(l, f, p);
  }
  removeEventListener(l, f, p) {
    if (super.removeEventListener(l, f, p), this.$$c) {
      const m = this.$$l_u.get(f);
      m && (m(), this.$$l_u.delete(f));
    }
  }
  async connectedCallback() {
    if (this.$$cn = !0, !this.$$c) {
      let l = function(b) {
        return () => {
          let y;
          return {
            c: function() {
              y = element("slot"), b !== "default" && attr(y, "name", b);
            },
            /**
             * @param {HTMLElement} target
             * @param {HTMLElement} [anchor]
             */
            m: function(S, $) {
              insert(S, y, $);
            },
            d: function(S) {
              S && detach(y);
            }
          };
        };
      };
      if (await Promise.resolve(), !this.$$cn || this.$$c)
        return;
      const f = {}, p = get_custom_elements_slots(this);
      for (const b of this.$$s)
        b in p && (f[b] = [l(b)]);
      for (const b of this.attributes) {
        const y = this.$$g_p(b.name);
        y in this.$$d || (this.$$d[y] = get_custom_element_value(y, b.value, this.$$p_d, "toProp"));
      }
      for (const b in this.$$p_d)
        !(b in this.$$d) && this[b] !== void 0 && (this.$$d[b] = this[b], delete this[b]);
      this.$$c = new this.$$ctor({
        target: this.shadowRoot || this,
        props: {
          ...this.$$d,
          $$slots: f,
          $$scope: {
            ctx: []
          }
        }
      });
      const m = () => {
        this.$$r = !0;
        for (const b in this.$$p_d)
          if (this.$$d[b] = this.$$c.$$.ctx[this.$$c.$$.props[b]], this.$$p_d[b].reflect) {
            const y = get_custom_element_value(
              b,
              this.$$d[b],
              this.$$p_d,
              "toAttribute"
            );
            y == null ? this.removeAttribute(this.$$p_d[b].attribute || b) : this.setAttribute(this.$$p_d[b].attribute || b, y);
          }
        this.$$r = !1;
      };
      this.$$c.$$.after_update.push(m), m();
      for (const b in this.$$l)
        for (const y of this.$$l[b]) {
          const v = this.$$c.$on(b, y);
          this.$$l_u.set(y, v);
        }
      this.$$l = {};
    }
  }
  // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
  // and setting attributes through setAttribute etc, this is helpful
  attributeChangedCallback(l, f, p) {
    var m;
    this.$$r || (l = this.$$g_p(l), this.$$d[l] = get_custom_element_value(l, p, this.$$p_d, "toProp"), (m = this.$$c) == null || m.$set({ [l]: this.$$d[l] }));
  }
  disconnectedCallback() {
    this.$$cn = !1, Promise.resolve().then(() => {
      !this.$$cn && this.$$c && (this.$$c.$destroy(), this.$$c = void 0);
    });
  }
  $$g_p(l) {
    return Object.keys(this.$$p_d).find(
      (f) => this.$$p_d[f].attribute === l || !this.$$p_d[f].attribute && f.toLowerCase() === l
    ) || l;
  }
});
function get_custom_element_value(u, l, f, p) {
  var b;
  const m = (b = f[u]) == null ? void 0 : b.type;
  if (l = m === "Boolean" && typeof l != "boolean" ? l != null : l, !p || !f[u])
    return l;
  if (p === "toAttribute")
    switch (m) {
      case "Object":
      case "Array":
        return l == null ? null : JSON.stringify(l);
      case "Boolean":
        return l ? "" : null;
      case "Number":
        return l ?? null;
      default:
        return l;
    }
  else
    switch (m) {
      case "Object":
      case "Array":
        return l && JSON.parse(l);
      case "Boolean":
        return l;
      case "Number":
        return l != null ? +l : l;
      default:
        return l;
    }
}
function create_custom_element(u, l, f, p, m, b) {
  let y = class extends SvelteElement {
    constructor() {
      super(u, f, m), this.$$p_d = l;
    }
    static get observedAttributes() {
      return Object.keys(l).map(
        (v) => (l[v].attribute || v).toLowerCase()
      );
    }
  };
  return Object.keys(l).forEach((v) => {
    Object.defineProperty(y.prototype, v, {
      get() {
        return this.$$c && v in this.$$c ? this.$$c[v] : this.$$d[v];
      },
      set(k) {
        var S;
        k = get_custom_element_value(v, k, l), this.$$d[v] = k, (S = this.$$c) == null || S.$set({ [v]: k });
      }
    });
  }), p.forEach((v) => {
    Object.defineProperty(y.prototype, v, {
      get() {
        var k;
        return (k = this.$$c) == null ? void 0 : k[v];
      }
    });
  }), b && (y = b(y)), u.element = /** @type {any} */
  y, y;
}
class SvelteComponent {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    me(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    me(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1), this.$destroy = noop$4;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(l, f) {
    if (!is_function(f))
      return noop$4;
    const p = this.$$.callbacks[l] || (this.$$.callbacks[l] = []);
    return p.push(f), () => {
      const m = p.indexOf(f);
      m !== -1 && p.splice(m, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(l) {
    this.$$set && !is_empty(l) && (this.$$.skip_bound = !0, this.$$set(l), this.$$.skip_bound = !1);
  }
}
const VERSION$1 = "4.2.19", PUBLIC_VERSION = "4";
function dispatch_dev(u, l) {
  document.dispatchEvent(custom_event(u, { version: VERSION$1, ...l }, { bubbles: !0 }));
}
function append_dev(u, l) {
  dispatch_dev("SvelteDOMInsert", { target: u, node: l }), append$1(u, l);
}
function append_hydration_dev(u, l) {
  dispatch_dev("SvelteDOMInsert", { target: u, node: l }), append_hydration(u, l);
}
function insert_dev(u, l, f) {
  dispatch_dev("SvelteDOMInsert", { target: u, node: l, anchor: f }), insert(u, l, f);
}
function insert_hydration_dev(u, l, f) {
  dispatch_dev("SvelteDOMInsert", { target: u, node: l, anchor: f }), insert_hydration(u, l, f);
}
function detach_dev(u) {
  dispatch_dev("SvelteDOMRemove", { node: u }), detach(u);
}
function detach_between_dev(u, l) {
  for (; u.nextSibling && u.nextSibling !== l; )
    detach_dev(u.nextSibling);
}
function detach_before_dev(u) {
  for (; u.previousSibling; )
    detach_dev(u.previousSibling);
}
function detach_after_dev(u) {
  for (; u.nextSibling; )
    detach_dev(u.nextSibling);
}
function listen_dev(u, l, f, p, m, b, y) {
  const v = p === !0 ? ["capture"] : p ? Array.from(Object.keys(p)) : [];
  m && v.push("preventDefault"), b && v.push("stopPropagation"), y && v.push("stopImmediatePropagation"), dispatch_dev("SvelteDOMAddEventListener", { node: u, event: l, handler: f, modifiers: v });
  const k = listen(u, l, f, p);
  return () => {
    dispatch_dev("SvelteDOMRemoveEventListener", { node: u, event: l, handler: f, modifiers: v }), k();
  };
}
function attr_dev(u, l, f) {
  attr(u, l, f), f == null ? dispatch_dev("SvelteDOMRemoveAttribute", { node: u, attribute: l }) : dispatch_dev("SvelteDOMSetAttribute", { node: u, attribute: l, value: f });
}
function prop_dev(u, l, f) {
  u[l] = f, dispatch_dev("SvelteDOMSetProperty", { node: u, property: l, value: f });
}
function dataset_dev(u, l, f) {
  u.dataset[l] = f, dispatch_dev("SvelteDOMSetDataset", { node: u, property: l, value: f });
}
function set_data_dev(u, l) {
  l = "" + l, u.data !== l && (dispatch_dev("SvelteDOMSetData", { node: u, data: l }), u.data = /** @type {string} */
  l);
}
function set_data_contenteditable_dev(u, l) {
  l = "" + l, u.wholeText !== l && (dispatch_dev("SvelteDOMSetData", { node: u, data: l }), u.data = /** @type {string} */
  l);
}
function set_data_maybe_contenteditable_dev(u, l, f) {
  ~contenteditable_truthy_values.indexOf(f) ? set_data_contenteditable_dev(u, l) : set_data_dev(u, l);
}
function ensure_array_like_dev(u) {
  if (typeof u != "string" && !(u && typeof u == "object" && "length" in u) && !(typeof Symbol == "function" && u && Symbol.iterator in u))
    throw new Error("{#each} only works with iterable values.");
  return ensure_array_like(u);
}
function validate_slots(u, l, f) {
  for (const p of Object.keys(l))
    ~f.indexOf(p) || console.warn(`<${u}> received an unexpected slot "${p}".`);
}
function validate_dynamic_element(u) {
  if (u && !(typeof u == "string"))
    throw new Error('<svelte:element> expects "this" attribute to be a string.');
}
function validate_void_dynamic_element(u) {
  u && is_void(u) && console.warn(`<svelte:element this="${u}"> is self-closing and cannot have content.`);
}
function construct_svelte_component_dev(u, l) {
  const f = "this={...} of <svelte:component> should specify a Svelte component.";
  try {
    const p = new u(l);
    if (!p.$$ || !p.$set || !p.$on || !p.$destroy)
      throw new Error(f);
    return p;
  } catch (p) {
    const { message: m } = p;
    throw typeof m == "string" && m.indexOf("is not a constructor") !== -1 ? new Error(f) : p;
  }
}
class SvelteComponentDev extends SvelteComponent {
  /** @param {import('./public.js').ComponentConstructorOptions<Props>} options */
  constructor(f) {
    if (!f || !f.target && !f.$$inline)
      throw new Error("'target' is a required option");
    super();
    /**
     * For type checking capabilities only.
     * Does not exist at runtime.
     * ### DO NOT USE!
     *
     * @type {Props}
     */
    me(this, "$$prop_def");
    /**
     * For type checking capabilities only.
     * Does not exist at runtime.
     * ### DO NOT USE!
     *
     * @type {Events}
     */
    me(this, "$$events_def");
    /**
     * For type checking capabilities only.
     * Does not exist at runtime.
     * ### DO NOT USE!
     *
     * @type {Slots}
     */
    me(this, "$$slot_def");
  }
  /** @returns {void} */
  $destroy() {
    super.$destroy(), this.$destroy = () => {
      console.warn("Component was already destroyed");
    };
  }
  /** @returns {void} */
  $capture_state() {
  }
  /** @returns {void} */
  $inject_state() {
  }
}
class SvelteComponentTyped extends SvelteComponentDev {
}
function loop_guard(u) {
  const l = Date.now();
  return () => {
    if (Date.now() - l > u)
      throw new Error("Infinite loop detected");
  };
}
const internal = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  HtmlTag,
  HtmlTagHydration,
  ResizeObserverSingleton,
  SvelteComponent,
  SvelteComponentDev,
  SvelteComponentTyped,
  get SvelteElement() {
    return SvelteElement;
  },
  action_destroyer,
  add_attribute,
  add_classes,
  add_flush_callback,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  add_styles,
  add_transform,
  afterUpdate,
  append: append$1,
  append_dev,
  append_empty_stylesheet,
  append_hydration,
  append_hydration_dev,
  append_styles,
  assign,
  attr,
  attr_dev,
  attribute_to_object,
  beforeUpdate,
  bind,
  binding_callbacks,
  blank_object,
  bubble,
  check_outros,
  children,
  claim_comment,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_svg_element,
  claim_text,
  clear_loops,
  comment,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component,
  construct_svelte_component_dev,
  contenteditable_truthy_values,
  createEventDispatcher,
  create_animation,
  create_bidirectional_transition,
  create_component,
  create_custom_element,
  create_in_transition,
  create_out_transition,
  create_slot,
  create_ssr_component,
  get current_component() {
    return current_component;
  },
  custom_event,
  dataset_dev,
  debug,
  destroy_block,
  destroy_component,
  destroy_each,
  detach,
  detach_after_dev,
  detach_before_dev,
  detach_between_dev,
  detach_dev,
  dirty_components,
  dispatch_dev,
  each: each$1,
  element,
  element_is,
  empty: empty$1,
  end_hydrating,
  ensure_array_like,
  ensure_array_like_dev,
  escape: escape$2,
  escape_attribute_value,
  escape_object,
  exclude_internal_props,
  fix_and_destroy_block,
  fix_and_outro_and_destroy_block,
  fix_position,
  flush,
  flush_render_callbacks,
  getAllContexts,
  getContext: getContext$1,
  get_all_dirty_from_scope,
  get_binding_group_value,
  get_current_component,
  get_custom_elements_slots,
  get_root_for_style,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  get_svelte_dataset,
  globals: globals$1,
  group_outros,
  handle_promise,
  hasContext,
  has_prop,
  head_selector,
  identity: identity$5,
  init: init$1,
  init_binding_group,
  init_binding_group_dynamic,
  insert,
  insert_dev,
  insert_hydration,
  insert_hydration_dev,
  intros,
  invalid_attribute_name_character,
  is_client,
  is_crossorigin,
  is_empty,
  is_function,
  is_promise,
  is_void,
  listen,
  listen_dev,
  loop,
  loop_guard,
  merge_ssr_styles,
  missing_component,
  mount_component,
  noop: noop$4,
  not_equal,
  get now() {
    return now;
  },
  null_to_empty,
  object_without_properties,
  onDestroy,
  onMount,
  once: once$1,
  outro_and_destroy_block,
  prevent_default,
  prop_dev,
  query_selector_all,
  get raf() {
    return raf;
  },
  resize_observer_border_box,
  resize_observer_content_box,
  resize_observer_device_pixel_content_box,
  run,
  run_all,
  safe_not_equal,
  schedule_update,
  select_multiple_value,
  select_option,
  select_options,
  select_value,
  self: self$1,
  setContext,
  set_attributes,
  set_current_component,
  set_custom_element_data,
  set_custom_element_data_map,
  set_data,
  set_data_contenteditable,
  set_data_contenteditable_dev,
  set_data_dev,
  set_data_maybe_contenteditable,
  set_data_maybe_contenteditable_dev,
  set_dynamic_element_data,
  set_input_type,
  set_input_value,
  set_now,
  set_raf,
  set_store_value,
  set_style,
  set_svg_attributes,
  space,
  split_css_unit,
  spread,
  src_url_equal,
  srcset_url_equal,
  start_hydrating,
  stop_immediate_propagation,
  stop_propagation,
  stringify_spread,
  subscribe,
  svg_element,
  text: text$2,
  tick,
  time_ranges_to_array,
  to_number,
  toggle_class,
  transition_in,
  transition_out,
  trusted,
  update_await_block_branch,
  update_keyed_each,
  update_slot,
  update_slot_base,
  validate_component,
  validate_dynamic_element,
  validate_each_keys,
  validate_slots,
  validate_store,
  validate_void_dynamic_element,
  xlink_attr
}, Symbol.toStringTag, { value: "Module" }));
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
const subscriber_queue = [];
function readable(u, l) {
  return {
    subscribe: writable(u, l).subscribe
  };
}
function writable(u, l = noop$4) {
  let f;
  const p = /* @__PURE__ */ new Set();
  function m(v) {
    if (safe_not_equal(u, v) && (u = v, f)) {
      const k = !subscriber_queue.length;
      for (const S of p)
        S[1](), subscriber_queue.push(S, u);
      if (k) {
        for (let S = 0; S < subscriber_queue.length; S += 2)
          subscriber_queue[S][0](subscriber_queue[S + 1]);
        subscriber_queue.length = 0;
      }
    }
  }
  function b(v) {
    m(v(u));
  }
  function y(v, k = noop$4) {
    const S = [v, k];
    return p.add(S), p.size === 1 && (f = l(m, b) || noop$4), v(u), () => {
      p.delete(S), p.size === 0 && f && (f(), f = null);
    };
  }
  return { set: m, update: b, subscribe: y };
}
function derived(u, l, f) {
  const p = !Array.isArray(u), m = p ? [u] : u;
  if (!m.every(Boolean))
    throw new Error("derived() expects stores as input, got a falsy value");
  const b = l.length < 2;
  return readable(f, (y, v) => {
    let k = !1;
    const S = [];
    let $ = 0, w = noop$4;
    const T = () => {
      if ($)
        return;
      w();
      const R = l(p ? S[0] : S, y, v);
      b ? y(R) : w = is_function(R) ? R : noop$4;
    }, E = m.map(
      (R, O) => subscribe(
        R,
        (P) => {
          S[O] = P, $ &= ~(1 << O), k && T();
        },
        () => {
          $ |= 1 << O;
        }
      )
    );
    return k = !0, T(), function() {
      run_all(E), w(), k = !1;
    };
  });
}
const svelte = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SvelteComponent: SvelteComponentDev,
  SvelteComponentTyped,
  afterUpdate,
  beforeUpdate,
  createEventDispatcher,
  getAllContexts,
  getContext: getContext$1,
  hasContext,
  onDestroy,
  onMount,
  setContext,
  tick
}, Symbol.toStringTag, { value: "Module" })), bbui = "";
var PopoverAlignment = /* @__PURE__ */ ((u) => (u.Left = "left", u.Right = "right", u.LeftOutside = "left-outside", u.RightOutside = "right-outside", u.Center = "center", u.RightContextMenu = "right-context-menu", u.LeftContextMenu = "left-context-menu", u))(PopoverAlignment || {}), TooltipPosition = /* @__PURE__ */ ((u) => (u.Top = "top", u.Right = "right", u.Bottom = "bottom", u.Left = "left", u))(TooltipPosition || {}), TooltipType = /* @__PURE__ */ ((u) => (u.Default = "default", u.Info = "info", u.Positive = "positive", u.Negative = "negative", u))(TooltipType || {}), ModalCancelFrom = /* @__PURE__ */ ((u) => (u.CLOSE_BUTTON = "close_button", u.CANCEL_BUTTON = "cancel_button", u.ESCAPE_KEY = "escape_key", u.OUTSIDE_CLICK = "outside_click", u))(ModalCancelFrom || {});
const indexVars$E = "";
function create_fragment$1K(u) {
  let l, f, p, m, b;
  const y = (
    /*#slots*/
    u[2].default
  ), v = create_slot(
    y,
    u,
    /*$$scope*/
    u[1],
    null
  );
  return {
    c() {
      l = element("div"), v && v.c(), l.hidden = !0;
    },
    m(k, S) {
      insert(k, l, S), v && v.m(l, null), p = !0, m || (b = action_destroyer(f = portal.call(
        null,
        l,
        /*target*/
        u[0]
      )), m = !0);
    },
    p(k, [S]) {
      v && v.p && (!p || S & /*$$scope*/
      2) && update_slot_base(
        v,
        y,
        k,
        /*$$scope*/
        k[1],
        p ? get_slot_changes(
          y,
          /*$$scope*/
          k[1],
          S,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          k[1]
        ),
        null
      ), f && is_function(f.update) && S & /*target*/
      1 && f.update.call(
        null,
        /*target*/
        k[0]
      );
    },
    i(k) {
      p || (transition_in(v, k), p = !0);
    },
    o(k) {
      transition_out(v, k), p = !1;
    },
    d(k) {
      k && detach(l), v && v.d(k), m = !1, b();
    }
  };
}
function portal(u, l = "body") {
  let f;
  async function p(b) {
    if (l = b, typeof l == "string") {
      if (f = document.querySelector(l), f === null && (await tick(), f = document.querySelector(l)), f === null)
        throw new Error(`No element found matching css selector: "${l}"`);
    } else if (l instanceof HTMLElement)
      f = l;
    else
      throw new TypeError(`Unknown portal target type: ${l === null ? "null" : typeof l}. Allowed types: string (CSS selector) or HTMLElement.`);
    f.appendChild(u), u.hidden = !1;
  }
  function m() {
    u.parentNode && u.parentNode.removeChild(u);
  }
  return p(l), { update: p, destroy: m };
}
function instance$1I(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l, { target: b = "body" } = l;
  return u.$$set = (y) => {
    "target" in y && f(0, b = y.target), "$$scope" in y && f(1, m = y.$$scope);
  }, [b, m, p];
}
class Portal extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1I, create_fragment$1K, safe_not_equal, { target: 0 });
  }
}
function cubicOut(u) {
  const l = u - 1;
  return l * l * l + 1;
}
function fade(u, { delay: l = 0, duration: f = 400, easing: p = identity$5 } = {}) {
  const m = +getComputedStyle(u).opacity;
  return {
    delay: l,
    duration: f,
    easing: p,
    css: (b) => `opacity: ${b * m}`
  };
}
function fly(u, { delay: l = 0, duration: f = 400, easing: p = cubicOut, x: m = 0, y: b = 0, opacity: y = 0 } = {}) {
  const v = getComputedStyle(u), k = +v.opacity, S = v.transform === "none" ? "" : v.transform, $ = k * (1 - y), [w, T] = split_css_unit(m), [E, R] = split_css_unit(b);
  return {
    delay: l,
    duration: f,
    easing: p,
    css: (O, P) => `
			transform: ${S} translate(${(1 - O) * w}${T}, ${(1 - O) * E}${R});
			opacity: ${k - $ * P}`
  };
}
function slide(u, { delay: l = 0, duration: f = 400, easing: p = cubicOut, axis: m = "y" } = {}) {
  const b = getComputedStyle(u), y = +b.opacity, v = m === "y" ? "height" : "width", k = parseFloat(b[v]), S = m === "y" ? ["top", "bottom"] : ["left", "right"], $ = S.map(
    (L) => `${L[0].toUpperCase()}${L.slice(1)}`
  ), w = parseFloat(b[`padding${$[0]}`]), T = parseFloat(b[`padding${$[1]}`]), E = parseFloat(b[`margin${$[0]}`]), R = parseFloat(b[`margin${$[1]}`]), O = parseFloat(
    b[`border${$[0]}Width`]
  ), P = parseFloat(
    b[`border${$[1]}Width`]
  );
  return {
    delay: l,
    duration: f,
    easing: p,
    css: (L) => `overflow: hidden;opacity: ${Math.min(L * 20, 1) * y};${v}: ${L * k}px;padding-${S[0]}: ${L * w}px;padding-${S[1]}: ${L * T}px;margin-${S[0]}: ${L * E}px;margin-${S[1]}: ${L * R}px;border-${S[0]}-width: ${L * O}px;border-${S[1]}-width: ${L * P}px;`
  };
}
const indexVars$D = "", AbsTooltip_svelte_svelte_type_style_lang = "";
function create_if_block$T(u) {
  let l, f;
  return l = new Portal({
    props: {
      target: ".spectrum",
      $$slots: { default: [create_default_slot$P] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, type, position, left, top, tooltipStyle, noWrap, tipStyle, text*/
      132815 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot$P(u) {
  let l, f, p, m, b, y, v, k, S;
  return {
    c() {
      l = element("span"), f = element("span"), p = text$2(
        /*text*/
        u[2]
      ), m = space(), b = element("span"), attr(f, "class", "spectrum-Tooltip-label svelte-dwbp30"), attr(b, "class", "spectrum-Tooltip-tip svelte-dwbp30"), attr(
        b,
        "style",
        /*tipStyle*/
        u[9]
      ), attr(l, "class", y = "spectrum-Tooltip spectrum-Tooltip--" + /*type*/
      u[1] + " spectrum-Tooltip--" + /*position*/
      u[0] + " is-open svelte-dwbp30"), attr(l, "style", v = `left:${/*left*/
      u[6]}px;top:${/*top*/
      u[7]}px;${/*tooltipStyle*/
      u[10]}`), toggle_class(
        l,
        "noWrap",
        /*noWrap*/
        u[3]
      );
    },
    m($, w) {
      insert($, l, w), append$1(l, f), append$1(f, p), append$1(l, m), append$1(l, b), S = !0;
    },
    p($, w) {
      (!S || w & /*text*/
      4) && set_data(
        p,
        /*text*/
        $[2]
      ), (!S || w & /*tipStyle*/
      512) && attr(
        b,
        "style",
        /*tipStyle*/
        $[9]
      ), (!S || w & /*type, position*/
      3 && y !== (y = "spectrum-Tooltip spectrum-Tooltip--" + /*type*/
      $[1] + " spectrum-Tooltip--" + /*position*/
      $[0] + " is-open svelte-dwbp30")) && attr(l, "class", y), (!S || w & /*left, top, tooltipStyle*/
      1216 && v !== (v = `left:${/*left*/
      $[6]}px;top:${/*top*/
      $[7]}px;${/*tooltipStyle*/
      $[10]}`)) && attr(l, "style", v), (!S || w & /*type, position, noWrap*/
      11) && toggle_class(
        l,
        "noWrap",
        /*noWrap*/
        $[3]
      );
    },
    i($) {
      S || ($ && add_render_callback(() => {
        S && (k || (k = create_bidirectional_transition(l, fade, { duration: 130 }, !0)), k.run(1));
      }), S = !0);
    },
    o($) {
      $ && (k || (k = create_bidirectional_transition(l, fade, { duration: 130 }, !1)), k.run(0)), S = !1;
    },
    d($) {
      $ && detach(l), $ && k && k.end();
    }
  };
}
function create_fragment$1J(u) {
  let l, f, p, m, b, y;
  const v = (
    /*#slots*/
    u[13].default
  ), k = create_slot(
    v,
    u,
    /*$$scope*/
    u[17],
    null
  );
  let S = (
    /*visible*/
    u[8] && /*text*/
    u[2] && /*left*/
    u[6] != null && /*top*/
    u[7] != null && create_if_block$T(u)
  );
  return {
    c() {
      l = element("div"), k && k.c(), f = space(), S && S.c(), p = empty$1(), attr(l, "class", "abs-tooltip svelte-dwbp30");
    },
    m($, w) {
      insert($, l, w), k && k.m(l, null), u[14](l), insert($, f, w), S && S.m($, w), insert($, p, w), m = !0, b || (y = [
        listen(l, "focus", null),
        listen(
          l,
          "mouseover",
          /*mouseover_handler*/
          u[15]
        ),
        listen(
          l,
          "mouseleave",
          /*mouseleave_handler*/
          u[16]
        )
      ], b = !0);
    },
    p($, [w]) {
      k && k.p && (!m || w & /*$$scope*/
      131072) && update_slot_base(
        k,
        v,
        $,
        /*$$scope*/
        $[17],
        m ? get_slot_changes(
          v,
          /*$$scope*/
          $[17],
          w,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          $[17]
        ),
        null
      ), /*visible*/
      $[8] && /*text*/
      $[2] && /*left*/
      $[6] != null && /*top*/
      $[7] != null ? S ? (S.p($, w), w & /*visible, text, left, top*/
      452 && transition_in(S, 1)) : (S = create_if_block$T($), S.c(), transition_in(S, 1), S.m(p.parentNode, p)) : S && (group_outros(), transition_out(S, 1, 1, () => {
        S = null;
      }), check_outros());
    },
    i($) {
      m || (transition_in(k, $), transition_in(S), m = !0);
    },
    o($) {
      transition_out(k, $), transition_out(S), m = !1;
    },
    d($) {
      $ && (detach(l), detach(f), detach(p)), k && k.d($), u[14](null), S && S.d($), b = !1, run_all(y);
    }
  };
}
function instance$1H(u, l, f) {
  let p, m, { $$slots: b = {}, $$scope: y } = l, { position: v = TooltipPosition.Top } = l, { type: k = TooltipType.Default } = l, { text: S = "" } = l, { fixed: $ = !1 } = l, { color: w = void 0 } = l, { noWrap: T = !1 } = l, E, R = !1, O, P, L = !1, M, B;
  const j = () => {
    var Y;
    const F = (Y = E == null ? void 0 : E.children) == null ? void 0 : Y[0];
    if (!F) {
      f(6, O = void 0), f(7, P = void 0);
      return;
    }
    const U = F.getBoundingClientRect();
    v === TooltipPosition.Top ? (f(6, O = U.left + U.width / 2), f(7, P = U.top)) : v === TooltipPosition.Right ? (f(6, O = U.left + U.width), f(7, P = U.top + U.height / 2)) : v === TooltipPosition.Bottom ? (f(6, O = U.left + U.width / 2), f(7, P = U.top + U.height)) : v === TooltipPosition.Left && (f(6, O = U.left), f(7, P = U.top + U.height / 2));
  }, x = () => {
    j(), B = setInterval(j, 100), f(8, L = !0);
  }, N = () => {
    clearTimeout(M), clearInterval(B), f(8, L = !1);
  };
  onDestroy(N);
  function D(F) {
    binding_callbacks[F ? "unshift" : "push"](() => {
      E = F, f(5, E);
    });
  }
  const V = () => f(4, R = !0), W = () => f(4, R = !1);
  return u.$$set = (F) => {
    "position" in F && f(0, v = F.position), "type" in F && f(1, k = F.type), "text" in F && f(2, S = F.text), "fixed" in F && f(11, $ = F.fixed), "color" in F && f(12, w = F.color), "noWrap" in F && f(3, T = F.noWrap), "$$scope" in F && f(17, y = F.$$scope);
  }, u.$$.update = () => {
    u.$$.dirty & /*hovered, fixed*/
    2064 && (R || $ ? M = setTimeout(x, 200) : N()), u.$$.dirty & /*color*/
    4096 && f(10, p = w ? `background:${w};` : null), u.$$.dirty & /*color*/
    4096 && f(9, m = w ? `border-top-color:${w};` : null);
  }, [
    v,
    k,
    S,
    T,
    R,
    E,
    O,
    P,
    L,
    m,
    p,
    $,
    w,
    b,
    D,
    V,
    W,
    y
  ];
}
class AbsTooltip extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1H, create_fragment$1J, safe_not_equal, {
      position: 0,
      type: 1,
      text: 2,
      fixed: 11,
      color: 12,
      noWrap: 3
    });
  }
}
var PingSource = /* @__PURE__ */ ((u) => (u.BUILDER = "builder", u.APP = "app", u))(PingSource || {}), SortOrder = /* @__PURE__ */ ((u) => (u.ASCENDING = "ascending", u.DESCENDING = "descending", u))(SortOrder || {}), SortType = /* @__PURE__ */ ((u) => (u.STRING = "string", u.NUMBER = "number", u))(SortType || {}), Feature = /* @__PURE__ */ ((u) => (u.USER_GROUPS = "userGroups", u.WORKSPACE_BACKUPS = "appBackups", u.ENVIRONMENT_VARIABLES = "environmentVariables", u.AUDIT_LOGS = "auditLogs", u.ENFORCEABLE_SSO = "enforceableSSO", u.BRANDING = "branding", u.SCIM = "scim", u.SYNC_AUTOMATIONS = "syncAutomations", u.TRIGGER_AUTOMATION_RUN = "triggerAutomationRun", u.APP_BUILDERS = "appBuilders", u.OFFLINE = "offline", u.EXPANDED_PUBLIC_API = "expandedPublicApi", u.CUSTOM_APP_SCRIPTS = "customAppScripts", u.PDF = "pdf", u.VIEW_PERMISSIONS = "viewPermissions", u.VIEW_READONLY_COLUMNS = "viewReadonlyColumns", u.BUDIBASE_AI = "budibaseAI", u.AI_CUSTOM_CONFIGS = "aiCustomConfigs", u.PWA = "pwa", u.RECAPTCHA = "recaptcha", u.PKCE_OIDC = "pkceOidc", u))(Feature || {}), commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$1(u) {
  return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
}
function getAugmentedNamespace(u) {
  if (u.__esModule)
    return u;
  var l = u.default;
  if (typeof l == "function") {
    var f = function p() {
      return this instanceof p ? Reflect.construct(l, arguments, this.constructor) : l.apply(this, arguments);
    };
    f.prototype = l.prototype;
  } else
    f = {};
  return Object.defineProperty(f, "__esModule", { value: !0 }), Object.keys(u).forEach(function(p) {
    var m = Object.getOwnPropertyDescriptor(u, p);
    Object.defineProperty(f, p, m.get ? m : {
      enumerable: !0,
      get: function() {
        return u[p];
      }
    });
  }), f;
}
var freeGlobal$2 = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1, _freeGlobal$1 = freeGlobal$2, freeGlobal$1 = _freeGlobal$1, freeSelf$1 = typeof self == "object" && self && self.Object === Object && self, root$d = freeGlobal$1 || freeSelf$1 || Function("return this")(), _root$1 = root$d, root$c = _root$1, Symbol$7 = root$c.Symbol, _Symbol$1 = Symbol$7, Symbol$6 = _Symbol$1, objectProto$y = Object.prototype, hasOwnProperty$u = objectProto$y.hasOwnProperty, nativeObjectToString$3 = objectProto$y.toString, symToStringTag$3 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$2(u) {
  var l = hasOwnProperty$u.call(u, symToStringTag$3), f = u[symToStringTag$3];
  try {
    u[symToStringTag$3] = void 0;
    var p = !0;
  } catch {
  }
  var m = nativeObjectToString$3.call(u);
  return p && (l ? u[symToStringTag$3] = f : delete u[symToStringTag$3]), m;
}
var _getRawTag$1 = getRawTag$2, objectProto$x = Object.prototype, nativeObjectToString$2 = objectProto$x.toString;
function objectToString$3(u) {
  return nativeObjectToString$2.call(u);
}
var _objectToString$1 = objectToString$3, Symbol$5 = _Symbol$1, getRawTag$1 = _getRawTag$1, objectToString$2 = _objectToString$1, nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]", symToStringTag$2 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$8(u) {
  return u == null ? u === void 0 ? undefinedTag$1 : nullTag$1 : symToStringTag$2 && symToStringTag$2 in Object(u) ? getRawTag$1(u) : objectToString$2(u);
}
var _baseGetTag$1 = baseGetTag$8;
function overArg$3(u, l) {
  return function(f) {
    return u(l(f));
  };
}
var _overArg$1 = overArg$3, overArg$2 = _overArg$1, getPrototype$4 = overArg$2(Object.getPrototypeOf, Object), _getPrototype$1 = getPrototype$4;
function isObjectLike$c(u) {
  return u != null && typeof u == "object";
}
var isObjectLike_1$1 = isObjectLike$c, baseGetTag$7 = _baseGetTag$1, getPrototype$3 = _getPrototype$1, isObjectLike$b = isObjectLike_1$1, objectTag$9 = "[object Object]", funcProto$5 = Function.prototype, objectProto$w = Object.prototype, funcToString$5 = funcProto$5.toString, hasOwnProperty$t = objectProto$w.hasOwnProperty, objectCtorString$1 = funcToString$5.call(Object);
function isPlainObject$2(u) {
  if (!isObjectLike$b(u) || baseGetTag$7(u) != objectTag$9)
    return !1;
  var l = getPrototype$3(u);
  if (l === null)
    return !0;
  var f = hasOwnProperty$t.call(l, "constructor") && l.constructor;
  return typeof f == "function" && f instanceof f && funcToString$5.call(f) == objectCtorString$1;
}
var isPlainObject_1$1 = isPlainObject$2;
const isPlainObject$3 = /* @__PURE__ */ getDefaultExportFromCjs$1(isPlainObject_1$1);
var BasicOperator = /* @__PURE__ */ ((u) => (u.EQUAL = "equal", u.NOT_EQUAL = "notEqual", u.EMPTY = "empty", u.NOT_EMPTY = "notEmpty", u.FUZZY = "fuzzy", u.STRING = "string", u))(BasicOperator || {}), ArrayOperator = /* @__PURE__ */ ((u) => (u.CONTAINS = "contains", u.NOT_CONTAINS = "notContains", u.CONTAINS_ANY = "containsAny", u.ONE_OF = "oneOf", u))(ArrayOperator || {}), RangeOperator = /* @__PURE__ */ ((u) => (u.RANGE = "range", u))(RangeOperator || {}), LogicalOperator = /* @__PURE__ */ ((u) => (u.AND = "$and", u.OR = "$or", u))(LogicalOperator || {});
function isLogicalSearchOperator(u) {
  return Object.values(LogicalOperator).includes(u);
}
function isBasicSearchOperator(u) {
  return Object.values(BasicOperator).includes(u);
}
function isArraySearchOperator(u) {
  return Object.values(ArrayOperator).includes(u);
}
function isRangeSearchOperator(u) {
  return Object.values(RangeOperator).includes(u);
}
var EmptyFilterOption = /* @__PURE__ */ ((u) => (u.RETURN_ALL = "all", u.RETURN_NONE = "none", u))(EmptyFilterOption || {}), UILogicalOperator = /* @__PURE__ */ ((u) => (u.ALL = "all", u.ANY = "any", u))(UILogicalOperator || {}), MaintenanceType = /* @__PURE__ */ ((u) => (u.SQS_MISSING = "sqs_missing", u))(MaintenanceType || {});
const SEPARATOR$1 = "_", prefixed = (u) => `${u}${SEPARATOR$1}`;
var DocumentType = /* @__PURE__ */ ((u) => (u.USER = "us", u.GROUP = "gr", u.CONFIG = "config", u.TEMPLATE = "template", u.WORKSPACE = "app", u.DEV = "dev", u.WORKSPACE_DEV = "app_dev", u.WORKSPACE_METADATA = "app_metadata", u.ROLE = "role", u.DEV_INFO = "devinfo", u.AUTOMATION_LOG = "log_au", u.ACCOUNT_METADATA = "acc_metadata", u.PLUGIN = "plg", u.DATASOURCE = "datasource", u.DATASOURCE_PLUS = "datasource_plus", u.APP_BACKUP = "backup", u.TABLE = "ta", u.ROW = "ro", u.AUTOMATION = "au", u.LINK = "li", u.WEBHOOK = "wh", u.INSTANCE = "inst", u.LAYOUT = "layout", u.SCREEN = "screen", u.QUERY = "query", u.DEPLOYMENTS = "deployments", u.METADATA = "metadata", u.MEM_VIEW = "view", u.USER_FLAG = "flag", u.AUTOMATION_METADATA = "meta_au", u.AUDIT_LOG = "al", u.SCIM_LOG = "scimlog", u.ROW_ACTIONS = "ra", u.OAUTH2_CONFIG = "oauth2", u.OAUTH2_CONFIG_LOG = "oauth2log", u.AGENT_CHAT = "agentchat", u.AGENT_TOOL_SOURCE = "agenttoolsource", u.WORKSPACE_APP = "workspace_app", u.WORKSPACE_FAVOURITE = "workspace_favourite", u))(DocumentType || {}), InternalTable = /* @__PURE__ */ ((u) => (u.USER_METADATA = "ta_users", u))(InternalTable || {}), RelationshipType = /* @__PURE__ */ ((u) => (u.ONE_TO_MANY = "one-to-many", u.MANY_TO_ONE = "many-to-one", u.MANY_TO_MANY = "many-to-many", u))(RelationshipType || {}), FormulaType = /* @__PURE__ */ ((u) => (u.STATIC = "static", u.DYNAMIC = "dynamic", u.AI = "ai", u))(FormulaType || {}), BBReferenceFieldSubType = /* @__PURE__ */ ((u) => (u.USER = "user", u.USERS = "users", u))(BBReferenceFieldSubType || {}), StringFieldSubType = /* @__PURE__ */ ((u) => (u.ARRAY = "array", u))(StringFieldSubType || {});
function isRelationshipField(u) {
  return u.type === FieldType.LINK;
}
const EXTERNAL_ROW_REV = "rev";
var FieldType = /* @__PURE__ */ ((u) => (u.STRING = "string", u.LONGFORM = "longform", u.OPTIONS = "options", u.NUMBER = "number", u.BOOLEAN = "boolean", u.ARRAY = "array", u.DATETIME = "datetime", u.ATTACHMENTS = "attachment", u.ATTACHMENT_SINGLE = "attachment_single", u.LINK = "link", u.FORMULA = "formula", u.AUTO = "auto", u.AI = "ai", u.JSON = "json", u.INTERNAL = "internal", u.BARCODEQR = "barcodeqr", u.SIGNATURE_SINGLE = "signature_single", u.BIGINT = "bigint", u.BB_REFERENCE = "bb_reference", u.BB_REFERENCE_SINGLE = "bb_reference_single", u))(FieldType || {}), ScreenVariant = /* @__PURE__ */ ((u) => (u.PDF = "pdf", u))(ScreenVariant || {}), Theme = /* @__PURE__ */ ((u) => (u.LIGHTEST = "lightest", u.LIGHT = "light", u.DARK = "dark", u.DARKEST = "darkest", u.NORD = "nord", u.MIDNIGHT = "midnight", u))(Theme || {}), ViewV2Type = /* @__PURE__ */ ((u) => (u.CALCULATION = "calculation", u))(ViewV2Type || {}), ComponentContextScopes = /* @__PURE__ */ ((u) => (u.Local = "local", u.Global = "global", u))(ComponentContextScopes || {}), DropPosition = /* @__PURE__ */ ((u) => (u.ABOVE = "above", u.BELOW = "below", u.INSIDE = "inside", u))(DropPosition || {}), Header = /* @__PURE__ */ ((u) => (u.API_KEY = "x-budibase-api-key", u.LICENSE_KEY = "x-budibase-license-key", u.API_VER = "x-budibase-api-version", u.APP_ID = "x-budibase-app-id", u.SESSION_ID = "x-budibase-session-id", u.CLIENT = "x-budibase-client", u.TYPE = "x-budibase-type", u.PREVIEW_ROLE = "x-budibase-role", u.TENANT_ID = "x-budibase-tenant-id", u.VERIFICATION_CODE = "x-budibase-verification-code", u.RETURN_VERIFICATION_CODE = "x-budibase-return-verification-code", u.RESET_PASSWORD_CODE = "x-budibase-reset-password-code", u.RETURN_RESET_PASSWORD_CODE = "x-budibase-return-reset-password-code", u.TOKEN = "x-budibase-token", u.CSRF_TOKEN = "x-csrf-token", u.CORRELATION_ID = "x-budibase-correlation-id", u.AUTHORIZATION = "authorization", u.MIGRATING_APP = "x-budibase-migrating-app", u.COOKIE = "cookie", u))(Header || {});
const ThemeClassPrefix = "spectrum--";
Theme.DARKEST;
const DefaultAppTheme = Theme.LIGHT, ThemeOptions = [
  {
    id: Theme.LIGHT,
    name: "Light"
  },
  {
    // We call this dark for simplicity, but we want to use the spectrum darkest style
    id: Theme.DARKEST,
    name: "Dark"
  },
  {
    id: Theme.NORD,
    name: "Nord",
    base: Theme.DARKEST
  },
  {
    id: Theme.MIDNIGHT,
    name: "Midnight",
    base: Theme.DARKEST
  }
], OperatorOptions = {
  Equals: {
    value: "equal",
    label: "Equals"
  },
  NotEquals: {
    value: "notEqual",
    label: "Not equals"
  },
  Empty: {
    value: "empty",
    label: "Is empty"
  },
  NotEmpty: {
    value: "notEmpty",
    label: "Is not empty"
  },
  StartsWith: {
    value: "string",
    label: "Starts with"
  },
  Like: {
    value: "fuzzy",
    label: "Like"
  },
  MoreThan: {
    value: "rangeLow",
    label: "More than or equal to"
  },
  LessThan: {
    value: "rangeHigh",
    label: "Less than or equal to"
  },
  Contains: {
    value: "contains",
    label: "Contains"
  },
  NotContains: {
    value: "notContains",
    label: "Does not contain"
  },
  In: {
    value: "oneOf",
    label: "Is in"
  },
  ContainsAny: {
    value: "containsAny",
    label: "Has any"
  }
}, SqlNumberTypeRangeMap = {
  integer: {
    max: 2147483647,
    min: -2147483648
  },
  int: {
    max: 2147483647,
    min: -2147483648
  },
  smallint: {
    max: 32767,
    min: -32768
  },
  mediumint: {
    max: 8388607,
    min: -8388608
  }
};
var SocketEvent = /* @__PURE__ */ ((u) => (u.UserUpdate = "UserUpdate", u.UserDisconnect = "UserDisconnect", u.Heartbeat = "Heartbeat", u))(SocketEvent || {}), GridSocketEvent = /* @__PURE__ */ ((u) => (u.RowChange = "RowChange", u.DatasourceChange = "DatasourceChange", u.SelectDatasource = "SelectDatasource", u.SelectCell = "SelectCell", u.WorkspaceAppChange = "WorkspaceAppChange", u))(GridSocketEvent || {});
const SocketSessionTTL = 60, ValidColumnNameRegex = /^[_a-zA-Z0-9\s]*$/g;
var BpmCorrelationKey = /* @__PURE__ */ ((u) => (u.ONBOARDING = "budibase:onboarding:correlationkey", u.VERIFY_SSO_LOGIN = "budibase:verify_sso_login:correlationkey", u))(BpmCorrelationKey || {});
const DEFAULT_BB_DATASOURCE_ID = "datasource_internal_bb_default";
var dayjs_min$1 = { exports: {} };
(function(u, l) {
  (function(f, p) {
    u.exports = p();
  })(commonjsGlobal$1, function() {
    var f = 1e3, p = 6e4, m = 36e5, b = "millisecond", y = "second", v = "minute", k = "hour", S = "day", $ = "week", w = "month", T = "quarter", E = "year", R = "date", O = "Invalid Date", P = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, L = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(Q) {
      var z = ["th", "st", "nd", "rd"], H = Q % 100;
      return "[" + Q + (z[(H - 20) % 10] || z[H] || z[0]) + "]";
    } }, B = function(Q, z, H) {
      var X = String(Q);
      return !X || X.length >= z ? Q : "" + Array(z + 1 - X.length).join(H) + Q;
    }, j = { s: B, z: function(Q) {
      var z = -Q.utcOffset(), H = Math.abs(z), X = Math.floor(H / 60), Z = H % 60;
      return (z <= 0 ? "+" : "-") + B(X, 2, "0") + ":" + B(Z, 2, "0");
    }, m: function Q(z, H) {
      if (z.date() < H.date())
        return -Q(H, z);
      var X = 12 * (H.year() - z.year()) + (H.month() - z.month()), Z = z.clone().add(X, w), oe = H - Z < 0, ee = z.clone().add(X + (oe ? -1 : 1), w);
      return +(-(X + (H - Z) / (oe ? Z - ee : ee - Z)) || 0);
    }, a: function(Q) {
      return Q < 0 ? Math.ceil(Q) || 0 : Math.floor(Q);
    }, p: function(Q) {
      return { M: w, y: E, w: $, d: S, D: R, h: k, m: v, s: y, ms: b, Q: T }[Q] || String(Q || "").toLowerCase().replace(/s$/, "");
    }, u: function(Q) {
      return Q === void 0;
    } }, x = "en", N = {};
    N[x] = M;
    var D = "$isDayjsObject", V = function(Q) {
      return Q instanceof Y || !(!Q || !Q[D]);
    }, W = function Q(z, H, X) {
      var Z;
      if (!z)
        return x;
      if (typeof z == "string") {
        var oe = z.toLowerCase();
        N[oe] && (Z = oe), H && (N[oe] = H, Z = oe);
        var ee = z.split("-");
        if (!Z && ee.length > 1)
          return Q(ee[0]);
      } else {
        var ie = z.name;
        N[ie] = z, Z = ie;
      }
      return !X && Z && (x = Z), Z || !X && x;
    }, F = function(Q, z) {
      if (V(Q))
        return Q.clone();
      var H = typeof z == "object" ? z : {};
      return H.date = Q, H.args = arguments, new Y(H);
    }, U = j;
    U.l = W, U.i = V, U.w = function(Q, z) {
      return F(Q, { locale: z.$L, utc: z.$u, x: z.$x, $offset: z.$offset });
    };
    var Y = function() {
      function Q(H) {
        this.$L = W(H.locale, null, !0), this.parse(H), this.$x = this.$x || H.x || {}, this[D] = !0;
      }
      var z = Q.prototype;
      return z.parse = function(H) {
        this.$d = function(X) {
          var Z = X.date, oe = X.utc;
          if (Z === null)
            return /* @__PURE__ */ new Date(NaN);
          if (U.u(Z))
            return /* @__PURE__ */ new Date();
          if (Z instanceof Date)
            return new Date(Z);
          if (typeof Z == "string" && !/Z$/i.test(Z)) {
            var ee = Z.match(P);
            if (ee) {
              var ie = ee[2] - 1 || 0, de = (ee[7] || "0").substring(0, 3);
              return oe ? new Date(Date.UTC(ee[1], ie, ee[3] || 1, ee[4] || 0, ee[5] || 0, ee[6] || 0, de)) : new Date(ee[1], ie, ee[3] || 1, ee[4] || 0, ee[5] || 0, ee[6] || 0, de);
            }
          }
          return new Date(Z);
        }(H), this.init();
      }, z.init = function() {
        var H = this.$d;
        this.$y = H.getFullYear(), this.$M = H.getMonth(), this.$D = H.getDate(), this.$W = H.getDay(), this.$H = H.getHours(), this.$m = H.getMinutes(), this.$s = H.getSeconds(), this.$ms = H.getMilliseconds();
      }, z.$utils = function() {
        return U;
      }, z.isValid = function() {
        return this.$d.toString() !== O;
      }, z.isSame = function(H, X) {
        var Z = F(H);
        return this.startOf(X) <= Z && Z <= this.endOf(X);
      }, z.isAfter = function(H, X) {
        return F(H) < this.startOf(X);
      }, z.isBefore = function(H, X) {
        return this.endOf(X) < F(H);
      }, z.$g = function(H, X, Z) {
        return U.u(H) ? this[X] : this.set(Z, H);
      }, z.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, z.valueOf = function() {
        return this.$d.getTime();
      }, z.startOf = function(H, X) {
        var Z = this, oe = !!U.u(X) || X, ee = U.p(H), ie = function(te, ue) {
          var J = U.w(Z.$u ? Date.UTC(Z.$y, ue, te) : new Date(Z.$y, ue, te), Z);
          return oe ? J : J.endOf(S);
        }, de = function(te, ue) {
          return U.w(Z.toDate()[te].apply(Z.toDate("s"), (oe ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ue)), Z);
        }, pe = this.$W, le = this.$M, ae = this.$D, ne = "set" + (this.$u ? "UTC" : "");
        switch (ee) {
          case E:
            return oe ? ie(1, 0) : ie(31, 11);
          case w:
            return oe ? ie(1, le) : ie(0, le + 1);
          case $:
            var K = this.$locale().weekStart || 0, ce = (pe < K ? pe + 7 : pe) - K;
            return ie(oe ? ae - ce : ae + (6 - ce), le);
          case S:
          case R:
            return de(ne + "Hours", 0);
          case k:
            return de(ne + "Minutes", 1);
          case v:
            return de(ne + "Seconds", 2);
          case y:
            return de(ne + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, z.endOf = function(H) {
        return this.startOf(H, !1);
      }, z.$set = function(H, X) {
        var Z, oe = U.p(H), ee = "set" + (this.$u ? "UTC" : ""), ie = (Z = {}, Z[S] = ee + "Date", Z[R] = ee + "Date", Z[w] = ee + "Month", Z[E] = ee + "FullYear", Z[k] = ee + "Hours", Z[v] = ee + "Minutes", Z[y] = ee + "Seconds", Z[b] = ee + "Milliseconds", Z)[oe], de = oe === S ? this.$D + (X - this.$W) : X;
        if (oe === w || oe === E) {
          var pe = this.clone().set(R, 1);
          pe.$d[ie](de), pe.init(), this.$d = pe.set(R, Math.min(this.$D, pe.daysInMonth())).$d;
        } else
          ie && this.$d[ie](de);
        return this.init(), this;
      }, z.set = function(H, X) {
        return this.clone().$set(H, X);
      }, z.get = function(H) {
        return this[U.p(H)]();
      }, z.add = function(H, X) {
        var Z, oe = this;
        H = Number(H);
        var ee = U.p(X), ie = function(le) {
          var ae = F(oe);
          return U.w(ae.date(ae.date() + Math.round(le * H)), oe);
        };
        if (ee === w)
          return this.set(w, this.$M + H);
        if (ee === E)
          return this.set(E, this.$y + H);
        if (ee === S)
          return ie(1);
        if (ee === $)
          return ie(7);
        var de = (Z = {}, Z[v] = p, Z[k] = m, Z[y] = f, Z)[ee] || 1, pe = this.$d.getTime() + H * de;
        return U.w(pe, this);
      }, z.subtract = function(H, X) {
        return this.add(-1 * H, X);
      }, z.format = function(H) {
        var X = this, Z = this.$locale();
        if (!this.isValid())
          return Z.invalidDate || O;
        var oe = H || "YYYY-MM-DDTHH:mm:ssZ", ee = U.z(this), ie = this.$H, de = this.$m, pe = this.$M, le = Z.weekdays, ae = Z.months, ne = Z.meridiem, K = function(ue, J, fe, _e) {
          return ue && (ue[J] || ue(X, oe)) || fe[J].slice(0, _e);
        }, ce = function(ue) {
          return U.s(ie % 12 || 12, ue, "0");
        }, te = ne || function(ue, J, fe) {
          var _e = ue < 12 ? "AM" : "PM";
          return fe ? _e.toLowerCase() : _e;
        };
        return oe.replace(L, function(ue, J) {
          return J || function(fe) {
            switch (fe) {
              case "YY":
                return String(X.$y).slice(-2);
              case "YYYY":
                return U.s(X.$y, 4, "0");
              case "M":
                return pe + 1;
              case "MM":
                return U.s(pe + 1, 2, "0");
              case "MMM":
                return K(Z.monthsShort, pe, ae, 3);
              case "MMMM":
                return K(ae, pe);
              case "D":
                return X.$D;
              case "DD":
                return U.s(X.$D, 2, "0");
              case "d":
                return String(X.$W);
              case "dd":
                return K(Z.weekdaysMin, X.$W, le, 2);
              case "ddd":
                return K(Z.weekdaysShort, X.$W, le, 3);
              case "dddd":
                return le[X.$W];
              case "H":
                return String(ie);
              case "HH":
                return U.s(ie, 2, "0");
              case "h":
                return ce(1);
              case "hh":
                return ce(2);
              case "a":
                return te(ie, de, !0);
              case "A":
                return te(ie, de, !1);
              case "m":
                return String(de);
              case "mm":
                return U.s(de, 2, "0");
              case "s":
                return String(X.$s);
              case "ss":
                return U.s(X.$s, 2, "0");
              case "SSS":
                return U.s(X.$ms, 3, "0");
              case "Z":
                return ee;
            }
            return null;
          }(ue) || ee.replace(":", "");
        });
      }, z.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, z.diff = function(H, X, Z) {
        var oe, ee = this, ie = U.p(X), de = F(H), pe = (de.utcOffset() - this.utcOffset()) * p, le = this - de, ae = function() {
          return U.m(ee, de);
        };
        switch (ie) {
          case E:
            oe = ae() / 12;
            break;
          case w:
            oe = ae();
            break;
          case T:
            oe = ae() / 3;
            break;
          case $:
            oe = (le - pe) / 6048e5;
            break;
          case S:
            oe = (le - pe) / 864e5;
            break;
          case k:
            oe = le / m;
            break;
          case v:
            oe = le / p;
            break;
          case y:
            oe = le / f;
            break;
          default:
            oe = le;
        }
        return Z ? oe : U.a(oe);
      }, z.daysInMonth = function() {
        return this.endOf(w).$D;
      }, z.$locale = function() {
        return N[this.$L];
      }, z.locale = function(H, X) {
        if (!H)
          return this.$L;
        var Z = this.clone(), oe = W(H, X, !0);
        return oe && (Z.$L = oe), Z;
      }, z.clone = function() {
        return U.w(this.$d, this);
      }, z.toDate = function() {
        return new Date(this.valueOf());
      }, z.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, z.toISOString = function() {
        return this.$d.toISOString();
      }, z.toString = function() {
        return this.$d.toUTCString();
      }, Q;
    }(), q = Y.prototype;
    return F.prototype = q, [["$ms", b], ["$s", y], ["$m", v], ["$H", k], ["$W", S], ["$M", w], ["$y", E], ["$D", R]].forEach(function(Q) {
      q[Q[1]] = function(z) {
        return this.$g(z, Q[0], Q[1]);
      };
    }), F.extend = function(Q, z) {
      return Q.$i || (Q(z, Y, F), Q.$i = !0), F;
    }, F.locale = W, F.isDayjs = V, F.unix = function(Q) {
      return F(1e3 * Q);
    }, F.en = N[x], F.Ls = N, F.p = {}, F;
  });
})(dayjs_min$1);
var dayjs_minExports = dayjs_min$1.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs$1(dayjs_minExports);
var isArray$g = Array.isArray, isArray_1$1 = isArray$g, baseGetTag$6 = _baseGetTag$1, isObjectLike$a = isObjectLike_1$1, symbolTag$6 = "[object Symbol]";
function isSymbol$6(u) {
  return typeof u == "symbol" || isObjectLike$a(u) && baseGetTag$6(u) == symbolTag$6;
}
var isSymbol_1$1 = isSymbol$6, isArray$f = isArray_1$1, isSymbol$5 = isSymbol_1$1, reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp$1 = /^\w*$/;
function isKey$4(u, l) {
  if (isArray$f(u))
    return !1;
  var f = typeof u;
  return f == "number" || f == "symbol" || f == "boolean" || u == null || isSymbol$5(u) ? !0 : reIsPlainProp$1.test(u) || !reIsDeepProp$1.test(u) || l != null && u in Object(l);
}
var _isKey$1 = isKey$4;
function isObject$c(u) {
  var l = typeof u;
  return u != null && (l == "object" || l == "function");
}
var isObject_1$1 = isObject$c, baseGetTag$5 = _baseGetTag$1, isObject$b = isObject_1$1, asyncTag$1 = "[object AsyncFunction]", funcTag$5 = "[object Function]", genTag$3 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
function isFunction$4(u) {
  if (!isObject$b(u))
    return !1;
  var l = baseGetTag$5(u);
  return l == funcTag$5 || l == genTag$3 || l == asyncTag$1 || l == proxyTag$1;
}
var isFunction_1$1 = isFunction$4, root$b = _root$1, coreJsData$2 = root$b["__core-js_shared__"], _coreJsData$1 = coreJsData$2, coreJsData$1 = _coreJsData$1, maskSrcKey$1 = function() {
  var u = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return u ? "Symbol(src)_1." + u : "";
}();
function isMasked$2(u) {
  return !!maskSrcKey$1 && maskSrcKey$1 in u;
}
var _isMasked$1 = isMasked$2, funcProto$4 = Function.prototype, funcToString$4 = funcProto$4.toString;
function toSource$3(u) {
  if (u != null) {
    try {
      return funcToString$4.call(u);
    } catch {
    }
    try {
      return u + "";
    } catch {
    }
  }
  return "";
}
var _toSource$1 = toSource$3, isFunction$3 = isFunction_1$1, isMasked$1 = _isMasked$1, isObject$a = isObject_1$1, toSource$2 = _toSource$1, reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor$1 = /^\[object .+?Constructor\]$/, funcProto$3 = Function.prototype, objectProto$v = Object.prototype, funcToString$3 = funcProto$3.toString, hasOwnProperty$s = objectProto$v.hasOwnProperty, reIsNative$1 = RegExp(
  "^" + funcToString$3.call(hasOwnProperty$s).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$2(u) {
  if (!isObject$a(u) || isMasked$1(u))
    return !1;
  var l = isFunction$3(u) ? reIsNative$1 : reIsHostCtor$1;
  return l.test(toSource$2(u));
}
var _baseIsNative$1 = baseIsNative$2;
function getValue$3(u, l) {
  return u == null ? void 0 : u[l];
}
var _getValue$1 = getValue$3, baseIsNative$1 = _baseIsNative$1, getValue$2 = _getValue$1;
function getNative$8(u, l) {
  var f = getValue$2(u, l);
  return baseIsNative$1(f) ? f : void 0;
}
var _getNative$1 = getNative$8, getNative$7 = _getNative$1, nativeCreate$5 = getNative$7(Object, "create"), _nativeCreate$1 = nativeCreate$5, nativeCreate$4 = _nativeCreate$1;
function hashClear$2() {
  this.__data__ = nativeCreate$4 ? nativeCreate$4(null) : {}, this.size = 0;
}
var _hashClear$1 = hashClear$2;
function hashDelete$2(u) {
  var l = this.has(u) && delete this.__data__[u];
  return this.size -= l ? 1 : 0, l;
}
var _hashDelete$1 = hashDelete$2, nativeCreate$3 = _nativeCreate$1, HASH_UNDEFINED$5 = "__lodash_hash_undefined__", objectProto$u = Object.prototype, hasOwnProperty$r = objectProto$u.hasOwnProperty;
function hashGet$2(u) {
  var l = this.__data__;
  if (nativeCreate$3) {
    var f = l[u];
    return f === HASH_UNDEFINED$5 ? void 0 : f;
  }
  return hasOwnProperty$r.call(l, u) ? l[u] : void 0;
}
var _hashGet$1 = hashGet$2, nativeCreate$2 = _nativeCreate$1, objectProto$t = Object.prototype, hasOwnProperty$q = objectProto$t.hasOwnProperty;
function hashHas$2(u) {
  var l = this.__data__;
  return nativeCreate$2 ? l[u] !== void 0 : hasOwnProperty$q.call(l, u);
}
var _hashHas$1 = hashHas$2, nativeCreate$1 = _nativeCreate$1, HASH_UNDEFINED$4 = "__lodash_hash_undefined__";
function hashSet$2(u, l) {
  var f = this.__data__;
  return this.size += this.has(u) ? 0 : 1, f[u] = nativeCreate$1 && l === void 0 ? HASH_UNDEFINED$4 : l, this;
}
var _hashSet$1 = hashSet$2, hashClear$1 = _hashClear$1, hashDelete$1 = _hashDelete$1, hashGet$1 = _hashGet$1, hashHas$1 = _hashHas$1, hashSet$1 = _hashSet$1;
function Hash$2(u) {
  var l = -1, f = u == null ? 0 : u.length;
  for (this.clear(); ++l < f; ) {
    var p = u[l];
    this.set(p[0], p[1]);
  }
}
Hash$2.prototype.clear = hashClear$1;
Hash$2.prototype.delete = hashDelete$1;
Hash$2.prototype.get = hashGet$1;
Hash$2.prototype.has = hashHas$1;
Hash$2.prototype.set = hashSet$1;
var _Hash$1 = Hash$2;
function listCacheClear$2() {
  this.__data__ = [], this.size = 0;
}
var _listCacheClear$1 = listCacheClear$2;
function eq$4(u, l) {
  return u === l || u !== u && l !== l;
}
var eq_1$1 = eq$4, eq$3 = eq_1$1;
function assocIndexOf$5(u, l) {
  for (var f = u.length; f--; )
    if (eq$3(u[f][0], l))
      return f;
  return -1;
}
var _assocIndexOf$1 = assocIndexOf$5, assocIndexOf$4 = _assocIndexOf$1, arrayProto$1 = Array.prototype, splice$1 = arrayProto$1.splice;
function listCacheDelete$2(u) {
  var l = this.__data__, f = assocIndexOf$4(l, u);
  if (f < 0)
    return !1;
  var p = l.length - 1;
  return f == p ? l.pop() : splice$1.call(l, f, 1), --this.size, !0;
}
var _listCacheDelete$1 = listCacheDelete$2, assocIndexOf$3 = _assocIndexOf$1;
function listCacheGet$2(u) {
  var l = this.__data__, f = assocIndexOf$3(l, u);
  return f < 0 ? void 0 : l[f][1];
}
var _listCacheGet$1 = listCacheGet$2, assocIndexOf$2 = _assocIndexOf$1;
function listCacheHas$2(u) {
  return assocIndexOf$2(this.__data__, u) > -1;
}
var _listCacheHas$1 = listCacheHas$2, assocIndexOf$1 = _assocIndexOf$1;
function listCacheSet$2(u, l) {
  var f = this.__data__, p = assocIndexOf$1(f, u);
  return p < 0 ? (++this.size, f.push([u, l])) : f[p][1] = l, this;
}
var _listCacheSet$1 = listCacheSet$2, listCacheClear$1 = _listCacheClear$1, listCacheDelete$1 = _listCacheDelete$1, listCacheGet$1 = _listCacheGet$1, listCacheHas$1 = _listCacheHas$1, listCacheSet$1 = _listCacheSet$1;
function ListCache$5(u) {
  var l = -1, f = u == null ? 0 : u.length;
  for (this.clear(); ++l < f; ) {
    var p = u[l];
    this.set(p[0], p[1]);
  }
}
ListCache$5.prototype.clear = listCacheClear$1;
ListCache$5.prototype.delete = listCacheDelete$1;
ListCache$5.prototype.get = listCacheGet$1;
ListCache$5.prototype.has = listCacheHas$1;
ListCache$5.prototype.set = listCacheSet$1;
var _ListCache$1 = ListCache$5, getNative$6 = _getNative$1, root$a = _root$1, Map$5 = getNative$6(root$a, "Map"), _Map$1 = Map$5, Hash$1 = _Hash$1, ListCache$4 = _ListCache$1, Map$4 = _Map$1;
function mapCacheClear$2() {
  this.size = 0, this.__data__ = {
    hash: new Hash$1(),
    map: new (Map$4 || ListCache$4)(),
    string: new Hash$1()
  };
}
var _mapCacheClear$1 = mapCacheClear$2;
function isKeyable$2(u) {
  var l = typeof u;
  return l == "string" || l == "number" || l == "symbol" || l == "boolean" ? u !== "__proto__" : u === null;
}
var _isKeyable$1 = isKeyable$2, isKeyable$1 = _isKeyable$1;
function getMapData$5(u, l) {
  var f = u.__data__;
  return isKeyable$1(l) ? f[typeof l == "string" ? "string" : "hash"] : f.map;
}
var _getMapData$1 = getMapData$5, getMapData$4 = _getMapData$1;
function mapCacheDelete$2(u) {
  var l = getMapData$4(this, u).delete(u);
  return this.size -= l ? 1 : 0, l;
}
var _mapCacheDelete$1 = mapCacheDelete$2, getMapData$3 = _getMapData$1;
function mapCacheGet$2(u) {
  return getMapData$3(this, u).get(u);
}
var _mapCacheGet$1 = mapCacheGet$2, getMapData$2 = _getMapData$1;
function mapCacheHas$2(u) {
  return getMapData$2(this, u).has(u);
}
var _mapCacheHas$1 = mapCacheHas$2, getMapData$1 = _getMapData$1;
function mapCacheSet$2(u, l) {
  var f = getMapData$1(this, u), p = f.size;
  return f.set(u, l), this.size += f.size == p ? 0 : 1, this;
}
var _mapCacheSet$1 = mapCacheSet$2, mapCacheClear$1 = _mapCacheClear$1, mapCacheDelete$1 = _mapCacheDelete$1, mapCacheGet$1 = _mapCacheGet$1, mapCacheHas$1 = _mapCacheHas$1, mapCacheSet$1 = _mapCacheSet$1;
function MapCache$4(u) {
  var l = -1, f = u == null ? 0 : u.length;
  for (this.clear(); ++l < f; ) {
    var p = u[l];
    this.set(p[0], p[1]);
  }
}
MapCache$4.prototype.clear = mapCacheClear$1;
MapCache$4.prototype.delete = mapCacheDelete$1;
MapCache$4.prototype.get = mapCacheGet$1;
MapCache$4.prototype.has = mapCacheHas$1;
MapCache$4.prototype.set = mapCacheSet$1;
var _MapCache$1 = MapCache$4, MapCache$3 = _MapCache$1, FUNC_ERROR_TEXT$3 = "Expected a function";
function memoize$2(u, l) {
  if (typeof u != "function" || l != null && typeof l != "function")
    throw new TypeError(FUNC_ERROR_TEXT$3);
  var f = function() {
    var p = arguments, m = l ? l.apply(this, p) : p[0], b = f.cache;
    if (b.has(m))
      return b.get(m);
    var y = u.apply(this, p);
    return f.cache = b.set(m, y) || b, y;
  };
  return f.cache = new (memoize$2.Cache || MapCache$3)(), f;
}
memoize$2.Cache = MapCache$3;
var memoize_1$1 = memoize$2, memoize$1 = memoize_1$1, MAX_MEMOIZE_SIZE$1 = 500;
function memoizeCapped$2(u) {
  var l = memoize$1(u, function(p) {
    return f.size === MAX_MEMOIZE_SIZE$1 && f.clear(), p;
  }), f = l.cache;
  return l;
}
var _memoizeCapped$1 = memoizeCapped$2, memoizeCapped$1 = _memoizeCapped$1, rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar$1 = /\\(\\)?/g, stringToPath$3 = memoizeCapped$1(function(u) {
  var l = [];
  return u.charCodeAt(0) === 46 && l.push(""), u.replace(rePropName$1, function(f, p, m, b) {
    l.push(m ? b.replace(reEscapeChar$1, "$1") : p || f);
  }), l;
}), _stringToPath$1 = stringToPath$3;
function arrayMap$3(u, l) {
  for (var f = -1, p = u == null ? 0 : u.length, m = Array(p); ++f < p; )
    m[f] = l(u[f], f, u);
  return m;
}
var _arrayMap$1 = arrayMap$3, Symbol$4 = _Symbol$1, arrayMap$2 = _arrayMap$1, isArray$e = isArray_1$1, isSymbol$4 = isSymbol_1$1, INFINITY$3 = 1 / 0, symbolProto$5 = Symbol$4 ? Symbol$4.prototype : void 0, symbolToString$1 = symbolProto$5 ? symbolProto$5.toString : void 0;
function baseToString$2(u) {
  if (typeof u == "string")
    return u;
  if (isArray$e(u))
    return arrayMap$2(u, baseToString$2) + "";
  if (isSymbol$4(u))
    return symbolToString$1 ? symbolToString$1.call(u) : "";
  var l = u + "";
  return l == "0" && 1 / u == -INFINITY$3 ? "-0" : l;
}
var _baseToString$1 = baseToString$2, baseToString$1 = _baseToString$1;
function toString$6(u) {
  return u == null ? "" : baseToString$1(u);
}
var toString_1$1 = toString$6, isArray$d = isArray_1$1, isKey$3 = _isKey$1, stringToPath$2 = _stringToPath$1, toString$5 = toString_1$1;
function castPath$5(u, l) {
  return isArray$d(u) ? u : isKey$3(u, l) ? [u] : stringToPath$2(toString$5(u));
}
var _castPath$1 = castPath$5, isSymbol$3 = isSymbol_1$1, INFINITY$2 = 1 / 0;
function toKey$7(u) {
  if (typeof u == "string" || isSymbol$3(u))
    return u;
  var l = u + "";
  return l == "0" && 1 / u == -INFINITY$2 ? "-0" : l;
}
var _toKey$1 = toKey$7, castPath$4 = _castPath$1, toKey$6 = _toKey$1;
function baseGet$4(u, l) {
  l = castPath$4(l, u);
  for (var f = 0, p = l.length; u != null && f < p; )
    u = u[toKey$6(l[f++])];
  return f && f == p ? u : void 0;
}
var _baseGet$1 = baseGet$4, getNative$5 = _getNative$1, defineProperty$3 = function() {
  try {
    var u = getNative$5(Object, "defineProperty");
    return u({}, "", {}), u;
  } catch {
  }
}(), _defineProperty$1 = defineProperty$3, defineProperty$2 = _defineProperty$1;
function baseAssignValue$3(u, l, f) {
  l == "__proto__" && defineProperty$2 ? defineProperty$2(u, l, {
    configurable: !0,
    enumerable: !0,
    value: f,
    writable: !0
  }) : u[l] = f;
}
var _baseAssignValue$1 = baseAssignValue$3, baseAssignValue$2 = _baseAssignValue$1, eq$2 = eq_1$1, objectProto$s = Object.prototype, hasOwnProperty$p = objectProto$s.hasOwnProperty;
function assignValue$4(u, l, f) {
  var p = u[l];
  (!(hasOwnProperty$p.call(u, l) && eq$2(p, f)) || f === void 0 && !(l in u)) && baseAssignValue$2(u, l, f);
}
var _assignValue$1 = assignValue$4, MAX_SAFE_INTEGER$3 = 9007199254740991, reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$5(u, l) {
  var f = typeof u;
  return l = l ?? MAX_SAFE_INTEGER$3, !!l && (f == "number" || f != "symbol" && reIsUint$1.test(u)) && u > -1 && u % 1 == 0 && u < l;
}
var _isIndex$1 = isIndex$5, assignValue$3 = _assignValue$1, castPath$3 = _castPath$1, isIndex$4 = _isIndex$1, isObject$9 = isObject_1$1, toKey$5 = _toKey$1;
function baseSet$1(u, l, f, p) {
  if (!isObject$9(u))
    return u;
  l = castPath$3(l, u);
  for (var m = -1, b = l.length, y = b - 1, v = u; v != null && ++m < b; ) {
    var k = toKey$5(l[m]), S = f;
    if (k === "__proto__" || k === "constructor" || k === "prototype")
      return u;
    if (m != y) {
      var $ = v[k];
      S = p ? p($, k, v) : void 0, S === void 0 && (S = isObject$9($) ? $ : isIndex$4(l[m + 1]) ? [] : {});
    }
    assignValue$3(v, k, S), v = v[k];
  }
  return u;
}
var _baseSet = baseSet$1, baseGet$3 = _baseGet$1, baseSet = _baseSet, castPath$2 = _castPath$1;
function basePickBy$1(u, l, f) {
  for (var p = -1, m = l.length, b = {}; ++p < m; ) {
    var y = l[p], v = baseGet$3(u, y);
    f(v, y) && baseSet(b, castPath$2(y, u), v);
  }
  return b;
}
var _basePickBy = basePickBy$1;
function baseHasIn$2(u, l) {
  return u != null && l in Object(u);
}
var _baseHasIn$1 = baseHasIn$2, baseGetTag$4 = _baseGetTag$1, isObjectLike$9 = isObjectLike_1$1, argsTag$7 = "[object Arguments]";
function baseIsArguments$2(u) {
  return isObjectLike$9(u) && baseGetTag$4(u) == argsTag$7;
}
var _baseIsArguments$1 = baseIsArguments$2, baseIsArguments$1 = _baseIsArguments$1, isObjectLike$8 = isObjectLike_1$1, objectProto$r = Object.prototype, hasOwnProperty$o = objectProto$r.hasOwnProperty, propertyIsEnumerable$3 = objectProto$r.propertyIsEnumerable, isArguments$6 = baseIsArguments$1(function() {
  return arguments;
}()) ? baseIsArguments$1 : function(u) {
  return isObjectLike$8(u) && hasOwnProperty$o.call(u, "callee") && !propertyIsEnumerable$3.call(u, "callee");
}, isArguments_1$1 = isArguments$6, MAX_SAFE_INTEGER$2 = 9007199254740991;
function isLength$4(u) {
  return typeof u == "number" && u > -1 && u % 1 == 0 && u <= MAX_SAFE_INTEGER$2;
}
var isLength_1$1 = isLength$4, castPath$1 = _castPath$1, isArguments$5 = isArguments_1$1, isArray$c = isArray_1$1, isIndex$3 = _isIndex$1, isLength$3 = isLength_1$1, toKey$4 = _toKey$1;
function hasPath$2(u, l, f) {
  l = castPath$1(l, u);
  for (var p = -1, m = l.length, b = !1; ++p < m; ) {
    var y = toKey$4(l[p]);
    if (!(b = u != null && f(u, y)))
      break;
    u = u[y];
  }
  return b || ++p != m ? b : (m = u == null ? 0 : u.length, !!m && isLength$3(m) && isIndex$3(y, m) && (isArray$c(u) || isArguments$5(u)));
}
var _hasPath$1 = hasPath$2, baseHasIn$1 = _baseHasIn$1, hasPath$1 = _hasPath$1;
function hasIn$3(u, l) {
  return u != null && hasPath$1(u, l, baseHasIn$1);
}
var hasIn_1$1 = hasIn$3, basePickBy = _basePickBy, hasIn$2 = hasIn_1$1;
function basePick$1(u, l) {
  return basePickBy(u, l, function(f, p) {
    return hasIn$2(u, p);
  });
}
var _basePick = basePick$1;
function arrayPush$4(u, l) {
  for (var f = -1, p = l.length, m = u.length; ++f < p; )
    u[m + f] = l[f];
  return u;
}
var _arrayPush$1 = arrayPush$4, Symbol$3 = _Symbol$1, isArguments$4 = isArguments_1$1, isArray$b = isArray_1$1, spreadableSymbol$1 = Symbol$3 ? Symbol$3.isConcatSpreadable : void 0;
function isFlattenable$2(u) {
  return isArray$b(u) || isArguments$4(u) || !!(spreadableSymbol$1 && u && u[spreadableSymbol$1]);
}
var _isFlattenable$1 = isFlattenable$2, arrayPush$3 = _arrayPush$1, isFlattenable$1 = _isFlattenable$1;
function baseFlatten$2(u, l, f, p, m) {
  var b = -1, y = u.length;
  for (f || (f = isFlattenable$1), m || (m = []); ++b < y; ) {
    var v = u[b];
    l > 0 && f(v) ? l > 1 ? baseFlatten$2(v, l - 1, f, p, m) : arrayPush$3(m, v) : p || (m[m.length] = v);
  }
  return m;
}
var _baseFlatten$1 = baseFlatten$2, baseFlatten$1 = _baseFlatten$1;
function flatten$2(u) {
  var l = u == null ? 0 : u.length;
  return l ? baseFlatten$1(u, 1) : [];
}
var flatten_1$1 = flatten$2;
function apply$4(u, l, f) {
  switch (f.length) {
    case 0:
      return u.call(l);
    case 1:
      return u.call(l, f[0]);
    case 2:
      return u.call(l, f[0], f[1]);
    case 3:
      return u.call(l, f[0], f[1], f[2]);
  }
  return u.apply(l, f);
}
var _apply$1 = apply$4, apply$3 = _apply$1, nativeMax$5 = Math.max;
function overRest$2(u, l, f) {
  return l = nativeMax$5(l === void 0 ? u.length - 1 : l, 0), function() {
    for (var p = arguments, m = -1, b = nativeMax$5(p.length - l, 0), y = Array(b); ++m < b; )
      y[m] = p[l + m];
    m = -1;
    for (var v = Array(l + 1); ++m < l; )
      v[m] = p[m];
    return v[l] = f(y), apply$3(u, this, v);
  };
}
var _overRest$1 = overRest$2;
function constant$2(u) {
  return function() {
    return u;
  };
}
var constant_1$1 = constant$2;
function identity$4(u) {
  return u;
}
var identity_1$1 = identity$4, constant$1 = constant_1$1, defineProperty$1 = _defineProperty$1, identity$3 = identity_1$1, baseSetToString$2 = defineProperty$1 ? function(u, l) {
  return defineProperty$1(u, "toString", {
    configurable: !0,
    enumerable: !1,
    value: constant$1(l),
    writable: !0
  });
} : identity$3, _baseSetToString$1 = baseSetToString$2, HOT_COUNT$1 = 800, HOT_SPAN$1 = 16, nativeNow$1 = Date.now;
function shortOut$3(u) {
  var l = 0, f = 0;
  return function() {
    var p = nativeNow$1(), m = HOT_SPAN$1 - (p - f);
    if (f = p, m > 0) {
      if (++l >= HOT_COUNT$1)
        return arguments[0];
    } else
      l = 0;
    return u.apply(void 0, arguments);
  };
}
var _shortOut$1 = shortOut$3, baseSetToString$1 = _baseSetToString$1, shortOut$2 = _shortOut$1, setToString$3 = shortOut$2(baseSetToString$1), _setToString$1 = setToString$3, flatten$1 = flatten_1$1, overRest$1 = _overRest$1, setToString$2 = _setToString$1;
function flatRest$3(u) {
  return setToString$2(overRest$1(u, void 0, flatten$1), u + "");
}
var _flatRest$1 = flatRest$3, basePick = _basePick, flatRest$2 = _flatRest$1, pick$1 = flatRest$2(function(u, l) {
  return u == null ? {} : basePick(u, l);
}), pick_1 = pick$1;
const pick$2 = /* @__PURE__ */ getDefaultExportFromCjs$1(pick_1), FILTER_ALLOWED_KEYS = [
  "field",
  "operator",
  "value",
  "type",
  "externalType",
  "valueType",
  "noValue",
  "formulaType"
];
function hasSchema(u) {
  return typeof u == "object" && !Array.isArray(u) && u !== null && !(u instanceof Date) && Object.keys(u).length > 0;
}
function isSupportedUserSearch(u) {
  const l = [
    { op: BasicOperator.STRING, key: "email" },
    { op: BasicOperator.EQUAL, key: "_id" },
    { op: ArrayOperator.ONE_OF, key: "_id" }
  ], { allOr: f, onEmptyFilter: p, ...m } = u;
  for (const [b, y] of Object.entries(m)) {
    if (typeof y != "object")
      return !1;
    if (isLogicalSearchOperator(b)) {
      for (const S of u[b].conditions)
        if (!isSupportedUserSearch(S))
          return !1;
      return !0;
    }
    const v = Object.keys(y || {});
    if (v.length === 0)
      continue;
    if (!l.find(
      (S) => S.op === b && v.length === 1 && v[0] === S.key
    ))
      return !1;
  }
  return !0;
}
function processSearchFilters(u) {
  if (!u || u.length === 0)
    return;
  const { allOr: l, onEmptyFilter: f, filters: p } = splitFiltersArray(u);
  return {
    logicalOperator: UILogicalOperator.ALL,
    onEmptyFilter: f || EmptyFilterOption.RETURN_ALL,
    groups: [
      {
        logicalOperator: l ? UILogicalOperator.ANY : UILogicalOperator.ALL,
        filters: p.map((m) => {
          const b = pick$2(
            m,
            FILTER_ALLOWED_KEYS
          );
          return b.field = removeKeyNumbering(b.field), b;
        })
      }
    ]
  };
}
const deepGet$1 = (u, l) => {
  if (!u || !l)
    return null;
  if (Object.prototype.hasOwnProperty.call(u, l))
    return u[l];
  const f = l.split(".");
  for (let p = 0; p < f.length; p++)
    u = u == null ? void 0 : u[f[p]];
  return u;
}, getUserInitials = (u) => {
  var f;
  if (!u)
    return "?";
  let l = "";
  return l += u.firstName ? u.firstName[0] : "", l += u.lastName ? u.lastName[0] : "", l !== "" ? l : ((f = u.email) == null ? void 0 : f[0]) || "U";
}, getUserColor = (u) => {
  let l = u == null ? void 0 : u._id;
  if (!l)
    return "var(--spectrum-global-color-blue-400)";
  l = l.replace("ro_ta_users_", "");
  let f = 1;
  for (let p = 0; p < l.length; p++)
    f += l.charCodeAt(p), f = f % 36;
  return `hsl(${f * 10}, 50%, 40%)`;
}, getUserLabel = (u) => {
  if (!u)
    return "";
  const { firstName: l, lastName: f, email: p } = u;
  return l && f ? `${l} ${f}` : l || f || p;
};
function baseTimes$2(u, l) {
  for (var f = -1, p = Array(u); ++f < u; )
    p[f] = l(f);
  return p;
}
var _baseTimes$1 = baseTimes$2, isBuffer$7 = { exports: {} };
function stubFalse$1() {
  return !1;
}
var stubFalse_1$1 = stubFalse$1;
isBuffer$7.exports;
(function(u, l) {
  var f = _root$1, p = stubFalse_1$1, m = l && !l.nodeType && l, b = m && !0 && u && !u.nodeType && u, y = b && b.exports === m, v = y ? f.Buffer : void 0, k = v ? v.isBuffer : void 0, S = k || p;
  u.exports = S;
})(isBuffer$7, isBuffer$7.exports);
var isBufferExports = isBuffer$7.exports, baseGetTag$3 = _baseGetTag$1, isLength$2 = isLength_1$1, isObjectLike$7 = isObjectLike_1$1, argsTag$6 = "[object Arguments]", arrayTag$5 = "[object Array]", boolTag$6 = "[object Boolean]", dateTag$6 = "[object Date]", errorTag$6 = "[object Error]", funcTag$4 = "[object Function]", mapTag$a = "[object Map]", numberTag$6 = "[object Number]", objectTag$8 = "[object Object]", regexpTag$6 = "[object RegExp]", setTag$a = "[object Set]", stringTag$6 = "[object String]", weakMapTag$6 = "[object WeakMap]", arrayBufferTag$6 = "[object ArrayBuffer]", dataViewTag$8 = "[object DataView]", float32Tag$4 = "[object Float32Array]", float64Tag$4 = "[object Float64Array]", int8Tag$4 = "[object Int8Array]", int16Tag$4 = "[object Int16Array]", int32Tag$4 = "[object Int32Array]", uint8Tag$4 = "[object Uint8Array]", uint8ClampedTag$4 = "[object Uint8ClampedArray]", uint16Tag$4 = "[object Uint16Array]", uint32Tag$4 = "[object Uint32Array]", typedArrayTags$1 = {};
typedArrayTags$1[float32Tag$4] = typedArrayTags$1[float64Tag$4] = typedArrayTags$1[int8Tag$4] = typedArrayTags$1[int16Tag$4] = typedArrayTags$1[int32Tag$4] = typedArrayTags$1[uint8Tag$4] = typedArrayTags$1[uint8ClampedTag$4] = typedArrayTags$1[uint16Tag$4] = typedArrayTags$1[uint32Tag$4] = !0;
typedArrayTags$1[argsTag$6] = typedArrayTags$1[arrayTag$5] = typedArrayTags$1[arrayBufferTag$6] = typedArrayTags$1[boolTag$6] = typedArrayTags$1[dataViewTag$8] = typedArrayTags$1[dateTag$6] = typedArrayTags$1[errorTag$6] = typedArrayTags$1[funcTag$4] = typedArrayTags$1[mapTag$a] = typedArrayTags$1[numberTag$6] = typedArrayTags$1[objectTag$8] = typedArrayTags$1[regexpTag$6] = typedArrayTags$1[setTag$a] = typedArrayTags$1[stringTag$6] = typedArrayTags$1[weakMapTag$6] = !1;
function baseIsTypedArray$2(u) {
  return isObjectLike$7(u) && isLength$2(u.length) && !!typedArrayTags$1[baseGetTag$3(u)];
}
var _baseIsTypedArray$1 = baseIsTypedArray$2;
function baseUnary$4(u) {
  return function(l) {
    return u(l);
  };
}
var _baseUnary$1 = baseUnary$4, _nodeUtil$1 = { exports: {} };
_nodeUtil$1.exports;
(function(u, l) {
  var f = _freeGlobal$1, p = l && !l.nodeType && l, m = p && !0 && u && !u.nodeType && u, b = m && m.exports === p, y = b && f.process, v = function() {
    try {
      var k = m && m.require && m.require("util").types;
      return k || y && y.binding && y.binding("util");
    } catch {
    }
  }();
  u.exports = v;
})(_nodeUtil$1, _nodeUtil$1.exports);
var _nodeUtilExports = _nodeUtil$1.exports, baseIsTypedArray$1 = _baseIsTypedArray$1, baseUnary$3 = _baseUnary$1, nodeUtil$2 = _nodeUtilExports, nodeIsTypedArray$1 = nodeUtil$2 && nodeUtil$2.isTypedArray, isTypedArray$4 = nodeIsTypedArray$1 ? baseUnary$3(nodeIsTypedArray$1) : baseIsTypedArray$1, isTypedArray_1$1 = isTypedArray$4, baseTimes$1 = _baseTimes$1, isArguments$3 = isArguments_1$1, isArray$a = isArray_1$1, isBuffer$6 = isBufferExports, isIndex$2 = _isIndex$1, isTypedArray$3 = isTypedArray_1$1, objectProto$q = Object.prototype, hasOwnProperty$n = objectProto$q.hasOwnProperty;
function arrayLikeKeys$3(u, l) {
  var f = isArray$a(u), p = !f && isArguments$3(u), m = !f && !p && isBuffer$6(u), b = !f && !p && !m && isTypedArray$3(u), y = f || p || m || b, v = y ? baseTimes$1(u.length, String) : [], k = v.length;
  for (var S in u)
    (l || hasOwnProperty$n.call(u, S)) && !(y && // Safari 9 has enumerable `arguments.length` in strict mode.
    (S == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    m && (S == "offset" || S == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    b && (S == "buffer" || S == "byteLength" || S == "byteOffset") || // Skip index properties.
    isIndex$2(S, k))) && v.push(S);
  return v;
}
var _arrayLikeKeys$1 = arrayLikeKeys$3, objectProto$p = Object.prototype;
function isPrototype$5(u) {
  var l = u && u.constructor, f = typeof l == "function" && l.prototype || objectProto$p;
  return u === f;
}
var _isPrototype$1 = isPrototype$5, overArg$1 = _overArg$1, nativeKeys$2 = overArg$1(Object.keys, Object), _nativeKeys$1 = nativeKeys$2, isPrototype$4 = _isPrototype$1, nativeKeys$1 = _nativeKeys$1, objectProto$o = Object.prototype, hasOwnProperty$m = objectProto$o.hasOwnProperty;
function baseKeys$3(u) {
  if (!isPrototype$4(u))
    return nativeKeys$1(u);
  var l = [];
  for (var f in Object(u))
    hasOwnProperty$m.call(u, f) && f != "constructor" && l.push(f);
  return l;
}
var _baseKeys$1 = baseKeys$3, isFunction$2 = isFunction_1$1, isLength$1 = isLength_1$1;
function isArrayLike$4(u) {
  return u != null && isLength$1(u.length) && !isFunction$2(u);
}
var isArrayLike_1$1 = isArrayLike$4, arrayLikeKeys$2 = _arrayLikeKeys$1, baseKeys$2 = _baseKeys$1, isArrayLike$3 = isArrayLike_1$1;
function keys$5(u) {
  return isArrayLike$3(u) ? arrayLikeKeys$2(u) : baseKeys$2(u);
}
var keys_1$1 = keys$5, ListCache$3 = _ListCache$1;
function stackClear$2() {
  this.__data__ = new ListCache$3(), this.size = 0;
}
var _stackClear$1 = stackClear$2;
function stackDelete$2(u) {
  var l = this.__data__, f = l.delete(u);
  return this.size = l.size, f;
}
var _stackDelete$1 = stackDelete$2;
function stackGet$2(u) {
  return this.__data__.get(u);
}
var _stackGet$1 = stackGet$2;
function stackHas$2(u) {
  return this.__data__.has(u);
}
var _stackHas$1 = stackHas$2, ListCache$2 = _ListCache$1, Map$3 = _Map$1, MapCache$2 = _MapCache$1, LARGE_ARRAY_SIZE$1 = 200;
function stackSet$2(u, l) {
  var f = this.__data__;
  if (f instanceof ListCache$2) {
    var p = f.__data__;
    if (!Map$3 || p.length < LARGE_ARRAY_SIZE$1 - 1)
      return p.push([u, l]), this.size = ++f.size, this;
    f = this.__data__ = new MapCache$2(p);
  }
  return f.set(u, l), this.size = f.size, this;
}
var _stackSet$1 = stackSet$2, ListCache$1 = _ListCache$1, stackClear$1 = _stackClear$1, stackDelete$1 = _stackDelete$1, stackGet$1 = _stackGet$1, stackHas$1 = _stackHas$1, stackSet$1 = _stackSet$1;
function Stack$4(u) {
  var l = this.__data__ = new ListCache$1(u);
  this.size = l.size;
}
Stack$4.prototype.clear = stackClear$1;
Stack$4.prototype.delete = stackDelete$1;
Stack$4.prototype.get = stackGet$1;
Stack$4.prototype.has = stackHas$1;
Stack$4.prototype.set = stackSet$1;
var _Stack$1 = Stack$4, HASH_UNDEFINED$3 = "__lodash_hash_undefined__";
function setCacheAdd$2(u) {
  return this.__data__.set(u, HASH_UNDEFINED$3), this;
}
var _setCacheAdd$1 = setCacheAdd$2;
function setCacheHas$2(u) {
  return this.__data__.has(u);
}
var _setCacheHas$1 = setCacheHas$2, MapCache$1 = _MapCache$1, setCacheAdd$1 = _setCacheAdd$1, setCacheHas$1 = _setCacheHas$1;
function SetCache$2(u) {
  var l = -1, f = u == null ? 0 : u.length;
  for (this.__data__ = new MapCache$1(); ++l < f; )
    this.add(u[l]);
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd$1;
SetCache$2.prototype.has = setCacheHas$1;
var _SetCache$1 = SetCache$2;
function arraySome$2(u, l) {
  for (var f = -1, p = u == null ? 0 : u.length; ++f < p; )
    if (l(u[f], f, u))
      return !0;
  return !1;
}
var _arraySome$1 = arraySome$2;
function cacheHas$2(u, l) {
  return u.has(l);
}
var _cacheHas$1 = cacheHas$2, SetCache$1 = _SetCache$1, arraySome$1 = _arraySome$1, cacheHas$1 = _cacheHas$1, COMPARE_PARTIAL_FLAG$b = 1, COMPARE_UNORDERED_FLAG$7 = 2;
function equalArrays$3(u, l, f, p, m, b) {
  var y = f & COMPARE_PARTIAL_FLAG$b, v = u.length, k = l.length;
  if (v != k && !(y && k > v))
    return !1;
  var S = b.get(u), $ = b.get(l);
  if (S && $)
    return S == l && $ == u;
  var w = -1, T = !0, E = f & COMPARE_UNORDERED_FLAG$7 ? new SetCache$1() : void 0;
  for (b.set(u, l), b.set(l, u); ++w < v; ) {
    var R = u[w], O = l[w];
    if (p)
      var P = y ? p(O, R, w, l, u, b) : p(R, O, w, u, l, b);
    if (P !== void 0) {
      if (P)
        continue;
      T = !1;
      break;
    }
    if (E) {
      if (!arraySome$1(l, function(L, M) {
        if (!cacheHas$1(E, M) && (R === L || m(R, L, f, p, b)))
          return E.push(M);
      })) {
        T = !1;
        break;
      }
    } else if (!(R === O || m(R, O, f, p, b))) {
      T = !1;
      break;
    }
  }
  return b.delete(u), b.delete(l), T;
}
var _equalArrays$1 = equalArrays$3, root$9 = _root$1, Uint8Array$3 = root$9.Uint8Array, _Uint8Array$1 = Uint8Array$3;
function mapToArray$2(u) {
  var l = -1, f = Array(u.size);
  return u.forEach(function(p, m) {
    f[++l] = [m, p];
  }), f;
}
var _mapToArray$1 = mapToArray$2;
function setToArray$2(u) {
  var l = -1, f = Array(u.size);
  return u.forEach(function(p) {
    f[++l] = p;
  }), f;
}
var _setToArray$1 = setToArray$2, Symbol$2 = _Symbol$1, Uint8Array$2 = _Uint8Array$1, eq$1 = eq_1$1, equalArrays$2 = _equalArrays$1, mapToArray$1 = _mapToArray$1, setToArray$1 = _setToArray$1, COMPARE_PARTIAL_FLAG$a = 1, COMPARE_UNORDERED_FLAG$6 = 2, boolTag$5 = "[object Boolean]", dateTag$5 = "[object Date]", errorTag$5 = "[object Error]", mapTag$9 = "[object Map]", numberTag$5 = "[object Number]", regexpTag$5 = "[object RegExp]", setTag$9 = "[object Set]", stringTag$5 = "[object String]", symbolTag$5 = "[object Symbol]", arrayBufferTag$5 = "[object ArrayBuffer]", dataViewTag$7 = "[object DataView]", symbolProto$4 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$3 = symbolProto$4 ? symbolProto$4.valueOf : void 0;
function equalByTag$2(u, l, f, p, m, b, y) {
  switch (f) {
    case dataViewTag$7:
      if (u.byteLength != l.byteLength || u.byteOffset != l.byteOffset)
        return !1;
      u = u.buffer, l = l.buffer;
    case arrayBufferTag$5:
      return !(u.byteLength != l.byteLength || !b(new Uint8Array$2(u), new Uint8Array$2(l)));
    case boolTag$5:
    case dateTag$5:
    case numberTag$5:
      return eq$1(+u, +l);
    case errorTag$5:
      return u.name == l.name && u.message == l.message;
    case regexpTag$5:
    case stringTag$5:
      return u == l + "";
    case mapTag$9:
      var v = mapToArray$1;
    case setTag$9:
      var k = p & COMPARE_PARTIAL_FLAG$a;
      if (v || (v = setToArray$1), u.size != l.size && !k)
        return !1;
      var S = y.get(u);
      if (S)
        return S == l;
      p |= COMPARE_UNORDERED_FLAG$6, y.set(u, l);
      var $ = equalArrays$2(v(u), v(l), p, m, b, y);
      return y.delete(u), $;
    case symbolTag$5:
      if (symbolValueOf$3)
        return symbolValueOf$3.call(u) == symbolValueOf$3.call(l);
  }
  return !1;
}
var _equalByTag$1 = equalByTag$2, arrayPush$2 = _arrayPush$1, isArray$9 = isArray_1$1;
function baseGetAllKeys$3(u, l, f) {
  var p = l(u);
  return isArray$9(u) ? p : arrayPush$2(p, f(u));
}
var _baseGetAllKeys$1 = baseGetAllKeys$3;
function arrayFilter$2(u, l) {
  for (var f = -1, p = u == null ? 0 : u.length, m = 0, b = []; ++f < p; ) {
    var y = u[f];
    l(y, f, u) && (b[m++] = y);
  }
  return b;
}
var _arrayFilter$1 = arrayFilter$2;
function stubArray$3() {
  return [];
}
var stubArray_1$1 = stubArray$3, arrayFilter$1 = _arrayFilter$1, stubArray$2 = stubArray_1$1, objectProto$n = Object.prototype, propertyIsEnumerable$2 = objectProto$n.propertyIsEnumerable, nativeGetSymbols$3 = Object.getOwnPropertySymbols, getSymbols$4 = nativeGetSymbols$3 ? function(u) {
  return u == null ? [] : (u = Object(u), arrayFilter$1(nativeGetSymbols$3(u), function(l) {
    return propertyIsEnumerable$2.call(u, l);
  }));
} : stubArray$2, _getSymbols$1 = getSymbols$4, baseGetAllKeys$2 = _baseGetAllKeys$1, getSymbols$3 = _getSymbols$1, keys$4 = keys_1$1;
function getAllKeys$3(u) {
  return baseGetAllKeys$2(u, keys$4, getSymbols$3);
}
var _getAllKeys$1 = getAllKeys$3, getAllKeys$2 = _getAllKeys$1, COMPARE_PARTIAL_FLAG$9 = 1, objectProto$m = Object.prototype, hasOwnProperty$l = objectProto$m.hasOwnProperty;
function equalObjects$2(u, l, f, p, m, b) {
  var y = f & COMPARE_PARTIAL_FLAG$9, v = getAllKeys$2(u), k = v.length, S = getAllKeys$2(l), $ = S.length;
  if (k != $ && !y)
    return !1;
  for (var w = k; w--; ) {
    var T = v[w];
    if (!(y ? T in l : hasOwnProperty$l.call(l, T)))
      return !1;
  }
  var E = b.get(u), R = b.get(l);
  if (E && R)
    return E == l && R == u;
  var O = !0;
  b.set(u, l), b.set(l, u);
  for (var P = y; ++w < k; ) {
    T = v[w];
    var L = u[T], M = l[T];
    if (p)
      var B = y ? p(M, L, T, l, u, b) : p(L, M, T, u, l, b);
    if (!(B === void 0 ? L === M || m(L, M, f, p, b) : B)) {
      O = !1;
      break;
    }
    P || (P = T == "constructor");
  }
  if (O && !P) {
    var j = u.constructor, x = l.constructor;
    j != x && "constructor" in u && "constructor" in l && !(typeof j == "function" && j instanceof j && typeof x == "function" && x instanceof x) && (O = !1);
  }
  return b.delete(u), b.delete(l), O;
}
var _equalObjects$1 = equalObjects$2, getNative$4 = _getNative$1, root$8 = _root$1, DataView$3 = getNative$4(root$8, "DataView"), _DataView$1 = DataView$3, getNative$3 = _getNative$1, root$7 = _root$1, Promise$3 = getNative$3(root$7, "Promise"), _Promise$1 = Promise$3, getNative$2 = _getNative$1, root$6 = _root$1, Set$3 = getNative$2(root$6, "Set"), _Set$1 = Set$3, getNative$1 = _getNative$1, root$5 = _root$1, WeakMap$4 = getNative$1(root$5, "WeakMap"), _WeakMap$1 = WeakMap$4, DataView$2 = _DataView$1, Map$2 = _Map$1, Promise$2 = _Promise$1, Set$2 = _Set$1, WeakMap$3 = _WeakMap$1, baseGetTag$2 = _baseGetTag$1, toSource$1 = _toSource$1, mapTag$8 = "[object Map]", objectTag$7 = "[object Object]", promiseTag$1 = "[object Promise]", setTag$8 = "[object Set]", weakMapTag$5 = "[object WeakMap]", dataViewTag$6 = "[object DataView]", dataViewCtorString$1 = toSource$1(DataView$2), mapCtorString$1 = toSource$1(Map$2), promiseCtorString$1 = toSource$1(Promise$2), setCtorString$1 = toSource$1(Set$2), weakMapCtorString$1 = toSource$1(WeakMap$3), getTag$7 = baseGetTag$2;
(DataView$2 && getTag$7(new DataView$2(new ArrayBuffer(1))) != dataViewTag$6 || Map$2 && getTag$7(new Map$2()) != mapTag$8 || Promise$2 && getTag$7(Promise$2.resolve()) != promiseTag$1 || Set$2 && getTag$7(new Set$2()) != setTag$8 || WeakMap$3 && getTag$7(new WeakMap$3()) != weakMapTag$5) && (getTag$7 = function(u) {
  var l = baseGetTag$2(u), f = l == objectTag$7 ? u.constructor : void 0, p = f ? toSource$1(f) : "";
  if (p)
    switch (p) {
      case dataViewCtorString$1:
        return dataViewTag$6;
      case mapCtorString$1:
        return mapTag$8;
      case promiseCtorString$1:
        return promiseTag$1;
      case setCtorString$1:
        return setTag$8;
      case weakMapCtorString$1:
        return weakMapTag$5;
    }
  return l;
});
var _getTag$1 = getTag$7, Stack$3 = _Stack$1, equalArrays$1 = _equalArrays$1, equalByTag$1 = _equalByTag$1, equalObjects$1 = _equalObjects$1, getTag$6 = _getTag$1, isArray$8 = isArray_1$1, isBuffer$5 = isBufferExports, isTypedArray$2 = isTypedArray_1$1, COMPARE_PARTIAL_FLAG$8 = 1, argsTag$5 = "[object Arguments]", arrayTag$4 = "[object Array]", objectTag$6 = "[object Object]", objectProto$l = Object.prototype, hasOwnProperty$k = objectProto$l.hasOwnProperty;
function baseIsEqualDeep$2(u, l, f, p, m, b) {
  var y = isArray$8(u), v = isArray$8(l), k = y ? arrayTag$4 : getTag$6(u), S = v ? arrayTag$4 : getTag$6(l);
  k = k == argsTag$5 ? objectTag$6 : k, S = S == argsTag$5 ? objectTag$6 : S;
  var $ = k == objectTag$6, w = S == objectTag$6, T = k == S;
  if (T && isBuffer$5(u)) {
    if (!isBuffer$5(l))
      return !1;
    y = !0, $ = !1;
  }
  if (T && !$)
    return b || (b = new Stack$3()), y || isTypedArray$2(u) ? equalArrays$1(u, l, f, p, m, b) : equalByTag$1(u, l, k, f, p, m, b);
  if (!(f & COMPARE_PARTIAL_FLAG$8)) {
    var E = $ && hasOwnProperty$k.call(u, "__wrapped__"), R = w && hasOwnProperty$k.call(l, "__wrapped__");
    if (E || R) {
      var O = E ? u.value() : u, P = R ? l.value() : l;
      return b || (b = new Stack$3()), m(O, P, f, p, b);
    }
  }
  return T ? (b || (b = new Stack$3()), equalObjects$1(u, l, f, p, m, b)) : !1;
}
var _baseIsEqualDeep$1 = baseIsEqualDeep$2, baseIsEqualDeep$1 = _baseIsEqualDeep$1, isObjectLike$6 = isObjectLike_1$1;
function baseIsEqual$3(u, l, f, p, m) {
  return u === l ? !0 : u == null || l == null || !isObjectLike$6(u) && !isObjectLike$6(l) ? u !== u && l !== l : baseIsEqualDeep$1(u, l, f, p, baseIsEqual$3, m);
}
var _baseIsEqual$1 = baseIsEqual$3, Stack$2 = _Stack$1, baseIsEqual$2 = _baseIsEqual$1, COMPARE_PARTIAL_FLAG$7 = 1, COMPARE_UNORDERED_FLAG$5 = 2;
function baseIsMatch$2(u, l, f, p) {
  var m = f.length, b = m, y = !p;
  if (u == null)
    return !b;
  for (u = Object(u); m--; ) {
    var v = f[m];
    if (y && v[2] ? v[1] !== u[v[0]] : !(v[0] in u))
      return !1;
  }
  for (; ++m < b; ) {
    v = f[m];
    var k = v[0], S = u[k], $ = v[1];
    if (y && v[2]) {
      if (S === void 0 && !(k in u))
        return !1;
    } else {
      var w = new Stack$2();
      if (p)
        var T = p(S, $, k, u, l, w);
      if (!(T === void 0 ? baseIsEqual$2($, S, COMPARE_PARTIAL_FLAG$7 | COMPARE_UNORDERED_FLAG$5, p, w) : T))
        return !1;
    }
  }
  return !0;
}
var _baseIsMatch$1 = baseIsMatch$2, isObject$8 = isObject_1$1;
function isStrictComparable$3(u) {
  return u === u && !isObject$8(u);
}
var _isStrictComparable$1 = isStrictComparable$3, isStrictComparable$2 = _isStrictComparable$1, keys$3 = keys_1$1;
function getMatchData$2(u) {
  for (var l = keys$3(u), f = l.length; f--; ) {
    var p = l[f], m = u[p];
    l[f] = [p, m, isStrictComparable$2(m)];
  }
  return l;
}
var _getMatchData$1 = getMatchData$2;
function matchesStrictComparable$3(u, l) {
  return function(f) {
    return f == null ? !1 : f[u] === l && (l !== void 0 || u in Object(f));
  };
}
var _matchesStrictComparable$1 = matchesStrictComparable$3, baseIsMatch$1 = _baseIsMatch$1, getMatchData$1 = _getMatchData$1, matchesStrictComparable$2 = _matchesStrictComparable$1;
function baseMatches$2(u) {
  var l = getMatchData$1(u);
  return l.length == 1 && l[0][2] ? matchesStrictComparable$2(l[0][0], l[0][1]) : function(f) {
    return f === u || baseIsMatch$1(f, u, l);
  };
}
var _baseMatches$1 = baseMatches$2, baseGet$2 = _baseGet$1;
function get$4(u, l, f) {
  var p = u == null ? void 0 : baseGet$2(u, l);
  return p === void 0 ? f : p;
}
var get_1$1 = get$4, baseIsEqual$1 = _baseIsEqual$1, get$3 = get_1$1, hasIn$1 = hasIn_1$1, isKey$2 = _isKey$1, isStrictComparable$1 = _isStrictComparable$1, matchesStrictComparable$1 = _matchesStrictComparable$1, toKey$3 = _toKey$1, COMPARE_PARTIAL_FLAG$6 = 1, COMPARE_UNORDERED_FLAG$4 = 2;
function baseMatchesProperty$2(u, l) {
  return isKey$2(u) && isStrictComparable$1(l) ? matchesStrictComparable$1(toKey$3(u), l) : function(f) {
    var p = get$3(f, u);
    return p === void 0 && p === l ? hasIn$1(f, u) : baseIsEqual$1(l, p, COMPARE_PARTIAL_FLAG$6 | COMPARE_UNORDERED_FLAG$4);
  };
}
var _baseMatchesProperty$1 = baseMatchesProperty$2;
function baseProperty$2(u) {
  return function(l) {
    return l == null ? void 0 : l[u];
  };
}
var _baseProperty$1 = baseProperty$2, baseGet$1 = _baseGet$1;
function basePropertyDeep$2(u) {
  return function(l) {
    return baseGet$1(l, u);
  };
}
var _basePropertyDeep$1 = basePropertyDeep$2, baseProperty$1 = _baseProperty$1, basePropertyDeep$1 = _basePropertyDeep$1, isKey$1 = _isKey$1, toKey$2 = _toKey$1;
function property$2(u) {
  return isKey$1(u) ? baseProperty$1(toKey$2(u)) : basePropertyDeep$1(u);
}
var property_1$1 = property$2, baseMatches$1 = _baseMatches$1, baseMatchesProperty$1 = _baseMatchesProperty$1, identity$2 = identity_1$1, isArray$7 = isArray_1$1, property$1 = property_1$1;
function baseIteratee$2(u) {
  return typeof u == "function" ? u : u == null ? identity$2 : typeof u == "object" ? isArray$7(u) ? baseMatchesProperty$1(u[0], u[1]) : baseMatches$1(u) : property$1(u);
}
var _baseIteratee$1 = baseIteratee$2;
function isDeprecatedSingleUserColumn(u) {
  var f;
  return u.type === FieldType.BB_REFERENCE && u.subtype === BBReferenceFieldSubType.USER && ((f = u.constraints) == null ? void 0 : f.type) !== "array";
}
function decodeNonAscii(u) {
  return u.replace(
    /\\u([0-9a-fA-F]{4})/g,
    (l, f) => String.fromCharCode(parseInt(f, 16))
  );
}
var arrayPush$1 = _arrayPush$1, getPrototype$2 = _getPrototype$1, getSymbols$2 = _getSymbols$1, stubArray$1 = stubArray_1$1, nativeGetSymbols$2 = Object.getOwnPropertySymbols, getSymbolsIn$3 = nativeGetSymbols$2 ? function(u) {
  for (var l = []; u; )
    arrayPush$1(l, getSymbols$2(u)), u = getPrototype$2(u);
  return l;
} : stubArray$1, _getSymbolsIn$1 = getSymbolsIn$3;
function nativeKeysIn$2(u) {
  var l = [];
  if (u != null)
    for (var f in Object(u))
      l.push(f);
  return l;
}
var _nativeKeysIn$1 = nativeKeysIn$2, isObject$7 = isObject_1$1, isPrototype$3 = _isPrototype$1, nativeKeysIn$1 = _nativeKeysIn$1, objectProto$k = Object.prototype, hasOwnProperty$j = objectProto$k.hasOwnProperty;
function baseKeysIn$2(u) {
  if (!isObject$7(u))
    return nativeKeysIn$1(u);
  var l = isPrototype$3(u), f = [];
  for (var p in u)
    p == "constructor" && (l || !hasOwnProperty$j.call(u, p)) || f.push(p);
  return f;
}
var _baseKeysIn$1 = baseKeysIn$2, arrayLikeKeys$1 = _arrayLikeKeys$1, baseKeysIn$1 = _baseKeysIn$1, isArrayLike$2 = isArrayLike_1$1;
function keysIn$4(u) {
  return isArrayLike$2(u) ? arrayLikeKeys$1(u, !0) : baseKeysIn$1(u);
}
var keysIn_1$1 = keysIn$4, baseGetAllKeys$1 = _baseGetAllKeys$1, getSymbolsIn$2 = _getSymbolsIn$1, keysIn$3 = keysIn_1$1;
function getAllKeysIn$2(u) {
  return baseGetAllKeys$1(u, keysIn$3, getSymbolsIn$2);
}
var _getAllKeysIn$1 = getAllKeysIn$2;
function isCalculationField(u) {
  return "calculationType" in u;
}
var baseKeys$1 = _baseKeys$1, getTag$5 = _getTag$1, isArguments$2 = isArguments_1$1, isArray$6 = isArray_1$1, isArrayLike$1 = isArrayLike_1$1, isBuffer$4 = isBufferExports, isPrototype$2 = _isPrototype$1, isTypedArray$1 = isTypedArray_1$1, mapTag$7 = "[object Map]", setTag$7 = "[object Set]", objectProto$j = Object.prototype, hasOwnProperty$i = objectProto$j.hasOwnProperty;
function isEmpty(u) {
  if (u == null)
    return !0;
  if (isArrayLike$1(u) && (isArray$6(u) || typeof u == "string" || typeof u.splice == "function" || isBuffer$4(u) || isTypedArray$1(u) || isArguments$2(u)))
    return !u.length;
  var l = getTag$5(u);
  if (l == mapTag$7 || l == setTag$7)
    return !u.size;
  if (isPrototype$2(u))
    return !baseKeys$1(u).length;
  for (var f in u)
    if (hasOwnProperty$i.call(u, f))
      return !1;
  return !0;
}
var isEmpty_1 = isEmpty;
const isEmpty$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(isEmpty_1), HBS_REGEX = /{{([^{].*?)}}/g, LOGICAL_OPERATORS = Object.values(LogicalOperator), SEARCH_OPERATORS = [
  ...Object.values(BasicOperator),
  ...Object.values(ArrayOperator),
  ...Object.values(RangeOperator)
], getValidOperatorsForType = (u, l, f) => {
  var T;
  const p = OperatorOptions, m = [
    p.Equals,
    p.NotEquals,
    p.StartsWith,
    p.Like,
    p.Empty,
    p.NotEmpty,
    p.In
  ], b = [
    p.Equals,
    p.NotEquals,
    p.MoreThan,
    p.LessThan,
    p.Empty,
    p.NotEmpty,
    p.In
  ], y = [
    p.Contains,
    p.NotContains,
    p.ContainsAny,
    p.Empty,
    p.NotEmpty
  ];
  let v = [];
  const { type: k, formulaType: S, subtype: $ } = u;
  k === FieldType.STRING ? $ === StringFieldSubType.ARRAY ? v = y : v = m : k === FieldType.NUMBER || k === FieldType.BIGINT ? v = b : k === FieldType.OPTIONS ? v = [p.Equals, p.NotEquals, p.Empty, p.NotEmpty, p.In] : k === FieldType.ARRAY ? v = y : k === FieldType.BOOLEAN ? v = [p.Equals, p.NotEquals, p.Empty, p.NotEmpty] : k === FieldType.LONGFORM ? v = m : k === FieldType.DATETIME ? v = b : k === FieldType.FORMULA && S === FormulaType.STATIC ? v = m.concat([p.MoreThan, p.LessThan]) : k === FieldType.AI ? v = m.concat([p.MoreThan, p.LessThan]) : k === FieldType.BB_REFERENCE_SINGLE || isDeprecatedSingleUserColumn(u) ? v = [p.Equals, p.NotEquals, p.Empty, p.NotEmpty, p.In] : k === FieldType.BB_REFERENCE ? v = y : k === FieldType.BARCODEQR && (v = m);
  const w = (T = f == null ? void 0 : f.tableId) == null ? void 0 : T.includes("datasource_plus");
  return l === "_id" && w && (v = [p.Equals, p.NotEquals, p.In]), v;
}, NoEmptyFilterStrings = [
  OperatorOptions.StartsWith.value,
  OperatorOptions.Like.value,
  OperatorOptions.Equals.value,
  OperatorOptions.NotEquals.value,
  OperatorOptions.Contains.value,
  OperatorOptions.NotContains.value,
  OperatorOptions.ContainsAny.value,
  OperatorOptions.In.value
];
function recurseLogicalOperators(u, l) {
  for (const f of LOGICAL_OPERATORS)
    u[f] && (u[f].conditions = u[f].conditions.map(
      (p) => l(p)
    ));
  return u;
}
const cleanupQuery = (u) => {
  for (let l of NoEmptyFilterStrings)
    if (u[l])
      for (let f of Object.keys(u)) {
        if (f !== l)
          continue;
        if (typeof u[f] == "object")
          for (let [m, b] of Object.entries(u[f]))
            (b == null || b === "" || isEmptyArray(b)) && delete u[l][m];
      }
  return u = recurseLogicalOperators(u, cleanupQuery), u;
};
function isEmptyArray(u) {
  return Array.isArray(u) && u.length === 0;
}
const removeKeyNumbering = (u) => getKeyNumbering(u).key, getKeyNumbering = (u) => {
  if (typeof u == "string" && u.match(/\d[0-9]*:/g) != null) {
    const l = u.split(":");
    return { prefix: `${l.shift()}:`, key: l.join(":") };
  } else
    return { key: u };
};
class ColumnSplitter {
  constructor(l, f) {
    if (this.tableNames = l.map((p) => p.name), this.tableIds = l.map((p) => p._id), this.relationshipColumnNames = l.flatMap(
      (p) => Object.keys(p.schema).filter(
        (m) => p.schema[m].type === FieldType.LINK
      )
    ), this.relationships = this.tableNames.concat(this.tableIds).concat(this.relationshipColumnNames).sort((p, m) => m.length - p.length), f != null && f.aliases) {
      this.aliases = {};
      for (const [p, m] of Object.entries(f.aliases))
        this.aliases[m] = p;
    }
    this.columnPrefix = f == null ? void 0 : f.columnPrefix;
  }
  run(l) {
    let { prefix: f, key: p } = getKeyNumbering(l), m;
    if (this.aliases)
      for (const y of Object.keys(this.aliases || {})) {
        const v = `${y}.`;
        p.startsWith(v) && (m = this.aliases[y], p = p.slice(v.length));
      }
    let b;
    for (const y of this.relationships) {
      const v = `${y}.`;
      if (p.startsWith(v)) {
        const k = p.split(v);
        k.shift(), b = v, p = k.join(".");
        break;
      }
    }
    return this.columnPrefix && p.startsWith(this.columnPrefix) && (p = decodeNonAscii(p.slice(this.columnPrefix.length))), {
      tableName: m,
      numberPrefix: f,
      relationshipPrefix: b,
      column: p
    };
  }
}
function buildCondition(u) {
  if (!u || !(u != null && u.operator) || !(u != null && u.field))
    return;
  const l = {}, { operator: f, field: p, type: m, externalType: b } = u;
  let { value: y } = u;
  (f === "empty" || f === "notEmpty") && (y = null);
  const v = typeof y == "string" && (y.match(HBS_REGEX) || []).length > 0;
  switch (m) {
    case FieldType.DATETIME:
      if (!v && f !== "empty" && f !== "notEmpty") {
        if (!y)
          return;
        if (typeof y == "string")
          y = new Date(y).toISOString();
        else if (isRangeSearchOperator(f))
          return l[f] ?? (l[f] = {}), l[f][p] = y, l;
      }
      break;
    case FieldType.NUMBER:
      typeof y == "string" && !v && (f === "oneOf" ? y = y.split(",").map(parseFloat) : y = parseFloat(y));
      break;
    case FieldType.BOOLEAN:
      y = `${y}`.toLowerCase() === "true";
      break;
    case FieldType.ARRAY:
      ["contains", "notContains", "containsAny"].includes(
        f.toLocaleString()
      ) && typeof y == "string" && (y = y.split(","));
      break;
  }
  if (isRangeSearchOperator(f)) {
    const S = SqlNumberTypeRangeMap[b] || {
      min: Number.MIN_SAFE_INTEGER,
      max: Number.MAX_SAFE_INTEGER
    };
    l[f] ?? (l[f] = {}), l[f][p] = {
      low: m === "number" ? S.min : "0000-00-00T00:00:00.000Z",
      high: m === "number" ? S.max : "9999-00-00T00:00:00.000Z"
    };
  } else if (f === "rangeHigh" && y != null && y !== "")
    l.range ?? (l.range = {}), l.range[p] = {
      ...l.range[p],
      high: y
    };
  else if (f === "rangeLow" && y != null && y !== "")
    l.range ?? (l.range = {}), l.range[p] = {
      ...l.range[p],
      low: y
    };
  else if (isBasicSearchOperator(f) || isArraySearchOperator(f) || isRangeSearchOperator(f))
    m === "boolean" ? f === "equal" && y === !1 ? (l.notEqual = l.notEqual || {}, l.notEqual[p] = !0) : f === "notEqual" && y === !1 ? (l.equal = l.equal || {}, l.equal[p] = !0) : (l[f] ?? (l[f] = {}), l[f][p] = y) : (l[f] ?? (l[f] = {}), l[f][p] = y);
  else
    throw new Error(`Unsupported operator: ${f}`);
  return l;
}
function splitFiltersArray(u) {
  const l = {
    filters: []
  };
  for (const f of u)
    "operator" in f && f.operator === "allOr" ? l.allOr = !0 : "onEmptyFilter" in f ? l.onEmptyFilter = f.onEmptyFilter : l.filters.push(f);
  return l;
}
function buildQuery$1(u) {
  if (!u)
    return {};
  if (Array.isArray(u) && (u = processSearchFilters(u), !u))
    return {};
  const l = {};
  u.onEmptyFilter ? l.onEmptyFilter = u.onEmptyFilter : l.onEmptyFilter = EmptyFilterOption.RETURN_ALL;
  const f = logicalOperatorFromUI(
    u.logicalOperator || UILogicalOperator.ALL
  );
  return l[f] = {
    conditions: (u.groups || []).map((p) => {
      if (p.groups) {
        const k = buildQuery$1(p);
        return delete k.onEmptyFilter, k;
      }
      const { allOr: m, onEmptyFilter: b, filters: y } = splitFiltersArray(
        p.filters || []
      );
      b && (l.onEmptyFilter = b);
      let v = m ? LogicalOperator.OR : LogicalOperator.AND;
      return p.logicalOperator && (v = logicalOperatorFromUI(p.logicalOperator)), {
        [v]: { conditions: y.map(buildCondition).filter((k) => k) }
      };
    })
  }, l;
}
function logicalOperatorFromUI(u) {
  return u === UILogicalOperator.ALL ? LogicalOperator.AND : LogicalOperator.OR;
}
function fixupFilterArrays(u) {
  if (!u)
    return u;
  for (const l of Object.values(ArrayOperator)) {
    const f = u[l];
    if (!(f == null || !isPlainObject$3(f)))
      for (const p of Object.keys(f)) {
        if (Array.isArray(f[p]))
          continue;
        const m = f[p];
        typeof m == "string" ? f[p] = m.split(",").map((b) => b.trim()) : f[p] = [m];
      }
  }
  return recurseLogicalOperators(u, fixupFilterArrays), u;
}
function search(u, l) {
  let f = runQuery$1(u, l.query);
  l.sort && (f = sort$1(
    f,
    l.sort,
    l.sortOrder || SortOrder.ASCENDING,
    l.sortType
  ));
  const p = f.length;
  l.limit && (f = limit(f, l.limit.toString()));
  const m = { rows: f };
  return l.countRows && (m.totalRows = p), m;
}
function runQuery$1(u, l) {
  if (!u || !Array.isArray(u))
    return [];
  if (!l)
    return u;
  if (l = cleanupQuery(l), l = fixupFilterArrays(l), !hasFilters(l) && l.onEmptyFilter === EmptyFilterOption.RETURN_NONE)
    return [];
  const f = (x, N) => (D) => {
    for (const [V, W] of Object.entries(l[x] || {})) {
      const F = isLogicalSearchOperator(x) ? D : deepGet$1(D, removeKeyNumbering(V)), U = N(F, W);
      if (l.allOr && U)
        return !0;
      if (!l.allOr && !U)
        return !1;
    }
    return !l.allOr;
  }, p = f(
    BasicOperator.STRING,
    (x, N) => typeof x != "string" || typeof N != "string" ? !1 : x.toLowerCase().startsWith(N.toLowerCase())
  ), m = f(
    BasicOperator.FUZZY,
    (x, N) => typeof x != "string" || typeof N != "string" ? !1 : x.toLowerCase().includes(N.toLowerCase())
  ), b = f(
    RangeOperator.RANGE,
    (x, N) => {
      if (x == null || x === "" || (isPlainObject$3(N.low) && isEmpty$1(N.low) && (N.low = void 0), isPlainObject$3(N.high) && isEmpty$1(N.high) && (N.high = void 0), N.low == null && N.high == null))
        return !1;
      const D = +x;
      if (!isNaN(D)) {
        const W = +N.low, F = +N.high;
        if (!isNaN(W) && !isNaN(F))
          return D >= W && D <= F;
        if (isNaN(W)) {
          if (!isNaN(F))
            return D <= F;
        } else
          return D >= W;
      }
      const V = dayjs(x);
      if (V.isValid()) {
        const W = dayjs(N.low || "0000-00-00T00:00:00.000Z"), F = dayjs(N.high || "9999-00-00T00:00:00.000Z");
        if (W.isValid() && F.isValid())
          return V.isAfter(W) && V.isBefore(F) || V.isSame(W) || V.isSame(F);
        if (W.isValid())
          return V.isAfter(W) || V.isSame(W);
        if (F.isValid())
          return V.isBefore(F) || V.isSame(F);
      }
      return N.low != null && N.high != null ? x >= N.low && x <= N.high : N.low != null ? x >= N.low : N.high != null ? x <= N.high : !1;
    }
  ), y = (x, N) => {
    if (Array.isArray(x)) {
      for (const V of x)
        if (y(V, N))
          return !0;
      return !1;
    }
    if (x && typeof x == "object" && typeof N == "string")
      return x._id === N;
    if (x === N)
      return !0;
    if (x == null && N != null || x != null && N == null)
      return !1;
    const D = dayjs(x);
    if (D.isValid()) {
      const V = dayjs(N);
      if (V.isValid())
        return D.isSame(V);
    }
    return !1;
  }, v = (x) => (...N) => !x(...N), k = f(BasicOperator.EQUAL, y), S = f(BasicOperator.NOT_EQUAL, v(y)), $ = (x) => typeof x == "string" ? x === "" : Array.isArray(x) ? x.length === 0 : x && typeof x == "object" ? Object.keys(x).length === 0 : x == null, w = f(BasicOperator.EMPTY, $), T = f(BasicOperator.NOT_EMPTY, v($)), E = f(ArrayOperator.ONE_OF, (x, N) => (typeof N == "string" && (N = N.split(",")), typeof x == "number" && (N = N.map((D) => parseFloat(D))), Array.isArray(N) ? N.some((D) => y(x, D)) : !1)), R = (x) => (N, D) => !Array.isArray(N) || (typeof D == "string" && (D = D.split(","), typeof N[0] == "number" && (D = D.map((V) => parseFloat(V)))), !Array.isArray(D)) ? !1 : D.length === 0 ? !0 : D[x]((V) => y(N, V)), O = f(
    ArrayOperator.CONTAINS,
    (x, N) => Array.isArray(N) && N.length === 0 ? !0 : R("every")(x, N)
  ), P = f(
    ArrayOperator.NOT_CONTAINS,
    (x, N) => Array.isArray(N) && N.length === 0 ? !0 : v(R("every"))(x, N)
  ), L = f(ArrayOperator.CONTAINS_ANY, R("some")), M = f(
    LogicalOperator.AND,
    (x, N) => {
      if (!N.length)
        return !1;
      for (const D of N)
        if (!runQuery$1([x], D).length)
          return !1;
      return !0;
    }
  ), B = f(
    LogicalOperator.OR,
    (x, N) => {
      if (!N.length)
        return !1;
      for (const D of N)
        if (runQuery$1([x], {
          ...D,
          allOr: !0
        }).length)
          return !0;
      return !1;
    }
  ), j = (x) => {
    const N = {
      string: p,
      fuzzy: m,
      range: b,
      equal: k,
      notEqual: S,
      empty: w,
      notEmpty: T,
      oneOf: E,
      contains: O,
      containsAny: L,
      notContains: P,
      [LogicalOperator.AND]: M,
      [LogicalOperator.OR]: B
    }, D = Object.entries(l || {}).filter(
      ([V, W]) => !["allOr", "onEmptyFilter"].includes(V) && W && Object.keys(W).length > 0
    ).map(([V]) => {
      var W;
      return ((W = N[V]) == null ? void 0 : W.call(N, x)) ?? !1;
    });
    return hasFilters(l) ? l.allOr ? D.some((V) => V === !0) : D.every((V) => V === !0) : !0;
  };
  return u.filter(j);
}
function sort$1(u, l, f, p = SortType.STRING) {
  if (!l || !f || !p)
    return u;
  const m = (b) => b == null ? b : p === "string" ? `${b}` : parseFloat(b);
  return u.slice().sort((b, y) => {
    const v = m(b[l]), k = m(y[l]), S = k == null || v > k ? 1 : -1;
    return f.toLowerCase() === "descending" ? S * -1 : S;
  });
}
function limit(u, l) {
  const f = typeof l == "number" ? l : parseFloat(l);
  return isNaN(f) ? u : u.slice(0, f);
}
const hasFilters = (u) => {
  if (!u)
    return !1;
  const l = (f) => {
    var p;
    for (const m of LOGICAL_OPERATORS)
      if (f[m])
        for (const b of ((p = f[m]) == null ? void 0 : p.conditions) || []) {
          const y = l(b);
          if (y)
            return y;
        }
    for (const m of SEARCH_OPERATORS) {
      const b = f[m];
      if (!b || typeof b != "object")
        continue;
      if (Object.entries(b).filter((v) => {
        const k = v[1] !== void 0 || v[1] !== null || v[1] !== "";
        return m === BasicOperator.NOT_EMPTY || k;
      }).length !== 0)
        return !0;
    }
    return !1;
  };
  return l(u);
}, QueryUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ColumnSplitter,
  NoEmptyFilterStrings,
  buildQuery: buildQuery$1,
  cleanupQuery,
  fixupFilterArrays,
  getKeyNumbering,
  getValidOperatorsForType,
  hasFilters,
  limit,
  recurseLogicalOperators,
  removeKeyNumbering,
  runQuery: runQuery$1,
  search,
  sort: sort$1,
  splitFiltersArray
}, Symbol.toStringTag, { value: "Module" })), APP_PREFIX = prefixed(DocumentType.WORKSPACE), APP_DEV_PREFIX = prefixed(DocumentType.WORKSPACE_DEV);
function getDevAppID(u) {
  if (!u)
    throw new Error("No app ID provided");
  if (u.startsWith(APP_DEV_PREFIX))
    return u;
  const l = u.split(APP_PREFIX);
  l.shift();
  const f = l.join(APP_PREFIX);
  return `${APP_DEV_PREFIX}${f}`;
}
const getThemeClassNames = (u) => {
  var p;
  u = ensureValidTheme(u);
  let l = `${ThemeClassPrefix}${u}`;
  const f = (p = ThemeOptions.find((m) => m.id === u)) == null ? void 0 : p.base;
  return f && (l = `${ThemeClassPrefix}${f} ${l}`), l;
}, ensureValidTheme = (u, l = Theme.DARKEST) => u ? (u.startsWith(ThemeClassPrefix) && (u = u.split(ThemeClassPrefix)[1]), ThemeOptions.some((f) => f.id === u) ? u : u === Theme.LIGHTEST ? Theme.LIGHT : u === Theme.DARK ? Theme.DARKEST : l) : l, MAX_SESSIONS_PER_USER = 3;
function convertRowsToCsv(u, l, f = ",") {
  const p = l.join(f), m = u.map(
    (b) => l.map((y) => escapeCsvValue(b[y], f)).join(f)
  );
  return [p, ...m].join(`
`);
}
function convertRowsToJson(u) {
  return JSON.stringify(u, null, 2);
}
function escapeCsvValue(u, l = ",") {
  if (u == null)
    return "";
  typeof u == "object" && (u = JSON.stringify(u));
  let f = String(u);
  return f = f.replace(/[\r\n]+/g, " "), f.includes(l) || f.includes('"') ? (f = f.replace(/"/g, '""'), `"${f}"`) : f;
}
function convertDataToExportFormat(u, l, f, p = ",") {
  const m = f != null && f.length ? f.map((y) => y.name) : Array.from(new Set(u.flatMap((y) => Object.keys(y)))), b = u.map(
    (y) => m.reduce((v, k) => (v[k] = k in y ? y[k] : "", v), {})
  );
  switch (l) {
    case "csv":
      return convertRowsToCsv(b, m, p);
    case "json":
      return convertRowsToJson(b);
    default:
      throw new Error(`Unsupported format: ${l}`);
  }
}
const deepGet = deepGet$1;
function uuid() {
  return "cxxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, (u) => {
    const l = Math.random() * 16 | 0;
    return (u === "x" ? l : l & 3 | 8).toString(16);
  });
}
const capitalise = (u) => u ? u.substring(0, 1).toUpperCase() + u.substring(1) : "", hashString = (u) => {
  if (!u)
    return "0";
  let l = 0;
  for (let f = 0; f < u.length; f++) {
    let p = u.charCodeAt(f);
    l = (l << 5) - l + p, l = l & l;
  }
  return l.toString();
}, deepSet = (u, l, f) => {
  if (!u || !l)
    return;
  if (Object.prototype.hasOwnProperty.call(u, l)) {
    u[l] = f;
    return;
  }
  const p = l.split(".");
  for (let m = 0; m < p.length - 1; m++) {
    const b = p[m];
    u && u[b] == null && (u[b] = {}), u = u == null ? void 0 : u[b];
  }
  u && (u[p[p.length - 1]] = f);
}, cloneDeep$5 = (u) => u && JSON.parse(JSON.stringify(u)), copyToClipboard = (u) => new Promise((l) => {
  if (navigator.clipboard && window.isSecureContext)
    navigator.clipboard.writeText(u).then(l);
  else {
    let f = document.createElement("textarea");
    f.value = u, f.style.position = "fixed", f.style.left = "-9999px", f.style.top = "-9999px", document.body.appendChild(f), f.focus(), f.select(), document.execCommand("copy"), f.remove(), l();
  }
}), parseDate = (u, { enableTime: l = !0 }) => {
  if (!u)
    return null;
  typeof u == "string" && (isNaN((/* @__PURE__ */ new Date(`0-${u}`)).valueOf()) ? !l && u.endsWith("Z") && (u = u.split("Z")[0]) : u = `0-${u}`);
  const f = dayjs(u);
  return f.isValid() ? dayjs(Math.floor(f.valueOf() / 1e3) * 1e3) : null;
}, stringifyDate = (u, { enableTime: l = !0, timeOnly: f = !1, ignoreTimezones: p = !1 } = {}) => {
  if (!u)
    return null;
  if (l && p || f) {
    const y = u.toDate().getTimezoneOffset() * 6e4, v = new Date(u.valueOf() - y);
    return f ? v.toISOString().slice(11, 16) : v.toISOString().slice(0, -1);
  } else {
    if (l)
      return u.toISOString();
    {
      const b = u.year(), y = `${u.month() + 1}`.padStart(2, "0"), v = `${u.date()}`.padStart(2, "0");
      return `${b}-${y}-${v}`;
    }
  }
}, getPatternForPart = (u) => {
  switch (u.type) {
    case "day":
      return "D".repeat(u.value.length);
    case "month":
      return "M".repeat(u.value.length);
    case "year":
      return "Y".repeat(u.value.length);
    case "literal":
      return u.value;
    default:
      return console.log("Unsupported date part", u), "";
  }
}, localeDateFormat = new Intl.DateTimeFormat().formatToParts(/* @__PURE__ */ new Date("2021-01-01")).map(getPatternForPart).join(""), getDateDisplayValue = (u, { enableTime: l = !0, timeOnly: f = !1 } = {}) => (typeof u == "string" && (u = dayjs(u)), u != null && u.isValid() ? f ? u.format("HH:mm") : l ? u.format(`${localeDateFormat} HH:mm`) : u.format(localeDateFormat) : ""), hexToRGBA = (u, l) => {
  u.includes("#") && (u = u.replace("#", ""));
  const f = parseInt(u.substring(0, 2), 16), p = parseInt(u.substring(2, 4), 16), m = parseInt(u.substring(4, 6), 16);
  return `rgba(${f}, ${p}, ${m}, ${l})`;
}, SpectrumIconMap = {
  123: "list-numbers",
  "3DMaterials": "cube",
  ABC: "text-aa",
  AEMScreens: "desktop-tower",
  Actions: "cursor-click",
  AdDisplay: "monitor",
  AdPrint: "printer",
  Add: "plus",
  AddCircle: "plus-circle",
  AddTo: "plus",
  AddToSelection: "selection-plus",
  Airplane: "airplane",
  Alert: "warning",
  AlertAdd: "warning-circle",
  AlertCheck: "warning-circle",
  AlertCircle: "warning-circle",
  AlertCircleFilled: "warning-circle",
  Algorithm: "flow-arrow",
  Alias: "link-simple",
  AlignBottom: "align-bottom",
  AlignCenter: "align-center-horizontal",
  AlignLeft: "align-left",
  AlignMiddle: "align-center-vertical",
  AlignRight: "align-right",
  AlignTop: "align-top",
  Amusementpark: "ferris-wheel",
  Anchor: "anchor",
  AnchorSelect: "anchor",
  Annotate: "pencil",
  AnnotatePen: "pen-nib",
  Answer: "chat-circle-dots",
  AnswerFavorite: "chat-circle-dots",
  App: "squares-four",
  AppRefresh: "arrow-clockwise",
  AppleFiles: "apple-logo",
  ApplicationDelivery: "truck",
  ApproveReject: "checks",
  Apps: "squares-four",
  Archive: "archive-tray",
  ArchiveRemove: "tray-arrow-up",
  Arrow: "arrow-right",
  ArrowDown: "arrow-down",
  ArrowLeft: "arrow-left",
  ArrowRight: "arrow-right",
  ArrowUp: "arrow-up",
  ArrowUpRight: "arrow-up-right",
  Artboard: "square",
  Article: "newspaper",
  Asset: "stack",
  AssetCheck: "stack",
  AssetsAdded: "stack",
  AssetsDownloaded: "stack",
  AssetsExpired: "stack",
  AssetsLinkedPublished: "stack",
  AssetsModified: "stack",
  AssetsPublished: "stack",
  Asterisk: "asterisk",
  At: "at",
  Attach: "paperclip",
  AttachmentExclude: "paperclip",
  Attributes: "list-bullets",
  Audio: "music-note",
  AutomatedSegment: "funnel",
  Back: "rotate-counter-clockwise",
  Back30Seconds: "rewind",
  BackAndroid: "arrow-left",
  Beaker: "beaker",
  BeakerCheck: "beaker",
  BeakerShare: "beaker",
  Bell: "bell",
  BidRule: "sliders-horizontal",
  BidRuleAdd: "sliders-horizontal",
  Blower: "wind",
  Blur: "drop-half",
  Book: "book",
  Bookmark: "bookmark",
  BookmarkSingle: "bookmark",
  BookmarkSingleOutline: "bookmark",
  BookmarkSmall: "bookmark-simple",
  BookmarkSmallOutline: "bookmark-simple",
  Boolean: "intersect",
  Border: "square",
  Box: "cube",
  BoxAdd: "cube",
  BoxExport: "cube",
  BoxImport: "cube",
  Brackets: "brackets-angle",
  BracketsSquare: "brackets-square",
  Branch1: "git-branch",
  Branch2: "git-branch",
  Branch3: "git-branch",
  BranchCircle: "git-branch",
  BreadcrumbNavigation: "dots-three-outline",
  Breakdown: "chart-line",
  BreakdownAdd: "chart-line",
  Briefcase: "briefcase",
  Browse: "folder-open",
  Brush: "paint-brush",
  Bug: "bug",
  Building: "buildings",
  BulkEditUsers: "users-three",
  Button: "square",
  CCLibrary: "books",
  Calculator: "calculator",
  Calendar: "calendar",
  CalendarAdd: "calendar-plus",
  CalendarLocked: "calendar",
  CalendarUnlocked: "calendar",
  CallCenter: "headset",
  Camera: "camera",
  CameraFlip: "camera-rotate",
  CameraRefresh: "camera",
  Campaign: "megaphone",
  CampaignAdd: "megaphone",
  CampaignClose: "megaphone",
  CampaignDelete: "megaphone",
  CampaignEdit: "megaphone",
  Cancel: "x",
  Capitals: "text-aa",
  Captcha: "puzzle-piece",
  Car: "car",
  Card: "credit-card",
  Channel: "share-network",
  Chat: "chat-circle",
  ChatAdd: "chat-circle",
  CheckPause: "pause-circle",
  Checkmark: "check",
  CheckmarkCircle: "check-circle",
  CheckmarkCircleOutline: "check-circle",
  Chevron: "caret-right",
  ChevronDoubleLeft: "caret-double-left",
  ChevronDoubleRight: "caret-double-right",
  ChevronDown: "caret-down",
  ChevronLeft: "caret-left",
  ChevronRight: "caret-right",
  ChevronUp: "caret-up",
  ChevronUpDown: "arrows-vertical",
  Circle: "circle",
  ClassicGridView: "squares-four",
  Clock: "clock",
  ClockCheck: "clock-check",
  CloneStamp: "stamp",
  Close: "x",
  CloseCaptions: "closed-captioning",
  CloseCircle: "xcircle",
  Cloud: "cloud",
  CloudDisconnected: "cloud-slash",
  CloudError: "cloud-warning",
  CloudOutline: "cloud",
  Code: "code",
  Collection: "stack",
  CollectionAdd: "stack",
  CollectionAddTo: "stack",
  CollectionCheck: "stack",
  CollectionEdit: "stack",
  CollectionExclude: "stack",
  CollectionLink: "stack",
  ColorFill: "paint-bucket",
  ColorPalette: "palette",
  ColorWheel: "circle-half-tilt",
  ColumnSettings: "columns",
  ColumnTwoA: "columns",
  ColumnTwoB: "columns",
  ColumnTwoC: "columns",
  Comment: "chat-circle",
  Compare: "swap",
  Compass: "compass",
  Condition: "git-merge",
  ConfidenceFour: "cell-signal-full",
  ConfidenceOne: "cell-signal-low",
  ConfidenceThree: "cell-signal-high",
  ConfidenceTwo: "cell-signal-medium",
  Connect: "link",
  ConnectedObjects: "link",
  ContactInfo: "address-book",
  ContrastFill: "circle-half-tilt",
  ConversionFunnel: "funnel",
  ConvertAnchorPoint: "anchor",
  Copy: "copy",
  CornerRadius: "square",
  CreatePDF: "file-pdf",
  Crop: "crop",
  CropLighten: "crop",
  CropRotate: "crop",
  CrossSize: "plus",
  CurveTool: "bezier-curve",
  Cut: "scissors",
  Data: "database",
  DataAdd: "database",
  DataBook: "database",
  DataCheck: "database",
  DataCorrelated: "database",
  DataDownload: "database",
  DataEdit: "database",
  DataMapping: "database",
  DataRefresh: "database",
  DataRemove: "database",
  DataSettings: "database",
  DataUpload: "database",
  DataUser: "database",
  DataUnavailable: "database-slash",
  Date: "calendar",
  DateInput: "calendar",
  Deduplication: "copy",
  Delete: "trash",
  DeleteOutline: "trash",
  Demographic: "users-three",
  DeselectCircular: "circle-dashed",
  Desktop: "desktop",
  DeviceDesktop: "desktop",
  DeviceLaptop: "laptop",
  DevicePhone: "device-mobile",
  DevicePreview: "devices",
  DeviceRotateLandscape: "device-rotate",
  DeviceRotatePortrait: "device-rotate",
  DeviceTablet: "device-tablet",
  DeviceTV: "television",
  Devices: "devices",
  Dimensions: "ruler",
  DirectRight: "arrow-right",
  DistributeBottomEdge: "align-bottom",
  DistributeHorizontalCenter: "align-center-horizontal",
  DistributeLeftEdge: "align-left",
  DistributeRightEdge: "align-right",
  DistributeSpaceHoriz: "align-horizontal",
  DistributeSpaceVert: "align-vertical",
  DistributeTopEdge: "align-top",
  DistributeVerticalCenter: "align-center-vertical",
  DistributeVertically: "align-vertical",
  Document: "file-text",
  DocumentFragment: "file-text",
  DocumentFragmentGroup: "files",
  DocumentOutline: "file-text",
  DocumentRefresh: "file-text",
  Download: "download",
  DownloadFromCloud: "cloud-arrow-down",
  DownloadFromCloudOutline: "cloud-arrow-down",
  Draft: "note-pencil",
  DragHandle: "dots-six",
  Draw: "pencil",
  Dropdown: "caret-down",
  Duplicate: "copy",
  Edit: "pencil",
  EditCircle: "pencil-circle",
  EditExclude: "pencil",
  EditIn: "pencil",
  Education: "graduation-cap",
  Effect: "sparkle",
  Email: "envelope",
  EmailCancel: "envelope",
  EmailCheck: "envelope",
  EmailExclude: "envelope",
  EmailGear: "envelope",
  EmailKey: "envelope",
  EmailLightning: "envelope",
  EmailOutline: "envelope",
  EmailRefresh: "envelope",
  EmailReject: "envelope",
  EmailSchedule: "envelope",
  Engagement: "handshake",
  Enterprise: "buildings",
  Erase: "eraser",
  Event: "calendar",
  EventExclude: "calendar",
  EventShare: "calendar",
  Events: "calendar",
  ExcludeOverlap: "intersect",
  Experience: "star",
  ExperienceAdd: "star",
  ExperienceAddTo: "star",
  ExperienceExport: "star",
  ExperienceImport: "star",
  Export: "export",
  ExportOriginal: "export",
  Exposure: "circle-half-tilt",
  Extension: "puzzle-piece",
  FaceHappy: "smiley",
  FaceSad: "smiley-sad",
  FastForward: "fast-forward",
  FastForwardCircle: "fast-forward-circle",
  Feature: "star",
  Feed: "rss",
  FeedAdd: "rss",
  FeedManagement: "rss",
  File: "file",
  FileAdd: "file-plus",
  FileCSV: "file-csv",
  FileCode: "file-code",
  FileData: "file-text",
  FileEmail: "file-text",
  FileGear: "file-text",
  FileHTML: "file-html",
  FileImportant: "file-text",
  FileKey: "file-text",
  FilePDF: "file-pdf",
  FileSingleWebPage: "file-html",
  FileTemplate: "file-text",
  FileTxt: "file-text",
  FileUser: "file-text",
  FileWorkflow: "file-text",
  FileZip: "file-zip",
  FilingCabinet: "filing-cabinet",
  Filter: "funnel",
  FilterAdd: "funnel",
  FilterCheck: "funnel",
  FilterColored: "funnel",
  FilterDelete: "funnel",
  FilterEdit: "funnel",
  FilterHeart: "funnel",
  FilterRemove: "funnel",
  FilterStar: "funnel",
  FindAndReplace: "magnifying-glass",
  Flag: "flag",
  FlagExclude: "flag",
  Flashlight: "flashlight",
  FlashlightOff: "flashlight",
  FlashlightOn: "flashlight",
  FlashOn: "lightning",
  Flight: "airplane",
  Flip: "flip-horizontal",
  FlipHorizontal: "flip-horizontal",
  FlipVertical: "flip-vertical",
  Folder: "folder",
  Folder2Color: "folder",
  FolderAdd: "folder-plus",
  FolderAddTo: "folder-plus",
  FolderArchive: "folder",
  FolderBreadcrumb: "folder",
  FolderDelete: "folder-minus",
  FolderGear: "folder",
  FolderLocked: "folder-lock",
  FolderOpen: "folder-open",
  FolderOpenOutline: "folder-open",
  FolderOutline: "folder",
  FolderRemove: "folder-minus",
  FolderSearch: "folder",
  FolderUser: "folder",
  Follow: "plus",
  FontDecrease: "text-size",
  FontIncrease: "text-size",
  FontSize: "text-size",
  Form: "list",
  Forward: "arrow-right",
  Forward30Seconds: "fast-forward",
  FullScreen: "arrows-out",
  FullScreenExit: "arrows-in",
  Function: "function",
  Gauge1: "gauge",
  Gauge2: "gauge",
  Gauge3: "gauge",
  Gauge4: "gauge",
  Gauge5: "gauge",
  Gears: "gears",
  GearsAdd: "gears",
  GearsDelete: "gears",
  GearsEdit: "gears",
  Gift: "gift",
  Globe: "globe",
  GlobeCheck: "globe",
  GlobeClock: "globe",
  GlobeEnter: "globe",
  GlobeExit: "globe",
  GlobeGrid: "globe",
  GlobeOutline: "globe",
  GlobeRemove: "globe",
  GlobeSearch: "globe",
  GlobeStrike: "globe",
  GlobeStrikeThrough: "globe",
  GovernmentBuilding: "bank",
  Gradient: "gradient",
  GraphArea: "chart-line",
  GraphAreaStacked: "chart-line",
  GraphBarHorizontal: "chart-bar-horizontal",
  GraphBarHorizontalAdd: "chart-bar-horizontal",
  GraphBarHorizontalStacked: "chart-bar-horizontal",
  GraphBarVertical: "chart-bar",
  GraphBarVerticalAdd: "chart-bar",
  GraphBarVerticalStacked: "chart-bar",
  GraphBubble: "chart-scatter",
  GraphBullet: "chart-bar",
  GraphConfidenceBand: "chart-line",
  GraphDonut: "chart-donut",
  GraphDonutAdd: "chart-donut",
  GraphGantt: "chart-bar",
  GraphHistogram: "chart-bar",
  GraphLine: "chart-line",
  GraphPie: "chart-pie",
  GraphProfitCurve: "chart-line",
  GraphScatter: "chart-scatter",
  GraphStream: "chart-line",
  GraphStreamRanked: "chart-line",
  GraphSunburst: "chart-donut",
  GraphTree: "tree-structure",
  GraphTrend: "trend-up",
  GraphTrendAdd: "trend-up",
  Graphic: "image",
  GraphicCircle: "circle",
  GraphicRectangle: "rectangle",
  Grid: "grid-four",
  GridView: "grid-four",
  Group: "squares-four",
  GroupedBarChart: "chart-bar",
  Hand: "hand",
  Hand0: "hand",
  Hand1: "hand",
  Hand2: "hand",
  Hand3: "hand",
  Hand4: "hand",
  HangingIndent: "text-indent",
  HardDrive: "hard-drive",
  Hashtag: "hash",
  Heal: "bandage",
  Heart: "heart",
  HeartOutline: "heart",
  Help: "question",
  HelpOutline: "question",
  Hide: "eye-slash",
  Histogram: "chart-bar",
  History: "clock-counter-clockwise",
  Home: "house",
  HomeFilled: "house",
  HomePage: "house",
  HorizontalContainer: "rectangle",
  HotSpot: "target",
  Hotel: "bed",
  Hourglass: "hourglass",
  House: "house",
  IdentityService: "identification-card",
  Image: "image",
  ImageAdd: "image",
  ImageAlbum: "images",
  ImageAutoMode: "image",
  ImageCarousel: "images",
  ImageCheck: "image",
  ImageCheckedOut: "image",
  ImageMapCircle: "image",
  ImageMapPolygon: "image",
  ImageMapRectangle: "image",
  ImageNext: "image",
  ImageProfile: "image",
  ImageSearch: "image",
  ImageText: "image",
  Images: "images",
  Import: "download",
  ImportantDetail: "warning",
  Inbox: "tray",
  IndentDecrease: "text-indent",
  IndentIncrease: "text-indent",
  Individual: "user",
  Info: "info",
  InfoOutline: "info",
  InkDrop: "drop",
  Insert: "plus",
  Insights: "chart-line",
  Intersect: "intersect",
  IntersectOverlap: "intersect",
  Invite: "user-plus",
  ItalicText: "text-italic",
  Journey: "path",
  JourneyAction: "path",
  JourneyData: "path",
  JourneyEvent: "path",
  JourneyVoyager: "path",
  JumpToTop: "arrow-up",
  Key: "key",
  KeyClock: "key",
  KeyExclude: "key",
  KeyMetrics: "key",
  Keyboard: "keyboard",
  Label: "tag",
  LabelExclude: "tag",
  Landscape: "mountains",
  Launch: "rocket-launch",
  Layer: "stack",
  LayerBackward: "stack",
  LayerForward: "stack",
  LayersBackward: "stack",
  LayersForward: "stack",
  LayersSendToBack: "stack",
  Layout: "layout",
  Learn: "graduation-cap",
  Light: "lightbulb",
  Line: "line-segment",
  LineHeight: "text-line-spacing",
  Link: "link",
  LinkCheck: "link",
  LinkGlobe: "link",
  LinkNav: "link",
  LinkOff: "link-break",
  LinkOut: "arrow-square-out",
  LinkOutLight: "arrow-square-out",
  LinkPage: "link",
  LinkUser: "link",
  Location: "map-pin",
  LocationBasedDate: "map-pin",
  LocationBasedEvent: "map-pin",
  LocationContribution: "map-pin",
  Lock: "lock",
  LockClosed: "lock",
  LockOpen: "lock-open",
  LogOut: "sign-out",
  Login: "sign-in",
  Look: "eye",
  LookupObjects: "magnifying-glass",
  Loupe: "magnifying-glass",
  LoupeView: "magnifying-glass",
  MBox: "envelope",
  MagicWand: "magic-wand",
  Magnify: "magnifying-glass",
  MailTo: "envelope",
  MapView: "map",
  MarginBottom: "align-bottom",
  MarginLeft: "align-left",
  MarginRight: "align-right",
  MarginTop: "align-top",
  MarketingActivities: "megaphone",
  Maximize: "arrows-out",
  Measure: "ruler",
  MediaRefresh: "arrow-clockwise",
  Megaphone: "megaphone",
  Merge: "git-merge",
  MergeLayers: "stack",
  Message: "chat-circle",
  Minimize: "arrows-in",
  Mobile: "device-mobile",
  ModernGridView: "grid-four",
  Money: "money",
  Monitor: "monitor",
  Monitoring: "monitor",
  More: "dots-three",
  MoreCircle: "dots-three-circle",
  MoreSmallList: "dots-three",
  MoreSmallListVert: "dots-three-vertical",
  MoreVertical: "dots-three-vertical",
  Move: "arrows-four",
  MoveLeftRight: "arrows-horizontal",
  MoveTo: "arrow-right",
  MoveUpDown: "arrows-vertical",
  MultipleAdd: "plus",
  MultipleCheck: "check",
  MultipleExclude: "minus",
  Music: "music-note",
  MusicNote: "music-note",
  NewItem: "plus",
  News: "newspaper",
  NewsAdd: "newspaper",
  Next: "arrow-right",
  NoDuplicate: "copy",
  NoEdit: "pencil-slash",
  Note: "note",
  NoteAdd: "note",
  Notification: "bell",
  NotificationImportant: "bell",
  Number: "hash",
  Number0: "number-zero",
  Number1: "number-one",
  Number2: "number-two",
  Number3: "number-three",
  Number4: "number-four",
  Number5: "number-five",
  Number6: "number-six",
  Number7: "number-seven",
  Number8: "number-eight",
  Number9: "number-nine",
  OpenIn: "arrow-square-out",
  OpenInLight: "arrow-square-out",
  OpenRecent: "clock-counter-clockwise",
  OpenRecentOutline: "clock-counter-clockwise",
  Operations: "gears",
  Orbit: "planet",
  OrderedList: "list-numbers",
  Organize: "squares-four",
  Orientation: "device-rotate",
  Outline: "square",
  Output: "export",
  Overlap: "intersect",
  Package: "package",
  PaddingBottom: "align-bottom",
  PaddingLeft: "align-left",
  PaddingRight: "align-right",
  PaddingTop: "align-top",
  Page: "file-text",
  PageBreak: "file-text",
  PageExclude: "file-text",
  PageGear: "file-text",
  PageRule: "file-text",
  PageShare: "file-text",
  PageTag: "file-text",
  Pages: "files",
  PagesExclude: "files",
  Pan: "hand",
  Panel: "sidebar",
  Paste: "clipboard",
  PasteHTML: "clipboard",
  PasteList: "clipboard",
  PasteText: "clipboard",
  PatternFill: "pattern",
  Pause: "pause",
  PauseCircle: "pause-circle",
  Paypal: "currency-dollar",
  Pen: "pen",
  Pencil: "pencil",
  PendingItems: "clock",
  People: "users-three",
  PersonalizationField: "user",
  Perspective: "cube",
  Phone: "phone",
  PhoneVerification: "phone",
  PieChart: "chart-pie",
  Pin: "push-pin",
  PinOff: "push-pin-slash",
  PinOn: "push-pin",
  Pivot: "arrows-clockwise",
  Play: "play",
  PlayCircle: "play-circle",
  Playlist: "playlist",
  PlaylistAdd: "playlist",
  PlaylistRemove: "playlist",
  Plugin: "puzzle-piece",
  PolarGrid: "grid-nine",
  Polygon: "polygon",
  PopIn: "arrow-square-in",
  Portrait: "user",
  Preferences: "gear",
  Preview: "eye",
  Previous: "arrow-left",
  Print: "printer",
  PrintPreview: "printer",
  Privacy: "lock",
  Project: "folder",
  ProjectAdd: "folder-plus",
  ProjectEdit: "folder",
  ProjectNameEdit: "folder",
  Properties: "list-bullets",
  PropertiesCopy: "list-bullets",
  Publish: "upload",
  PublishCheck: "upload",
  PublishPending: "upload",
  PublishReject: "upload",
  PublishRemove: "upload",
  PublishSchedule: "upload",
  PushNotification: "bell",
  QRCode: "qr-code",
  Question: "question",
  QuestionMarkCircle: "question",
  Queue: "queue",
  QuickSelect: "cursor-click",
  RadioButton: "radio-button",
  Rail: "sidebar",
  RailBottom: "align-bottom",
  RailLeft: "align-left",
  RailRight: "align-right",
  RailRightClose: "align-right",
  RailRightOpen: "align-right",
  RailTop: "align-top",
  RapidGrowth: "trend-up",
  RealTime: "clock",
  RealTimeCustomerProfile: "user",
  Receipt: "receipt",
  RecentItems: "clock-counter-clockwise",
  Rectangle: "rectangle",
  RectangleSelect: "rectangle",
  Redo: "arrow-clockwise",
  Refresh: "arrow-clockwise",
  RegionSelect: "selection",
  Reject: "x",
  Remove: "minus",
  RemoveCircle: "minus-circle",
  Rename: "pencil",
  Reorder: "list-bullets",
  Replay: "arrow-clockwise",
  Reply: "arrow-bend-up-left",
  ReplyAll: "arrow-bend-up-left",
  Report: "chart-bar",
  ReportAdd: "chart-bar",
  Resize: "arrows-out",
  ResourceFork: "git-fork",
  Restore: "arrow-counter-clockwise",
  Retweet: "repeat",
  Reuse: "recycle",
  Revert: "arrow-counter-clockwise",
  Rewind: "rewind",
  RewindCircle: "rewind-circle",
  Ribbon: "medal",
  Rotate: "arrow-clockwise",
  RotateLeft: "arrow-counter-clockwise",
  RotateLeftOutline: "arrow-counter-clockwise",
  RotateRight: "arrow-clockwise",
  RotateRightOutline: "arrow-clockwise",
  RotateCW: "arrow-clockwise",
  SMS: "chat-circle",
  SQLQuery: "database",
  Sandbox: "columns",
  Save: "floppy-disk",
  SaveAsFloppy: "floppy-disk",
  SaveFloppy: "floppy-disk",
  SaveTo: "floppy-disk",
  SaveToLight: "floppy-disk",
  Scale: "resize",
  Scribble: "scribble-loop",
  Search: "magnifying-glass",
  SearchExclude: "magnifying-glass",
  Seat: "chair",
  SeatAdd: "chair",
  Segmentation: "funnel",
  Select: "cursor-click",
  SelectAdd: "selection-plus",
  SelectBox: "selection",
  SelectBoxAll: "selection",
  SelectCircular: "circle-dashed",
  SelectContainer: "selection",
  SelectGear: "selection",
  SelectIntersect: "intersect",
  SelectSubtract: "minus",
  Selection: "selection",
  SelectionChecked: "selection",
  SelectionMove: "selection",
  Send: "paper-plane-tilt",
  SendBackward: "arrow-down",
  SendToBack: "arrow-line-down",
  Sentiment: "smiley",
  SentimentNegative: "smiley-sad",
  SentimentNeutral: "smiley-meh",
  SentimentPositive: "smiley",
  SequenceAfter: "arrow-right",
  SequenceBefore: "arrow-left",
  Server: "server",
  ServiceRequest: "headset",
  Settings: "gear",
  Share: "share",
  ShareAndroid: "share",
  ShareCheck: "share",
  ShareLight: "share",
  Shield: "shield",
  ShieldCheck: "shield-check",
  Ship: "boat",
  Shop: "storefront",
  ShoppingCart: "shopping-cart",
  ShowAllLayers: "stack",
  ShowMenu: "list-bullets",
  ShowOneLayer: "stack",
  Shuffle: "shuffle",
  SideKick: "robot",
  Slice: "scissors",
  Slow: "hourglass",
  SmallCaps: "text-aa",
  Snapshot: "camera",
  SocialNetwork: "share-network",
  SortOrderDown: "sort-descending",
  SortOrderUp: "sort-ascending",
  Spam: "prohibit",
  Spellcheck: "check",
  Spin: "spinner-gap",
  SplitView: "columns",
  SpotHeal: "bandage",
  Stadium: "circle",
  Stage: "square",
  Stamp: "stamp",
  Star: "star",
  StarOutline: "star",
  Starburst: "sparkle",
  StatusLight: "circle",
  StepBackward: "skip-back",
  StepBackwardCircle: "skip-back-circle",
  StepForward: "skip-forward",
  StepForwardCircle: "skip-forward-circle",
  Stop: "stop",
  StopCircle: "stop-circle",
  Stopwatch: "stopwatch",
  Straighten: "ruler",
  StraightenOutline: "ruler",
  StrokeWidth: "minus",
  Subscribe: "bell",
  SubstractBackPath: "minus",
  SubstractFromSelection: "minus",
  SubtractBackPath: "minus",
  SubtractFromSelection: "minus",
  SubtractFrontPath: "minus",
  SuccessMetric: "trend-up",
  Summarize: "list-checks",
  Survey: "clipboard-text",
  Switch: "toggle-left",
  Sync: "arrows-clockwise",
  SyncRemove: "arrows-clockwise",
  Table: "table",
  TableAdd: "table",
  TableAndChart: "table",
  TableColumnAddLeft: "table",
  TableColumnAddRight: "table",
  TableColumnMerge: "table",
  TableColumnRemoveCenter: "table",
  TableColumnSplit: "table",
  TableEdit: "table",
  TableHistogram: "table",
  TableMergeCells: "table",
  TableRowAddBottom: "table",
  TableRowAddTop: "table",
  TableRowMerge: "table",
  TableRowRemoveCenter: "table",
  TableRowSplit: "table",
  TableSelectColumn: "table",
  TableSelectRow: "table",
  Tableau: "chart-bar",
  TagBold: "text-bolder",
  TagItalic: "text-italic",
  TagUnderline: "text-underline",
  Target: "target",
  Targeted: "target",
  TaskList: "list-checks",
  Teapot: "coffee",
  Temperature: "thermometer",
  TestAB: "flask",
  TestABEdit: "flask",
  TestABGear: "flask",
  TestABRemove: "flask",
  TestProfile: "flask",
  Text: "article",
  TextAdd: "article",
  TextAlignCenter: "text-align-center",
  TextAlignJustify: "text-align-justify",
  TextAlignLeft: "text-align-left",
  TextAlignRight: "text-align-right",
  TextBaselineShift: "text-line-spacing",
  TextBold: "text-bolder",
  TextBulleted: "list-bullets",
  TextBulletedAttach: "list-bullets",
  TextBulletedHierarchy: "list-bullets",
  TextBulletedHierarchyExclude: "list-bullets",
  TextColor: "paint-bucket",
  TextDecrease: "text-line-spacing",
  TextEdit: "article",
  TextExclude: "article",
  TextIncrease: "text-line-spacing",
  TextIndentDecrease: "text-indent",
  TextIndentIncrease: "text-indent",
  TextItalic: "text-italic",
  TextKerning: "text-line-spacing",
  TextLetteredLowerCase: "text-aa",
  TextLetteredUpperCase: "text-aa",
  TextNumbered: "list-numbers",
  TextParagraph: "text-align-justify",
  TextRomanLowercase: "text-aa",
  TextRomanUppercase: "text-aa",
  TextSize: "text-size",
  TextSizeAdd: "text-size",
  TextSpaceAfter: "text-line-spacing",
  TextSpaceBefore: "text-line-spacing",
  TextStrikethrough: "text-strikethrough",
  TextStroke: "text",
  TextStyle: "sparkle",
  TextSubscript: "text-subscript",
  TextSuperscript: "text-superscript",
  TextTracking: "text-line-spacing",
  TextUnderline: "text-underline",
  ThumbDown: "thumbs-down",
  ThumbDownOutline: "thumbs-down",
  ThumbUp: "thumbs-up",
  ThumbUpOutline: "thumbs-up",
  Tips: "lightbulb",
  Train: "train",
  TransferToPlatform: "arrow-up-tray",
  Transparency: "squares-four",
  Trap: "target",
  TreeCollapse: "caret-right",
  TreeCollapseAll: "caret-double-right",
  TreeExpand: "caret-down",
  TreeExpandAll: "caret-double-down",
  TrendInspect: "chart-line",
  TrimPath: "crop",
  TripleGripper: "list-bullets",
  Trophy: "trophy",
  Type: "text-t",
  USA: "flag",
  Underline: "text-underline",
  Undo: "arrow-counter-clockwise",
  Ungroup: "squares-four",
  Unlink: "link-break",
  Unmerge: "intersect",
  UploadToCloud: "cloud-arrow-up",
  UploadToCloudOutline: "cloud-arrow-up",
  User: "user",
  UserActivity: "graph-line",
  UserAdd: "user-plus",
  UserAdmin: "user-gear",
  UserArrow: "user-switch",
  UserCheckedOut: "user-circle-minus",
  UserDeveloper: "user-gear",
  UserEdit: "user-circle-gear",
  UserExclude: "user-minus",
  UserGroup: "users-three",
  UserLock: "user-lock",
  UserShare: "share-network",
  UsersAdd: "users-three",
  UsersExclude: "users-three",
  UsersLock: "users-three",
  UsersShare: "users-three",
  Variable: "function",
  VectorDraw: "bezier-curve",
  VideoCheckedOut: "film-slate",
  VideoFilled: "film-slate",
  VideoOutline: "film-slate",
  ViewAllTags: "tags",
  ViewBiWeek: "calendar",
  ViewCard: "squares-four",
  ViewColumn: "columns",
  ViewDay: "calendar",
  ViewDetail: "list-dashes",
  ViewGrid: "squares-four",
  ViewList: "list-bullets",
  ViewRow: "rows",
  ViewSingle: "square",
  ViewStack: "stack",
  ViewWeek: "calendar",
  ViewedMarkAs: "eye",
  Vignette: "circle-half-tilt",
  Visibility: "eye",
  VisibilityOff: "eye-slash",
  Visit: "arrow-square-out",
  VisitShare: "arrow-square-out",
  VoiceOver: "microphone",
  VolumeMute: "speaker-none",
  VolumeOne: "speaker-low",
  VolumeThree: "speaker-high",
  VolumeTwo: "speaker-high",
  Watch: "watch",
  WebPage: "browser",
  WebPages: "browsers",
  Workflow: "tree-structure",
  WorkflowAdd: "tree-structure",
  Wrench: "wrench",
  ZoomIn: "magnifying-glass-plus",
  ZoomOut: "magnifying-glass-minus"
};
function getPhosphorIcon(u) {
  return SpectrumIconMap[u] || u;
}
const InnerIcon_svelte_svelte_type_style_lang = "";
function create_fragment$1I(u) {
  let l, f, p, m, b, y;
  return {
    c() {
      l = element("i"), attr(l, "class", f = null_to_empty(
        /*phosphorClass*/
        u[6]
      ) + " svelte-8f9wnr"), attr(
        l,
        "style",
        /*style*/
        u[5]
      ), attr(l, "aria-hidden", p = /*hidden*/
      u[1] ? "true" : "false"), attr(l, "aria-label", m = /*tooltip*/
      u[4] || /*name*/
      u[0]), attr(
        l,
        "title",
        /*tooltip*/
        u[4]
      ), toggle_class(
        l,
        "hoverable",
        /*hoverable*/
        u[2]
      ), toggle_class(
        l,
        "disabled",
        /*disabled*/
        u[3]
      );
    },
    m(v, k) {
      insert(v, l, k), b || (y = [
        listen(
          l,
          "contextmenu",
          /*contextmenu_handler*/
          u[12]
        ),
        listen(
          l,
          "click",
          /*click_handler*/
          u[13]
        ),
        listen(
          l,
          "mouseover",
          /*mouseover_handler*/
          u[14]
        ),
        listen(
          l,
          "mouseleave",
          /*mouseleave_handler*/
          u[15]
        ),
        listen(
          l,
          "focus",
          /*focus_handler*/
          u[16]
        )
      ], b = !0);
    },
    p(v, [k]) {
      k & /*phosphorClass*/
      64 && f !== (f = null_to_empty(
        /*phosphorClass*/
        v[6]
      ) + " svelte-8f9wnr") && attr(l, "class", f), k & /*style*/
      32 && attr(
        l,
        "style",
        /*style*/
        v[5]
      ), k & /*hidden*/
      2 && p !== (p = /*hidden*/
      v[1] ? "true" : "false") && attr(l, "aria-hidden", p), k & /*tooltip, name*/
      17 && m !== (m = /*tooltip*/
      v[4] || /*name*/
      v[0]) && attr(l, "aria-label", m), k & /*tooltip*/
      16 && attr(
        l,
        "title",
        /*tooltip*/
        v[4]
      ), k & /*phosphorClass, hoverable*/
      68 && toggle_class(
        l,
        "hoverable",
        /*hoverable*/
        v[2]
      ), k & /*phosphorClass, disabled*/
      72 && toggle_class(
        l,
        "disabled",
        /*disabled*/
        v[3]
      );
    },
    i: noop$4,
    o: noop$4,
    d(v) {
      v && detach(l), b = !1, run_all(y);
    }
  };
}
function instance$1G(u, l, f) {
  let p, m, b, { size: y = "M" } = l, { name: v = "plus" } = l, { hidden: k = !1 } = l, { hoverable: S = !1 } = l, { disabled: $ = !1 } = l, { color: w = void 0 } = l, { hoverColor: T = void 0 } = l, { tooltip: E = void 0 } = l, { weight: R = "regular" } = l;
  const O = {
    XXS: "12px",
    XS: "14px",
    S: "16px",
    M: "18px",
    L: "22px",
    XL: "28px",
    XXL: "36px",
    XXXL: "72px"
  }, P = (N, D, V) => {
    let W = `--size:${O[N]};`;
    return D && (W += `--color:${D};`), V && (W += `--hover-color:${V};`), W;
  };
  function L(N) {
    bubble.call(this, u, N);
  }
  function M(N) {
    bubble.call(this, u, N);
  }
  function B(N) {
    bubble.call(this, u, N);
  }
  function j(N) {
    bubble.call(this, u, N);
  }
  function x(N) {
    bubble.call(this, u, N);
  }
  return u.$$set = (N) => {
    "size" in N && f(7, y = N.size), "name" in N && f(0, v = N.name), "hidden" in N && f(1, k = N.hidden), "hoverable" in N && f(2, S = N.hoverable), "disabled" in N && f(3, $ = N.disabled), "color" in N && f(8, w = N.color), "hoverColor" in N && f(9, T = N.hoverColor), "tooltip" in N && f(4, E = N.tooltip), "weight" in N && f(10, R = N.weight);
  }, u.$$.update = () => {
    u.$$.dirty & /*name*/
    1 && f(11, p = getPhosphorIcon(v)), u.$$.dirty & /*weight, phosphorIconName*/
    3072 && f(6, m = `ph ph-${R} ph-${p}`), u.$$.dirty & /*size, color, hoverColor*/
    896 && f(5, b = P(y, w, T));
  }, [
    v,
    k,
    S,
    $,
    E,
    b,
    m,
    y,
    w,
    T,
    R,
    p,
    L,
    M,
    B,
    j,
    x
  ];
}
class InnerIcon extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1G, create_fragment$1I, safe_not_equal, {
      size: 7,
      name: 0,
      hidden: 1,
      hoverable: 2,
      disabled: 3,
      color: 8,
      hoverColor: 9,
      tooltip: 4,
      weight: 10
    });
  }
}
function create_else_block$i(u) {
  let l, f;
  return l = new InnerIcon({
    props: {
      size: (
        /*size*/
        u[0]
      ),
      name: (
        /*name*/
        u[1]
      ),
      hidden: (
        /*hidden*/
        u[2]
      ),
      hoverable: (
        /*hoverable*/
        u[3]
      ),
      disabled: (
        /*disabled*/
        u[4]
      ),
      color: (
        /*color*/
        u[5]
      ),
      hoverColor: (
        /*hoverColor*/
        u[6]
      ),
      weight: (
        /*weight*/
        u[12]
      )
    }
  }), l.$on(
    "contextmenu",
    /*contextmenu_handler_1*/
    u[18]
  ), l.$on(
    "click",
    /*click_handler_1*/
    u[19]
  ), l.$on(
    "mouseover",
    /*mouseover_handler_1*/
    u[20]
  ), l.$on(
    "mouseleave",
    /*mouseleave_handler_1*/
    u[21]
  ), l.$on(
    "focus",
    /*focus_handler_1*/
    u[22]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*size*/
      1 && (b.size = /*size*/
      p[0]), m & /*name*/
      2 && (b.name = /*name*/
      p[1]), m & /*hidden*/
      4 && (b.hidden = /*hidden*/
      p[2]), m & /*hoverable*/
      8 && (b.hoverable = /*hoverable*/
      p[3]), m & /*disabled*/
      16 && (b.disabled = /*disabled*/
      p[4]), m & /*color*/
      32 && (b.color = /*color*/
      p[5]), m & /*hoverColor*/
      64 && (b.hoverColor = /*hoverColor*/
      p[6]), m & /*weight*/
      4096 && (b.weight = /*weight*/
      p[12]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block$S(u) {
  let l, f;
  return l = new AbsTooltip({
    props: {
      text: (
        /*tooltip*/
        u[7]
      ),
      type: (
        /*tooltipType*/
        u[9]
      ),
      position: (
        /*tooltipPosition*/
        u[8]
      ),
      color: (
        /*tooltipColor*/
        u[10]
      ),
      noWrap: (
        /*tooltipWrap*/
        u[11]
      ),
      $$slots: { default: [create_default_slot$O] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*tooltip*/
      128 && (b.text = /*tooltip*/
      p[7]), m & /*tooltipType*/
      512 && (b.type = /*tooltipType*/
      p[9]), m & /*tooltipPosition*/
      256 && (b.position = /*tooltipPosition*/
      p[8]), m & /*tooltipColor*/
      1024 && (b.color = /*tooltipColor*/
      p[10]), m & /*tooltipWrap*/
      2048 && (b.noWrap = /*tooltipWrap*/
      p[11]), m & /*$$scope, size, name, hidden, hoverable, disabled, color, hoverColor, weight*/
      8392831 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot$O(u) {
  let l, f;
  return l = new InnerIcon({
    props: {
      size: (
        /*size*/
        u[0]
      ),
      name: (
        /*name*/
        u[1]
      ),
      hidden: (
        /*hidden*/
        u[2]
      ),
      hoverable: (
        /*hoverable*/
        u[3]
      ),
      disabled: (
        /*disabled*/
        u[4]
      ),
      color: (
        /*color*/
        u[5]
      ),
      hoverColor: (
        /*hoverColor*/
        u[6]
      ),
      weight: (
        /*weight*/
        u[12]
      )
    }
  }), l.$on(
    "contextmenu",
    /*contextmenu_handler*/
    u[13]
  ), l.$on(
    "click",
    /*click_handler*/
    u[14]
  ), l.$on(
    "mouseover",
    /*mouseover_handler*/
    u[15]
  ), l.$on(
    "mouseleave",
    /*mouseleave_handler*/
    u[16]
  ), l.$on(
    "focus",
    /*focus_handler*/
    u[17]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*size*/
      1 && (b.size = /*size*/
      p[0]), m & /*name*/
      2 && (b.name = /*name*/
      p[1]), m & /*hidden*/
      4 && (b.hidden = /*hidden*/
      p[2]), m & /*hoverable*/
      8 && (b.hoverable = /*hoverable*/
      p[3]), m & /*disabled*/
      16 && (b.disabled = /*disabled*/
      p[4]), m & /*color*/
      32 && (b.color = /*color*/
      p[5]), m & /*hoverColor*/
      64 && (b.hoverColor = /*hoverColor*/
      p[6]), m & /*weight*/
      4096 && (b.weight = /*weight*/
      p[12]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$1H(u) {
  let l, f, p, m;
  const b = [create_if_block$S, create_else_block$i], y = [];
  function v(k, S) {
    return (
      /*tooltip*/
      k[7] ? 0 : 1
    );
  }
  return l = v(u), f = y[l] = b[l](u), {
    c() {
      f.c(), p = empty$1();
    },
    m(k, S) {
      y[l].m(k, S), insert(k, p, S), m = !0;
    },
    p(k, [S]) {
      let $ = l;
      l = v(k), l === $ ? y[l].p(k, S) : (group_outros(), transition_out(y[$], 1, 1, () => {
        y[$] = null;
      }), check_outros(), f = y[l], f ? f.p(k, S) : (f = y[l] = b[l](k), f.c()), transition_in(f, 1), f.m(p.parentNode, p));
    },
    i(k) {
      m || (transition_in(f), m = !0);
    },
    o(k) {
      transition_out(f), m = !1;
    },
    d(k) {
      k && detach(p), y[l].d(k);
    }
  };
}
function instance$1F(u, l, f) {
  let { size: p = "M" } = l, { name: m = "plus" } = l, { hidden: b = !1 } = l, { hoverable: y = !1 } = l, { disabled: v = !1 } = l, { color: k = void 0 } = l, { hoverColor: S = void 0 } = l, { tooltip: $ = void 0 } = l, { tooltipPosition: w = TooltipPosition.Bottom } = l, { tooltipType: T = TooltipType.Default } = l, { tooltipColor: E = void 0 } = l, { tooltipWrap: R = !0 } = l, { weight: O = "regular" } = l;
  function P(F) {
    bubble.call(this, u, F);
  }
  function L(F) {
    bubble.call(this, u, F);
  }
  function M(F) {
    bubble.call(this, u, F);
  }
  function B(F) {
    bubble.call(this, u, F);
  }
  function j(F) {
    bubble.call(this, u, F);
  }
  function x(F) {
    bubble.call(this, u, F);
  }
  function N(F) {
    bubble.call(this, u, F);
  }
  function D(F) {
    bubble.call(this, u, F);
  }
  function V(F) {
    bubble.call(this, u, F);
  }
  function W(F) {
    bubble.call(this, u, F);
  }
  return u.$$set = (F) => {
    "size" in F && f(0, p = F.size), "name" in F && f(1, m = F.name), "hidden" in F && f(2, b = F.hidden), "hoverable" in F && f(3, y = F.hoverable), "disabled" in F && f(4, v = F.disabled), "color" in F && f(5, k = F.color), "hoverColor" in F && f(6, S = F.hoverColor), "tooltip" in F && f(7, $ = F.tooltip), "tooltipPosition" in F && f(8, w = F.tooltipPosition), "tooltipType" in F && f(9, T = F.tooltipType), "tooltipColor" in F && f(10, E = F.tooltipColor), "tooltipWrap" in F && f(11, R = F.tooltipWrap), "weight" in F && f(12, O = F.weight);
  }, [
    p,
    m,
    b,
    y,
    v,
    k,
    S,
    $,
    w,
    T,
    E,
    R,
    O,
    P,
    L,
    M,
    B,
    j,
    x,
    N,
    D,
    V,
    W
  ];
}
class Icon extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1F, create_fragment$1H, safe_not_equal, {
      size: 0,
      name: 1,
      hidden: 2,
      hoverable: 3,
      disabled: 4,
      color: 5,
      hoverColor: 6,
      tooltip: 7,
      tooltipPosition: 8,
      tooltipType: 9,
      tooltipColor: 10,
      tooltipWrap: 11,
      weight: 12
    });
  }
}
const TooltipWrapper_svelte_svelte_type_style_lang = "";
function create_if_block$R(u) {
  let l, f, p;
  return f = new AbsTooltip({
    props: {
      text: (
        /*tooltip*/
        u[0]
      ),
      position: (
        /*position*/
        u[3]
      ),
      $$slots: { default: [create_default_slot$N] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "icon-container svelte-19tap7e");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b & /*tooltip*/
      1 && (y.text = /*tooltip*/
      m[0]), b & /*position*/
      8 && (y.position = /*position*/
      m[3]), b & /*$$scope, size, disabled*/
      70 && (y.$$scope = { dirty: b, ctx: m }), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_default_slot$N(u) {
  let l, f, p, m, b;
  return f = new Icon({
    props: {
      name: "info",
      size: "S",
      disabled: (
        /*disabled*/
        u[2]
      ),
      hoverable: !0
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "icon svelte-19tap7e"), toggle_class(
        l,
        "icon-small",
        /*size*/
        u[1] === "M" || /*size*/
        u[1] === "S"
      );
    },
    m(y, v) {
      insert(y, l, v), mount_component(f, l, null), p = !0, m || (b = listen(
        l,
        "focus",
        /*focus_handler*/
        u[5]
      ), m = !0);
    },
    p(y, v) {
      const k = {};
      v & /*disabled*/
      4 && (k.disabled = /*disabled*/
      y[2]), f.$set(k), (!p || v & /*size*/
      2) && toggle_class(
        l,
        "icon-small",
        /*size*/
        y[1] === "M" || /*size*/
        y[1] === "S"
      );
    },
    i(y) {
      p || (transition_in(f.$$.fragment, y), p = !0);
    },
    o(y) {
      transition_out(f.$$.fragment, y), p = !1;
    },
    d(y) {
      y && detach(l), destroy_component(f), m = !1, b();
    }
  };
}
function create_fragment$1G(u) {
  let l, f, p;
  const m = (
    /*#slots*/
    u[4].default
  ), b = create_slot(
    m,
    u,
    /*$$scope*/
    u[6],
    null
  );
  let y = (
    /*tooltip*/
    u[0] && create_if_block$R(u)
  );
  return {
    c() {
      l = element("div"), b && b.c(), f = space(), y && y.c(), attr(l, "class", "svelte-19tap7e"), toggle_class(l, "container", !!/*tooltip*/
      u[0]);
    },
    m(v, k) {
      insert(v, l, k), b && b.m(l, null), append$1(l, f), y && y.m(l, null), p = !0;
    },
    p(v, [k]) {
      b && b.p && (!p || k & /*$$scope*/
      64) && update_slot_base(
        b,
        m,
        v,
        /*$$scope*/
        v[6],
        p ? get_slot_changes(
          m,
          /*$$scope*/
          v[6],
          k,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          v[6]
        ),
        null
      ), /*tooltip*/
      v[0] ? y ? (y.p(v, k), k & /*tooltip*/
      1 && transition_in(y, 1)) : (y = create_if_block$R(v), y.c(), transition_in(y, 1), y.m(l, null)) : y && (group_outros(), transition_out(y, 1, 1, () => {
        y = null;
      }), check_outros()), (!p || k & /*tooltip*/
      1) && toggle_class(l, "container", !!/*tooltip*/
      v[0]);
    },
    i(v) {
      p || (transition_in(b, v), transition_in(y), p = !0);
    },
    o(v) {
      transition_out(b, v), transition_out(y), p = !1;
    },
    d(v) {
      v && detach(l), b && b.d(v), y && y.d();
    }
  };
}
function instance$1E(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l, { tooltip: b = "" } = l, { size: y = "M" } = l, { disabled: v = !0 } = l, { position: k = void 0 } = l;
  function S($) {
    bubble.call(this, u, $);
  }
  return u.$$set = ($) => {
    "tooltip" in $ && f(0, b = $.tooltip), "size" in $ && f(1, y = $.size), "disabled" in $ && f(2, v = $.disabled), "position" in $ && f(3, k = $.position), "$$scope" in $ && f(6, m = $.$$scope);
  }, [b, y, v, k, p, S, m];
}
class TooltipWrapper extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1E, create_fragment$1G, safe_not_equal, {
      tooltip: 0,
      size: 1,
      disabled: 2,
      position: 3
    });
  }
}
const FieldLabel_svelte_svelte_type_style_lang = "";
function create_default_slot$M(u) {
  let l, f = (
    /*label*/
    (u[1] || "") + ""
  ), p, m;
  return {
    c() {
      l = element("label"), p = text$2(f), attr(
        l,
        "for",
        /*forId*/
        u[0]
      ), attr(l, "class", m = null_to_empty(`spectrum-FieldLabel spectrum-FieldLabel--sizeM spectrum-Form-itemLabel ${/*className*/
      u[3]}`) + " svelte-dqoj9e");
    },
    m(b, y) {
      insert(b, l, y), append$1(l, p);
    },
    p(b, y) {
      y & /*label*/
      2 && f !== (f = /*label*/
      (b[1] || "") + "") && set_data(p, f), y & /*forId*/
      1 && attr(
        l,
        "for",
        /*forId*/
        b[0]
      ), y & /*className*/
      8 && m !== (m = null_to_empty(`spectrum-FieldLabel spectrum-FieldLabel--sizeM spectrum-Form-itemLabel ${/*className*/
      b[3]}`) + " svelte-dqoj9e") && attr(l, "class", m);
    },
    d(b) {
      b && detach(l);
    }
  };
}
function create_fragment$1F(u) {
  let l, f;
  return l = new TooltipWrapper({
    props: {
      tooltip: (
        /*tooltip*/
        u[2]
      ),
      size: "S",
      $$slots: { default: [create_default_slot$M] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*tooltip*/
      4 && (b.tooltip = /*tooltip*/
      p[2]), m & /*$$scope, forId, className, label*/
      43 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$1D(u, l, f) {
  let p, { forId: m } = l, { label: b } = l, { position: y = "above" } = l, { tooltip: v = "" } = l;
  return u.$$set = (k) => {
    "forId" in k && f(0, m = k.forId), "label" in k && f(1, b = k.label), "position" in k && f(4, y = k.position), "tooltip" in k && f(2, v = k.tooltip);
  }, u.$$.update = () => {
    u.$$.dirty & /*position*/
    16 && f(3, p = y === "above" ? "" : `spectrum-FieldLabel--${y}`);
  }, [m, b, v, p, y];
}
class FieldLabel extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1D, create_fragment$1F, safe_not_equal, {
      forId: 0,
      label: 1,
      position: 4,
      tooltip: 2
    });
  }
}
const Field_svelte_svelte_type_style_lang = "";
function create_if_block_2$m(u) {
  let l, f;
  return l = new FieldLabel({
    props: {
      forId: (
        /*id*/
        u[0]
      ),
      label: (
        /*label*/
        u[1]
      ),
      position: (
        /*labelPosition*/
        u[2]
      ),
      tooltip: (
        /*tooltip*/
        u[5]
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*id*/
      1 && (b.forId = /*id*/
      p[0]), m & /*label*/
      2 && (b.label = /*label*/
      p[1]), m & /*labelPosition*/
      4 && (b.position = /*labelPosition*/
      p[2]), m & /*tooltip*/
      32 && (b.tooltip = /*tooltip*/
      p[5]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_1$s(u) {
  let l, f, p, m, b, y;
  return f = new Icon({ props: { name: "question" } }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), p = space(), m = element("span"), b = text$2(
        /*helpText*/
        u[4]
      ), attr(m, "class", "svelte-e52e9j"), attr(l, "class", "helpText svelte-e52e9j");
    },
    m(v, k) {
      insert(v, l, k), mount_component(f, l, null), append$1(l, p), append$1(l, m), append$1(m, b), y = !0;
    },
    p(v, k) {
      (!y || k & /*helpText*/
      16) && set_data(
        b,
        /*helpText*/
        v[4]
      );
    },
    i(v) {
      y || (transition_in(f.$$.fragment, v), y = !0);
    },
    o(v) {
      transition_out(f.$$.fragment, v), y = !1;
    },
    d(v) {
      v && detach(l), destroy_component(f);
    }
  };
}
function create_if_block$Q(u) {
  let l, f;
  return {
    c() {
      l = element("div"), f = text$2(
        /*error*/
        u[3]
      ), attr(l, "class", "error svelte-e52e9j");
    },
    m(p, m) {
      insert(p, l, m), append$1(l, f);
    },
    p(p, m) {
      m & /*error*/
      8 && set_data(
        f,
        /*error*/
        p[3]
      );
    },
    i: noop$4,
    o: noop$4,
    d(p) {
      p && detach(l);
    }
  };
}
function create_fragment$1E(u) {
  let l, f, p, m, b, y, v, k = (
    /*label*/
    u[1] && create_if_block_2$m(u)
  );
  const S = (
    /*#slots*/
    u[7].default
  ), $ = create_slot(
    S,
    u,
    /*$$scope*/
    u[6],
    null
  ), w = [create_if_block$Q, create_if_block_1$s], T = [];
  function E(R, O) {
    return (
      /*error*/
      R[3] ? 0 : (
        /*helpText*/
        R[4] ? 1 : -1
      )
    );
  }
  return ~(b = E(u)) && (y = T[b] = w[b](u)), {
    c() {
      l = element("div"), k && k.c(), f = space(), p = element("div"), $ && $.c(), m = space(), y && y.c(), attr(p, "class", "spectrum-Form-itemField svelte-e52e9j"), attr(l, "class", "spectrum-Form-item svelte-e52e9j"), toggle_class(
        l,
        "above",
        /*labelPosition*/
        u[2] === "above"
      );
    },
    m(R, O) {
      insert(R, l, O), k && k.m(l, null), append$1(l, f), append$1(l, p), $ && $.m(p, null), append$1(p, m), ~b && T[b].m(p, null), v = !0;
    },
    p(R, [O]) {
      /*label*/
      R[1] ? k ? (k.p(R, O), O & /*label*/
      2 && transition_in(k, 1)) : (k = create_if_block_2$m(R), k.c(), transition_in(k, 1), k.m(l, f)) : k && (group_outros(), transition_out(k, 1, 1, () => {
        k = null;
      }), check_outros()), $ && $.p && (!v || O & /*$$scope*/
      64) && update_slot_base(
        $,
        S,
        R,
        /*$$scope*/
        R[6],
        v ? get_slot_changes(
          S,
          /*$$scope*/
          R[6],
          O,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          R[6]
        ),
        null
      );
      let P = b;
      b = E(R), b === P ? ~b && T[b].p(R, O) : (y && (group_outros(), transition_out(T[P], 1, 1, () => {
        T[P] = null;
      }), check_outros()), ~b ? (y = T[b], y ? y.p(R, O) : (y = T[b] = w[b](R), y.c()), transition_in(y, 1), y.m(p, null)) : y = null), (!v || O & /*labelPosition*/
      4) && toggle_class(
        l,
        "above",
        /*labelPosition*/
        R[2] === "above"
      );
    },
    i(R) {
      v || (transition_in(k), transition_in($, R), transition_in(y), v = !0);
    },
    o(R) {
      transition_out(k), transition_out($, R), transition_out(y), v = !1;
    },
    d(R) {
      R && detach(l), k && k.d(), $ && $.d(R), ~b && T[b].d();
    }
  };
}
function instance$1C(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l, { id: b = void 0 } = l, { label: y = void 0 } = l, { labelPosition: v = "above" } = l, { error: k = void 0 } = l, { helpText: S = void 0 } = l, { tooltip: $ = void 0 } = l;
  return u.$$set = (w) => {
    "id" in w && f(0, b = w.id), "label" in w && f(1, y = w.label), "labelPosition" in w && f(2, v = w.labelPosition), "error" in w && f(3, k = w.error), "helpText" in w && f(4, S = w.helpText), "tooltip" in w && f(5, $ = w.tooltip), "$$scope" in w && f(6, m = w.$$scope);
  }, [b, y, v, k, S, $, m, p];
}
class Field extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1C, create_fragment$1E, safe_not_equal, {
      id: 0,
      label: 1,
      labelPosition: 2,
      error: 3,
      helpText: 4,
      tooltip: 5
    });
  }
}
const indexVars$C = "", indexVars$B = "", Checkbox_svelte_svelte_type_style_lang = "";
function create_if_block_2$l(u) {
  let l, f, p;
  return f = new Icon({
    props: {
      name: "check",
      weight: "bold",
      color: "var(--spectrum-global-color-gray-50)"
    }
  }), {
    c() {
      l = element("span"), create_component(f.$$.fragment), attr(l, "class", "icon svelte-19fatlf");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block_1$r(u) {
  let l, f, p;
  return f = new Icon({
    props: {
      name: "minus",
      weight: "bold",
      color: "var(--spectrum-global-color-gray-50)"
    }
  }), {
    c() {
      l = element("span"), create_component(f.$$.fragment), attr(l, "class", "icon svelte-19fatlf");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block$P(u) {
  let l, f;
  return {
    c() {
      l = element("span"), f = text$2(
        /*text*/
        u[2]
      ), attr(l, "class", "spectrum-Checkbox-label");
    },
    m(p, m) {
      insert(p, l, m), append$1(l, f);
    },
    p(p, m) {
      m & /*text*/
      4 && set_data(
        f,
        /*text*/
        p[2]
      );
    },
    d(p) {
      p && detach(l);
    }
  };
}
function create_fragment$1D(u) {
  let l, f, p, m, b, y, v, k, S, $, w, T;
  const E = [create_if_block_1$r, create_if_block_2$l], R = [];
  function O(L, M) {
    return (
      /*indeterminate*/
      L[5] ? 0 : (
        /*value*/
        L[0] ? 1 : -1
      )
    );
  }
  ~(y = O(u)) && (v = R[y] = E[y](u));
  let P = (
    /*text*/
    u[2] && create_if_block$P(u)
  );
  return {
    c() {
      l = element("label"), f = element("input"), m = space(), b = element("span"), v && v.c(), k = space(), P && P.c(), f.checked = p = /*value*/
      u[0] || /*indeterminate*/
      u[5], f.disabled = /*disabled*/
      u[3], attr(f, "type", "checkbox"), attr(f, "class", "spectrum-Checkbox-input svelte-19fatlf"), attr(
        f,
        "id",
        /*id*/
        u[1]
      ), attr(b, "class", "spectrum-Checkbox-box"), attr(l, "class", S = "spectrum-Checkbox " + /*sizeClass*/
      u[6] + " svelte-19fatlf"), toggle_class(l, "spectrum-Checkbox--emphasized", !/*disabled*/
      u[3]), toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        u[3]
      ), toggle_class(
        l,
        "readonly",
        /*readonly*/
        u[4]
      );
    },
    m(L, M) {
      insert(L, l, M), append$1(l, f), append$1(l, m), append$1(l, b), ~y && R[y].m(b, null), append$1(l, k), P && P.m(l, null), $ = !0, w || (T = listen(
        f,
        "change",
        /*onChange*/
        u[7]
      ), w = !0);
    },
    p(L, [M]) {
      (!$ || M & /*value, indeterminate*/
      33 && p !== (p = /*value*/
      L[0] || /*indeterminate*/
      L[5])) && (f.checked = p), (!$ || M & /*disabled*/
      8) && (f.disabled = /*disabled*/
      L[3]), (!$ || M & /*id*/
      2) && attr(
        f,
        "id",
        /*id*/
        L[1]
      );
      let B = y;
      y = O(L), y !== B && (v && (group_outros(), transition_out(R[B], 1, 1, () => {
        R[B] = null;
      }), check_outros()), ~y ? (v = R[y], v || (v = R[y] = E[y](L), v.c()), transition_in(v, 1), v.m(b, null)) : v = null), /*text*/
      L[2] ? P ? P.p(L, M) : (P = create_if_block$P(L), P.c(), P.m(l, null)) : P && (P.d(1), P = null), (!$ || M & /*sizeClass*/
      64 && S !== (S = "spectrum-Checkbox " + /*sizeClass*/
      L[6] + " svelte-19fatlf")) && attr(l, "class", S), (!$ || M & /*sizeClass, disabled*/
      72) && toggle_class(l, "spectrum-Checkbox--emphasized", !/*disabled*/
      L[3]), (!$ || M & /*sizeClass, disabled*/
      72) && toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        L[3]
      ), (!$ || M & /*sizeClass, readonly*/
      80) && toggle_class(
        l,
        "readonly",
        /*readonly*/
        L[4]
      );
    },
    i(L) {
      $ || (transition_in(v), $ = !0);
    },
    o(L) {
      transition_out(v), $ = !1;
    },
    d(L) {
      L && detach(l), ~y && R[y].d(), P && P.d(), w = !1, T();
    }
  };
}
function instance$1B(u, l, f) {
  let p, { value: m = !1 } = l, { id: b = void 0 } = l, { text: y = void 0 } = l, { disabled: v = !1 } = l, { readonly: k = !1 } = l, { size: S = "M" } = l, { indeterminate: $ = !1 } = l;
  const w = createEventDispatcher(), T = (E) => {
    w("change", E.currentTarget.checked);
  };
  return u.$$set = (E) => {
    "value" in E && f(0, m = E.value), "id" in E && f(1, b = E.id), "text" in E && f(2, y = E.text), "disabled" in E && f(3, v = E.disabled), "readonly" in E && f(4, k = E.readonly), "size" in E && f(8, S = E.size), "indeterminate" in E && f(5, $ = E.indeterminate);
  }, u.$$.update = () => {
    u.$$.dirty & /*size*/
    256 && f(6, p = `spectrum-Checkbox--size${S}`);
  }, [m, b, y, v, k, $, p, T, S];
}
class Checkbox extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1B, create_fragment$1D, safe_not_equal, {
      value: 0,
      id: 1,
      text: 2,
      disabled: 3,
      readonly: 4,
      size: 8,
      indeterminate: 5
    });
  }
}
function create_default_slot$L(u) {
  let l, f;
  return l = new Checkbox({
    props: {
      disabled: (
        /*disabled*/
        u[5]
      ),
      text: (
        /*text*/
        u[4]
      ),
      value: (
        /*value*/
        u[0]
      ),
      size: (
        /*size*/
        u[7]
      ),
      indeterminate: (
        /*indeterminate*/
        u[1]
      )
    }
  }), l.$on(
    "change",
    /*onChange*/
    u[9]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*disabled*/
      32 && (b.disabled = /*disabled*/
      p[5]), m & /*text*/
      16 && (b.text = /*text*/
      p[4]), m & /*value*/
      1 && (b.value = /*value*/
      p[0]), m & /*size*/
      128 && (b.size = /*size*/
      p[7]), m & /*indeterminate*/
      2 && (b.indeterminate = /*indeterminate*/
      p[1]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$1C(u) {
  let l, f;
  return l = new Field({
    props: {
      helpText: (
        /*helpText*/
        u[8]
      ),
      label: (
        /*label*/
        u[2]
      ),
      labelPosition: (
        /*labelPosition*/
        u[3]
      ),
      error: (
        /*error*/
        u[6]
      ),
      $$slots: { default: [create_default_slot$L] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*helpText*/
      256 && (b.helpText = /*helpText*/
      p[8]), m & /*label*/
      4 && (b.label = /*label*/
      p[2]), m & /*labelPosition*/
      8 && (b.labelPosition = /*labelPosition*/
      p[3]), m & /*error*/
      64 && (b.error = /*error*/
      p[6]), m & /*$$scope, disabled, text, value, size, indeterminate*/
      2227 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$1A(u, l, f) {
  let { value: p = void 0 } = l, { indeterminate: m = void 0 } = l, { label: b = void 0 } = l, { labelPosition: y = "above" } = l, { text: v = void 0 } = l, { disabled: k = !1 } = l, { error: S = void 0 } = l, { size: $ = "M" } = l, { helpText: w = void 0 } = l;
  const T = createEventDispatcher(), E = (R) => {
    f(0, p = R.detail), T("change", R.detail);
  };
  return u.$$set = (R) => {
    "value" in R && f(0, p = R.value), "indeterminate" in R && f(1, m = R.indeterminate), "label" in R && f(2, b = R.label), "labelPosition" in R && f(3, y = R.labelPosition), "text" in R && f(4, v = R.text), "disabled" in R && f(5, k = R.disabled), "error" in R && f(6, S = R.error), "size" in R && f(7, $ = R.size), "helpText" in R && f(8, w = R.helpText);
  }, [
    p,
    m,
    b,
    y,
    v,
    k,
    S,
    $,
    w,
    E
  ];
}
class Checkbox_1 extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1A, create_fragment$1C, safe_not_equal, {
      value: 0,
      indeterminate: 1,
      label: 2,
      labelPosition: 3,
      text: 4,
      disabled: 5,
      error: 6,
      size: 7,
      helpText: 8
    });
  }
}
const indexVars$A = "", indexVars$z = "", indexVars$y = "", ignoredClasses = [
  ".download-js-link",
  ".spectrum-Menu",
  ".date-time-popover"
], conditionallyIgnoredClasses = [
  ".spectrum-Underlay",
  ".drawer-wrapper",
  ".spectrum-Popover"
];
let clickHandlers = [], candidateTarget;
const handleClick = (u) => {
  const l = u.target || u.relatedTarget;
  if (!l.closest('[data-ignore-click-outside="true"]')) {
    for (let f of ignoredClasses)
      if (l.closest(f))
        return;
    clickHandlers.forEach((f) => {
      var p;
      if (!f.element.contains(l)) {
        for (let m of conditionallyIgnoredClasses) {
          const b = f.anchor.closest(m) != null;
          if (l.closest(m) != null && !b)
            return;
        }
        (p = f.callback) == null || p.call(f, u);
      }
    });
  }
}, handleMouseUp = (u) => {
  candidateTarget === u.target && handleClick(u), candidateTarget = void 0;
}, handleMouseDown = (u) => {
  u.button === 0 && (candidateTarget = u.target, document.removeEventListener("click", handleMouseUp), document.addEventListener("click", handleMouseUp, !0));
}, handleBlur = () => {
  document.activeElement && ["IFRAME", "BODY"].includes(document.activeElement.tagName) && handleClick(
    new MouseEvent("click", { relatedTarget: document.activeElement })
  );
};
document.addEventListener("mousedown", handleMouseDown);
document.addEventListener("contextmenu", handleClick);
window.addEventListener("blur", handleBlur);
const updateHandler = (u, l, f, p) => {
  let m = clickHandlers.find((b) => b.id === u);
  m ? m.callback = p : clickHandlers.push({ id: u, element: l, anchor: f, callback: p });
}, removeHandler = (u) => {
  clickHandlers = clickHandlers.filter((l) => l.id !== u);
}, clickOutside = (u, l) => {
  const f = Math.random(), p = (y) => typeof y == "function", m = (y) => y != null && typeof y == "object", b = (y) => {
    let v, k = u;
    p(y) ? v = y : m(y) && (v = y.callback, y.anchor && (k = y.anchor)), updateHandler(f, u, k, v);
  };
  return b(l), {
    update: b,
    destroy: () => removeHandler(f)
  };
};
function positionDropdown(u, l) {
  let f, p = l;
  const m = () => b(p), b = (v) => {
    const {
      anchor: k,
      align: S,
      maxHeight: $,
      maxWidth: w,
      minWidth: T,
      useAnchorWidth: E,
      offset: R = 5,
      customUpdate: O,
      resizable: P,
      wrap: L
    } = v;
    if (!k)
      return;
    const M = k.getBoundingClientRect(), B = u.getBoundingClientRect(), j = window.innerWidth, x = window.innerHeight, N = 8;
    let D = {
      maxHeight: $,
      minWidth: E ? M.width : T,
      maxWidth: E ? M.width : w,
      left: 0,
      top: 0
    };
    if (typeof O == "function")
      D = O(M, B, {
        ...D,
        offset: v.offset
      });
    else {
      const V = () => D.left + B.width > j && M.left > j - M.right, W = () => D.top + B.height > x && M.top > x - M.bottom, F = (q) => {
        !D.maxHeight && P && (D.maxHeight = q);
      }, U = (q) => {
        switch (q) {
          case "StartToStart":
          default:
            D.left = M.left;
            break;
          case "EndToEnd":
            D.left = M.right - B.width;
            break;
          case "StartToEnd":
            D.left = M.right + R;
            break;
          case "EndToStart":
            D.left = M.left - B.width - R;
            break;
          case "MidPoint":
            D.left = M.left + M.width / 2 - B.width / 2;
            break;
          case "ScreenEdge":
            D.left = j - B.width - N;
            break;
        }
      }, Y = (q) => {
        switch (q) {
          case "StartToStart":
            D.top = M.top, F(x - M.top - N);
            break;
          case "EndToEnd":
            D.top = M.bottom - B.height, F(M.bottom - N);
            break;
          case "StartToEnd":
          default:
            D.top = M.bottom + R, F(x - M.bottom - N);
            break;
          case "EndToStart":
            D.top = M.top - B.height - R, F(M.top - N);
            break;
          case "MidPoint":
            D.top = M.top + M.height / 2 - B.height / 2;
            break;
          case "ScreenEdge":
            D.top = x - B.height - N, F(x - 2 * N);
            break;
        }
      };
      S === PopoverAlignment.Right ? U("EndToEnd") : S === PopoverAlignment.RightOutside || S === PopoverAlignment.RightContextMenu ? U("StartToEnd") : S === PopoverAlignment.LeftOutside || S === PopoverAlignment.LeftContextMenu ? U("EndToStart") : S === PopoverAlignment.Center ? U("MidPoint") : U("StartToStart"), S === PopoverAlignment.RightOutside || S === PopoverAlignment.LeftOutside ? Y("MidPoint") : S === PopoverAlignment.RightContextMenu || S === PopoverAlignment.LeftContextMenu ? (Y("StartToStart"), D.top && (D.top -= 5)) : Y("StartToEnd"), V() && (S === PopoverAlignment.Left ? U("EndToEnd") : S === PopoverAlignment.RightOutside && U("EndToStart")), W() && (L ? (Y("MidPoint"), W() && Y("ScreenEdge"), U("StartToEnd"), V() && U("EndToStart")) : S === PopoverAlignment.LeftOutside || S === PopoverAlignment.RightOutside ? Y("ScreenEdge") : Y("EndToStart"));
    }
    for (const [V, W] of Object.entries(D)) {
      const F = V;
      W != null ? u.style[F] = `${W}px` : u.style[F] = "";
    }
  }, y = (v) => {
    p = v, f && f.disconnect();
    const { anchor: k } = v;
    k && (f = new ResizeObserver(() => b(v)), f.observe(k), f.observe(u), f.observe(document.body));
  };
  return u.style.position = "fixed", u.style.zIndex = "9999", document.addEventListener("scroll", m, !0), y(l), {
    update: y,
    destroy() {
      f && f.disconnect(), document.removeEventListener("scroll", m, !0);
    }
  };
}
const Context$1 = {
  Modal: "bbui-modal",
  PopoverRoot: "bbui-popover-root"
}, Popover_svelte_svelte_type_style_lang = "";
function create_if_block$O(u) {
  let l, f;
  return l = new Portal({
    props: {
      target: (
        /*target*/
        u[18]
      ),
      $$slots: { default: [create_default_slot$K] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*target*/
      262144 && (b.target = /*target*/
      p[18]), m[0] & /*$$scope, customHeight, customZIndex, borderRadius, animate, anchor, align, maxHeight, maxWidth, minWidth, useAnchorWidth, offset, handlePositionUpdate, resizable, wrap, dismissible, showPopover, blockPointerEvents*/
      1074003966 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot$K(u) {
  let l, f, p, m, b, y, v, k;
  const S = (
    /*#slots*/
    u[27].default
  ), $ = create_slot(
    S,
    u,
    /*$$scope*/
    u[30],
    null
  );
  return {
    c() {
      l = element("div"), $ && $.c(), attr(l, "tabindex", "0"), attr(l, "class", "spectrum-Popover is-open svelte-z8qspy"), attr(l, "role", "presentation"), attr(l, "style", f = "height: " + /*customHeight*/
      u[10] + "; --customZIndex: " + /*customZIndex*/
      u[12] + "; " + /*borderRadius*/
      (u[6] ? `border-radius: ${/*borderRadius*/
      u[6]}` : "")), toggle_class(
        l,
        "customZIndex",
        /*customZIndex*/
        u[12]
      ), toggle_class(l, "hidden", !/*showPopover*/
      u[14]), toggle_class(
        l,
        "blockPointerEvents",
        /*blockPointerEvents*/
        u[17]
      );
    },
    m(w, T) {
      insert(w, l, T), $ && $.m(l, null), y = !0, v || (k = [
        action_destroyer(p = positionDropdown.call(null, l, {
          anchor: (
            /*anchor*/
            u[1]
          ),
          align: (
            /*align*/
            u[2]
          ),
          maxHeight: (
            /*maxHeight*/
            u[5]
          ),
          maxWidth: (
            /*maxWidth*/
            u[4]
          ),
          minWidth: (
            /*minWidth*/
            u[3]
          ),
          useAnchorWidth: (
            /*useAnchorWidth*/
            u[7]
          ),
          offset: (
            /*offset*/
            u[9]
          ),
          customUpdate: (
            /*handlePositionUpdate*/
            u[13]
          ),
          resizable: (
            /*resizable*/
            u[15]
          ),
          wrap: (
            /*wrap*/
            u[16]
          )
        })),
        action_destroyer(m = clickOutside.call(null, l, {
          callback: (
            /*dismissible*/
            u[8] ? (
              /*handleOutsideClick*/
              u[19]
            ) : clickOutside_function
          ),
          anchor: (
            /*anchor*/
            u[1]
          )
        })),
        listen(
          l,
          "keydown",
          /*handleEscape*/
          u[20]
        ),
        listen(
          l,
          "mouseenter",
          /*mouseenter_handler*/
          u[28]
        ),
        listen(
          l,
          "mouseleave",
          /*mouseleave_handler*/
          u[29]
        )
      ], v = !0);
    },
    p(w, T) {
      u = w, $ && $.p && (!y || T[0] & /*$$scope*/
      1073741824) && update_slot_base(
        $,
        S,
        u,
        /*$$scope*/
        u[30],
        y ? get_slot_changes(
          S,
          /*$$scope*/
          u[30],
          T,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          u[30]
        ),
        null
      ), (!y || T[0] & /*customHeight, customZIndex, borderRadius*/
      5184 && f !== (f = "height: " + /*customHeight*/
      u[10] + "; --customZIndex: " + /*customZIndex*/
      u[12] + "; " + /*borderRadius*/
      (u[6] ? `border-radius: ${/*borderRadius*/
      u[6]}` : ""))) && attr(l, "style", f), p && is_function(p.update) && T[0] & /*anchor, align, maxHeight, maxWidth, minWidth, useAnchorWidth, offset, handlePositionUpdate, resizable, wrap*/
      107198 && p.update.call(null, {
        anchor: (
          /*anchor*/
          u[1]
        ),
        align: (
          /*align*/
          u[2]
        ),
        maxHeight: (
          /*maxHeight*/
          u[5]
        ),
        maxWidth: (
          /*maxWidth*/
          u[4]
        ),
        minWidth: (
          /*minWidth*/
          u[3]
        ),
        useAnchorWidth: (
          /*useAnchorWidth*/
          u[7]
        ),
        offset: (
          /*offset*/
          u[9]
        ),
        customUpdate: (
          /*handlePositionUpdate*/
          u[13]
        ),
        resizable: (
          /*resizable*/
          u[15]
        ),
        wrap: (
          /*wrap*/
          u[16]
        )
      }), m && is_function(m.update) && T[0] & /*dismissible, anchor*/
      258 && m.update.call(null, {
        callback: (
          /*dismissible*/
          u[8] ? (
            /*handleOutsideClick*/
            u[19]
          ) : clickOutside_function
        ),
        anchor: (
          /*anchor*/
          u[1]
        )
      }), (!y || T[0] & /*customZIndex*/
      4096) && toggle_class(
        l,
        "customZIndex",
        /*customZIndex*/
        u[12]
      ), (!y || T[0] & /*showPopover*/
      16384) && toggle_class(l, "hidden", !/*showPopover*/
      u[14]), (!y || T[0] & /*blockPointerEvents*/
      131072) && toggle_class(
        l,
        "blockPointerEvents",
        /*blockPointerEvents*/
        u[17]
      );
    },
    i(w) {
      y || (transition_in($, w), w && add_render_callback(() => {
        y && (b || (b = create_bidirectional_transition(
          l,
          fly,
          {
            y: -20,
            duration: (
              /*animate*/
              u[11] ? animationDuration : 0
            )
          },
          !0
        )), b.run(1));
      }), y = !0);
    },
    o(w) {
      transition_out($, w), w && (b || (b = create_bidirectional_transition(
        l,
        fly,
        {
          y: -20,
          duration: (
            /*animate*/
            u[11] ? animationDuration : 0
          )
        },
        !1
      )), b.run(0)), y = !1;
    },
    d(w) {
      w && detach(l), $ && $.d(w), w && b && b.end(), v = !1, run_all(k);
    }
  };
}
function create_fragment$1B(u) {
  let l, f, p = (
    /*open*/
    u[0] && create_if_block$O(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, b) {
      /*open*/
      m[0] ? p ? (p.p(m, b), b[0] & /*open*/
      1 && transition_in(p, 1)) : (p = create_if_block$O(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
const animationDuration = 260, clickOutside_function = () => {
};
function instance$1z(u, l, f) {
  let p, { $$slots: m = {}, $$scope: b } = l, { anchor: y } = l, { align: v = PopoverAlignment.Right } = l, { portalTarget: k = void 0 } = l, { minWidth: S = void 0 } = l, { maxWidth: $ = void 0 } = l, { maxHeight: w = void 0 } = l, { borderRadius: T = void 0 } = l, { open: E = !1 } = l, { useAnchorWidth: R = !1 } = l, { dismissible: O = !0 } = l, { offset: P = 4 } = l, { customHeight: L = void 0 } = l, { animate: M = !0 } = l, { customZIndex: B = void 0 } = l, { handlePositionUpdate: j = void 0 } = l, { showPopover: x = !0 } = l, { clickOutsideOverride: N = !1 } = l, { resizable: D = !0 } = l, { wrap: V = !1 } = l;
  const W = createEventDispatcher();
  let F, U = !1;
  const Y = () => {
    W("open"), f(0, E = !0);
  }, q = () => {
    W("close"), f(0, E = !1);
  }, Q = () => {
    E ? q() : Y();
  }, z = (oe) => {
    if (!N && E) {
      let ee = oe.target, ie = !1;
      for (; !ie && ee && ee.parentNode; )
        ie = ee === y, ee = ee.parentNode;
      ie && oe.stopPropagation(), q();
    }
  }, H = (oe) => {
    N && E && oe.key === "Escape" && q();
  };
  onDestroy(() => {
    clearTimeout(F);
  });
  function X(oe) {
    bubble.call(this, u, oe);
  }
  function Z(oe) {
    bubble.call(this, u, oe);
  }
  return u.$$set = (oe) => {
    "anchor" in oe && f(1, y = oe.anchor), "align" in oe && f(2, v = oe.align), "portalTarget" in oe && f(21, k = oe.portalTarget), "minWidth" in oe && f(3, S = oe.minWidth), "maxWidth" in oe && f(4, $ = oe.maxWidth), "maxHeight" in oe && f(5, w = oe.maxHeight), "borderRadius" in oe && f(6, T = oe.borderRadius), "open" in oe && f(0, E = oe.open), "useAnchorWidth" in oe && f(7, R = oe.useAnchorWidth), "dismissible" in oe && f(8, O = oe.dismissible), "offset" in oe && f(9, P = oe.offset), "customHeight" in oe && f(10, L = oe.customHeight), "animate" in oe && f(11, M = oe.animate), "customZIndex" in oe && f(12, B = oe.customZIndex), "handlePositionUpdate" in oe && f(13, j = oe.handlePositionUpdate), "showPopover" in oe && f(14, x = oe.showPopover), "clickOutsideOverride" in oe && f(22, N = oe.clickOutsideOverride), "resizable" in oe && f(15, D = oe.resizable), "wrap" in oe && f(16, V = oe.wrap), "$$scope" in oe && f(30, b = oe.$$scope);
  }, u.$$.update = () => {
    u.$$.dirty[0] & /*portalTarget*/
    2097152 && f(18, p = k || getContext$1(Context$1.PopoverRoot) || ".spectrum"), u.$$.dirty[0] & /*open, animate, timeout*/
    67110913 && E && M && (f(17, U = !0), clearTimeout(F), f(26, F = setTimeout(
      () => {
        f(17, U = !1);
      },
      animationDuration / 2
    )));
  }, [
    E,
    y,
    v,
    S,
    $,
    w,
    T,
    R,
    O,
    P,
    L,
    M,
    B,
    j,
    x,
    D,
    V,
    U,
    p,
    z,
    H,
    k,
    N,
    Y,
    q,
    Q,
    F,
    m,
    X,
    Z,
    b
  ];
}
class Popover extends SvelteComponent {
  constructor(l) {
    super(), init$1(
      this,
      l,
      instance$1z,
      create_fragment$1B,
      safe_not_equal,
      {
        anchor: 1,
        align: 2,
        portalTarget: 21,
        minWidth: 3,
        maxWidth: 4,
        maxHeight: 5,
        borderRadius: 6,
        open: 0,
        useAnchorWidth: 7,
        dismissible: 8,
        offset: 9,
        customHeight: 10,
        animate: 11,
        customZIndex: 12,
        handlePositionUpdate: 13,
        showPopover: 14,
        clickOutsideOverride: 22,
        resizable: 15,
        wrap: 16,
        show: 23,
        hide: 24,
        toggle: 25
      },
      null,
      [-1, -1]
    );
  }
  get show() {
    return this.$$.ctx[23];
  }
  get hide() {
    return this.$$.ctx[24];
  }
  get toggle() {
    return this.$$.ctx[25];
  }
}
const Combobox_svelte_svelte_type_style_lang = "", indexVars$x = "", indexVars$w = "", DateInput_svelte_svelte_type_style_lang = "", NumberInput_svelte_svelte_type_style_lang = "";
function create_fragment$1A(u) {
  let l, f, p;
  return {
    c() {
      l = element("input"), attr(
        l,
        "type",
        /*type*/
        u[4]
      ), attr(
        l,
        "style",
        /*style*/
        u[5]
      ), l.value = /*value*/
      u[0], attr(
        l,
        "min",
        /*min*/
        u[1]
      ), attr(
        l,
        "max",
        /*max*/
        u[2]
      ), attr(l, "class", "svelte-zyjkwa"), toggle_class(
        l,
        "hide-arrows",
        /*hideArrows*/
        u[3]
      );
    },
    m(m, b) {
      insert(m, l, b), f || (p = [
        listen(
          l,
          "click",
          /*selectAll*/
          u[6]
        ),
        listen(
          l,
          "change",
          /*change_handler*/
          u[8]
        ),
        listen(
          l,
          "input",
          /*input_handler*/
          u[9]
        )
      ], f = !0);
    },
    p(m, [b]) {
      b & /*type*/
      16 && attr(
        l,
        "type",
        /*type*/
        m[4]
      ), b & /*style*/
      32 && attr(
        l,
        "style",
        /*style*/
        m[5]
      ), b & /*value*/
      1 && l.value !== /*value*/
      m[0] && (l.value = /*value*/
      m[0]), b & /*min*/
      2 && attr(
        l,
        "min",
        /*min*/
        m[1]
      ), b & /*max*/
      4 && attr(
        l,
        "max",
        /*max*/
        m[2]
      ), b & /*hideArrows*/
      8 && toggle_class(
        l,
        "hide-arrows",
        /*hideArrows*/
        m[3]
      );
    },
    i: noop$4,
    o: noop$4,
    d(m) {
      m && detach(l), f = !1, run_all(p);
    }
  };
}
function instance$1y(u, l, f) {
  let p, { value: m } = l, { min: b } = l, { max: y } = l, { hideArrows: v = !1 } = l, { width: k } = l, { type: S = "number" } = l;
  const $ = (E) => E.target.select();
  function w(E) {
    bubble.call(this, u, E);
  }
  function T(E) {
    bubble.call(this, u, E);
  }
  return u.$$set = (E) => {
    "value" in E && f(0, m = E.value), "min" in E && f(1, b = E.min), "max" in E && f(2, y = E.max), "hideArrows" in E && f(3, v = E.hideArrows), "width" in E && f(7, k = E.width), "type" in E && f(4, S = E.type);
  }, u.$$.update = () => {
    u.$$.dirty & /*width*/
    128 && f(5, p = k ? `width:${k}px;` : "");
  }, [
    m,
    b,
    y,
    v,
    S,
    p,
    $,
    k,
    w,
    T
  ];
}
class NumberInput extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1y, create_fragment$1A, safe_not_equal, {
      value: 0,
      min: 1,
      max: 2,
      hideArrows: 3,
      width: 7,
      type: 4
    });
  }
}
const TimePicker_svelte_svelte_type_style_lang = "";
function create_fragment$1z(u) {
  let l, f, p;
  return f = new NumberInput({
    props: {
      hideArrows: !0,
      type: "time",
      value: (
        /*displayValue*/
        u[0]
      )
    }
  }), f.$on(
    "input",
    /*handleChange*/
    u[1]
  ), f.$on(
    "change",
    /*handleChange*/
    u[1]
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "time-picker svelte-60qev7");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, [b]) {
      const y = {};
      b & /*displayValue*/
      1 && (y.value = /*displayValue*/
      m[0]), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function instance$1x(u, l, f) {
  let p, { value: m } = l;
  const b = createEventDispatcher(), y = (v) => {
    if (!v.target.value) {
      b("change", void 0);
      return;
    }
    const [k, S] = v.target.value.split(":").map(($) => parseInt($));
    b("change", (m || dayjs()).hour(k).minute(S));
  };
  return u.$$set = (v) => {
    "value" in v && f(2, m = v.value);
  }, u.$$.update = () => {
    u.$$.dirty & /*value*/
    4 && f(0, p = m == null ? void 0 : m.format("HH:mm"));
  }, [p, y, m];
}
class TimePicker extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1x, create_fragment$1z, safe_not_equal, { value: 2 });
  }
}
const cleanInput = ({ max: u, pad: l, fallback: f }) => (p) => {
  const m = p.target;
  if (m.value) {
    const b = parseInt(m.value);
    isNaN(b) ? m.value = f : m.value = Math.min(u, b).toString().padStart(l, "0");
  } else
    m.value = f;
}, indexVars$v = "", indexVars$u = "";
function create_fragment$1y(u) {
  let l, f, p, m, b, y, v, k, S, $, w, T, E, R;
  return {
    c() {
      l = element("div"), f = element("div"), p = space(), m = element("div"), b = element("div"), y = element("div"), v = element("div"), k = space(), S = element("div"), $ = element("div"), w = element("div"), attr(f, "class", "spectrum-ProgressCircle-track"), attr(v, "class", "spectrum-ProgressCircle-fill"), attr(y, "class", "spectrum-ProgressCircle-fillSubMask1"), attr(
        y,
        "style",
        /*subMask1Style*/
        u[3]
      ), attr(b, "class", "spectrum-ProgressCircle-fillMask1"), attr(w, "class", "spectrum-ProgressCircle-fill"), attr($, "class", "spectrum-ProgressCircle-fillSubMask2"), attr(
        $,
        "style",
        /*subMask2Style*/
        u[4]
      ), attr(S, "class", "spectrum-ProgressCircle-fillMask2"), attr(m, "class", "spectrum-ProgressCircle-fills"), attr(l, "class", T = "spectrum-ProgressCircle spectrum-ProgressCircle--" + convertSize(
        /*size*/
        u[0]
      )), toggle_class(
        l,
        "spectrum-ProgressCircle--indeterminate",
        /*value*/
        u[1] == null
      ), toggle_class(
        l,
        "spectrum-ProgressCircle--overBackground",
        /*overBackground*/
        u[2]
      );
    },
    m(O, P) {
      insert(O, l, P), append$1(l, f), append$1(l, p), append$1(l, m), append$1(m, b), append$1(b, y), append$1(y, v), append$1(m, k), append$1(m, S), append$1(S, $), append$1($, w), E || (R = listen(
        l,
        "click",
        /*click_handler*/
        u[7]
      ), E = !0);
    },
    p(O, [P]) {
      P & /*subMask1Style*/
      8 && attr(
        y,
        "style",
        /*subMask1Style*/
        O[3]
      ), P & /*subMask2Style*/
      16 && attr(
        $,
        "style",
        /*subMask2Style*/
        O[4]
      ), P & /*size*/
      1 && T !== (T = "spectrum-ProgressCircle spectrum-ProgressCircle--" + convertSize(
        /*size*/
        O[0]
      )) && attr(l, "class", T), P & /*size, value*/
      3 && toggle_class(
        l,
        "spectrum-ProgressCircle--indeterminate",
        /*value*/
        O[1] == null
      ), P & /*size, overBackground*/
      5 && toggle_class(
        l,
        "spectrum-ProgressCircle--overBackground",
        /*overBackground*/
        O[2]
      );
    },
    i: noop$4,
    o: noop$4,
    d(O) {
      O && detach(l), E = !1, R();
    }
  };
}
function convertSize(u) {
  switch (u) {
    case "S":
      return "small";
    case "L":
      return "large";
    default:
      return;
  }
}
function instance$1w(u, l, f) {
  let { size: p = "M" } = l, { value: m = null } = l, { minValue: b = 0 } = l, { maxValue: y = 100 } = l, v, k;
  function S(T) {
    if (T) {
      let E = (T - b) / (y - b) * 100, R;
      E > 0 && E <= 50 ? (R = -180 + E / 50 * 180, f(3, v = `transform: rotate(${R}deg);`), f(4, k = "transform: rotate(-180deg);")) : E > 50 && (R = -180 + (E - 50) / 50 * 180, f(3, v = "transform: rotate(0deg);"), f(4, k = `transform: rotate(${R}deg);`));
    }
  }
  let { overBackground: $ = !1 } = l;
  function w(T) {
    bubble.call(this, u, T);
  }
  return u.$$set = (T) => {
    "size" in T && f(0, p = T.size), "value" in T && f(1, m = T.value), "minValue" in T && f(5, b = T.minValue), "maxValue" in T && f(6, y = T.maxValue), "overBackground" in T && f(2, $ = T.overBackground);
  }, u.$$.update = () => {
    u.$$.dirty & /*value*/
    2 && S(m);
  }, [
    p,
    m,
    $,
    v,
    k,
    b,
    y,
    w
  ];
}
class ProgressCircle extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1w, create_fragment$1y, safe_not_equal, {
      size: 0,
      value: 1,
      minValue: 5,
      maxValue: 6,
      overBackground: 2
    });
  }
}
const indexVars$t = "", StatusLight_svelte_svelte_type_style_lang = "";
function create_fragment$1x(u) {
  let l, f, p, m, b, y;
  const v = (
    /*#slots*/
    u[21].default
  ), k = create_slot(
    v,
    u,
    /*$$scope*/
    u[20],
    null
  );
  return {
    c() {
      l = element("div"), k && k.c(), attr(l, "class", f = "spectrum-StatusLight spectrum-StatusLight--size" + /*size*/
      u[0] + " svelte-1wk2ay6"), attr(l, "style", p = `--color: ${/*color*/
      u[16] ?? "var(--spectrum-global-color-gray-400)"};`), toggle_class(l, "custom", !!/*color*/
      u[16]), toggle_class(
        l,
        "square",
        /*square*/
        u[17]
      ), toggle_class(
        l,
        "hoverable",
        /*hoverable*/
        u[18]
      ), toggle_class(
        l,
        "spectrum-StatusLight--celery",
        /*celery*/
        u[1]
      ), toggle_class(
        l,
        "spectrum-StatusLight--yellow",
        /*yellow*/
        u[2]
      ), toggle_class(
        l,
        "spectrum-StatusLight--fuchsia",
        /*fuchsia*/
        u[3]
      ), toggle_class(
        l,
        "spectrum-StatusLight--indigo",
        /*indigo*/
        u[4]
      ), toggle_class(
        l,
        "spectrum-StatusLight--seafoam",
        /*seafoam*/
        u[5]
      ), toggle_class(
        l,
        "spectrum-StatusLight--chartreuse",
        /*chartreuse*/
        u[6]
      ), toggle_class(
        l,
        "spectrum-StatusLight--magenta",
        /*magenta*/
        u[7]
      ), toggle_class(
        l,
        "spectrum-StatusLight--purple",
        /*purple*/
        u[8]
      ), toggle_class(
        l,
        "spectrum-StatusLight--neutral",
        /*neutral*/
        u[9]
      ), toggle_class(
        l,
        "spectrum-StatusLight--info",
        /*info*/
        u[10]
      ), toggle_class(
        l,
        "spectrum-StatusLight--positive",
        /*positive*/
        u[11]
      ), toggle_class(
        l,
        "spectrum-StatusLight--notice",
        /*notice*/
        u[12]
      ), toggle_class(
        l,
        "spectrum-StatusLight--negative",
        /*negative*/
        u[13]
      ), toggle_class(
        l,
        "spectrum-StatusLight--disabled",
        /*disabled*/
        u[14]
      ), toggle_class(
        l,
        "spectrum-StatusLight--active",
        /*active*/
        u[15]
      ), toggle_class(l, "withText", !!/*$$slots*/
      u[19].default);
    },
    m(S, $) {
      insert(S, l, $), k && k.m(l, null), m = !0, b || (y = listen(
        l,
        "click",
        /*click_handler*/
        u[22]
      ), b = !0);
    },
    p(S, [$]) {
      k && k.p && (!m || $ & /*$$scope*/
      1048576) && update_slot_base(
        k,
        v,
        S,
        /*$$scope*/
        S[20],
        m ? get_slot_changes(
          v,
          /*$$scope*/
          S[20],
          $,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          S[20]
        ),
        null
      ), (!m || $ & /*size*/
      1 && f !== (f = "spectrum-StatusLight spectrum-StatusLight--size" + /*size*/
      S[0] + " svelte-1wk2ay6")) && attr(l, "class", f), (!m || $ & /*color*/
      65536 && p !== (p = `--color: ${/*color*/
      S[16] ?? "var(--spectrum-global-color-gray-400)"};`)) && attr(l, "style", p), (!m || $ & /*size, color*/
      65537) && toggle_class(l, "custom", !!/*color*/
      S[16]), (!m || $ & /*size, square*/
      131073) && toggle_class(
        l,
        "square",
        /*square*/
        S[17]
      ), (!m || $ & /*size, hoverable*/
      262145) && toggle_class(
        l,
        "hoverable",
        /*hoverable*/
        S[18]
      ), (!m || $ & /*size, celery*/
      3) && toggle_class(
        l,
        "spectrum-StatusLight--celery",
        /*celery*/
        S[1]
      ), (!m || $ & /*size, yellow*/
      5) && toggle_class(
        l,
        "spectrum-StatusLight--yellow",
        /*yellow*/
        S[2]
      ), (!m || $ & /*size, fuchsia*/
      9) && toggle_class(
        l,
        "spectrum-StatusLight--fuchsia",
        /*fuchsia*/
        S[3]
      ), (!m || $ & /*size, indigo*/
      17) && toggle_class(
        l,
        "spectrum-StatusLight--indigo",
        /*indigo*/
        S[4]
      ), (!m || $ & /*size, seafoam*/
      33) && toggle_class(
        l,
        "spectrum-StatusLight--seafoam",
        /*seafoam*/
        S[5]
      ), (!m || $ & /*size, chartreuse*/
      65) && toggle_class(
        l,
        "spectrum-StatusLight--chartreuse",
        /*chartreuse*/
        S[6]
      ), (!m || $ & /*size, magenta*/
      129) && toggle_class(
        l,
        "spectrum-StatusLight--magenta",
        /*magenta*/
        S[7]
      ), (!m || $ & /*size, purple*/
      257) && toggle_class(
        l,
        "spectrum-StatusLight--purple",
        /*purple*/
        S[8]
      ), (!m || $ & /*size, neutral*/
      513) && toggle_class(
        l,
        "spectrum-StatusLight--neutral",
        /*neutral*/
        S[9]
      ), (!m || $ & /*size, info*/
      1025) && toggle_class(
        l,
        "spectrum-StatusLight--info",
        /*info*/
        S[10]
      ), (!m || $ & /*size, positive*/
      2049) && toggle_class(
        l,
        "spectrum-StatusLight--positive",
        /*positive*/
        S[11]
      ), (!m || $ & /*size, notice*/
      4097) && toggle_class(
        l,
        "spectrum-StatusLight--notice",
        /*notice*/
        S[12]
      ), (!m || $ & /*size, negative*/
      8193) && toggle_class(
        l,
        "spectrum-StatusLight--negative",
        /*negative*/
        S[13]
      ), (!m || $ & /*size, disabled*/
      16385) && toggle_class(
        l,
        "spectrum-StatusLight--disabled",
        /*disabled*/
        S[14]
      ), (!m || $ & /*size, active*/
      32769) && toggle_class(
        l,
        "spectrum-StatusLight--active",
        /*active*/
        S[15]
      ), (!m || $ & /*size, $$slots*/
      524289) && toggle_class(l, "withText", !!/*$$slots*/
      S[19].default);
    },
    i(S) {
      m || (transition_in(k, S), m = !0);
    },
    o(S) {
      transition_out(k, S), m = !1;
    },
    d(S) {
      S && detach(l), k && k.d(S), b = !1, y();
    }
  };
}
function instance$1v(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l;
  const b = compute_slots(p);
  let { size: y = "M" } = l, { celery: v = !1 } = l, { yellow: k = !1 } = l, { fuchsia: S = !1 } = l, { indigo: $ = !1 } = l, { seafoam: w = !1 } = l, { chartreuse: T = !1 } = l, { magenta: E = !1 } = l, { purple: R = !1 } = l, { neutral: O = !1 } = l, { info: P = !1 } = l, { positive: L = !1 } = l, { notice: M = !1 } = l, { negative: B = !1 } = l, { disabled: j = !1 } = l, { active: x = !1 } = l, { color: N = void 0 } = l, { square: D = !1 } = l, { hoverable: V = !1 } = l;
  function W(F) {
    bubble.call(this, u, F);
  }
  return u.$$set = (F) => {
    "size" in F && f(0, y = F.size), "celery" in F && f(1, v = F.celery), "yellow" in F && f(2, k = F.yellow), "fuchsia" in F && f(3, S = F.fuchsia), "indigo" in F && f(4, $ = F.indigo), "seafoam" in F && f(5, w = F.seafoam), "chartreuse" in F && f(6, T = F.chartreuse), "magenta" in F && f(7, E = F.magenta), "purple" in F && f(8, R = F.purple), "neutral" in F && f(9, O = F.neutral), "info" in F && f(10, P = F.info), "positive" in F && f(11, L = F.positive), "notice" in F && f(12, M = F.notice), "negative" in F && f(13, B = F.negative), "disabled" in F && f(14, j = F.disabled), "active" in F && f(15, x = F.active), "color" in F && f(16, N = F.color), "square" in F && f(17, D = F.square), "hoverable" in F && f(18, V = F.hoverable), "$$scope" in F && f(20, m = F.$$scope);
  }, [
    y,
    v,
    k,
    S,
    $,
    w,
    T,
    E,
    R,
    O,
    P,
    L,
    M,
    B,
    j,
    x,
    N,
    D,
    V,
    b,
    m,
    p,
    W
  ];
}
class StatusLight extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1v, create_fragment$1x, safe_not_equal, {
      size: 0,
      celery: 1,
      yellow: 2,
      fuchsia: 3,
      indigo: 4,
      seafoam: 5,
      chartreuse: 6,
      magenta: 7,
      purple: 8,
      neutral: 9,
      info: 10,
      positive: 11,
      notice: 12,
      negative: 13,
      disabled: 14,
      active: 15,
      color: 16,
      square: 17,
      hoverable: 18
    });
  }
}
const indexVars$s = "", indexVars$r = "", Avatar_svelte_svelte_type_style_lang = "";
function create_else_block$h(u) {
  let l, f = (
    /*initials*/
    (u[3] || "") + ""
  ), p;
  return {
    c() {
      l = element("div"), p = text$2(f), attr(l, "class", "spectrum-Avatar svelte-xutedg"), attr(
        l,
        "style",
        /*style*/
        u[4]
      ), toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        u[2]
      );
    },
    m(m, b) {
      insert(m, l, b), append$1(l, p);
    },
    p(m, b) {
      b & /*initials*/
      8 && f !== (f = /*initials*/
      (m[3] || "") + "") && set_data(p, f), b & /*style*/
      16 && attr(
        l,
        "style",
        /*style*/
        m[4]
      ), b & /*disabled*/
      4 && toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        m[2]
      );
    },
    d(m) {
      m && detach(l);
    }
  };
}
function create_if_block$N(u) {
  let l, f;
  return {
    c() {
      l = element("img"), attr(l, "class", "spectrum-Avatar"), src_url_equal(l.src, f = /*url*/
      u[1]) || attr(l, "src", f), attr(l, "alt", "Avatar"), set_style(l, "width", "var(" + /*sizes*/
      u[5].get(
        /*size*/
        u[0]
      ) + ")"), set_style(l, "height", "var(" + /*sizes*/
      u[5].get(
        /*size*/
        u[0]
      ) + ")"), toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        u[2]
      );
    },
    m(p, m) {
      insert(p, l, m);
    },
    p(p, m) {
      m & /*url*/
      2 && !src_url_equal(l.src, f = /*url*/
      p[1]) && attr(l, "src", f), m & /*size*/
      1 && set_style(l, "width", "var(" + /*sizes*/
      p[5].get(
        /*size*/
        p[0]
      ) + ")"), m & /*size*/
      1 && set_style(l, "height", "var(" + /*sizes*/
      p[5].get(
        /*size*/
        p[0]
      ) + ")"), m & /*disabled*/
      4 && toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        p[2]
      );
    },
    d(p) {
      p && detach(l);
    }
  };
}
function create_fragment$1w(u) {
  let l;
  function f(b, y) {
    return (
      /*url*/
      b[1] ? create_if_block$N : create_else_block$h
    );
  }
  let p = f(u), m = p(u);
  return {
    c() {
      m.c(), l = empty$1();
    },
    m(b, y) {
      m.m(b, y), insert(b, l, y);
    },
    p(b, [y]) {
      p === (p = f(b)) && m ? m.p(b, y) : (m.d(1), m = p(b), m && (m.c(), m.m(l.parentNode, l)));
    },
    i: noop$4,
    o: noop$4,
    d(b) {
      b && detach(l), m.d(b);
    }
  };
}
const DefaultColor = "#3aab87";
function instance$1u(u, l, f) {
  let p, m, b = /* @__PURE__ */ new Map([
    ["XXS", "--spectrum-alias-avatar-size-50"],
    ["XS", "--spectrum-alias-avatar-size-75"],
    ["S", "--spectrum-alias-avatar-size-200"],
    ["M", "--spectrum-alias-avatar-size-400"],
    ["L", "--spectrum-alias-avatar-size-500"],
    ["XL", "--spectrum-alias-avatar-size-600"],
    ["XXL", "--spectrum-alias-avatar-size-700"]
  ]), { size: y = "M" } = l, { url: v = "" } = l, { disabled: k = !1 } = l, { initials: S = "JD" } = l, { color: $ = "" } = l;
  const w = (E) => E != null && E.length ? `hsl(${E[0].toLowerCase().charCodeAt(0) % 26 / 26 * 360}, 50%, 50%)` : DefaultColor, T = (E, R) => {
    const O = `var(${b.get(E)})`, P = `calc(${O} / 2)`;
    return `width:${O}; height:${O}; font-size:${P}; background:${R};`;
  };
  return u.$$set = (E) => {
    "size" in E && f(0, y = E.size), "url" in E && f(1, v = E.url), "disabled" in E && f(2, k = E.disabled), "initials" in E && f(3, S = E.initials), "color" in E && f(6, $ = E.color);
  }, u.$$.update = () => {
    u.$$.dirty & /*color, initials*/
    72 && f(7, p = $ || w(S)), u.$$.dirty & /*size, avatarColor*/
    129 && f(4, m = T(y, p));
  }, [y, v, k, S, m, b, $, p];
}
class Avatar extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1u, create_fragment$1w, safe_not_equal, {
      size: 0,
      url: 1,
      disabled: 2,
      initials: 3,
      color: 6
    });
  }
}
function create_fragment$1v(u) {
  let l, f, p, m, b;
  return f = new Icon({
    props: {
      name: "x",
      size: (
        /*small*/
        u[0] ? "XS" : "S"
      )
    }
  }), {
    c() {
      l = element("button"), create_component(f.$$.fragment), attr(l, "class", "spectrum-ClearButton"), l.disabled = /*disabled*/
      u[1], toggle_class(
        l,
        "spectrum-ClearButton--small",
        /*small*/
        u[0]
      );
    },
    m(y, v) {
      insert(y, l, v), mount_component(f, l, null), p = !0, m || (b = listen(
        l,
        "click",
        /*click_handler*/
        u[2]
      ), m = !0);
    },
    p(y, [v]) {
      const k = {};
      v & /*small*/
      1 && (k.size = /*small*/
      y[0] ? "XS" : "S"), f.$set(k), (!p || v & /*disabled*/
      2) && (l.disabled = /*disabled*/
      y[1]), (!p || v & /*small*/
      1) && toggle_class(
        l,
        "spectrum-ClearButton--small",
        /*small*/
        y[0]
      );
    },
    i(y) {
      p || (transition_in(f.$$.fragment, y), p = !0);
    },
    o(y) {
      transition_out(f.$$.fragment, y), p = !1;
    },
    d(y) {
      y && detach(l), destroy_component(f), m = !1, b();
    }
  };
}
function instance$1t(u, l, f) {
  let { small: p = !1 } = l, { disabled: m = !1 } = l;
  function b(y) {
    bubble.call(this, u, y);
  }
  return u.$$set = (y) => {
    "small" in y && f(0, p = y.small), "disabled" in y && f(1, m = y.disabled);
  }, [p, m, b];
}
class ClearButton extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1t, create_fragment$1v, safe_not_equal, { small: 0, disabled: 1 });
  }
}
const Tag_svelte_svelte_type_style_lang = "";
function create_if_block_2$k(u) {
  let l, f;
  return l = new Avatar({ props: { url: (
    /*avatar*/
    u[1]
  ) } }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*avatar*/
      2 && (b.url = /*avatar*/
      p[1]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_1$q(u) {
  let l, f;
  return l = new Icon({
    props: { name: (
      /*icon*/
      u[0]
    ), size: "S" }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*icon*/
      1 && (b.name = /*icon*/
      p[0]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block$M(u) {
  let l, f;
  return l = new ClearButton({}), l.$on(
    "click",
    /*click_handler*/
    u[8]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$1u(u) {
  let l, f, p, m, b, y, v = (
    /*avatar*/
    u[1] && create_if_block_2$k(u)
  ), k = (
    /*icon*/
    u[0] && create_if_block_1$q(u)
  );
  const S = (
    /*#slots*/
    u[7].default
  ), $ = create_slot(
    S,
    u,
    /*$$scope*/
    u[6],
    null
  );
  let w = (
    /*closable*/
    u[4] && create_if_block$M(u)
  );
  return {
    c() {
      l = element("div"), v && v.c(), f = space(), k && k.c(), p = space(), m = element("span"), $ && $.c(), b = space(), w && w.c(), attr(m, "class", "spectrum-Tags-itemLabel"), attr(l, "class", "spectrum-Tags-item svelte-gzjwsm"), attr(l, "role", "listitem"), toggle_class(
        l,
        "is-invalid",
        /*invalid*/
        u[2]
      ), toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        u[3]
      ), toggle_class(
        l,
        "is-emphasized",
        /*emphasized*/
        u[5]
      );
    },
    m(T, E) {
      insert(T, l, E), v && v.m(l, null), append$1(l, f), k && k.m(l, null), append$1(l, p), append$1(l, m), $ && $.m(m, null), append$1(l, b), w && w.m(l, null), y = !0;
    },
    p(T, [E]) {
      /*avatar*/
      T[1] ? v ? (v.p(T, E), E & /*avatar*/
      2 && transition_in(v, 1)) : (v = create_if_block_2$k(T), v.c(), transition_in(v, 1), v.m(l, f)) : v && (group_outros(), transition_out(v, 1, 1, () => {
        v = null;
      }), check_outros()), /*icon*/
      T[0] ? k ? (k.p(T, E), E & /*icon*/
      1 && transition_in(k, 1)) : (k = create_if_block_1$q(T), k.c(), transition_in(k, 1), k.m(l, p)) : k && (group_outros(), transition_out(k, 1, 1, () => {
        k = null;
      }), check_outros()), $ && $.p && (!y || E & /*$$scope*/
      64) && update_slot_base(
        $,
        S,
        T,
        /*$$scope*/
        T[6],
        y ? get_slot_changes(
          S,
          /*$$scope*/
          T[6],
          E,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          T[6]
        ),
        null
      ), /*closable*/
      T[4] ? w ? E & /*closable*/
      16 && transition_in(w, 1) : (w = create_if_block$M(T), w.c(), transition_in(w, 1), w.m(l, null)) : w && (group_outros(), transition_out(w, 1, 1, () => {
        w = null;
      }), check_outros()), (!y || E & /*invalid*/
      4) && toggle_class(
        l,
        "is-invalid",
        /*invalid*/
        T[2]
      ), (!y || E & /*disabled*/
      8) && toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        T[3]
      ), (!y || E & /*emphasized*/
      32) && toggle_class(
        l,
        "is-emphasized",
        /*emphasized*/
        T[5]
      );
    },
    i(T) {
      y || (transition_in(v), transition_in(k), transition_in($, T), transition_in(w), y = !0);
    },
    o(T) {
      transition_out(v), transition_out(k), transition_out($, T), transition_out(w), y = !1;
    },
    d(T) {
      T && detach(l), v && v.d(), k && k.d(), $ && $.d(T), w && w.d();
    }
  };
}
function instance$1s(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l, { icon: b = "" } = l, { avatar: y = "" } = l, { invalid: v = !1 } = l, { disabled: k = !1 } = l, { closable: S = !1 } = l, { emphasized: $ = !1 } = l;
  function w(T) {
    bubble.call(this, u, T);
  }
  return u.$$set = (T) => {
    "icon" in T && f(0, b = T.icon), "avatar" in T && f(1, y = T.avatar), "invalid" in T && f(2, v = T.invalid), "disabled" in T && f(3, k = T.disabled), "closable" in T && f(4, S = T.closable), "emphasized" in T && f(5, $ = T.emphasized), "$$scope" in T && f(6, m = T.$$scope);
  }, [
    b,
    y,
    v,
    k,
    S,
    $,
    m,
    p,
    w
  ];
}
class Tag extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1s, create_fragment$1u, safe_not_equal, {
      icon: 0,
      avatar: 1,
      invalid: 2,
      disabled: 3,
      closable: 4,
      emphasized: 5
    });
  }
}
const Tags_svelte_svelte_type_style_lang = "";
function create_fragment$1t(u) {
  let l, f;
  const p = (
    /*#slots*/
    u[1].default
  ), m = create_slot(
    p,
    u,
    /*$$scope*/
    u[0],
    null
  );
  return {
    c() {
      l = element("div"), m && m.c(), attr(l, "class", "spectrum-Tags svelte-17cj8k0"), attr(l, "role", "list"), attr(l, "aria-label", "list");
    },
    m(b, y) {
      insert(b, l, y), m && m.m(l, null), f = !0;
    },
    p(b, [y]) {
      m && m.p && (!f || y & /*$$scope*/
      1) && update_slot_base(
        m,
        p,
        b,
        /*$$scope*/
        b[0],
        f ? get_slot_changes(
          p,
          /*$$scope*/
          b[0],
          y,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          b[0]
        ),
        null
      );
    },
    i(b) {
      f || (transition_in(m, b), f = !0);
    },
    o(b) {
      transition_out(m, b), f = !1;
    },
    d(b) {
      b && detach(l), m && m.d(b);
    }
  };
}
function instance$1r(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l;
  return u.$$set = (b) => {
    "$$scope" in b && f(0, m = b.$$scope);
  }, [m, p];
}
class Tags extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1r, create_fragment$1t, safe_not_equal, {});
  }
}
const indexVars$q = "", Search_svelte_svelte_type_style_lang = "";
function create_fragment$1s(u) {
  let l, f, p, m, b, y, v, k, S, $, w, T, E, R;
  return m = new Icon({
    props: { name: "magnifying-glass", size: "S" }
  }), w = new Icon({ props: { name: "x", size: "S" } }), {
    c() {
      l = element("div"), f = element("div"), p = element("div"), create_component(m.$$.fragment), b = space(), y = element("input"), S = space(), $ = element("button"), create_component(w.$$.fragment), attr(p, "class", "search-icon svelte-16dnyba"), y.disabled = /*disabled*/
      u[3], attr(
        y,
        "id",
        /*id*/
        u[4]
      ), y.value = v = /*value*/
      u[1] || "", attr(y, "placeholder", k = /*placeholder*/
      u[2] || ""), attr(y, "type", "search"), attr(y, "class", "spectrum-Textfield-input spectrum-Search-input svelte-16dnyba"), attr(y, "autocomplete", "off"), attr(f, "class", "spectrum-Textfield svelte-16dnyba"), toggle_class(
        f,
        "spectrum-Textfield--quiet",
        /*quiet*/
        u[5]
      ), toggle_class(
        f,
        "is-focused",
        /*focus*/
        u[6]
      ), toggle_class(
        f,
        "is-disabled",
        /*disabled*/
        u[3]
      ), attr($, "type", "reset"), attr($, "class", "spectrum-ClearButton spectrum-Search-clearButton svelte-16dnyba"), attr(l, "class", "spectrum-Search svelte-16dnyba"), toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        u[3]
      );
    },
    m(O, P) {
      insert(O, l, P), append$1(l, f), append$1(f, p), mount_component(m, p, null), append$1(f, b), append$1(f, y), u[17](y), append$1(l, S), append$1(l, $), mount_component(w, $, null), T = !0, E || (R = [
        listen(
          y,
          "click",
          /*click_handler*/
          u[13]
        ),
        listen(
          y,
          "blur",
          /*blur_handler*/
          u[14]
        ),
        listen(
          y,
          "focus",
          /*focus_handler*/
          u[15]
        ),
        listen(
          y,
          "input",
          /*input_handler*/
          u[16]
        ),
        listen(
          y,
          "blur",
          /*onBlur*/
          u[9]
        ),
        listen(
          y,
          "focus",
          /*onFocus*/
          u[8]
        ),
        listen(
          y,
          "input",
          /*onInput*/
          u[10]
        ),
        listen(
          y,
          "keyup",
          /*updateValueOnEnter*/
          u[11]
        ),
        listen(
          $,
          "click",
          /*click_handler_1*/
          u[18]
        )
      ], E = !0);
    },
    p(O, [P]) {
      (!T || P & /*disabled*/
      8) && (y.disabled = /*disabled*/
      O[3]), (!T || P & /*id*/
      16) && attr(
        y,
        "id",
        /*id*/
        O[4]
      ), (!T || P & /*value*/
      2 && v !== (v = /*value*/
      O[1] || "") && y.value !== v) && (y.value = v), (!T || P & /*placeholder*/
      4 && k !== (k = /*placeholder*/
      O[2] || "")) && attr(y, "placeholder", k), (!T || P & /*quiet*/
      32) && toggle_class(
        f,
        "spectrum-Textfield--quiet",
        /*quiet*/
        O[5]
      ), (!T || P & /*focus*/
      64) && toggle_class(
        f,
        "is-focused",
        /*focus*/
        O[6]
      ), (!T || P & /*disabled*/
      8) && toggle_class(
        f,
        "is-disabled",
        /*disabled*/
        O[3]
      ), (!T || P & /*disabled*/
      8) && toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        O[3]
      );
    },
    i(O) {
      T || (transition_in(m.$$.fragment, O), transition_in(w.$$.fragment, O), T = !0);
    },
    o(O) {
      transition_out(m.$$.fragment, O), transition_out(w.$$.fragment, O), T = !1;
    },
    d(O) {
      O && detach(l), destroy_component(m), u[17](null), destroy_component(w), E = !1, run_all(R);
    }
  };
}
function instance$1q(u, l, f) {
  let { value: p = null } = l, { placeholder: m = void 0 } = l, { disabled: b = !1 } = l, { id: y = null } = l, { updateOnChange: v = !0 } = l, { quiet: k = !1 } = l, { inputRef: S = void 0 } = l;
  const $ = createEventDispatcher();
  let w = !1;
  const T = (D) => {
    $("change", D);
  }, E = () => {
    f(6, w = !0);
  }, R = (D) => {
    f(6, w = !1), T(D.target.value);
  }, O = (D) => {
    v && T(D.target.value);
  }, P = (D) => {
    D.key === "Enter" && T(D.target.value);
  };
  function L(D) {
    bubble.call(this, u, D);
  }
  function M(D) {
    bubble.call(this, u, D);
  }
  function B(D) {
    bubble.call(this, u, D);
  }
  function j(D) {
    bubble.call(this, u, D);
  }
  function x(D) {
    binding_callbacks[D ? "unshift" : "push"](() => {
      S = D, f(0, S);
    });
  }
  const N = () => T("");
  return u.$$set = (D) => {
    "value" in D && f(1, p = D.value), "placeholder" in D && f(2, m = D.placeholder), "disabled" in D && f(3, b = D.disabled), "id" in D && f(4, y = D.id), "updateOnChange" in D && f(12, v = D.updateOnChange), "quiet" in D && f(5, k = D.quiet), "inputRef" in D && f(0, S = D.inputRef);
  }, [
    S,
    p,
    m,
    b,
    y,
    k,
    w,
    T,
    E,
    R,
    O,
    P,
    v,
    L,
    M,
    B,
    j,
    x,
    N
  ];
}
class Search extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1q, create_fragment$1s, safe_not_equal, {
      value: 1,
      placeholder: 2,
      disabled: 3,
      id: 4,
      updateOnChange: 12,
      quiet: 5,
      inputRef: 0
    });
  }
}
const Picker_svelte_svelte_type_style_lang = "";
function get_each_context$f(u, l, f) {
  const p = u.slice();
  return p[50] = l[f], p[52] = f, p;
}
function create_if_block_12$2(u) {
  let l, f, p, m;
  const b = [create_if_block_13$2, create_else_block_1$5], y = [];
  function v(k, S) {
    return (
      /*useOptionIconImage*/
      k[18] ? 1 : 0
    );
  }
  return l = v(u), f = y[l] = b[l](u), {
    c() {
      f.c(), p = empty$1();
    },
    m(k, S) {
      y[l].m(k, S), insert(k, p, S), m = !0;
    },
    p(k, S) {
      let $ = l;
      l = v(k), l === $ ? y[l].p(k, S) : (group_outros(), transition_out(y[$], 1, 1, () => {
        y[$] = null;
      }), check_outros(), f = y[l], f ? f.p(k, S) : (f = y[l] = b[l](k), f.c()), transition_in(f, 1), f.m(p.parentNode, p));
    },
    i(k) {
      m || (transition_in(f), m = !0);
    },
    o(k) {
      transition_out(f), m = !1;
    },
    d(k) {
      k && detach(p), y[l].d(k);
    }
  };
}
function create_else_block_1$5(u) {
  let l, f, p;
  return {
    c() {
      l = element("span"), f = element("img"), attr(f, "class", "icon-dims svelte-96jbs1"), src_url_equal(f.src, p = /*fieldIcon*/
      u[5]) || attr(f, "src", p), attr(f, "alt", "icon"), attr(l, "class", "option-extra icon field-icon svelte-96jbs1");
    },
    m(m, b) {
      insert(m, l, b), append$1(l, f);
    },
    p(m, b) {
      b[0] & /*fieldIcon*/
      32 && !src_url_equal(f.src, p = /*fieldIcon*/
      m[5]) && attr(f, "src", p);
    },
    i: noop$4,
    o: noop$4,
    d(m) {
      m && detach(l);
    }
  };
}
function create_if_block_13$2(u) {
  let l, f, p;
  return f = new Icon({
    props: { size: "M", name: (
      /*fieldIcon*/
      u[5]
    ) }
  }), {
    c() {
      l = element("span"), create_component(f.$$.fragment), attr(l, "class", "option-extra icon svelte-96jbs1");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b[0] & /*fieldIcon*/
      32 && (y.name = /*fieldIcon*/
      m[5]), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block_11$2(u) {
  let l, f, p;
  return f = new StatusLight({
    props: {
      square: !0,
      color: (
        /*fieldColour*/
        u[6]
      )
    }
  }), {
    c() {
      l = element("span"), create_component(f.$$.fragment), attr(l, "class", "option-extra svelte-96jbs1");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b[0] & /*fieldColour*/
      64 && (y.color = /*fieldColour*/
      m[6]), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block_10$3(u) {
  let l, f;
  return l = new Search({
    props: {
      value: (
        /*searchTerm*/
        u[0]
      ),
      disabled: (
        /*disabled*/
        u[3]
      ),
      placeholder: "Search"
    }
  }), l.$on(
    "change",
    /*change_handler*/
    u[38]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*searchTerm*/
      1 && (b.value = /*searchTerm*/
      p[0]), m[0] & /*disabled*/
      8 && (b.disabled = /*disabled*/
      p[3]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_9$3(u) {
  let l, f, p, m, b, y, v, k, S;
  return y = new Icon({
    props: {
      name: "check",
      size: "S",
      weight: "bold",
      color: "var(--spectrum-global-color-blue-500)"
    }
  }), {
    c() {
      l = element("li"), f = element("span"), p = text$2(
        /*placeholderOption*/
        u[8]
      ), m = space(), b = element("div"), create_component(y.$$.fragment), attr(f, "class", "spectrum-Menu-itemLabel svelte-96jbs1"), attr(b, "class", "check svelte-96jbs1"), attr(l, "class", "spectrum-Menu-item placeholder svelte-96jbs1"), attr(l, "role", "option"), attr(l, "aria-selected", "true"), attr(l, "tabindex", "0"), toggle_class(
        l,
        "is-selected",
        /*isPlaceholder*/
        u[7]
      );
    },
    m($, w) {
      insert($, l, w), append$1(l, f), append$1(f, p), append$1(l, m), append$1(l, b), mount_component(y, b, null), v = !0, k || (S = listen(
        l,
        "click",
        /*click_handler*/
        u[39]
      ), k = !0);
    },
    p($, w) {
      (!v || w[0] & /*placeholderOption*/
      256) && set_data(
        p,
        /*placeholderOption*/
        $[8]
      ), (!v || w[0] & /*isPlaceholder*/
      128) && toggle_class(
        l,
        "is-selected",
        /*isPlaceholder*/
        $[7]
      );
    },
    i($) {
      v || (transition_in(y.$$.fragment, $), v = !0);
    },
    o($) {
      transition_out(y.$$.fragment, $), v = !1;
    },
    d($) {
      $ && detach(l), destroy_component(y), k = !1, S();
    }
  };
}
function create_if_block_2$j(u) {
  let l, f, p = ensure_array_like(
    /*filteredOptions*/
    u[31]
  ), m = [];
  for (let y = 0; y < p.length; y += 1)
    m[y] = create_each_block$f(get_each_context$f(u, p, y));
  const b = (y) => transition_out(m[y], 1, 1, () => {
    m[y] = null;
  });
  return {
    c() {
      for (let y = 0; y < m.length; y += 1)
        m[y].c();
      l = empty$1();
    },
    m(y, v) {
      for (let k = 0; k < m.length; k += 1)
        m[k] && m[k].m(y, v);
      insert(y, l, v), f = !0;
    },
    p(y, v) {
      if (v[0] & /*isOptionSelected, getOptionValue, isOptionEnabled, onSelectOption, onOptionMouseenter, onOptionMouseleave, tooltipMessage, getOptionSubtitle, getOptionLabel, getOptionColour, getOptionIcon, useOptionIconImage*/
      403176960 | v[1] & /*filteredOptions*/
      1) {
        p = ensure_array_like(
          /*filteredOptions*/
          y[31]
        );
        let k;
        for (k = 0; k < p.length; k += 1) {
          const S = get_each_context$f(y, p, k);
          m[k] ? (m[k].p(S, v), transition_in(m[k], 1)) : (m[k] = create_each_block$f(S), m[k].c(), transition_in(m[k], 1), m[k].m(l.parentNode, l));
        }
        for (group_outros(), k = p.length; k < m.length; k += 1)
          b(k);
        check_outros();
      }
    },
    i(y) {
      if (!f) {
        for (let v = 0; v < p.length; v += 1)
          transition_in(m[v]);
        f = !0;
      }
    },
    o(y) {
      m = m.filter(Boolean);
      for (let v = 0; v < m.length; v += 1)
        transition_out(m[v]);
      f = !1;
    },
    d(y) {
      y && detach(l), destroy_each(m, y);
    }
  };
}
function create_if_block_7$5(u) {
  let l, f, p, m;
  const b = [create_if_block_8$3, create_else_block$g], y = [];
  function v(k, S) {
    return (
      /*useOptionIconImage*/
      k[18] ? 0 : 1
    );
  }
  return f = v(u), p = y[f] = b[f](u), {
    c() {
      l = element("span"), p.c(), attr(l, "class", "option-extra icon svelte-96jbs1");
    },
    m(k, S) {
      insert(k, l, S), y[f].m(l, null), m = !0;
    },
    p(k, S) {
      let $ = f;
      f = v(k), f === $ ? y[f].p(k, S) : (group_outros(), transition_out(y[$], 1, 1, () => {
        y[$] = null;
      }), check_outros(), p = y[f], p ? p.p(k, S) : (p = y[f] = b[f](k), p.c()), transition_in(p, 1), p.m(l, null));
    },
    i(k) {
      m || (transition_in(p), m = !0);
    },
    o(k) {
      transition_out(p), m = !1;
    },
    d(k) {
      k && detach(l), y[f].d();
    }
  };
}
function create_else_block$g(u) {
  let l, f;
  return l = new Icon({
    props: {
      size: "M",
      color: "var(--spectrum-global-color-gray-600)",
      name: (
        /*getOptionIcon*/
        u[15](
          /*option*/
          u[50],
          /*idx*/
          u[52]
        )
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*getOptionIcon*/
      32768 | m[1] & /*filteredOptions*/
      1 && (b.name = /*getOptionIcon*/
      p[15](
        /*option*/
        p[50],
        /*idx*/
        p[52]
      )), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_8$3(u) {
  let l, f;
  return {
    c() {
      l = element("img"), attr(l, "class", "icon-dims svelte-96jbs1"), src_url_equal(l.src, f = /*getOptionIcon*/
      u[15](
        /*option*/
        u[50],
        /*idx*/
        u[52]
      )) || attr(l, "src", f), attr(l, "alt", "icon");
    },
    m(p, m) {
      insert(p, l, m);
    },
    p(p, m) {
      m[0] & /*getOptionIcon*/
      32768 | m[1] & /*filteredOptions*/
      1 && !src_url_equal(l.src, f = /*getOptionIcon*/
      p[15](
        /*option*/
        p[50],
        /*idx*/
        p[52]
      )) && attr(l, "src", f);
    },
    i: noop$4,
    o: noop$4,
    d(p) {
      p && detach(l);
    }
  };
}
function create_if_block_6$5(u) {
  let l, f, p;
  return f = new StatusLight({
    props: {
      square: !0,
      color: (
        /*getOptionColour*/
        u[16](
          /*option*/
          u[50],
          /*idx*/
          u[52]
        )
      )
    }
  }), {
    c() {
      l = element("span"), create_component(f.$$.fragment), attr(l, "class", "option-extra svelte-96jbs1");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b[0] & /*getOptionColour*/
      65536 | b[1] & /*filteredOptions*/
      1 && (y.color = /*getOptionColour*/
      m[16](
        /*option*/
        m[50],
        /*idx*/
        m[52]
      )), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block_5$7(u) {
  let l, f = (
    /*getOptionSubtitle*/
    u[17](
      /*option*/
      u[50],
      /*idx*/
      u[52]
    ) + ""
  ), p;
  return {
    c() {
      l = element("span"), p = text$2(f), attr(l, "class", "subtitle-text svelte-96jbs1");
    },
    m(m, b) {
      insert(m, l, b), append$1(l, p);
    },
    p(m, b) {
      b[0] & /*getOptionSubtitle*/
      131072 | b[1] & /*filteredOptions*/
      1 && f !== (f = /*getOptionSubtitle*/
      m[17](
        /*option*/
        m[50],
        /*idx*/
        m[52]
      ) + "") && set_data(p, f);
    },
    d(m) {
      m && detach(l);
    }
  };
}
function create_if_block_4$7(u) {
  let l, f, p;
  return f = new Tags({
    props: {
      $$slots: { default: [create_default_slot_2$b] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      l = element("span"), create_component(f.$$.fragment), attr(l, "class", "option-tag svelte-96jbs1");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b[1] & /*$$scope, filteredOptions*/
      4194305 && (y.$$scope = { dirty: b, ctx: m }), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_default_slot_3$6(u) {
  let l = (
    /*option*/
    u[50].tag + ""
  ), f;
  return {
    c() {
      f = text$2(l);
    },
    m(p, m) {
      insert(p, f, m);
    },
    p(p, m) {
      m[1] & /*filteredOptions*/
      1 && l !== (l = /*option*/
      p[50].tag + "") && set_data(f, l);
    },
    d(p) {
      p && detach(f);
    }
  };
}
function create_default_slot_2$b(u) {
  let l, f;
  return l = new Tag({
    props: {
      icon: "lock",
      $$slots: { default: [create_default_slot_3$6] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[1] & /*$$scope, filteredOptions*/
      4194305 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_3$a(u) {
  let l, f;
  return l = new AbsTooltip({
    props: {
      text: (
        /*tooltipMessage*/
        u[11](
          /*option*/
          u[50]
        )
      ),
      $$slots: { default: [create_default_slot_1$i] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*tooltipMessage*/
      2048 | m[1] & /*filteredOptions*/
      1 && (b.text = /*tooltipMessage*/
      p[11](
        /*option*/
        p[50]
      )), m[1] & /*$$scope*/
      4194304 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_1$i(u) {
  let l, f;
  return l = new Icon({ props: { size: "XS", name: "info" } }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p: noop$4,
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_each_block$f(u) {
  let l, f = (
    /*getOptionIcon*/
    u[15](
      /*option*/
      u[50],
      /*idx*/
      u[52]
    )
  ), p, m = (
    /*getOptionColour*/
    u[16](
      /*option*/
      u[50],
      /*idx*/
      u[52]
    )
  ), b, y, v = (
    /*getOptionLabel*/
    u[13](
      /*option*/
      u[50],
      /*idx*/
      u[52]
    ) + ""
  ), k, S, $ = (
    /*getOptionSubtitle*/
    u[17](
      /*option*/
      u[50],
      /*idx*/
      u[52]
    )
  ), w, T, E = (
    /*tooltipMessage*/
    u[11] && /*tooltipMessage*/
    u[11](
      /*option*/
      u[50]
    ).length > 0
  ), R, O, P, L, M, B, j, x = f && create_if_block_7$5(u), N = m && create_if_block_6$5(u), D = $ && create_if_block_5$7(u), V = (
    /*option*/
    u[50].tag && create_if_block_4$7(u)
  ), W = E && create_if_block_3$a(u);
  P = new Icon({
    props: {
      name: "check",
      size: "S",
      weight: "bold",
      color: "var(--spectrum-global-color-blue-500)"
    }
  });
  function F() {
    return (
      /*click_handler_1*/
      u[40](
        /*option*/
        u[50],
        /*idx*/
        u[52]
      )
    );
  }
  function U(...q) {
    return (
      /*mouseenter_handler*/
      u[41](
        /*option*/
        u[50],
        ...q
      )
    );
  }
  function Y(...q) {
    return (
      /*mouseleave_handler*/
      u[42](
        /*option*/
        u[50],
        ...q
      )
    );
  }
  return {
    c() {
      l = element("li"), x && x.c(), p = space(), N && N.c(), b = space(), y = element("span"), k = text$2(v), S = space(), D && D.c(), w = space(), V && V.c(), T = space(), W && W.c(), R = space(), O = element("div"), create_component(P.$$.fragment), L = space(), attr(y, "class", "spectrum-Menu-itemLabel svelte-96jbs1"), attr(O, "class", "check svelte-96jbs1"), attr(l, "class", "spectrum-Menu-item svelte-96jbs1"), attr(l, "role", "option"), attr(l, "aria-selected", "true"), attr(l, "tabindex", "0"), toggle_class(
        l,
        "is-selected",
        /*isOptionSelected*/
        u[9](
          /*getOptionValue*/
          u[14](
            /*option*/
            u[50],
            /*idx*/
            u[52]
          )
        )
      ), toggle_class(l, "is-disabled", !/*isOptionEnabled*/
      u[10](
        /*option*/
        u[50]
      ));
    },
    m(q, Q) {
      insert(q, l, Q), x && x.m(l, null), append$1(l, p), N && N.m(l, null), append$1(l, b), append$1(l, y), append$1(y, k), append$1(y, S), D && D.m(y, null), append$1(l, w), V && V.m(l, null), append$1(l, T), W && W.m(l, null), append$1(l, R), append$1(l, O), mount_component(P, O, null), append$1(l, L), M = !0, B || (j = [
        listen(l, "click", F),
        listen(l, "mouseenter", U),
        listen(l, "mouseleave", Y)
      ], B = !0);
    },
    p(q, Q) {
      u = q, Q[0] & /*getOptionIcon*/
      32768 | Q[1] & /*filteredOptions*/
      1 && (f = /*getOptionIcon*/
      u[15](
        /*option*/
        u[50],
        /*idx*/
        u[52]
      )), f ? x ? (x.p(u, Q), Q[0] & /*getOptionIcon*/
      32768 | Q[1] & /*filteredOptions*/
      1 && transition_in(x, 1)) : (x = create_if_block_7$5(u), x.c(), transition_in(x, 1), x.m(l, p)) : x && (group_outros(), transition_out(x, 1, 1, () => {
        x = null;
      }), check_outros()), Q[0] & /*getOptionColour*/
      65536 | Q[1] & /*filteredOptions*/
      1 && (m = /*getOptionColour*/
      u[16](
        /*option*/
        u[50],
        /*idx*/
        u[52]
      )), m ? N ? (N.p(u, Q), Q[0] & /*getOptionColour*/
      65536 | Q[1] & /*filteredOptions*/
      1 && transition_in(N, 1)) : (N = create_if_block_6$5(u), N.c(), transition_in(N, 1), N.m(l, b)) : N && (group_outros(), transition_out(N, 1, 1, () => {
        N = null;
      }), check_outros()), (!M || Q[0] & /*getOptionLabel*/
      8192 | Q[1] & /*filteredOptions*/
      1) && v !== (v = /*getOptionLabel*/
      u[13](
        /*option*/
        u[50],
        /*idx*/
        u[52]
      ) + "") && set_data(k, v), Q[0] & /*getOptionSubtitle*/
      131072 | Q[1] & /*filteredOptions*/
      1 && ($ = /*getOptionSubtitle*/
      u[17](
        /*option*/
        u[50],
        /*idx*/
        u[52]
      )), $ ? D ? D.p(u, Q) : (D = create_if_block_5$7(u), D.c(), D.m(y, null)) : D && (D.d(1), D = null), /*option*/
      u[50].tag ? V ? (V.p(u, Q), Q[1] & /*filteredOptions*/
      1 && transition_in(V, 1)) : (V = create_if_block_4$7(u), V.c(), transition_in(V, 1), V.m(l, T)) : V && (group_outros(), transition_out(V, 1, 1, () => {
        V = null;
      }), check_outros()), Q[0] & /*tooltipMessage*/
      2048 | Q[1] & /*filteredOptions*/
      1 && (E = /*tooltipMessage*/
      u[11] && /*tooltipMessage*/
      u[11](
        /*option*/
        u[50]
      ).length > 0), E ? W ? (W.p(u, Q), Q[0] & /*tooltipMessage*/
      2048 | Q[1] & /*filteredOptions*/
      1 && transition_in(W, 1)) : (W = create_if_block_3$a(u), W.c(), transition_in(W, 1), W.m(l, R)) : W && (group_outros(), transition_out(W, 1, 1, () => {
        W = null;
      }), check_outros()), (!M || Q[0] & /*isOptionSelected, getOptionValue*/
      16896 | Q[1] & /*filteredOptions*/
      1) && toggle_class(
        l,
        "is-selected",
        /*isOptionSelected*/
        u[9](
          /*getOptionValue*/
          u[14](
            /*option*/
            u[50],
            /*idx*/
            u[52]
          )
        )
      ), (!M || Q[0] & /*isOptionEnabled*/
      1024 | Q[1] & /*filteredOptions*/
      1) && toggle_class(l, "is-disabled", !/*isOptionEnabled*/
      u[10](
        /*option*/
        u[50]
      ));
    },
    i(q) {
      M || (transition_in(x), transition_in(N), transition_in(V), transition_in(W), transition_in(P.$$.fragment, q), M = !0);
    },
    o(q) {
      transition_out(x), transition_out(N), transition_out(V), transition_out(W), transition_out(P.$$.fragment, q), M = !1;
    },
    d(q) {
      q && detach(l), x && x.d(), N && N.d(), D && D.d(), V && V.d(), W && W.d(), destroy_component(P), B = !1, run_all(j);
    }
  };
}
function create_if_block_1$p(u) {
  let l, f, p;
  return f = new ProgressCircle({ props: { size: "S" } }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "loading svelte-96jbs1"), toggle_class(
        l,
        "loading--withAutocomplete",
        /*autocomplete*/
        u[21]
      );
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      (!p || b[0] & /*autocomplete*/
      2097152) && toggle_class(
        l,
        "loading--withAutocomplete",
        /*autocomplete*/
        m[21]
      );
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block$L(u) {
  let l, f;
  return {
    c() {
      l = element("div"), f = text$2(
        /*footer*/
        u[24]
      ), attr(l, "class", "footer svelte-96jbs1");
    },
    m(p, m) {
      insert(p, l, m), append$1(l, f);
    },
    p(p, m) {
      m[0] & /*footer*/
      16777216 && set_data(
        f,
        /*footer*/
        p[24]
      );
    },
    d(p) {
      p && detach(l);
    }
  };
}
function create_default_slot$J(u) {
  let l, f, p, m, b, y, v, k, S, $, w = (
    /*autocomplete*/
    u[21] && create_if_block_10$3(u)
  ), T = (
    /*placeholderOption*/
    u[8] && create_if_block_9$3(u)
  ), E = (
    /*filteredOptions*/
    u[31].length && create_if_block_2$j(u)
  ), R = (
    /*loading*/
    u[26] && create_if_block_1$p(u)
  ), O = (
    /*footer*/
    u[24] && create_if_block$L(u)
  );
  return {
    c() {
      l = element("div"), w && w.c(), f = space(), p = element("ul"), T && T.c(), m = space(), E && E.c(), b = space(), R && R.c(), y = space(), O && O.c(), attr(p, "class", "spectrum-Menu"), attr(p, "role", "listbox"), attr(l, "class", "popover-content svelte-96jbs1"), toggle_class(
        l,
        "auto-width",
        /*autoWidth*/
        u[20]
      );
    },
    m(P, L) {
      insert(P, l, L), w && w.m(l, null), append$1(l, f), append$1(l, p), T && T.m(p, null), append$1(p, m), E && E.m(p, null), u[43](p), append$1(l, b), R && R.m(l, null), append$1(l, y), O && O.m(l, null), k = !0, S || ($ = action_destroyer(v = clickOutside.call(
        null,
        l,
        /*clickOutside_function*/
        u[44]
      )), S = !0);
    },
    p(P, L) {
      /*autocomplete*/
      P[21] ? w ? (w.p(P, L), L[0] & /*autocomplete*/
      2097152 && transition_in(w, 1)) : (w = create_if_block_10$3(P), w.c(), transition_in(w, 1), w.m(l, f)) : w && (group_outros(), transition_out(w, 1, 1, () => {
        w = null;
      }), check_outros()), /*placeholderOption*/
      P[8] ? T ? (T.p(P, L), L[0] & /*placeholderOption*/
      256 && transition_in(T, 1)) : (T = create_if_block_9$3(P), T.c(), transition_in(T, 1), T.m(p, m)) : T && (group_outros(), transition_out(T, 1, 1, () => {
        T = null;
      }), check_outros()), /*filteredOptions*/
      P[31].length ? E ? (E.p(P, L), L[1] & /*filteredOptions*/
      1 && transition_in(E, 1)) : (E = create_if_block_2$j(P), E.c(), transition_in(E, 1), E.m(p, null)) : E && (group_outros(), transition_out(E, 1, 1, () => {
        E = null;
      }), check_outros()), /*loading*/
      P[26] ? R ? (R.p(P, L), L[0] & /*loading*/
      67108864 && transition_in(R, 1)) : (R = create_if_block_1$p(P), R.c(), transition_in(R, 1), R.m(l, y)) : R && (group_outros(), transition_out(R, 1, 1, () => {
        R = null;
      }), check_outros()), /*footer*/
      P[24] ? O ? O.p(P, L) : (O = create_if_block$L(P), O.c(), O.m(l, null)) : O && (O.d(1), O = null), v && is_function(v.update) && L[0] & /*open*/
      2 && v.update.call(
        null,
        /*clickOutside_function*/
        P[44]
      ), (!k || L[0] & /*autoWidth*/
      1048576) && toggle_class(
        l,
        "auto-width",
        /*autoWidth*/
        P[20]
      );
    },
    i(P) {
      k || (transition_in(w), transition_in(T), transition_in(E), transition_in(R), k = !0);
    },
    o(P) {
      transition_out(w), transition_out(T), transition_out(E), transition_out(R), k = !1;
    },
    d(P) {
      P && detach(l), w && w.d(), T && T.d(), E && E.d(), u[43](null), R && R.d(), O && O.d(), S = !1, $();
    }
  };
}
function create_fragment$1r(u) {
  let l, f, p, m, b, y, v, k, S, $, w, T, E = (
    /*fieldIcon*/
    u[5] && create_if_block_12$2(u)
  ), R = (
    /*fieldColour*/
    u[6] && create_if_block_11$2(u)
  );
  return v = new Icon({ props: { name: "caret-down", size: "S" } }), S = new Popover({
    props: {
      anchor: (
        /*customAnchor*/
        u[25] ? (
          /*customAnchor*/
          u[25]
        ) : (
          /*button*/
          u[30]
        )
      ),
      align: (
        /*align*/
        u[23] || PopoverAlignment.Left
      ),
      open: (
        /*open*/
        u[1]
      ),
      useAnchorWidth: !/*autoWidth*/
      u[20],
      maxWidth: (
        /*autoWidth*/
        u[20] ? 400 : void 0
      ),
      customHeight: (
        /*customPopoverHeight*/
        u[22]
      ),
      maxHeight: 360,
      $$slots: { default: [create_default_slot$J] },
      $$scope: { ctx: u }
    }
  }), S.$on(
    "close",
    /*close_handler*/
    u[45]
  ), {
    c() {
      l = element("button"), E && E.c(), f = space(), R && R.c(), p = space(), m = element("span"), b = text$2(
        /*fieldText*/
        u[4]
      ), y = space(), create_component(v.$$.fragment), k = space(), create_component(S.$$.fragment), attr(m, "class", "spectrum-Picker-label svelte-96jbs1"), toggle_class(
        m,
        "is-placeholder",
        /*isPlaceholder*/
        u[7]
      ), toggle_class(
        m,
        "auto-width",
        /*autoWidth*/
        u[20]
      ), attr(
        l,
        "id",
        /*id*/
        u[2]
      ), attr(l, "class", "spectrum-Picker spectrum-Picker--sizeM svelte-96jbs1"), l.disabled = /*disabled*/
      u[3], attr(l, "aria-haspopup", "listbox"), toggle_class(
        l,
        "spectrum-Picker--quiet",
        /*quiet*/
        u[19]
      ), toggle_class(
        l,
        "is-open",
        /*open*/
        u[1]
      );
    },
    m(O, P) {
      insert(O, l, P), E && E.m(l, null), append$1(l, f), R && R.m(l, null), append$1(l, p), append$1(l, m), append$1(m, b), append$1(l, y), mount_component(v, l, null), u[37](l), insert(O, k, P), mount_component(S, O, P), $ = !0, w || (T = listen(
        l,
        "click",
        /*onClick*/
        u[32]
      ), w = !0);
    },
    p(O, P) {
      /*fieldIcon*/
      O[5] ? E ? (E.p(O, P), P[0] & /*fieldIcon*/
      32 && transition_in(E, 1)) : (E = create_if_block_12$2(O), E.c(), transition_in(E, 1), E.m(l, f)) : E && (group_outros(), transition_out(E, 1, 1, () => {
        E = null;
      }), check_outros()), /*fieldColour*/
      O[6] ? R ? (R.p(O, P), P[0] & /*fieldColour*/
      64 && transition_in(R, 1)) : (R = create_if_block_11$2(O), R.c(), transition_in(R, 1), R.m(l, p)) : R && (group_outros(), transition_out(R, 1, 1, () => {
        R = null;
      }), check_outros()), (!$ || P[0] & /*fieldText*/
      16) && set_data(
        b,
        /*fieldText*/
        O[4]
      ), (!$ || P[0] & /*isPlaceholder*/
      128) && toggle_class(
        m,
        "is-placeholder",
        /*isPlaceholder*/
        O[7]
      ), (!$ || P[0] & /*autoWidth*/
      1048576) && toggle_class(
        m,
        "auto-width",
        /*autoWidth*/
        O[20]
      ), (!$ || P[0] & /*id*/
      4) && attr(
        l,
        "id",
        /*id*/
        O[2]
      ), (!$ || P[0] & /*disabled*/
      8) && (l.disabled = /*disabled*/
      O[3]), (!$ || P[0] & /*quiet*/
      524288) && toggle_class(
        l,
        "spectrum-Picker--quiet",
        /*quiet*/
        O[19]
      ), (!$ || P[0] & /*open*/
      2) && toggle_class(
        l,
        "is-open",
        /*open*/
        O[1]
      );
      const L = {};
      P[0] & /*customAnchor, button*/
      1107296256 && (L.anchor = /*customAnchor*/
      O[25] ? (
        /*customAnchor*/
        O[25]
      ) : (
        /*button*/
        O[30]
      )), P[0] & /*align*/
      8388608 && (L.align = /*align*/
      O[23] || PopoverAlignment.Left), P[0] & /*open*/
      2 && (L.open = /*open*/
      O[1]), P[0] & /*autoWidth*/
      1048576 && (L.useAnchorWidth = !/*autoWidth*/
      O[20]), P[0] & /*autoWidth*/
      1048576 && (L.maxWidth = /*autoWidth*/
      O[20] ? 400 : void 0), P[0] & /*customPopoverHeight*/
      4194304 && (L.customHeight = /*customPopoverHeight*/
      O[22]), P[0] & /*open, autoWidth, footer, autocomplete, loading, component, isOptionSelected, getOptionValue, isOptionEnabled, onSelectOption, onOptionMouseenter, onOptionMouseleave, tooltipMessage, getOptionSubtitle, getOptionLabel, getOptionColour, getOptionIcon, useOptionIconImage, isPlaceholder, placeholderOption, searchTerm, disabled*/
      1027080075 | P[1] & /*$$scope, filteredOptions*/
      4194305 && (L.$$scope = { dirty: P, ctx: O }), S.$set(L);
    },
    i(O) {
      $ || (transition_in(E), transition_in(R), transition_in(v.$$.fragment, O), transition_in(S.$$.fragment, O), $ = !0);
    },
    o(O) {
      transition_out(E), transition_out(R), transition_out(v.$$.fragment, O), transition_out(S.$$.fragment, O), $ = !1;
    },
    d(O) {
      O && (detach(l), detach(k)), E && E.d(), R && R.d(), destroy_component(v), u[37](null), destroy_component(S, O), w = !1, T();
    }
  };
}
function instance$1p(u, l, f) {
  let p, m, { id: b = void 0 } = l, { disabled: y = !1 } = l, { fieldText: v = "" } = l, { fieldIcon: k = "" } = l, { fieldColour: S = "" } = l, { isPlaceholder: $ = !1 } = l, { placeholderOption: w = void 0 } = l, { options: T = [] } = l, { isOptionSelected: E = (se) => se } = l, { isOptionEnabled: R = (se, $e) => se } = l, { tooltipMessage: O = void 0 } = l, { onSelectOption: P = () => {
  } } = l, { getOptionLabel: L = (se, $e) => `${se}` } = l, { getOptionValue: M = (se, $e) => se } = l, { getOptionIcon: B = (se, $e) => (se == null ? void 0 : se.icon) ?? void 0 } = l, { getOptionColour: j = (se, $e) => (se == null ? void 0 : se.colour) ?? void 0 } = l, { getOptionSubtitle: x = (se, $e) => (se == null ? void 0 : se.subtitle) ?? void 0 } = l, { useOptionIconImage: N = !1 } = l, { open: D = !1 } = l, { readonly: V = !1 } = l, { quiet: W = !1 } = l, { autoWidth: F = !1 } = l, { autocomplete: U = !1 } = l, { sort: Y = !1 } = l, { searchTerm: q = null } = l, { customPopoverHeight: Q = void 0 } = l, { align: z = PopoverAlignment.Left } = l, { footer: H = void 0 } = l, { customAnchor: X = void 0 } = l, { loading: Z = !1 } = l, { onOptionMouseenter: oe = () => {
  } } = l, { onOptionMouseleave: ee = () => {
  } } = l;
  const ie = createEventDispatcher();
  let de, pe;
  const le = (se) => {
    se.preventDefault(), se.stopPropagation(), ie("click"), !V && (f(0, q = null), f(1, D = !D));
  }, ae = (se, $e, Pe) => !(se != null && se.length) || !Array.isArray(se) ? [] : Pe ? se.sort((De, He) => {
    const Ce = $e(De), Ue = $e(He);
    return Ce > Ue ? 1 : -1;
  }) : se, ne = (se, $e, Pe) => {
    if (U && $e) {
      const De = $e.toLowerCase();
      return se.filter((He) => `${Pe(He)}`.toLowerCase().includes(De));
    }
    return se;
  }, K = (se) => {
    se.target.scrollHeight - se.target.clientHeight - se.target.scrollTop < 100 && ie("loadMore");
  };
  onDestroy(() => {
    pe == null || pe.removeEventListener("scroll", null);
  });
  function ce(se) {
    binding_callbacks[se ? "unshift" : "push"](() => {
      de = se, f(30, de);
    });
  }
  const te = (se) => f(0, q = se.detail), ue = () => P(null), J = (se, $e) => P(M(se, $e)), fe = (se, $e) => oe($e, se), _e = (se, $e) => ee($e, se);
  function ye(se) {
    binding_callbacks[se ? "unshift" : "push"](() => {
      pe = se, f(29, pe);
    });
  }
  const ke = () => {
    f(1, D = !1);
  }, we = () => f(1, D = !1);
  return u.$$set = (se) => {
    "id" in se && f(2, b = se.id), "disabled" in se && f(3, y = se.disabled), "fieldText" in se && f(4, v = se.fieldText), "fieldIcon" in se && f(5, k = se.fieldIcon), "fieldColour" in se && f(6, S = se.fieldColour), "isPlaceholder" in se && f(7, $ = se.isPlaceholder), "placeholderOption" in se && f(8, w = se.placeholderOption), "options" in se && f(33, T = se.options), "isOptionSelected" in se && f(9, E = se.isOptionSelected), "isOptionEnabled" in se && f(10, R = se.isOptionEnabled), "tooltipMessage" in se && f(11, O = se.tooltipMessage), "onSelectOption" in se && f(12, P = se.onSelectOption), "getOptionLabel" in se && f(13, L = se.getOptionLabel), "getOptionValue" in se && f(14, M = se.getOptionValue), "getOptionIcon" in se && f(15, B = se.getOptionIcon), "getOptionColour" in se && f(16, j = se.getOptionColour), "getOptionSubtitle" in se && f(17, x = se.getOptionSubtitle), "useOptionIconImage" in se && f(18, N = se.useOptionIconImage), "open" in se && f(1, D = se.open), "readonly" in se && f(34, V = se.readonly), "quiet" in se && f(19, W = se.quiet), "autoWidth" in se && f(20, F = se.autoWidth), "autocomplete" in se && f(21, U = se.autocomplete), "sort" in se && f(35, Y = se.sort), "searchTerm" in se && f(0, q = se.searchTerm), "customPopoverHeight" in se && f(22, Q = se.customPopoverHeight), "align" in se && f(23, z = se.align), "footer" in se && f(24, H = se.footer), "customAnchor" in se && f(25, X = se.customAnchor), "loading" in se && f(26, Z = se.loading), "onOptionMouseenter" in se && f(27, oe = se.onOptionMouseenter), "onOptionMouseleave" in se && f(28, ee = se.onOptionMouseleave);
  }, u.$$.update = () => {
    u.$$.dirty[0] & /*getOptionLabel*/
    8192 | u.$$.dirty[1] & /*options, sort*/
    20 && f(36, p = ae(T, L, Y)), u.$$.dirty[0] & /*searchTerm, getOptionLabel*/
    8193 | u.$$.dirty[1] & /*sortedOptions*/
    32 && f(31, m = ne(p, q, L)), u.$$.dirty[0] & /*component*/
    536870912 && (pe == null || pe.addEventListener("scroll", K));
  }, [
    q,
    D,
    b,
    y,
    v,
    k,
    S,
    $,
    w,
    E,
    R,
    O,
    P,
    L,
    M,
    B,
    j,
    x,
    N,
    W,
    F,
    U,
    Q,
    z,
    H,
    X,
    Z,
    oe,
    ee,
    pe,
    de,
    m,
    le,
    T,
    V,
    Y,
    p,
    ce,
    te,
    ue,
    J,
    fe,
    _e,
    ye,
    ke,
    we
  ];
}
class Picker extends SvelteComponent {
  constructor(l) {
    super(), init$1(
      this,
      l,
      instance$1p,
      create_fragment$1r,
      safe_not_equal,
      {
        id: 2,
        disabled: 3,
        fieldText: 4,
        fieldIcon: 5,
        fieldColour: 6,
        isPlaceholder: 7,
        placeholderOption: 8,
        options: 33,
        isOptionSelected: 9,
        isOptionEnabled: 10,
        tooltipMessage: 11,
        onSelectOption: 12,
        getOptionLabel: 13,
        getOptionValue: 14,
        getOptionIcon: 15,
        getOptionColour: 16,
        getOptionSubtitle: 17,
        useOptionIconImage: 18,
        open: 1,
        readonly: 34,
        quiet: 19,
        autoWidth: 20,
        autocomplete: 21,
        sort: 35,
        searchTerm: 0,
        customPopoverHeight: 22,
        align: 23,
        footer: 24,
        customAnchor: 25,
        loading: 26,
        onOptionMouseenter: 27,
        onOptionMouseleave: 28
      },
      null,
      [-1, -1]
    );
  }
}
function create_fragment$1q(u) {
  let l, f, p, m;
  function b(k) {
    u[33](k);
  }
  function y(k) {
    u[34](k);
  }
  let v = {
    quiet: (
      /*quiet*/
      u[16]
    ),
    id: (
      /*id*/
      u[3]
    ),
    disabled: (
      /*disabled*/
      u[5]
    ),
    readonly: (
      /*readonly*/
      u[15]
    ),
    fieldText: (
      /*fieldText*/
      u[28]
    ),
    fieldIcon: (
      /*fieldIcon*/
      u[27]
    ),
    fieldColour: (
      /*fieldColour*/
      u[26]
    ),
    options: (
      /*options*/
      u[6]
    ),
    autoWidth: (
      /*autoWidth*/
      u[17]
    ),
    align: (
      /*align*/
      u[20]
    ),
    footer: (
      /*footer*/
      u[21]
    ),
    getOptionLabel: (
      /*getOptionLabel*/
      u[7]
    ),
    getOptionValue: (
      /*getOptionValue*/
      u[8]
    ),
    getOptionIcon: (
      /*getOptionIcon*/
      u[9]
    ),
    getOptionColour: (
      /*getOptionColour*/
      u[10]
    ),
    getOptionSubtitle: (
      /*getOptionSubtitle*/
      u[11]
    ),
    useOptionIconImage: (
      /*useOptionIconImage*/
      u[12]
    ),
    isOptionEnabled: (
      /*isOptionEnabled*/
      u[13]
    ),
    tooltipMessage: (
      /*tooltipMessage*/
      u[14]
    ),
    autocomplete: (
      /*autocomplete*/
      u[18]
    ),
    sort: (
      /*sort*/
      u[19]
    ),
    onOptionMouseenter: (
      /*onOptionMouseenter*/
      u[23]
    ),
    onOptionMouseleave: (
      /*onOptionMouseleave*/
      u[24]
    ),
    isPlaceholder: (
      /*value*/
      u[2] == null || /*value*/
      u[2] === ""
    ),
    placeholderOption: (
      /*placeholder*/
      u[4] === !1 ? void 0 : (
        /*placeholder*/
        u[4] || "Choose an option"
      )
    ),
    isOptionSelected: (
      /*func*/
      u[32]
    ),
    onSelectOption: (
      /*selectOption*/
      u[30]
    ),
    loading: (
      /*loading*/
      u[22]
    ),
    customPopoverHeight: (
      /*customPopoverHeight*/
      u[25]
    )
  };
  return (
    /*open*/
    u[0] !== void 0 && (v.open = /*open*/
    u[0]), /*searchTerm*/
    u[1] !== void 0 && (v.searchTerm = /*searchTerm*/
    u[1]), l = new Picker({ props: v }), binding_callbacks.push(() => bind(l, "open", b)), binding_callbacks.push(() => bind(l, "searchTerm", y)), l.$on(
      "click",
      /*click_handler*/
      u[35]
    ), l.$on(
      "loadMore",
      /*loadMore_handler*/
      u[36]
    ), {
      c() {
        create_component(l.$$.fragment);
      },
      m(k, S) {
        mount_component(l, k, S), m = !0;
      },
      p(k, S) {
        const $ = {};
        S[0] & /*quiet*/
        65536 && ($.quiet = /*quiet*/
        k[16]), S[0] & /*id*/
        8 && ($.id = /*id*/
        k[3]), S[0] & /*disabled*/
        32 && ($.disabled = /*disabled*/
        k[5]), S[0] & /*readonly*/
        32768 && ($.readonly = /*readonly*/
        k[15]), S[0] & /*fieldText*/
        268435456 && ($.fieldText = /*fieldText*/
        k[28]), S[0] & /*fieldIcon*/
        134217728 && ($.fieldIcon = /*fieldIcon*/
        k[27]), S[0] & /*fieldColour*/
        67108864 && ($.fieldColour = /*fieldColour*/
        k[26]), S[0] & /*options*/
        64 && ($.options = /*options*/
        k[6]), S[0] & /*autoWidth*/
        131072 && ($.autoWidth = /*autoWidth*/
        k[17]), S[0] & /*align*/
        1048576 && ($.align = /*align*/
        k[20]), S[0] & /*footer*/
        2097152 && ($.footer = /*footer*/
        k[21]), S[0] & /*getOptionLabel*/
        128 && ($.getOptionLabel = /*getOptionLabel*/
        k[7]), S[0] & /*getOptionValue*/
        256 && ($.getOptionValue = /*getOptionValue*/
        k[8]), S[0] & /*getOptionIcon*/
        512 && ($.getOptionIcon = /*getOptionIcon*/
        k[9]), S[0] & /*getOptionColour*/
        1024 && ($.getOptionColour = /*getOptionColour*/
        k[10]), S[0] & /*getOptionSubtitle*/
        2048 && ($.getOptionSubtitle = /*getOptionSubtitle*/
        k[11]), S[0] & /*useOptionIconImage*/
        4096 && ($.useOptionIconImage = /*useOptionIconImage*/
        k[12]), S[0] & /*isOptionEnabled*/
        8192 && ($.isOptionEnabled = /*isOptionEnabled*/
        k[13]), S[0] & /*tooltipMessage*/
        16384 && ($.tooltipMessage = /*tooltipMessage*/
        k[14]), S[0] & /*autocomplete*/
        262144 && ($.autocomplete = /*autocomplete*/
        k[18]), S[0] & /*sort*/
        524288 && ($.sort = /*sort*/
        k[19]), S[0] & /*onOptionMouseenter*/
        8388608 && ($.onOptionMouseenter = /*onOptionMouseenter*/
        k[23]), S[0] & /*onOptionMouseleave*/
        16777216 && ($.onOptionMouseleave = /*onOptionMouseleave*/
        k[24]), S[0] & /*value*/
        4 && ($.isPlaceholder = /*value*/
        k[2] == null || /*value*/
        k[2] === ""), S[0] & /*placeholder*/
        16 && ($.placeholderOption = /*placeholder*/
        k[4] === !1 ? void 0 : (
          /*placeholder*/
          k[4] || "Choose an option"
        )), S[0] & /*value*/
        4 && ($.isOptionSelected = /*func*/
        k[32]), S[0] & /*loading*/
        4194304 && ($.loading = /*loading*/
        k[22]), S[0] & /*customPopoverHeight*/
        33554432 && ($.customPopoverHeight = /*customPopoverHeight*/
        k[25]), !f && S[0] & /*open*/
        1 && (f = !0, $.open = /*open*/
        k[0], add_flush_callback(() => f = !1)), !p && S[0] & /*searchTerm*/
        2 && (p = !0, $.searchTerm = /*searchTerm*/
        k[1], add_flush_callback(() => p = !1)), l.$set($);
      },
      i(k) {
        m || (transition_in(l.$$.fragment, k), m = !0);
      },
      o(k) {
        transition_out(l.$$.fragment, k), m = !1;
      },
      d(k) {
        destroy_component(l, k);
      }
    }
  );
}
function instance$1o(u, l, f) {
  let p, m, b, { value: y = null } = l, { id: v = void 0 } = l, { placeholder: k = "Choose an option" } = l, { disabled: S = !1 } = l, { options: $ = [] } = l, { getOptionLabel: w = (K, ce) => `${K}` } = l, { getOptionValue: T = (K, ce) => K } = l, { getOptionIcon: E = (K, ce) => (K == null ? void 0 : K.icon) ?? void 0 } = l, { getOptionColour: R = (K, ce) => (K == null ? void 0 : K.colour) ?? void 0 } = l, { getOptionSubtitle: O = (K, ce) => (K == null ? void 0 : K.subtitle) ?? void 0 } = l, { compare: P = (K, ce) => K === ce } = l, { useOptionIconImage: L = !1 } = l, { isOptionEnabled: M = (K, ce) => K } = l, { tooltipMessage: B = void 0 } = l, { readonly: j = !1 } = l, { quiet: x = !1 } = l, { autoWidth: N = !1 } = l, { autocomplete: D = !1 } = l, { sort: V = !1 } = l, { align: W = PopoverAlignment.Left } = l, { footer: F = void 0 } = l, { open: U = !1 } = l, { searchTerm: Y = void 0 } = l, { loading: q = !1 } = l, { onOptionMouseenter: Q = () => {
  } } = l, { onOptionMouseleave: z = () => {
  } } = l, { customPopoverHeight: H = void 0 } = l;
  const X = createEventDispatcher();
  function Z(K, ce) {
    return typeof P == "function" ? P(K, ce) : K === ce;
  }
  const oe = (K, ce, te) => {
    if (!(te != null && te.length))
      return "";
    const ue = te.findIndex((J, fe) => Z(T(J, fe), ce));
    return ue !== -1 ? K(te[ue], ue) : null;
  }, ee = (K, ce, te) => K == null || K === "" ? te === !1 ? "" : te || "Choose an option" : oe(w, K, ce) || "Choose an option", ie = (K) => {
    X("change", K), f(0, U = !1);
  }, de = (K) => Z(K, y);
  function pe(K) {
    U = K, f(0, U);
  }
  function le(K) {
    Y = K, f(1, Y);
  }
  function ae(K) {
    bubble.call(this, u, K);
  }
  function ne(K) {
    bubble.call(this, u, K);
  }
  return u.$$set = (K) => {
    "value" in K && f(2, y = K.value), "id" in K && f(3, v = K.id), "placeholder" in K && f(4, k = K.placeholder), "disabled" in K && f(5, S = K.disabled), "options" in K && f(6, $ = K.options), "getOptionLabel" in K && f(7, w = K.getOptionLabel), "getOptionValue" in K && f(8, T = K.getOptionValue), "getOptionIcon" in K && f(9, E = K.getOptionIcon), "getOptionColour" in K && f(10, R = K.getOptionColour), "getOptionSubtitle" in K && f(11, O = K.getOptionSubtitle), "compare" in K && f(31, P = K.compare), "useOptionIconImage" in K && f(12, L = K.useOptionIconImage), "isOptionEnabled" in K && f(13, M = K.isOptionEnabled), "tooltipMessage" in K && f(14, B = K.tooltipMessage), "readonly" in K && f(15, j = K.readonly), "quiet" in K && f(16, x = K.quiet), "autoWidth" in K && f(17, N = K.autoWidth), "autocomplete" in K && f(18, D = K.autocomplete), "sort" in K && f(19, V = K.sort), "align" in K && f(20, W = K.align), "footer" in K && f(21, F = K.footer), "open" in K && f(0, U = K.open), "searchTerm" in K && f(1, Y = K.searchTerm), "loading" in K && f(22, q = K.loading), "onOptionMouseenter" in K && f(23, Q = K.onOptionMouseenter), "onOptionMouseleave" in K && f(24, z = K.onOptionMouseleave), "customPopoverHeight" in K && f(25, H = K.customPopoverHeight);
  }, u.$$.update = () => {
    u.$$.dirty[0] & /*value, options, placeholder*/
    84 && f(28, p = ee(y, $, k)), u.$$.dirty[0] & /*getOptionIcon, value, options*/
    580 && f(27, m = oe(E, y, $)), u.$$.dirty[0] & /*getOptionColour, value, options*/
    1092 && f(26, b = oe(R, y, $));
  }, [
    U,
    Y,
    y,
    v,
    k,
    S,
    $,
    w,
    T,
    E,
    R,
    O,
    L,
    M,
    B,
    j,
    x,
    N,
    D,
    V,
    W,
    F,
    q,
    Q,
    z,
    H,
    b,
    m,
    p,
    Z,
    ie,
    P,
    de,
    pe,
    le,
    ae,
    ne
  ];
}
class Select extends SvelteComponent {
  constructor(l) {
    super(), init$1(
      this,
      l,
      instance$1o,
      create_fragment$1q,
      safe_not_equal,
      {
        value: 2,
        id: 3,
        placeholder: 4,
        disabled: 5,
        options: 6,
        getOptionLabel: 7,
        getOptionValue: 8,
        getOptionIcon: 9,
        getOptionColour: 10,
        getOptionSubtitle: 11,
        compare: 31,
        useOptionIconImage: 12,
        isOptionEnabled: 13,
        tooltipMessage: 14,
        readonly: 15,
        quiet: 16,
        autoWidth: 17,
        autocomplete: 18,
        sort: 19,
        align: 20,
        footer: 21,
        open: 0,
        searchTerm: 1,
        loading: 22,
        onOptionMouseenter: 23,
        onOptionMouseleave: 24,
        customPopoverHeight: 25
      },
      null,
      [-1, -1]
    );
  }
}
function create_default_slot$I(u) {
  let l, f;
  return l = new Select({
    props: {
      quiet: (
        /*quiet*/
        u[15]
      ),
      loading: (
        /*loading*/
        u[28]
      ),
      disabled: (
        /*disabled*/
        u[2]
      ),
      readonly: (
        /*readonly*/
        u[3]
      ),
      value: (
        /*value*/
        u[0]
      ),
      options: (
        /*options*/
        u[7]
      ),
      placeholder: (
        /*placeholder*/
        u[6]
      ),
      autoWidth: (
        /*autoWidth*/
        u[16]
      ),
      sort: (
        /*sort*/
        u[17]
      ),
      align: (
        /*align*/
        u[22]
      ),
      footer: (
        /*footer*/
        u[23]
      ),
      getOptionLabel: (
        /*getOptionLabel*/
        u[8]
      ),
      getOptionValue: (
        /*getOptionValue*/
        u[9]
      ),
      getOptionIcon: (
        /*getOptionIcon*/
        u[11]
      ),
      getOptionColour: (
        /*getOptionColour*/
        u[12]
      ),
      getOptionSubtitle: (
        /*getOptionSubtitle*/
        u[10]
      ),
      useOptionIconImage: (
        /*useOptionIconImage*/
        u[13]
      ),
      isOptionEnabled: (
        /*isOptionEnabled*/
        u[14]
      ),
      autocomplete: (
        /*autocomplete*/
        u[20]
      ),
      customPopoverHeight: (
        /*customPopoverHeight*/
        u[21]
      ),
      compare: (
        /*compare*/
        u[25]
      ),
      onOptionMouseenter: (
        /*onOptionMouseenter*/
        u[26]
      ),
      onOptionMouseleave: (
        /*onOptionMouseleave*/
        u[27]
      ),
      tooltipMessage: (
        /*tooltipMessage*/
        u[19]
      )
    }
  }), l.$on(
    "change",
    /*onChange*/
    u[29]
  ), l.$on(
    "click",
    /*click_handler*/
    u[30]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*quiet*/
      32768 && (b.quiet = /*quiet*/
      p[15]), m[0] & /*loading*/
      268435456 && (b.loading = /*loading*/
      p[28]), m[0] & /*disabled*/
      4 && (b.disabled = /*disabled*/
      p[2]), m[0] & /*readonly*/
      8 && (b.readonly = /*readonly*/
      p[3]), m[0] & /*value*/
      1 && (b.value = /*value*/
      p[0]), m[0] & /*options*/
      128 && (b.options = /*options*/
      p[7]), m[0] & /*placeholder*/
      64 && (b.placeholder = /*placeholder*/
      p[6]), m[0] & /*autoWidth*/
      65536 && (b.autoWidth = /*autoWidth*/
      p[16]), m[0] & /*sort*/
      131072 && (b.sort = /*sort*/
      p[17]), m[0] & /*align*/
      4194304 && (b.align = /*align*/
      p[22]), m[0] & /*footer*/
      8388608 && (b.footer = /*footer*/
      p[23]), m[0] & /*getOptionLabel*/
      256 && (b.getOptionLabel = /*getOptionLabel*/
      p[8]), m[0] & /*getOptionValue*/
      512 && (b.getOptionValue = /*getOptionValue*/
      p[9]), m[0] & /*getOptionIcon*/
      2048 && (b.getOptionIcon = /*getOptionIcon*/
      p[11]), m[0] & /*getOptionColour*/
      4096 && (b.getOptionColour = /*getOptionColour*/
      p[12]), m[0] & /*getOptionSubtitle*/
      1024 && (b.getOptionSubtitle = /*getOptionSubtitle*/
      p[10]), m[0] & /*useOptionIconImage*/
      8192 && (b.useOptionIconImage = /*useOptionIconImage*/
      p[13]), m[0] & /*isOptionEnabled*/
      16384 && (b.isOptionEnabled = /*isOptionEnabled*/
      p[14]), m[0] & /*autocomplete*/
      1048576 && (b.autocomplete = /*autocomplete*/
      p[20]), m[0] & /*customPopoverHeight*/
      2097152 && (b.customPopoverHeight = /*customPopoverHeight*/
      p[21]), m[0] & /*compare*/
      33554432 && (b.compare = /*compare*/
      p[25]), m[0] & /*onOptionMouseenter*/
      67108864 && (b.onOptionMouseenter = /*onOptionMouseenter*/
      p[26]), m[0] & /*onOptionMouseleave*/
      134217728 && (b.onOptionMouseleave = /*onOptionMouseleave*/
      p[27]), m[0] & /*tooltipMessage*/
      524288 && (b.tooltipMessage = /*tooltipMessage*/
      p[19]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$1p(u) {
  let l, f;
  return l = new Field({
    props: {
      helpText: (
        /*helpText*/
        u[24]
      ),
      label: (
        /*label*/
        u[1]
      ),
      labelPosition: (
        /*labelPosition*/
        u[4]
      ),
      error: (
        /*error*/
        u[5]
      ),
      tooltip: (
        /*tooltip*/
        u[18]
      ),
      $$slots: { default: [create_default_slot$I] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*helpText*/
      16777216 && (b.helpText = /*helpText*/
      p[24]), m[0] & /*label*/
      2 && (b.label = /*label*/
      p[1]), m[0] & /*labelPosition*/
      16 && (b.labelPosition = /*labelPosition*/
      p[4]), m[0] & /*error*/
      32 && (b.error = /*error*/
      p[5]), m[0] & /*tooltip*/
      262144 && (b.tooltip = /*tooltip*/
      p[18]), m[0] & /*quiet, loading, disabled, readonly, value, options, placeholder, autoWidth, sort, align, footer, getOptionLabel, getOptionValue, getOptionIcon, getOptionColour, getOptionSubtitle, useOptionIconImage, isOptionEnabled, autocomplete, customPopoverHeight, compare, onOptionMouseenter, onOptionMouseleave, tooltipMessage*/
      519831501 | m[1] & /*$$scope*/
      4 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$1n(u, l, f) {
  let { value: p = void 0 } = l, { label: m = void 0 } = l, { disabled: b = !1 } = l, { readonly: y = !1 } = l, { labelPosition: v = "above" } = l, { error: k = void 0 } = l, { placeholder: S = "Choose an option" } = l, { options: $ = [] } = l, { getOptionLabel: w = (ee, ie) => Z(ee, "label") } = l, { getOptionValue: T = (ee, ie) => Z(ee, "value") } = l, { getOptionSubtitle: E = (ee, ie) => ee == null ? void 0 : ee.subtitle } = l, { getOptionIcon: R = (ee, ie) => ee == null ? void 0 : ee.icon } = l, { getOptionColour: O = (ee, ie) => ee == null ? void 0 : ee.colour } = l, { useOptionIconImage: P = !1 } = l, { isOptionEnabled: L = void 0 } = l, { quiet: M = !1 } = l, { autoWidth: B = !1 } = l, { sort: j = !1 } = l, { tooltip: x = void 0 } = l, { tooltipMessage: N = void 0 } = l, { autocomplete: D = !1 } = l, { customPopoverHeight: V = void 0 } = l, { align: W = PopoverAlignment.Left } = l, { footer: F = void 0 } = l, { helpText: U = void 0 } = l, { compare: Y = void 0 } = l, { onOptionMouseenter: q = () => {
  } } = l, { onOptionMouseleave: Q = () => {
  } } = l, { loading: z = !1 } = l;
  const H = createEventDispatcher(), X = (ee) => {
    f(0, p = ee.detail), H("change", ee.detail);
  }, Z = (ee, ie) => ee && typeof ee == "object" ? ee[ie] : ee;
  function oe(ee) {
    bubble.call(this, u, ee);
  }
  return u.$$set = (ee) => {
    "value" in ee && f(0, p = ee.value), "label" in ee && f(1, m = ee.label), "disabled" in ee && f(2, b = ee.disabled), "readonly" in ee && f(3, y = ee.readonly), "labelPosition" in ee && f(4, v = ee.labelPosition), "error" in ee && f(5, k = ee.error), "placeholder" in ee && f(6, S = ee.placeholder), "options" in ee && f(7, $ = ee.options), "getOptionLabel" in ee && f(8, w = ee.getOptionLabel), "getOptionValue" in ee && f(9, T = ee.getOptionValue), "getOptionSubtitle" in ee && f(10, E = ee.getOptionSubtitle), "getOptionIcon" in ee && f(11, R = ee.getOptionIcon), "getOptionColour" in ee && f(12, O = ee.getOptionColour), "useOptionIconImage" in ee && f(13, P = ee.useOptionIconImage), "isOptionEnabled" in ee && f(14, L = ee.isOptionEnabled), "quiet" in ee && f(15, M = ee.quiet), "autoWidth" in ee && f(16, B = ee.autoWidth), "sort" in ee && f(17, j = ee.sort), "tooltip" in ee && f(18, x = ee.tooltip), "tooltipMessage" in ee && f(19, N = ee.tooltipMessage), "autocomplete" in ee && f(20, D = ee.autocomplete), "customPopoverHeight" in ee && f(21, V = ee.customPopoverHeight), "align" in ee && f(22, W = ee.align), "footer" in ee && f(23, F = ee.footer), "helpText" in ee && f(24, U = ee.helpText), "compare" in ee && f(25, Y = ee.compare), "onOptionMouseenter" in ee && f(26, q = ee.onOptionMouseenter), "onOptionMouseleave" in ee && f(27, Q = ee.onOptionMouseleave), "loading" in ee && f(28, z = ee.loading);
  }, [
    p,
    m,
    b,
    y,
    v,
    k,
    S,
    $,
    w,
    T,
    E,
    R,
    O,
    P,
    L,
    M,
    B,
    j,
    x,
    N,
    D,
    V,
    W,
    F,
    U,
    Y,
    q,
    Q,
    z,
    X,
    oe
  ];
}
class Select_1 extends SvelteComponent {
  constructor(l) {
    super(), init$1(
      this,
      l,
      instance$1n,
      create_fragment$1p,
      safe_not_equal,
      {
        value: 0,
        label: 1,
        disabled: 2,
        readonly: 3,
        labelPosition: 4,
        error: 5,
        placeholder: 6,
        options: 7,
        getOptionLabel: 8,
        getOptionValue: 9,
        getOptionSubtitle: 10,
        getOptionIcon: 11,
        getOptionColour: 12,
        useOptionIconImage: 13,
        isOptionEnabled: 14,
        quiet: 15,
        autoWidth: 16,
        sort: 17,
        tooltip: 18,
        tooltipMessage: 19,
        autocomplete: 20,
        customPopoverHeight: 21,
        align: 22,
        footer: 23,
        helpText: 24,
        compare: 25,
        onOptionMouseenter: 26,
        onOptionMouseleave: 27,
        loading: 28
      },
      null,
      [-1, -1]
    );
  }
}
var isoWeek$2 = { exports: {} };
(function(u, l) {
  (function(f, p) {
    u.exports = p();
  })(commonjsGlobal$1, function() {
    var f = "day";
    return function(p, m, b) {
      var y = function(S) {
        return S.add(4 - S.isoWeekday(), f);
      }, v = m.prototype;
      v.isoWeekYear = function() {
        return y(this).year();
      }, v.isoWeek = function(S) {
        if (!this.$utils().u(S))
          return this.add(7 * (S - this.isoWeek()), f);
        var $, w, T, E, R = y(this), O = ($ = this.isoWeekYear(), w = this.$u, T = (w ? b.utc : b)().year($).startOf("year"), E = 4 - T.isoWeekday(), T.isoWeekday() > 4 && (E += 7), T.add(E, f));
        return R.diff(O, "week") + 1;
      }, v.isoWeekday = function(S) {
        return this.$utils().u(S) ? this.day() || 7 : this.day(this.day() % 7 ? S : S - 7);
      };
      var k = v.startOf;
      v.startOf = function(S, $) {
        var w = this.$utils(), T = !!w.u($) || $;
        return w.p(S) === "isoweek" ? T ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : k.bind(this)(S, $);
      };
    };
  });
})(isoWeek$2);
var isoWeekExports = isoWeek$2.exports;
const isoWeek$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(isoWeekExports), Calendar_svelte_svelte_type_style_lang = "";
function get_each_context$e(u, l, f) {
  const p = u.slice();
  return p[16] = l[f], p;
}
function get_each_context_1$5(u, l, f) {
  const p = u.slice();
  p[19] = l[f];
  const m = (
    /*monday*/
    p[16].add(
      /*dayOffset*/
      p[19],
      "days"
    )
  );
  p[20] = m;
  const b = (
    /*date*/
    p[20].month() !== /*calendarDate*/
    p[1].month()
  );
  return p[21] = b, p;
}
function get_each_context_2(u, l, f) {
  const p = u.slice();
  return p[24] = l[f], p;
}
function create_each_block_2(u) {
  let l, f, p = (
    /*day*/
    u[24][0] + ""
  ), m, b;
  return {
    c() {
      l = element("th"), f = element("abbr"), m = text$2(p), b = space(), attr(f, "class", "spectrum-Calendar-dayOfWeek svelte-ixg9b0"), attr(
        f,
        "title",
        /*day*/
        u[24]
      ), attr(l, "scope", "col"), attr(l, "class", "spectrum-Calendar-tableCell svelte-ixg9b0");
    },
    m(y, v) {
      insert(y, l, v), append$1(l, f), append$1(f, m), append$1(l, b);
    },
    p: noop$4,
    d(y) {
      y && detach(l);
    }
  };
}
function create_each_block_1$5(u) {
  let l, f, p = (
    /*date*/
    u[20].date() + ""
  ), m, b, y, v;
  function k() {
    return (
      /*click_handler_2*/
      u[13](
        /*date*/
        u[20]
      )
    );
  }
  return {
    c() {
      l = element("td"), f = element("span"), m = text$2(p), attr(f, "role", "presentation"), attr(f, "class", "spectrum-Calendar-date svelte-ixg9b0"), toggle_class(
        f,
        "is-outsideMonth",
        /*outsideMonth*/
        u[21]
      ), toggle_class(f, "is-today", !/*outsideMonth*/
      u[21] && /*date*/
      u[20].isSame(
        /*now*/
        u[5],
        "day"
      )), toggle_class(
        f,
        "is-selected",
        /*date*/
        u[20].isSame(
          /*value*/
          u[0],
          "day"
        )
      ), attr(l, "class", "spectrum-Calendar-tableCell svelte-ixg9b0"), attr(l, "aria-disabled", "true"), attr(l, "aria-selected", "false"), attr(l, "aria-invalid", "false"), attr(l, "title", b = /*date*/
      u[20].format("dddd, MMMM D, YYYY"));
    },
    m(S, $) {
      insert(S, l, $), append$1(l, f), append$1(f, m), y || (v = listen(l, "click", k), y = !0);
    },
    p(S, $) {
      u = S, $ & /*mondays*/
      4 && p !== (p = /*date*/
      u[20].date() + "") && set_data(m, p), $ & /*mondays, calendarDate*/
      6 && toggle_class(
        f,
        "is-outsideMonth",
        /*outsideMonth*/
        u[21]
      ), $ & /*mondays, calendarDate, now*/
      38 && toggle_class(f, "is-today", !/*outsideMonth*/
      u[21] && /*date*/
      u[20].isSame(
        /*now*/
        u[5],
        "day"
      )), $ & /*mondays, value*/
      5 && toggle_class(
        f,
        "is-selected",
        /*date*/
        u[20].isSame(
          /*value*/
          u[0],
          "day"
        )
      ), $ & /*mondays*/
      4 && b !== (b = /*date*/
      u[20].format("dddd, MMMM D, YYYY")) && attr(l, "title", b);
    },
    d(S) {
      S && detach(l), y = !1, v();
    }
  };
}
function create_each_block$e(u) {
  let l, f, p = ensure_array_like([0, 1, 2, 3, 4, 5, 6]), m = [];
  for (let b = 0; b < 7; b += 1)
    m[b] = create_each_block_1$5(get_each_context_1$5(u, p, b));
  return {
    c() {
      l = element("tr");
      for (let b = 0; b < 7; b += 1)
        m[b].c();
      f = space(), attr(l, "class", "svelte-ixg9b0");
    },
    m(b, y) {
      insert(b, l, y);
      for (let v = 0; v < 7; v += 1)
        m[v] && m[v].m(l, null);
      append$1(l, f);
    },
    p(b, y) {
      if (y & /*mondays, handleDateChange, calendarDate, now, value*/
      167) {
        p = ensure_array_like([0, 1, 2, 3, 4, 5, 6]);
        let v;
        for (v = 0; v < 7; v += 1) {
          const k = get_each_context_1$5(b, p, v);
          m[v] ? m[v].p(k, y) : (m[v] = create_each_block_1$5(k), m[v].c(), m[v].m(l, f));
        }
        for (; v < 7; v += 1)
          m[v].d(1);
      }
    },
    d(b) {
      b && detach(l), destroy_each(m, b);
    }
  };
}
function create_fragment$1o(u) {
  let l, f, p, m, b, y, v, k, S, $, w, T, E, R, O, P, L, M, B, j, x, N, D;
  b = new Select_1({
    props: {
      autoWidth: !0,
      placeholder: null,
      options: (
        /*MonthsOfYear*/
        u[4].map(func$2)
      ),
      value: (
        /*calendarDate*/
        u[1].month()
      )
    }
  }), b.$on(
    "change",
    /*change_handler*/
    u[10]
  ), v = new NumberInput({
    props: {
      value: (
        /*calendarDate*/
        u[1].year()
      ),
      min: 0,
      max: 9999,
      width: 64
    }
  }), v.$on(
    "change",
    /*handleCalendarYearChange*/
    u[6]
  ), v.$on(
    "input",
    /*cleanYear*/
    u[8]
  ), $ = new Icon({
    props: {
      name: "caret-left",
      weight: "bold",
      size: "S"
    }
  }), E = new Icon({
    props: {
      name: "caret-right",
      weight: "bold",
      size: "S"
    }
  });
  let V = ensure_array_like(
    /*DaysOfWeek*/
    u[3]
  ), W = [];
  for (let Y = 0; Y < V.length; Y += 1)
    W[Y] = create_each_block_2(get_each_context_2(u, V, Y));
  let F = ensure_array_like(
    /*mondays*/
    u[2]
  ), U = [];
  for (let Y = 0; Y < F.length; Y += 1)
    U[Y] = create_each_block$e(get_each_context$e(u, F, Y));
  return {
    c() {
      l = element("div"), f = element("div"), p = element("div"), m = element("div"), create_component(b.$$.fragment), y = space(), create_component(v.$$.fragment), k = space(), S = element("button"), create_component($.$$.fragment), w = space(), T = element("button"), create_component(E.$$.fragment), R = space(), O = element("div"), P = element("table"), L = element("thead"), M = element("tr");
      for (let Y = 0; Y < W.length; Y += 1)
        W[Y].c();
      B = space(), j = element("tbody");
      for (let Y = 0; Y < U.length; Y += 1)
        U[Y].c();
      attr(m, "class", "month-selector svelte-ixg9b0"), attr(p, "class", "spectrum-Calendar-title svelte-ixg9b0"), attr(p, "aria-live", "assertive"), attr(p, "aria-atomic", "true"), attr(S, "aria-label", "Previous"), attr(S, "title", "Previous"), attr(S, "class", "spectrum-ActionButton spectrum-ActionButton--quiet spectrum-Calendar-prevMonth svelte-ixg9b0"), attr(T, "aria-label", "Next"), attr(T, "title", "Next"), attr(T, "class", "spectrum-ActionButton spectrum-ActionButton--quiet spectrum-Calendar-nextMonth svelte-ixg9b0"), attr(f, "class", "spectrum-Calendar-header svelte-ixg9b0"), attr(M, "class", "svelte-ixg9b0"), attr(L, "role", "presentation"), attr(j, "role", "presentation"), attr(P, "role", "presentation"), attr(P, "class", "spectrum-Calendar-table"), attr(O, "class", "spectrum-Calendar-body"), attr(O, "aria-readonly", "true"), attr(O, "aria-disabled", "false"), attr(l, "class", "spectrum-Calendar svelte-ixg9b0");
    },
    m(Y, q) {
      insert(Y, l, q), append$1(l, f), append$1(f, p), append$1(p, m), mount_component(b, m, null), append$1(p, y), mount_component(v, p, null), append$1(f, k), append$1(f, S), mount_component($, S, null), append$1(f, w), append$1(f, T), mount_component(E, T, null), append$1(l, R), append$1(l, O), append$1(O, P), append$1(P, L), append$1(L, M);
      for (let Q = 0; Q < W.length; Q += 1)
        W[Q] && W[Q].m(M, null);
      append$1(P, B), append$1(P, j);
      for (let Q = 0; Q < U.length; Q += 1)
        U[Q] && U[Q].m(j, null);
      x = !0, N || (D = [
        listen(
          S,
          "click",
          /*click_handler*/
          u[11]
        ),
        listen(
          T,
          "click",
          /*click_handler_1*/
          u[12]
        )
      ], N = !0);
    },
    p(Y, [q]) {
      const Q = {};
      q & /*calendarDate*/
      2 && (Q.value = /*calendarDate*/
      Y[1].month()), b.$set(Q);
      const z = {};
      if (q & /*calendarDate*/
      2 && (z.value = /*calendarDate*/
      Y[1].year()), v.$set(z), q & /*DaysOfWeek*/
      8) {
        V = ensure_array_like(
          /*DaysOfWeek*/
          Y[3]
        );
        let H;
        for (H = 0; H < V.length; H += 1) {
          const X = get_each_context_2(Y, V, H);
          W[H] ? W[H].p(X, q) : (W[H] = create_each_block_2(X), W[H].c(), W[H].m(M, null));
        }
        for (; H < W.length; H += 1)
          W[H].d(1);
        W.length = V.length;
      }
      if (q & /*mondays, handleDateChange, calendarDate, now, value*/
      167) {
        F = ensure_array_like(
          /*mondays*/
          Y[2]
        );
        let H;
        for (H = 0; H < F.length; H += 1) {
          const X = get_each_context$e(Y, F, H);
          U[H] ? U[H].p(X, q) : (U[H] = create_each_block$e(X), U[H].c(), U[H].m(j, null));
        }
        for (; H < U.length; H += 1)
          U[H].d(1);
        U.length = F.length;
      }
    },
    i(Y) {
      x || (transition_in(b.$$.fragment, Y), transition_in(v.$$.fragment, Y), transition_in($.$$.fragment, Y), transition_in(E.$$.fragment, Y), x = !0);
    },
    o(Y) {
      transition_out(b.$$.fragment, Y), transition_out(v.$$.fragment, Y), transition_out($.$$.fragment, Y), transition_out(E.$$.fragment, Y), x = !1;
    },
    d(Y) {
      Y && detach(l), destroy_component(b), destroy_component(v), destroy_component($), destroy_component(E), destroy_each(W, Y), destroy_each(U, Y), N = !1, run_all(D);
    }
  };
}
const func$2 = (u, l) => ({ label: u, value: l });
function instance$1m(u, l, f) {
  let p;
  dayjs.extend(isoWeek$1);
  let { value: m } = l;
  const b = createEventDispatcher(), y = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], v = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ], k = dayjs();
  let S;
  const $ = (B) => {
    if (!(B != null && B.isValid()))
      return [];
    let j = B.endOf("month"), x = B.startOf("isoWeek");
    const N = Math.ceil((j.diff(x, "day") + 1) / 7);
    let D = [];
    for (let V = 0; V < N; V++)
      D.push(x.add(V, "weeks"));
    return D;
  }, w = (B) => {
    f(1, S = S.year(parseInt(B.target.value)));
  }, T = (B) => {
    b("change", (m || k).year(B.year()).month(B.month()).date(B.date()));
  }, E = (B) => {
    f(1, S = B);
  }, R = cleanInput({ max: 9999, pad: 0, fallback: k.year() }), O = (B) => f(1, S = S.month(B.detail)), P = () => f(1, S = S.subtract(1, "month")), L = () => f(1, S = S.add(1, "month")), M = (B) => T(B);
  return u.$$set = (B) => {
    "value" in B && f(0, m = B.value);
  }, u.$$.update = () => {
    u.$$.dirty & /*value*/
    1 && f(1, S = dayjs(m || dayjs()).startOf("month")), u.$$.dirty & /*calendarDate*/
    2 && f(2, p = $(S));
  }, [
    m,
    S,
    p,
    y,
    v,
    k,
    w,
    T,
    R,
    E,
    O,
    P,
    L,
    M
  ];
}
class Calendar extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1m, create_fragment$1o, safe_not_equal, { value: 0, setDate: 9 });
  }
  get setDate() {
    return this.$$.ctx[9];
  }
}
const indexVars$p = "", Tooltip_svelte_svelte_type_style_lang = "";
function create_else_block$f(u) {
  let l, f, p, m, b, y, v, k, S;
  const $ = (
    /*#slots*/
    u[4].default
  ), w = create_slot(
    $,
    u,
    /*$$scope*/
    u[3],
    null
  );
  return {
    c() {
      l = element("span"), w && w.c(), f = space(), p = element("div"), m = element("span"), b = text$2(
        /*text*/
        u[1]
      ), y = space(), v = element("span"), attr(m, "class", "spectrum-Tooltip-label svelte-12iylyn"), attr(v, "class", "spectrum-Tooltip-tip svelte-12iylyn"), attr(p, "class", k = null_to_empty(`spectrum-Tooltip spectrum-Tooltip--${/*direction*/
      u[0]}`) + " svelte-12iylyn"), attr(l, "class", "u-tooltip-showOnHover tooltip svelte-12iylyn");
    },
    m(T, E) {
      insert(T, l, E), w && w.m(l, null), append$1(l, f), append$1(l, p), append$1(p, m), append$1(m, b), append$1(p, y), append$1(p, v), S = !0;
    },
    p(T, E) {
      w && w.p && (!S || E & /*$$scope*/
      8) && update_slot_base(
        w,
        $,
        T,
        /*$$scope*/
        T[3],
        S ? get_slot_changes(
          $,
          /*$$scope*/
          T[3],
          E,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          T[3]
        ),
        null
      ), (!S || E & /*text*/
      2) && set_data(
        b,
        /*text*/
        T[1]
      ), (!S || E & /*direction*/
      1 && k !== (k = null_to_empty(`spectrum-Tooltip spectrum-Tooltip--${/*direction*/
      T[0]}`) + " svelte-12iylyn")) && attr(p, "class", k);
    },
    i(T) {
      S || (transition_in(w, T), S = !0);
    },
    o(T) {
      transition_out(w, T), S = !1;
    },
    d(T) {
      T && detach(l), w && w.d(T);
    }
  };
}
function create_if_block$K(u) {
  let l, f, p, m, b, y;
  return {
    c() {
      l = element("span"), f = element("span"), p = text$2(
        /*text*/
        u[1]
      ), m = space(), b = element("span"), attr(f, "class", "spectrum-Tooltip-label svelte-12iylyn"), attr(b, "class", "spectrum-Tooltip-tip svelte-12iylyn"), attr(l, "class", y = "spectrum-Tooltip spectrum-Tooltip--" + /*direction*/
      u[0] + " is-open tooltip svelte-12iylyn");
    },
    m(v, k) {
      insert(v, l, k), append$1(l, f), append$1(f, p), append$1(l, m), append$1(l, b);
    },
    p(v, k) {
      k & /*text*/
      2 && set_data(
        p,
        /*text*/
        v[1]
      ), k & /*direction*/
      1 && y !== (y = "spectrum-Tooltip spectrum-Tooltip--" + /*direction*/
      v[0] + " is-open tooltip svelte-12iylyn") && attr(l, "class", y);
    },
    i: noop$4,
    o: noop$4,
    d(v) {
      v && detach(l);
    }
  };
}
function create_fragment$1n(u) {
  let l, f, p, m;
  const b = [create_if_block$K, create_else_block$f], y = [];
  function v(k, S) {
    return (
      /*textWrapping*/
      k[2] ? 0 : 1
    );
  }
  return l = v(u), f = y[l] = b[l](u), {
    c() {
      f.c(), p = empty$1();
    },
    m(k, S) {
      y[l].m(k, S), insert(k, p, S), m = !0;
    },
    p(k, [S]) {
      let $ = l;
      l = v(k), l === $ ? y[l].p(k, S) : (group_outros(), transition_out(y[$], 1, 1, () => {
        y[$] = null;
      }), check_outros(), f = y[l], f ? f.p(k, S) : (f = y[l] = b[l](k), f.c()), transition_in(f, 1), f.m(p.parentNode, p));
    },
    i(k) {
      m || (transition_in(f), m = !0);
    },
    o(k) {
      transition_out(f), m = !1;
    },
    d(k) {
      k && detach(p), y[l].d(k);
    }
  };
}
function instance$1l(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l, { direction: b = "top" } = l, { text: y = "" } = l, { textWrapping: v = !1 } = l;
  return u.$$set = (k) => {
    "direction" in k && f(0, b = k.direction), "text" in k && f(1, y = k.text), "textWrapping" in k && f(2, v = k.textWrapping), "$$scope" in k && f(3, m = k.$$scope);
  }, [b, y, v, m, p];
}
class Tooltip extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1l, create_fragment$1n, safe_not_equal, { direction: 0, text: 1, textWrapping: 2 });
  }
}
const ActionButton_svelte_svelte_type_style_lang = "";
function create_if_block_2$i(u) {
  let l, f;
  return l = new Icon({
    props: {
      name: (
        /*icon*/
        u[3]
      ),
      size: (
        /*size*/
        u[4]
      ),
      color: `var(--spectrum-global-color-gray-${/*$$slots*/
      u[12].default ? 600 : 700})`
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*icon*/
      8 && (b.name = /*icon*/
      p[3]), m & /*size*/
      16 && (b.size = /*size*/
      p[4]), m & /*$$slots*/
      4096 && (b.color = `var(--spectrum-global-color-gray-${/*$$slots*/
      p[12].default ? 600 : 700})`), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_1$o(u) {
  let l, f;
  const p = (
    /*#slots*/
    u[14].default
  ), m = create_slot(
    p,
    u,
    /*$$scope*/
    u[13],
    null
  );
  return {
    c() {
      l = element("span"), m && m.c(), attr(l, "class", "spectrum-ActionButton-label svelte-1v8ll3t");
    },
    m(b, y) {
      insert(b, l, y), m && m.m(l, null), f = !0;
    },
    p(b, y) {
      m && m.p && (!f || y & /*$$scope*/
      8192) && update_slot_base(
        m,
        p,
        b,
        /*$$scope*/
        b[13],
        f ? get_slot_changes(
          p,
          /*$$scope*/
          b[13],
          y,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          b[13]
        ),
        null
      );
    },
    i(b) {
      f || (transition_in(m, b), f = !0);
    },
    o(b) {
      transition_out(m, b), f = !1;
    },
    d(b) {
      b && detach(l), m && m.d(b);
    }
  };
}
function create_if_block$J(u) {
  let l, f, p, m;
  return f = new Tooltip({
    props: {
      textWrapping: !0,
      direction: "bottom",
      text: (
        /*tooltip*/
        u[8]
      )
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "tooltip svelte-1v8ll3t");
    },
    m(b, y) {
      insert(b, l, y), mount_component(f, l, null), m = !0;
    },
    p(b, y) {
      const v = {};
      y & /*tooltip*/
      256 && (v.text = /*tooltip*/
      b[8]), f.$set(v);
    },
    i(b) {
      m || (transition_in(f.$$.fragment, b), b && (p || add_render_callback(() => {
        p = create_in_transition(l, fade, { duration: 130, delay: 250 }), p.start();
      })), m = !0);
    },
    o(b) {
      transition_out(f.$$.fragment, b), m = !1;
    },
    d(b) {
      b && detach(l), destroy_component(f);
    }
  };
}
function create_fragment$1m(u) {
  let l, f, p, m, b, y, v, k = (
    /*icon*/
    u[3] && create_if_block_2$i(u)
  ), S = (
    /*$$slots*/
    u[12] && create_if_block_1$o(u)
  ), $ = (
    /*tooltip*/
    u[8] && /*showTooltip*/
    u[10] && create_if_block$J(u)
  );
  return {
    c() {
      l = element("button"), k && k.c(), f = space(), S && S.c(), p = space(), $ && $.c(), attr(l, "class", m = "spectrum-ActionButton spectrum-ActionButton--size" + /*size*/
      u[4] + " svelte-1v8ll3t"), l.disabled = /*disabled*/
      u[2], attr(
        l,
        "style",
        /*accentStyle*/
        u[11]
      ), toggle_class(
        l,
        "spectrum-ActionButton--quiet",
        /*quiet*/
        u[0]
      ), toggle_class(
        l,
        "is-selected",
        /*selected*/
        u[1]
      ), toggle_class(
        l,
        "noPadding",
        /*noPadding*/
        u[7]
      ), toggle_class(
        l,
        "fullWidth",
        /*fullWidth*/
        u[6]
      ), toggle_class(
        l,
        "active",
        /*active*/
        u[5]
      ), toggle_class(
        l,
        "disabled",
        /*disabled*/
        u[2]
      ), toggle_class(
        l,
        "accent",
        /*accentColor*/
        u[9] != null
      );
    },
    m(w, T) {
      insert(w, l, T), k && k.m(l, null), append$1(l, f), S && S.m(l, null), append$1(l, p), $ && $.m(l, null), b = !0, y || (v = [
        listen(l, "click", prevent_default(
          /*click_handler*/
          u[15]
        )),
        listen(
          l,
          "mouseover",
          /*mouseover_handler*/
          u[16]
        ),
        listen(
          l,
          "mouseleave",
          /*mouseleave_handler*/
          u[17]
        ),
        listen(
          l,
          "focus",
          /*focus_handler*/
          u[18]
        )
      ], y = !0);
    },
    p(w, [T]) {
      /*icon*/
      w[3] ? k ? (k.p(w, T), T & /*icon*/
      8 && transition_in(k, 1)) : (k = create_if_block_2$i(w), k.c(), transition_in(k, 1), k.m(l, f)) : k && (group_outros(), transition_out(k, 1, 1, () => {
        k = null;
      }), check_outros()), /*$$slots*/
      w[12] ? S ? (S.p(w, T), T & /*$$slots*/
      4096 && transition_in(S, 1)) : (S = create_if_block_1$o(w), S.c(), transition_in(S, 1), S.m(l, p)) : S && (group_outros(), transition_out(S, 1, 1, () => {
        S = null;
      }), check_outros()), /*tooltip*/
      w[8] && /*showTooltip*/
      w[10] ? $ ? ($.p(w, T), T & /*tooltip, showTooltip*/
      1280 && transition_in($, 1)) : ($ = create_if_block$J(w), $.c(), transition_in($, 1), $.m(l, null)) : $ && (group_outros(), transition_out($, 1, 1, () => {
        $ = null;
      }), check_outros()), (!b || T & /*size*/
      16 && m !== (m = "spectrum-ActionButton spectrum-ActionButton--size" + /*size*/
      w[4] + " svelte-1v8ll3t")) && attr(l, "class", m), (!b || T & /*disabled*/
      4) && (l.disabled = /*disabled*/
      w[2]), (!b || T & /*accentStyle*/
      2048) && attr(
        l,
        "style",
        /*accentStyle*/
        w[11]
      ), (!b || T & /*size, quiet*/
      17) && toggle_class(
        l,
        "spectrum-ActionButton--quiet",
        /*quiet*/
        w[0]
      ), (!b || T & /*size, selected*/
      18) && toggle_class(
        l,
        "is-selected",
        /*selected*/
        w[1]
      ), (!b || T & /*size, noPadding*/
      144) && toggle_class(
        l,
        "noPadding",
        /*noPadding*/
        w[7]
      ), (!b || T & /*size, fullWidth*/
      80) && toggle_class(
        l,
        "fullWidth",
        /*fullWidth*/
        w[6]
      ), (!b || T & /*size, active*/
      48) && toggle_class(
        l,
        "active",
        /*active*/
        w[5]
      ), (!b || T & /*size, disabled*/
      20) && toggle_class(
        l,
        "disabled",
        /*disabled*/
        w[2]
      ), (!b || T & /*size, accentColor*/
      528) && toggle_class(
        l,
        "accent",
        /*accentColor*/
        w[9] != null
      );
    },
    i(w) {
      b || (transition_in(k), transition_in(S), transition_in($), b = !0);
    },
    o(w) {
      transition_out(k), transition_out(S), transition_out($), b = !1;
    },
    d(w) {
      w && detach(l), k && k.d(), S && S.d(), $ && $.d(), y = !1, run_all(v);
    }
  };
}
function instance$1k(u, l, f) {
  let p, { $$slots: m = {}, $$scope: b } = l;
  const y = compute_slots(m);
  let { quiet: v = !1 } = l, { selected: k = !1 } = l, { disabled: S = !1 } = l, { icon: $ = "" } = l, { size: w = "M" } = l, { active: T = !1 } = l, { fullWidth: E = !1 } = l, { noPadding: R = !1 } = l, { tooltip: O = "" } = l, { accentColor: P = null } = l, L = !1;
  const M = (D) => {
    if (!D)
      return "";
    D.startsWith("rgba") || (D = D.startsWith("rgb") ? `${D.substring(0, D.length - 1)}, 0.2)` : hexToRGBA(D, 0.2));
    let V = "";
    return V += `--accent-bg-color:${D};`, V += `--accent-border-color:${D};`, V;
  };
  function B(D) {
    bubble.call(this, u, D);
  }
  const j = () => f(10, L = !0), x = () => f(10, L = !1), N = () => f(10, L = !0);
  return u.$$set = (D) => {
    "quiet" in D && f(0, v = D.quiet), "selected" in D && f(1, k = D.selected), "disabled" in D && f(2, S = D.disabled), "icon" in D && f(3, $ = D.icon), "size" in D && f(4, w = D.size), "active" in D && f(5, T = D.active), "fullWidth" in D && f(6, E = D.fullWidth), "noPadding" in D && f(7, R = D.noPadding), "tooltip" in D && f(8, O = D.tooltip), "accentColor" in D && f(9, P = D.accentColor), "$$scope" in D && f(13, b = D.$$scope);
  }, u.$$.update = () => {
    u.$$.dirty & /*accentColor*/
    512 && f(11, p = M(P));
  }, [
    v,
    k,
    S,
    $,
    w,
    T,
    E,
    R,
    O,
    P,
    L,
    p,
    y,
    b,
    m,
    B,
    j,
    x,
    N
  ];
}
class ActionButton extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1k, create_fragment$1m, safe_not_equal, {
      quiet: 0,
      selected: 1,
      disabled: 2,
      icon: 3,
      size: 4,
      active: 5,
      fullWidth: 6,
      noPadding: 7,
      tooltip: 8,
      accentColor: 9
    });
  }
}
const DatePickerPopoverContents_svelte_svelte_type_style_lang = "";
function create_if_block_1$n(u) {
  let l, f, p = { value: (
    /*value*/
    u[0]
  ) };
  return l = new Calendar({ props: p }), u[11](l), l.$on(
    "change",
    /*change_handler*/
    u[12]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(m, b) {
      mount_component(l, m, b), f = !0;
    },
    p(m, b) {
      const y = {};
      b & /*value*/
      1 && (y.value = /*value*/
      m[0]), l.$set(y);
    },
    i(m) {
      f || (transition_in(l.$$.fragment, m), f = !0);
    },
    o(m) {
      transition_out(l.$$.fragment, m), f = !1;
    },
    d(m) {
      u[11](null), destroy_component(l, m);
    }
  };
}
function create_if_block$I(u) {
  let l, f;
  return l = new TimePicker({ props: { value: (
    /*value*/
    u[0]
  ) } }), l.$on(
    "change",
    /*change_handler_1*/
    u[13]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*value*/
      1 && (b.value = /*value*/
      p[0]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_1$h(u) {
  let l;
  return {
    c() {
      l = text$2("Clear");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot$H(u) {
  let l = (
    /*showTime*/
    u[2] ? "Now" : "Today"
  ), f;
  return {
    c() {
      f = text$2(l);
    },
    m(p, m) {
      insert(p, f, m);
    },
    p(p, m) {
      m & /*showTime*/
      4 && l !== (l = /*showTime*/
      p[2] ? "Now" : "Today") && set_data(f, l);
    },
    d(p) {
      p && detach(f);
    }
  };
}
function create_fragment$1l(u) {
  let l, f, p, m, b, y, v, k, S, $ = (
    /*showCalendar*/
    u[3] && create_if_block_1$n(u)
  ), w = (
    /*showTime*/
    u[2] && create_if_block$I(u)
  );
  return y = new ActionButton({
    props: {
      disabled: !/*value*/
      u[0],
      size: "S",
      $$slots: { default: [create_default_slot_1$h] },
      $$scope: { ctx: u }
    }
  }), y.$on(
    "click",
    /*click_handler*/
    u[14]
  ), k = new ActionButton({
    props: {
      size: "S",
      $$slots: { default: [create_default_slot$H] },
      $$scope: { ctx: u }
    }
  }), k.$on(
    "click",
    /*setToNow*/
    u[5]
  ), {
    c() {
      l = element("div"), $ && $.c(), f = space(), p = element("div"), w && w.c(), m = space(), b = element("div"), create_component(y.$$.fragment), v = space(), create_component(k.$$.fragment), attr(b, "class", "actions svelte-1ds30rz"), attr(p, "class", "footer svelte-1ds30rz"), toggle_class(
        p,
        "spaced",
        /*showCalendar*/
        u[3]
      ), attr(l, "class", "date-time-popover svelte-1ds30rz");
    },
    m(T, E) {
      insert(T, l, E), $ && $.m(l, null), append$1(l, f), append$1(l, p), w && w.m(p, null), append$1(p, m), append$1(p, b), mount_component(y, b, null), append$1(b, v), mount_component(k, b, null), S = !0;
    },
    p(T, [E]) {
      /*showCalendar*/
      T[3] ? $ ? ($.p(T, E), E & /*showCalendar*/
      8 && transition_in($, 1)) : ($ = create_if_block_1$n(T), $.c(), transition_in($, 1), $.m(l, f)) : $ && (group_outros(), transition_out($, 1, 1, () => {
        $ = null;
      }), check_outros()), /*showTime*/
      T[2] ? w ? (w.p(T, E), E & /*showTime*/
      4 && transition_in(w, 1)) : (w = create_if_block$I(T), w.c(), transition_in(w, 1), w.m(p, m)) : w && (group_outros(), transition_out(w, 1, 1, () => {
        w = null;
      }), check_outros());
      const R = {};
      E & /*value*/
      1 && (R.disabled = !/*value*/
      T[0]), E & /*$$scope*/
      65536 && (R.$$scope = { dirty: E, ctx: T }), y.$set(R);
      const O = {};
      E & /*$$scope, showTime*/
      65540 && (O.$$scope = { dirty: E, ctx: T }), k.$set(O), (!S || E & /*showCalendar*/
      8) && toggle_class(
        p,
        "spaced",
        /*showCalendar*/
        T[3]
      );
    },
    i(T) {
      S || (transition_in($), transition_in(w), transition_in(y.$$.fragment, T), transition_in(k.$$.fragment, T), S = !0);
    },
    o(T) {
      transition_out($), transition_out(w), transition_out(y.$$.fragment, T), transition_out(k.$$.fragment, T), S = !1;
    },
    d(T) {
      T && detach(l), $ && $.d(), w && w.d(), destroy_component(y), destroy_component(k);
    }
  };
}
function instance$1j(u, l, f) {
  let p, m, { useKeyboardShortcuts: b = !0 } = l, { ignoreTimezones: y } = l, { enableTime: v } = l, { timeOnly: k } = l, { value: S } = l;
  const $ = createEventDispatcher();
  let w;
  const T = () => {
    const B = dayjs();
    w == null || w.setDate(B), E(B);
  }, E = (B) => {
    $("change", stringifyDate(B, { enableTime: v, timeOnly: k, ignoreTimezones: y }));
  }, R = (B) => {
    var j;
    ((j = document.activeElement) == null ? void 0 : j.tagName.toLowerCase()) !== "input" && ["Backspace", "Clear", "Delete"].includes(B.key) && $("change", null);
  };
  onMount(() => (b && document.addEventListener("keyup", R), () => {
    document.removeEventListener("keyup", R);
  }));
  function O(B) {
    binding_callbacks[B ? "unshift" : "push"](() => {
      w = B, f(1, w);
    });
  }
  const P = (B) => E(B.detail), L = (B) => E(B.detail), M = () => $("change", null);
  return u.$$set = (B) => {
    "useKeyboardShortcuts" in B && f(7, b = B.useKeyboardShortcuts), "ignoreTimezones" in B && f(8, y = B.ignoreTimezones), "enableTime" in B && f(9, v = B.enableTime), "timeOnly" in B && f(10, k = B.timeOnly), "value" in B && f(0, S = B.value);
  }, u.$$.update = () => {
    u.$$.dirty & /*timeOnly*/
    1024 && f(3, p = !k), u.$$.dirty & /*enableTime, timeOnly*/
    1536 && f(2, m = v || k);
  }, [
    S,
    w,
    m,
    p,
    $,
    T,
    E,
    b,
    y,
    v,
    k,
    O,
    P,
    L,
    M
  ];
}
class DatePickerPopoverContents extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1j, create_fragment$1l, safe_not_equal, {
      useKeyboardShortcuts: 7,
      ignoreTimezones: 8,
      enableTime: 9,
      timeOnly: 10,
      value: 0
    });
  }
}
const DateRangePicker_svelte_svelte_type_style_lang = "", indexVars$o = "", indexVars$n = "", indexVars$m = "", indexVars$l = "", Link_svelte_svelte_type_style_lang = "";
function create_if_block$H(u) {
  let l, f, p;
  return f = new Tooltip({
    props: {
      textWrapping: !0,
      direction: "bottom",
      text: (
        /*tooltip*/
        u[9]
      )
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "tooltip svelte-171sey2");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b & /*tooltip*/
      512 && (y.text = /*tooltip*/
      m[9]), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_fragment$1k(u) {
  let l, f, p, m, b, y;
  const v = (
    /*#slots*/
    u[12].default
  ), k = create_slot(
    v,
    u,
    /*$$scope*/
    u[11],
    null
  );
  let S = (
    /*tooltip*/
    u[9] && create_if_block$H(u)
  );
  return {
    c() {
      l = element("a"), k && k.c(), f = space(), S && S.c(), attr(
        l,
        "href",
        /*href*/
        u[0]
      ), attr(
        l,
        "target",
        /*target*/
        u[6]
      ), attr(
        l,
        "download",
        /*download*/
        u[7]
      ), attr(l, "class", p = "spectrum-Link spectrum-Link--size" + /*size*/
      u[1] + " svelte-171sey2"), toggle_class(
        l,
        "disabled",
        /*disabled*/
        u[8]
      ), toggle_class(
        l,
        "spectrum-Link--primary",
        /*primary*/
        u[3]
      ), toggle_class(
        l,
        "spectrum-Link--secondary",
        /*secondary*/
        u[4]
      ), toggle_class(
        l,
        "spectrum-Link--overBackground",
        /*overBackground*/
        u[5]
      ), toggle_class(
        l,
        "spectrum-Link--quiet",
        /*quiet*/
        u[2]
      );
    },
    m($, w) {
      insert($, l, w), k && k.m(l, null), append$1(l, f), S && S.m(l, null), m = !0, b || (y = listen(
        l,
        "click",
        /*onClick*/
        u[10]
      ), b = !0);
    },
    p($, [w]) {
      k && k.p && (!m || w & /*$$scope*/
      2048) && update_slot_base(
        k,
        v,
        $,
        /*$$scope*/
        $[11],
        m ? get_slot_changes(
          v,
          /*$$scope*/
          $[11],
          w,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          $[11]
        ),
        null
      ), /*tooltip*/
      $[9] ? S ? (S.p($, w), w & /*tooltip*/
      512 && transition_in(S, 1)) : (S = create_if_block$H($), S.c(), transition_in(S, 1), S.m(l, null)) : S && (group_outros(), transition_out(S, 1, 1, () => {
        S = null;
      }), check_outros()), (!m || w & /*href*/
      1) && attr(
        l,
        "href",
        /*href*/
        $[0]
      ), (!m || w & /*target*/
      64) && attr(
        l,
        "target",
        /*target*/
        $[6]
      ), (!m || w & /*download*/
      128) && attr(
        l,
        "download",
        /*download*/
        $[7]
      ), (!m || w & /*size*/
      2 && p !== (p = "spectrum-Link spectrum-Link--size" + /*size*/
      $[1] + " svelte-171sey2")) && attr(l, "class", p), (!m || w & /*size, disabled*/
      258) && toggle_class(
        l,
        "disabled",
        /*disabled*/
        $[8]
      ), (!m || w & /*size, primary*/
      10) && toggle_class(
        l,
        "spectrum-Link--primary",
        /*primary*/
        $[3]
      ), (!m || w & /*size, secondary*/
      18) && toggle_class(
        l,
        "spectrum-Link--secondary",
        /*secondary*/
        $[4]
      ), (!m || w & /*size, overBackground*/
      34) && toggle_class(
        l,
        "spectrum-Link--overBackground",
        /*overBackground*/
        $[5]
      ), (!m || w & /*size, quiet*/
      6) && toggle_class(
        l,
        "spectrum-Link--quiet",
        /*quiet*/
        $[2]
      );
    },
    i($) {
      m || (transition_in(k, $), transition_in(S), m = !0);
    },
    o($) {
      transition_out(k, $), transition_out(S), m = !1;
    },
    d($) {
      $ && detach(l), k && k.d($), S && S.d(), b = !1, y();
    }
  };
}
function instance$1i(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l, { href: b = "#" } = l, { size: y = "M" } = l, { quiet: v = !1 } = l, { primary: k = !1 } = l, { secondary: S = !1 } = l, { overBackground: $ = !1 } = l, { target: w = void 0 } = l, { download: T = void 0 } = l, { disabled: E = !1 } = l, { tooltip: R = null } = l;
  const O = createEventDispatcher(), P = () => {
    E || O("click");
  };
  return u.$$set = (L) => {
    "href" in L && f(0, b = L.href), "size" in L && f(1, y = L.size), "quiet" in L && f(2, v = L.quiet), "primary" in L && f(3, k = L.primary), "secondary" in L && f(4, S = L.secondary), "overBackground" in L && f(5, $ = L.overBackground), "target" in L && f(6, w = L.target), "download" in L && f(7, T = L.download), "disabled" in L && f(8, E = L.disabled), "tooltip" in L && f(9, R = L.tooltip), "$$scope" in L && f(11, m = L.$$scope);
  }, [
    b,
    y,
    v,
    k,
    S,
    $,
    w,
    T,
    E,
    R,
    P,
    m,
    p
  ];
}
class Link extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1i, create_fragment$1k, safe_not_equal, {
      href: 0,
      size: 1,
      quiet: 2,
      primary: 3,
      secondary: 4,
      overBackground: 5,
      target: 6,
      download: 7,
      disabled: 8,
      tooltip: 9
    });
  }
}
const Dropzone_svelte_svelte_type_style_lang = "";
function get_each_context$d(u, l, f) {
  const p = u.slice();
  return p[37] = l[f], p;
}
function get_each_context_1$4(u, l, f) {
  const p = u.slice();
  return p[40] = l[f], p;
}
function create_if_block_6$4(u) {
  let l, f, p, m;
  const b = [create_if_block_7$4, create_if_block_14], y = [];
  function v(k, S) {
    var $;
    return (
      /*gallery*/
      k[3] ? 0 : (
        /*value*/
        ($ = k[0]) != null && $.length ? 1 : -1
      )
    );
  }
  return ~(l = v(u)) && (f = y[l] = b[l](u)), {
    c() {
      f && f.c(), p = empty$1();
    },
    m(k, S) {
      ~l && y[l].m(k, S), insert(k, p, S), m = !0;
    },
    p(k, S) {
      let $ = l;
      l = v(k), l === $ ? ~l && y[l].p(k, S) : (f && (group_outros(), transition_out(y[$], 1, 1, () => {
        y[$] = null;
      }), check_outros()), ~l ? (f = y[l], f ? f.p(k, S) : (f = y[l] = b[l](k), f.c()), transition_in(f, 1), f.m(p.parentNode, p)) : f = null);
    },
    i(k) {
      m || (transition_in(f), m = !0);
    },
    o(k) {
      transition_out(f), m = !1;
    },
    d(k) {
      k && detach(p), ~l && y[l].d(k);
    }
  };
}
function create_if_block_14(u) {
  let l, f, p = ensure_array_like(
    /*value*/
    u[0]
  ), m = [];
  for (let y = 0; y < p.length; y += 1)
    m[y] = create_each_block_1$4(get_each_context_1$4(u, p, y));
  const b = (y) => transition_out(m[y], 1, 1, () => {
    m[y] = null;
  });
  return {
    c() {
      for (let y = 0; y < m.length; y += 1)
        m[y].c();
      l = empty$1();
    },
    m(y, v) {
      for (let k = 0; k < m.length; k += 1)
        m[k] && m[k].m(y, v);
      insert(y, l, v), f = !0;
    },
    p(y, v) {
      if (v[0] & /*removeFile, disabled, value*/
      1048579) {
        p = ensure_array_like(
          /*value*/
          y[0]
        );
        let k;
        for (k = 0; k < p.length; k += 1) {
          const S = get_each_context_1$4(y, p, k);
          m[k] ? (m[k].p(S, v), transition_in(m[k], 1)) : (m[k] = create_each_block_1$4(S), m[k].c(), transition_in(m[k], 1), m[k].m(l.parentNode, l));
        }
        for (group_outros(), k = p.length; k < m.length; k += 1)
          b(k);
        check_outros();
      }
    },
    i(y) {
      if (!f) {
        for (let v = 0; v < p.length; v += 1)
          transition_in(m[v]);
        f = !0;
      }
    },
    o(y) {
      m = m.filter(Boolean);
      for (let v = 0; v < m.length; v += 1)
        transition_out(m[v]);
      f = !1;
    },
    d(y) {
      y && detach(l), destroy_each(m, y);
    }
  };
}
function create_if_block_7$4(u) {
  let l, f, p, m, b, y, v, k, S, $, w, T, E, R, O, P, L, M;
  const B = [create_if_block_13$1, create_else_block_2], j = [];
  function x(Y, q) {
    return (
      /*selectedUrl*/
      Y[14] ? 0 : 1
    );
  }
  m = x(u), b = j[m] = B[m](u);
  let N = (
    /*selectedImage*/
    u[11].size && create_if_block_11$1(u)
  ), D = !/*disabled*/
  u[1] && create_if_block_10$2(u);
  function V(Y, q) {
    return (
      /*isImage*/
      Y[12] ? create_if_block_9$2 : create_else_block$e
    );
  }
  let W = V(u), F = W(u);
  w = new Icon({ props: { name: "caret-left" } }), R = new Icon({ props: { name: "caret-right" } });
  let U = (
    /*maximum*/
    u[5] !== 1 && create_if_block_8$2(u)
  );
  return {
    c() {
      l = element("div"), f = element("div"), p = element("div"), b.c(), y = space(), N && N.c(), v = space(), D && D.c(), k = space(), F.c(), S = space(), $ = element("div"), create_component(w.$$.fragment), T = space(), E = element("div"), create_component(R.$$.fragment), O = space(), U && U.c(), attr(p, "class", "filename svelte-1wflao9"), attr(f, "class", "title svelte-1wflao9"), attr($, "class", "nav left svelte-1wflao9"), toggle_class(
        $,
        "visible",
        /*selectedImageIdx*/
        u[10] > 0
      ), attr(E, "class", "nav right svelte-1wflao9"), toggle_class(
        E,
        "visible",
        /*selectedImageIdx*/
        u[10] < /*fileCount*/
        u[18] - 1
      ), attr(l, "class", "gallery svelte-1wflao9");
    },
    m(Y, q) {
      insert(Y, l, q), append$1(l, f), append$1(f, p), j[m].m(p, null), append$1(f, y), N && N.m(f, null), append$1(f, v), D && D.m(f, null), append$1(l, k), F.m(l, null), append$1(l, S), append$1(l, $), mount_component(w, $, null), append$1(l, T), append$1(l, E), mount_component(R, E, null), append$1(l, O), U && U.m(l, null), P = !0, L || (M = [
        listen(
          $,
          "click",
          /*navigateLeft*/
          u[21]
        ),
        listen(
          E,
          "click",
          /*navigateRight*/
          u[22]
        )
      ], L = !0);
    },
    p(Y, q) {
      let Q = m;
      m = x(Y), m === Q ? j[m].p(Y, q) : (group_outros(), transition_out(j[Q], 1, 1, () => {
        j[Q] = null;
      }), check_outros(), b = j[m], b ? b.p(Y, q) : (b = j[m] = B[m](Y), b.c()), transition_in(b, 1), b.m(p, null)), /*selectedImage*/
      Y[11].size ? N ? N.p(Y, q) : (N = create_if_block_11$1(Y), N.c(), N.m(f, v)) : N && (N.d(1), N = null), /*disabled*/
      Y[1] ? D && (group_outros(), transition_out(D, 1, 1, () => {
        D = null;
      }), check_outros()) : D ? (D.p(Y, q), q[0] & /*disabled*/
      2 && transition_in(D, 1)) : (D = create_if_block_10$2(Y), D.c(), transition_in(D, 1), D.m(f, null)), W === (W = V(Y)) && F ? F.p(Y, q) : (F.d(1), F = W(Y), F && (F.c(), F.m(l, S))), (!P || q[0] & /*selectedImageIdx*/
      1024) && toggle_class(
        $,
        "visible",
        /*selectedImageIdx*/
        Y[10] > 0
      ), (!P || q[0] & /*selectedImageIdx, fileCount*/
      263168) && toggle_class(
        E,
        "visible",
        /*selectedImageIdx*/
        Y[10] < /*fileCount*/
        Y[18] - 1
      ), /*maximum*/
      Y[5] !== 1 ? U ? U.p(Y, q) : (U = create_if_block_8$2(Y), U.c(), U.m(l, null)) : U && (U.d(1), U = null);
    },
    i(Y) {
      P || (transition_in(b), transition_in(D), transition_in(w.$$.fragment, Y), transition_in(R.$$.fragment, Y), P = !0);
    },
    o(Y) {
      transition_out(b), transition_out(D), transition_out(w.$$.fragment, Y), transition_out(R.$$.fragment, Y), P = !1;
    },
    d(Y) {
      Y && detach(l), j[m].d(), N && N.d(), D && D.d(), F.d(), destroy_component(w), destroy_component(R), U && U.d(), L = !1, run_all(M);
    }
  };
}
function create_if_block_16(u) {
  let l;
  function f(b, y) {
    return (
      /*file*/
      b[40].size <= BYTES_IN_MB ? create_if_block_17 : create_else_block_3
    );
  }
  let p = f(u), m = p(u);
  return {
    c() {
      l = element("div"), m.c(), attr(l, "class", "filesize");
    },
    m(b, y) {
      insert(b, l, y), m.m(l, null);
    },
    p(b, y) {
      p === (p = f(b)) && m ? m.p(b, y) : (m.d(1), m = p(b), m && (m.c(), m.m(l, null)));
    },
    d(b) {
      b && detach(l), m.d();
    }
  };
}
function create_else_block_3(u) {
  let l = `${/*file*/
  (u[40].size / BYTES_IN_MB).toFixed(1)} MB`, f;
  return {
    c() {
      f = text$2(l);
    },
    m(p, m) {
      insert(p, f, m);
    },
    p(p, m) {
      m[0] & /*value*/
      1 && l !== (l = `${/*file*/
      (p[40].size / BYTES_IN_MB).toFixed(1)} MB`) && set_data(f, l);
    },
    d(p) {
      p && detach(f);
    }
  };
}
function create_if_block_17(u) {
  let l = `${/*file*/
  (u[40].size / BYTES_IN_KB).toFixed(1)} KB`, f;
  return {
    c() {
      f = text$2(l);
    },
    m(p, m) {
      insert(p, f, m);
    },
    p(p, m) {
      m[0] & /*value*/
      1 && l !== (l = `${/*file*/
      (p[40].size / BYTES_IN_KB).toFixed(1)} KB`) && set_data(f, l);
    },
    d(p) {
      p && detach(f);
    }
  };
}
function create_if_block_15(u) {
  let l, f, p, m, b;
  return f = new Icon({ props: { name: "trash" } }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "delete-button svelte-1wflao9");
    },
    m(y, v) {
      insert(y, l, v), mount_component(f, l, null), p = !0, m || (b = listen(
        l,
        "click",
        /*removeFile*/
        u[20]
      ), m = !0);
    },
    p: noop$4,
    i(y) {
      p || (transition_in(f.$$.fragment, y), p = !0);
    },
    o(y) {
      transition_out(f.$$.fragment, y), p = !1;
    },
    d(y) {
      y && detach(l), destroy_component(f), m = !1, b();
    }
  };
}
function create_each_block_1$4(u) {
  let l, f, p, m = (
    /*file*/
    u[40].name + ""
  ), b, y, v, k, S, $ = (
    /*file*/
    u[40].size && create_if_block_16(u)
  ), w = !/*disabled*/
  u[1] && create_if_block_15(u);
  return {
    c() {
      l = element("div"), f = element("div"), p = element("div"), b = text$2(m), y = space(), $ && $.c(), v = space(), w && w.c(), k = space(), attr(p, "class", "filename svelte-1wflao9"), attr(f, "class", "title svelte-1wflao9"), attr(l, "class", "gallery svelte-1wflao9");
    },
    m(T, E) {
      insert(T, l, E), append$1(l, f), append$1(f, p), append$1(p, b), append$1(f, y), $ && $.m(f, null), append$1(f, v), w && w.m(f, null), append$1(l, k), S = !0;
    },
    p(T, E) {
      (!S || E[0] & /*value*/
      1) && m !== (m = /*file*/
      T[40].name + "") && set_data(b, m), /*file*/
      T[40].size ? $ ? $.p(T, E) : ($ = create_if_block_16(T), $.c(), $.m(f, v)) : $ && ($.d(1), $ = null), /*disabled*/
      T[1] ? w && (group_outros(), transition_out(w, 1, 1, () => {
        w = null;
      }), check_outros()) : w ? (w.p(T, E), E[0] & /*disabled*/
      2 && transition_in(w, 1)) : (w = create_if_block_15(T), w.c(), transition_in(w, 1), w.m(f, null));
    },
    i(T) {
      S || (transition_in(w), S = !0);
    },
    o(T) {
      transition_out(w), S = !1;
    },
    d(T) {
      T && detach(l), $ && $.d(), w && w.d();
    }
  };
}
function create_else_block_2(u) {
  let l = (
    /*selectedImage*/
    u[11].name + ""
  ), f;
  return {
    c() {
      f = text$2(l);
    },
    m(p, m) {
      insert(p, f, m);
    },
    p(p, m) {
      m[0] & /*selectedImage*/
      2048 && l !== (l = /*selectedImage*/
      p[11].name + "") && set_data(f, l);
    },
    i: noop$4,
    o: noop$4,
    d(p) {
      p && detach(f);
    }
  };
}
function create_if_block_13$1(u) {
  let l, f;
  return l = new Link({
    props: {
      target: "_blank",
      download: (
        /*selectedImage*/
        u[11].name
      ),
      href: (
        /*selectedUrl*/
        u[14]
      ),
      $$slots: { default: [create_default_slot_2$a] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*selectedImage*/
      2048 && (b.download = /*selectedImage*/
      p[11].name), m[0] & /*selectedUrl*/
      16384 && (b.href = /*selectedUrl*/
      p[14]), m[0] & /*selectedImage*/
      2048 | m[1] & /*$$scope*/
      4096 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_2$a(u) {
  let l = (
    /*selectedImage*/
    u[11].name + ""
  ), f;
  return {
    c() {
      f = text$2(l);
    },
    m(p, m) {
      insert(p, f, m);
    },
    p(p, m) {
      m[0] & /*selectedImage*/
      2048 && l !== (l = /*selectedImage*/
      p[11].name + "") && set_data(f, l);
    },
    d(p) {
      p && detach(f);
    }
  };
}
function create_if_block_11$1(u) {
  let l;
  function f(b, y) {
    return (
      /*selectedImage*/
      b[11].size <= BYTES_IN_MB ? create_if_block_12$1 : create_else_block_1$4
    );
  }
  let p = f(u), m = p(u);
  return {
    c() {
      l = element("div"), m.c(), attr(l, "class", "filesize");
    },
    m(b, y) {
      insert(b, l, y), m.m(l, null);
    },
    p(b, y) {
      p === (p = f(b)) && m ? m.p(b, y) : (m.d(1), m = p(b), m && (m.c(), m.m(l, null)));
    },
    d(b) {
      b && detach(l), m.d();
    }
  };
}
function create_else_block_1$4(u) {
  let l = `${/*selectedImage*/
  (u[11].size / BYTES_IN_MB).toFixed(1)} MB`, f;
  return {
    c() {
      f = text$2(l);
    },
    m(p, m) {
      insert(p, f, m);
    },
    p(p, m) {
      m[0] & /*selectedImage*/
      2048 && l !== (l = `${/*selectedImage*/
      (p[11].size / BYTES_IN_MB).toFixed(1)} MB`) && set_data(f, l);
    },
    d(p) {
      p && detach(f);
    }
  };
}
function create_if_block_12$1(u) {
  let l = `${/*selectedImage*/
  (u[11].size / BYTES_IN_KB).toFixed(1)} KB`, f;
  return {
    c() {
      f = text$2(l);
    },
    m(p, m) {
      insert(p, f, m);
    },
    p(p, m) {
      m[0] & /*selectedImage*/
      2048 && l !== (l = `${/*selectedImage*/
      (p[11].size / BYTES_IN_KB).toFixed(1)} KB`) && set_data(f, l);
    },
    d(p) {
      p && detach(f);
    }
  };
}
function create_if_block_10$2(u) {
  let l, f, p, m, b;
  return f = new Icon({ props: { name: "trash" } }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "delete-button svelte-1wflao9");
    },
    m(y, v) {
      insert(y, l, v), mount_component(f, l, null), p = !0, m || (b = listen(
        l,
        "click",
        /*removeFile*/
        u[20]
      ), m = !0);
    },
    p: noop$4,
    i(y) {
      p || (transition_in(f.$$.fragment, y), p = !0);
    },
    o(y) {
      transition_out(f.$$.fragment, y), p = !1;
    },
    d(y) {
      y && detach(l), destroy_component(f), m = !1, b();
    }
  };
}
function create_else_block$e(u) {
  let l, f, p = (
    /*selectedImage*/
    (u[11].name || "Unknown file") + ""
  ), m, b, y;
  return {
    c() {
      l = element("div"), f = element("div"), m = text$2(p), b = space(), y = element("div"), y.textContent = "Preview not supported", attr(f, "class", "extension svelte-1wflao9"), attr(l, "class", "placeholder svelte-1wflao9");
    },
    m(v, k) {
      insert(v, l, k), append$1(l, f), append$1(f, m), append$1(l, b), append$1(l, y);
    },
    p(v, k) {
      k[0] & /*selectedImage*/
      2048 && p !== (p = /*selectedImage*/
      (v[11].name || "Unknown file") + "") && set_data(m, p);
    },
    d(v) {
      v && detach(l);
    }
  };
}
function create_if_block_9$2(u) {
  let l, f;
  return {
    c() {
      l = element("img"), attr(l, "alt", "preview"), src_url_equal(l.src, f = /*selectedUrl*/
      u[14]) || attr(l, "src", f), attr(l, "class", "svelte-1wflao9");
    },
    m(p, m) {
      insert(p, l, m);
    },
    p(p, m) {
      m[0] & /*selectedUrl*/
      16384 && !src_url_equal(l.src, f = /*selectedUrl*/
      p[14]) && attr(l, "src", f);
    },
    d(p) {
      p && detach(l);
    }
  };
}
function create_if_block_8$2(u) {
  let l, f, p = (
    /*selectedImageIdx*/
    u[10] + 1 + ""
  ), m, b, y;
  return {
    c() {
      l = element("div"), f = text$2("File "), m = text$2(p), b = text$2(" of "), y = text$2(
        /*fileCount*/
        u[18]
      ), attr(l, "class", "footer");
    },
    m(v, k) {
      insert(v, l, k), append$1(l, f), append$1(l, m), append$1(l, b), append$1(l, y);
    },
    p(v, k) {
      k[0] & /*selectedImageIdx*/
      1024 && p !== (p = /*selectedImageIdx*/
      v[10] + 1 + "") && set_data(m, p), k[0] & /*fileCount*/
      262144 && set_data(
        y,
        /*fileCount*/
        v[18]
      );
    },
    d(v) {
      v && detach(l);
    }
  };
}
function create_if_block$G(u) {
  let l, f, p, m, b, y, v, k, S, $, w = !/*compact*/
  u[2] && create_if_block_5$6(u), T = !/*disabled*/
  u[1] && create_if_block_2$h(u), E = (
    /*loading*/
    u[16] && create_if_block_1$m()
  );
  return {
    c() {
      l = element("div"), f = element("div"), p = element("input"), b = space(), w && w.c(), y = space(), T && T.c(), v = space(), E && E.c(), attr(
        p,
        "id",
        /*fieldId*/
        u[19]
      ), p.disabled = /*disabled*/
      u[1], attr(p, "type", "file"), p.multiple = m = /*maximum*/
      u[5] !== 1, attr(
        p,
        "accept",
        /*extensions*/
        u[6]
      ), attr(p, "class", "svelte-1wflao9"), attr(f, "class", "spectrum-IllustratedMessage spectrum-IllustratedMessage--cta"), attr(l, "class", "spectrum-Dropzone svelte-1wflao9"), attr(l, "role", "region"), attr(l, "tabindex", "0"), toggle_class(
        l,
        "disabled",
        /*disabled*/
        u[1] || /*loading*/
        u[16]
      ), toggle_class(
        l,
        "is-dragged",
        /*fileDragged*/
        u[13]
      );
    },
    m(R, O) {
      insert(R, l, O), append$1(l, f), append$1(f, p), u[33](p), append$1(f, b), w && w.m(f, null), append$1(f, y), T && T.m(f, null), append$1(l, v), E && E.m(l, null), k = !0, S || ($ = [
        listen(
          p,
          "change",
          /*handleFile*/
          u[23]
        ),
        listen(
          l,
          "dragover",
          /*handleDragOver*/
          u[24]
        ),
        listen(
          l,
          "dragleave",
          /*handleDragLeave*/
          u[25]
        ),
        listen(
          l,
          "dragenter",
          /*handleDragOver*/
          u[24]
        ),
        listen(
          l,
          "drop",
          /*handleDrop*/
          u[26]
        )
      ], S = !0);
    },
    p(R, O) {
      (!k || O[0] & /*disabled*/
      2) && (p.disabled = /*disabled*/
      R[1]), (!k || O[0] & /*maximum*/
      32 && m !== (m = /*maximum*/
      R[5] !== 1)) && (p.multiple = m), (!k || O[0] & /*extensions*/
      64) && attr(
        p,
        "accept",
        /*extensions*/
        R[6]
      ), /*compact*/
      R[2] ? w && (w.d(1), w = null) : w ? w.p(R, O) : (w = create_if_block_5$6(R), w.c(), w.m(f, y)), /*disabled*/
      R[1] ? T && (group_outros(), transition_out(T, 1, 1, () => {
        T = null;
      }), check_outros()) : T ? (T.p(R, O), O[0] & /*disabled*/
      2 && transition_in(T, 1)) : (T = create_if_block_2$h(R), T.c(), transition_in(T, 1), T.m(f, null)), /*loading*/
      R[16] ? E ? O[0] & /*loading*/
      65536 && transition_in(E, 1) : (E = create_if_block_1$m(), E.c(), transition_in(E, 1), E.m(l, null)) : E && (group_outros(), transition_out(E, 1, 1, () => {
        E = null;
      }), check_outros()), (!k || O[0] & /*disabled, loading*/
      65538) && toggle_class(
        l,
        "disabled",
        /*disabled*/
        R[1] || /*loading*/
        R[16]
      ), (!k || O[0] & /*fileDragged*/
      8192) && toggle_class(
        l,
        "is-dragged",
        /*fileDragged*/
        R[13]
      );
    },
    i(R) {
      k || (transition_in(T), transition_in(E), k = !0);
    },
    o(R) {
      transition_out(T), transition_out(E), k = !1;
    },
    d(R) {
      R && detach(l), u[33](null), w && w.d(), T && T.d(), E && E.d(), S = !1, run_all($);
    }
  };
}
function create_if_block_5$6(u) {
  let l, f, p, m, b, y, v, k, S, $, w, T, E, R, O, P, L = (
    /*titleText*/
    (u[7] || "Drag and drop your file") + ""
  ), M;
  return {
    c() {
      l = svg_element("svg"), f = svg_element("defs"), p = svg_element("style"), m = text$2(`.cls-1,
                .cls-2 {
                  fill: none;
                  stroke-linecap: round;
                  stroke-linejoin: round;
                }
                .cls-1 {
                  stroke-width: 3px;
                }
                .cls-2 {
                  stroke-width: 2px;
                }
              `), b = svg_element("path"), y = svg_element("line"), v = svg_element("path"), k = svg_element("path"), S = svg_element("line"), $ = svg_element("path"), w = svg_element("path"), T = svg_element("path"), E = svg_element("path"), R = svg_element("rect"), O = space(), P = element("h2"), M = text$2(L), attr(b, "class", "cls-1"), attr(b, "d", "M110.53,85.66,100.26,95.89a1.09,1.09,0,0,1-1.52,0L88.47,85.66"), attr(y, "class", "cls-1"), attr(y, "x1", "99.5"), attr(y, "y1", "95.5"), attr(y, "x2", "99.5"), attr(y, "y2", "58.5"), attr(v, "class", "cls-1"), attr(v, "d", "M105.5,73.5h19a2,2,0,0,0,2-2v-43"), attr(k, "class", "cls-1"), attr(k, "d", "M126.5,22.5h-19a2,2,0,0,1-2-2V1.5h-31a2,2,0,0,0-2,2v68a2,2,0,0,0,2,2h19"), attr(S, "class", "cls-1"), attr(S, "x1", "105.5"), attr(S, "y1", "1.5"), attr(S, "x2", "126.5"), attr(S, "y2", "22.5"), attr($, "class", "cls-2"), attr($, "d", "M47.93,50.49a5,5,0,1,0-4.83-5A4.93,4.93,0,0,0,47.93,50.49Z"), attr(w, "class", "cls-2"), attr(w, "d", "M36.6,65.93,42.05,60A2.06,2.06,0,0,1,45,60l12.68,13.2"), attr(T, "class", "cls-2"), attr(T, "d", "M3.14,73.23,22.42,53.76a1.65,1.65,0,0,1,2.38,0l19.05,19.7"), attr(E, "class", "cls-1"), attr(E, "d", "M139.5,36.5H196A1.49,1.49,0,0,1,197.5,38V72A1.49,1.49,0,0,1,196,73.5H141A1.49,1.49,0,0,1,139.5,72V32A1.49,1.49,0,0,1,141,30.5H154a2.43,2.43,0,0,1,1.67.66l6,5.66"), attr(R, "class", "cls-1"), attr(R, "x", "1.5"), attr(R, "y", "34.5"), attr(R, "width", "58"), attr(R, "height", "39"), attr(R, "rx", "2"), attr(R, "ry", "2"), attr(l, "class", "spectrum-IllustratedMessage-illustration"), attr(l, "width", "125"), attr(l, "height", "60"), attr(l, "viewBox", "0 0 199 97.7"), attr(P, "class", "spectrum-Heading spectrum-Heading--sizeL spectrum-Heading--light spectrum-IllustratedMessage-heading svelte-1wflao9");
    },
    m(B, j) {
      insert(B, l, j), append$1(l, f), append$1(f, p), append$1(p, m), append$1(l, b), append$1(l, y), append$1(l, v), append$1(l, k), append$1(l, S), append$1(l, $), append$1(l, w), append$1(l, T), append$1(l, E), append$1(l, R), insert(B, O, j), insert(B, P, j), append$1(P, M);
    },
    p(B, j) {
      j[0] & /*titleText*/
      128 && L !== (L = /*titleText*/
      (B[7] || "Drag and drop your file") + "") && set_data(M, L);
    },
    d(B) {
      B && (detach(l), detach(O), detach(P));
    }
  };
}
function create_if_block_2$h(u) {
  let l, f, p = (
    /*clickText*/
    (u[8] || "Click to select a file") + ""
  ), m, b, y, v, k, S = !/*compact*/
  u[2] && create_if_block_4$6(u), $ = (
    /*fileTags*/
    u[4].length && create_if_block_3$9(u)
  );
  return {
    c() {
      l = element("p"), f = element("label"), m = text$2(p), b = space(), S && S.c(), y = space(), $ && $.c(), v = empty$1(), attr(
        f,
        "for",
        /*fieldId*/
        u[19]
      ), attr(f, "class", "spectrum-Link"), attr(l, "class", "spectrum-Body spectrum-Body--sizeS spectrum-IllustratedMessage-description svelte-1wflao9");
    },
    m(w, T) {
      insert(w, l, T), append$1(l, f), append$1(f, m), append$1(l, b), S && S.m(l, null), insert(w, y, T), $ && $.m(w, T), insert(w, v, T), k = !0;
    },
    p(w, T) {
      (!k || T[0] & /*clickText*/
      256) && p !== (p = /*clickText*/
      (w[8] || "Click to select a file") + "") && set_data(m, p), /*compact*/
      w[2] ? S && (S.d(1), S = null) : S ? S.p(w, T) : (S = create_if_block_4$6(w), S.c(), S.m(l, null)), /*fileTags*/
      w[4].length ? $ ? ($.p(w, T), T[0] & /*fileTags*/
      16 && transition_in($, 1)) : ($ = create_if_block_3$9(w), $.c(), transition_in($, 1), $.m(v.parentNode, v)) : $ && (group_outros(), transition_out($, 1, 1, () => {
        $ = null;
      }), check_outros());
    },
    i(w) {
      k || (transition_in($), k = !0);
    },
    o(w) {
      transition_out($), k = !1;
    },
    d(w) {
      w && (detach(l), detach(y), detach(v)), S && S.d(), $ && $.d(w);
    }
  };
}
function create_if_block_4$6(u) {
  let l, f, p = (
    /*addText*/
    (u[9] || "or drop it here") + ""
  ), m;
  return {
    c() {
      l = element("br"), f = space(), m = text$2(p);
    },
    m(b, y) {
      insert(b, l, y), insert(b, f, y), insert(b, m, y);
    },
    p(b, y) {
      y[0] & /*addText*/
      512 && p !== (p = /*addText*/
      (b[9] || "or drop it here") + "") && set_data(m, p);
    },
    d(b) {
      b && (detach(l), detach(f), detach(m));
    }
  };
}
function create_if_block_3$9(u) {
  let l, f;
  return l = new Tags({
    props: {
      $$slots: { default: [create_default_slot$G] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*fileTags*/
      16 | m[1] & /*$$scope*/
      4096 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_1$g(u) {
  let l = (
    /*tag*/
    u[37] + ""
  ), f;
  return {
    c() {
      f = text$2(l);
    },
    m(p, m) {
      insert(p, f, m);
    },
    p(p, m) {
      m[0] & /*fileTags*/
      16 && l !== (l = /*tag*/
      p[37] + "") && set_data(f, l);
    },
    d(p) {
      p && detach(f);
    }
  };
}
function create_each_block$d(u) {
  let l, f, p, m;
  return f = new Tag({
    props: {
      $$slots: { default: [create_default_slot_1$g] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), p = space(), attr(l, "class", "tag svelte-1wflao9");
    },
    m(b, y) {
      insert(b, l, y), mount_component(f, l, null), append$1(l, p), m = !0;
    },
    p(b, y) {
      const v = {};
      y[0] & /*fileTags*/
      16 | y[1] & /*$$scope*/
      4096 && (v.$$scope = { dirty: y, ctx: b }), f.$set(v);
    },
    i(b) {
      m || (transition_in(f.$$.fragment, b), m = !0);
    },
    o(b) {
      transition_out(f.$$.fragment, b), m = !1;
    },
    d(b) {
      b && detach(l), destroy_component(f);
    }
  };
}
function create_default_slot$G(u) {
  let l, f, p = ensure_array_like(
    /*fileTags*/
    u[4]
  ), m = [];
  for (let y = 0; y < p.length; y += 1)
    m[y] = create_each_block$d(get_each_context$d(u, p, y));
  const b = (y) => transition_out(m[y], 1, 1, () => {
    m[y] = null;
  });
  return {
    c() {
      l = element("div");
      for (let y = 0; y < m.length; y += 1)
        m[y].c();
      attr(l, "class", "tags svelte-1wflao9");
    },
    m(y, v) {
      insert(y, l, v);
      for (let k = 0; k < m.length; k += 1)
        m[k] && m[k].m(l, null);
      f = !0;
    },
    p(y, v) {
      if (v[0] & /*fileTags*/
      16) {
        p = ensure_array_like(
          /*fileTags*/
          y[4]
        );
        let k;
        for (k = 0; k < p.length; k += 1) {
          const S = get_each_context$d(y, p, k);
          m[k] ? (m[k].p(S, v), transition_in(m[k], 1)) : (m[k] = create_each_block$d(S), m[k].c(), transition_in(m[k], 1), m[k].m(l, null));
        }
        for (group_outros(), k = p.length; k < m.length; k += 1)
          b(k);
        check_outros();
      }
    },
    i(y) {
      if (!f) {
        for (let v = 0; v < p.length; v += 1)
          transition_in(m[v]);
        f = !0;
      }
    },
    o(y) {
      m = m.filter(Boolean);
      for (let v = 0; v < m.length; v += 1)
        transition_out(m[v]);
      f = !1;
    },
    d(y) {
      y && detach(l), destroy_each(m, y);
    }
  };
}
function create_if_block_1$m(u) {
  let l, f, p;
  return f = new ProgressCircle({ props: { size: "M" } }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "loading svelte-1wflao9");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_fragment$1j(u) {
  let l, f, p, m = (
    /*selectedImage*/
    u[11] && create_if_block_6$4(u)
  ), b = (
    /*showDropzone*/
    u[17] && create_if_block$G(u)
  );
  return {
    c() {
      l = element("div"), m && m.c(), f = space(), b && b.c(), attr(l, "class", "container svelte-1wflao9"), toggle_class(
        l,
        "compact",
        /*compact*/
        u[2]
      );
    },
    m(y, v) {
      insert(y, l, v), m && m.m(l, null), append$1(l, f), b && b.m(l, null), p = !0;
    },
    p(y, v) {
      /*selectedImage*/
      y[11] ? m ? (m.p(y, v), v[0] & /*selectedImage*/
      2048 && transition_in(m, 1)) : (m = create_if_block_6$4(y), m.c(), transition_in(m, 1), m.m(l, f)) : m && (group_outros(), transition_out(m, 1, 1, () => {
        m = null;
      }), check_outros()), /*showDropzone*/
      y[17] ? b ? (b.p(y, v), v[0] & /*showDropzone*/
      131072 && transition_in(b, 1)) : (b = create_if_block$G(y), b.c(), transition_in(b, 1), b.m(l, null)) : b && (group_outros(), transition_out(b, 1, 1, () => {
        b = null;
      }), check_outros()), (!p || v[0] & /*compact*/
      4) && toggle_class(
        l,
        "compact",
        /*compact*/
        y[2]
      );
    },
    i(y) {
      p || (transition_in(m), transition_in(b), p = !0);
    },
    o(y) {
      transition_out(m), transition_out(b), p = !1;
    },
    d(y) {
      y && detach(l), m && m.d(), b && b.d();
    }
  };
}
const BYTES_IN_KB = 1e3, BYTES_IN_MB = 1e6;
function instance$1h(u, l, f) {
  let p, m, b, y, { value: v = [] } = l, { id: k = null } = l, { disabled: S = !1 } = l, { compact: $ = !1 } = l, { fileSizeLimit: w = BYTES_IN_MB * 20 } = l, { processFiles: T = null } = l, { deleteAttachments: E = null } = l, { handleFileTooLarge: R = null } = l, { handleTooManyFiles: O = null } = l, { gallery: P = !0 } = l, { fileTags: L = [] } = l, { maximum: M = void 0 } = l, { extensions: B = "*" } = l, { titleText: j = null } = l, { clickText: x = null } = l, { addText: N = null } = l;
  const D = createEventDispatcher(), V = ["png", "tiff", "gif", "raw", "jpg", "jpeg", "svg", "bmp", "jfif", "webp"], W = k || uuid();
  let F = 0, U = !1, Y, q, Q = !1;
  async function z(le) {
    if (R && Array.from(le).some((ne) => ne.size >= w)) {
      R(w, v);
      return;
    }
    const ae = le.length + v.length;
    if (O && M && ae > M) {
      O(M);
      return;
    }
    if (T) {
      f(16, Q = !0);
      try {
        const ne = await T(le), K = [...v, ...ne];
        D("change", K), f(10, F = K.length - 1);
      } finally {
        f(16, Q = !1);
      }
    } else
      D("change", Array.from(le));
  }
  async function H() {
    D("change", v.filter((le, ae) => ae !== F)), E && (await E(v.filter((le, ae) => ae === F).map((le) => "key" in le && le.key || "")), f(15, q.value = "", q)), f(10, F = 0);
  }
  function X() {
    f(10, F -= 1);
  }
  function Z() {
    f(10, F += 1);
  }
  function oe(le) {
    const ae = le.target;
    ae != null && ae.files && z(ae.files);
  }
  function ee(le) {
    le.preventDefault(), f(13, U = !0);
  }
  function ie(le) {
    le.preventDefault(), f(13, U = !1);
  }
  function de(le) {
    var ae;
    le.preventDefault(), (ae = le.dataTransfer) != null && ae.files && z(le.dataTransfer.files), f(13, U = !1);
  }
  function pe(le) {
    binding_callbacks[le ? "unshift" : "push"](() => {
      q = le, f(15, q);
    });
  }
  return u.$$set = (le) => {
    "value" in le && f(0, v = le.value), "id" in le && f(27, k = le.id), "disabled" in le && f(1, S = le.disabled), "compact" in le && f(2, $ = le.compact), "fileSizeLimit" in le && f(28, w = le.fileSizeLimit), "processFiles" in le && f(29, T = le.processFiles), "deleteAttachments" in le && f(30, E = le.deleteAttachments), "handleFileTooLarge" in le && f(31, R = le.handleFileTooLarge), "handleTooManyFiles" in le && f(32, O = le.handleTooManyFiles), "gallery" in le && f(3, P = le.gallery), "fileTags" in le && f(4, L = le.fileTags), "maximum" in le && f(5, M = le.maximum), "extensions" in le && f(6, B = le.extensions), "titleText" in le && f(7, j = le.titleText), "clickText" in le && f(8, x = le.clickText), "addText" in le && f(9, N = le.addText);
  }, u.$$.update = () => {
    var le, ae;
    if (u.$$.dirty[0] & /*value, selectedImageIdx*/
    1025 && f(11, p = (v == null ? void 0 : v[F]) ?? null), u.$$.dirty[0] & /*value*/
    1 && f(18, m = (v == null ? void 0 : v.length) ?? 0), u.$$.dirty[0] & /*selectedImage*/
    2048 && f(12, b = p && "extension" in p && V.includes((le = p == null ? void 0 : p.extension) == null ? void 0 : le.toLowerCase()) || ((ae = p == null ? void 0 : p.type) == null ? void 0 : ae.startsWith("image"))), u.$$.dirty[0] & /*selectedImage, isImage*/
    6144) {
      if (p && "url" in p && (p != null && p.url))
        f(14, Y = p == null ? void 0 : p.url);
      else if (p && b)
        try {
          let ne = new FileReader();
          ne.readAsDataURL(p), ne.onload = (K) => {
            var ce;
            f(14, Y = (ce = K.target) == null ? void 0 : ce.result);
          };
        } catch {
          f(14, Y = void 0);
        }
    }
    u.$$.dirty[0] & /*maximum, value, disabled*/
    35 && f(17, y = (!M || M && ((v == null ? void 0 : v.length) || 0) < M) && !S);
  }, [
    v,
    S,
    $,
    P,
    L,
    M,
    B,
    j,
    x,
    N,
    F,
    p,
    b,
    U,
    Y,
    q,
    Q,
    y,
    m,
    W,
    H,
    X,
    Z,
    oe,
    ee,
    ie,
    de,
    k,
    w,
    T,
    E,
    R,
    O,
    pe
  ];
}
let Dropzone$1 = class extends SvelteComponent {
  constructor(l) {
    super(), init$1(
      this,
      l,
      instance$1h,
      create_fragment$1j,
      safe_not_equal,
      {
        value: 0,
        id: 27,
        disabled: 1,
        compact: 2,
        fileSizeLimit: 28,
        processFiles: 29,
        deleteAttachments: 30,
        handleFileTooLarge: 31,
        handleTooManyFiles: 32,
        gallery: 3,
        fileTags: 4,
        maximum: 5,
        extensions: 6,
        titleText: 7,
        clickText: 8,
        addText: 9
      },
      null,
      [-1, -1]
    );
  }
};
function create_default_slot$F(u) {
  let l, f;
  return l = new Dropzone$1({
    props: {
      disabled: (
        /*disabled*/
        u[3]
      ),
      value: (
        /*value*/
        u[0]
      ),
      fileSizeLimit: (
        /*fileSizeLimit*/
        u[5]
      ),
      processFiles: (
        /*processFiles*/
        u[6]
      ),
      deleteAttachments: (
        /*deleteAttachments*/
        u[7]
      ),
      handleFileTooLarge: (
        /*handleFileTooLarge*/
        u[8]
      ),
      handleTooManyFiles: (
        /*handleTooManyFiles*/
        u[9]
      ),
      gallery: (
        /*gallery*/
        u[10]
      ),
      fileTags: (
        /*fileTags*/
        u[11]
      ),
      maximum: (
        /*maximum*/
        u[12]
      ),
      compact: (
        /*compact*/
        u[13]
      )
    }
  }), l.$on(
    "change",
    /*onChange*/
    u[15]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*disabled*/
      8 && (b.disabled = /*disabled*/
      p[3]), m & /*value*/
      1 && (b.value = /*value*/
      p[0]), m & /*fileSizeLimit*/
      32 && (b.fileSizeLimit = /*fileSizeLimit*/
      p[5]), m & /*processFiles*/
      64 && (b.processFiles = /*processFiles*/
      p[6]), m & /*deleteAttachments*/
      128 && (b.deleteAttachments = /*deleteAttachments*/
      p[7]), m & /*handleFileTooLarge*/
      256 && (b.handleFileTooLarge = /*handleFileTooLarge*/
      p[8]), m & /*handleTooManyFiles*/
      512 && (b.handleTooManyFiles = /*handleTooManyFiles*/
      p[9]), m & /*gallery*/
      1024 && (b.gallery = /*gallery*/
      p[10]), m & /*fileTags*/
      2048 && (b.fileTags = /*fileTags*/
      p[11]), m & /*maximum*/
      4096 && (b.maximum = /*maximum*/
      p[12]), m & /*compact*/
      8192 && (b.compact = /*compact*/
      p[13]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$1i(u) {
  let l, f;
  return l = new Field({
    props: {
      helpText: (
        /*helpText*/
        u[14]
      ),
      label: (
        /*label*/
        u[1]
      ),
      labelPosition: (
        /*labelPosition*/
        u[2]
      ),
      error: (
        /*error*/
        u[4]
      ),
      $$slots: { default: [create_default_slot$F] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*helpText*/
      16384 && (b.helpText = /*helpText*/
      p[14]), m & /*label*/
      2 && (b.label = /*label*/
      p[1]), m & /*labelPosition*/
      4 && (b.labelPosition = /*labelPosition*/
      p[2]), m & /*error*/
      16 && (b.error = /*error*/
      p[4]), m & /*$$scope, disabled, value, fileSizeLimit, processFiles, deleteAttachments, handleFileTooLarge, handleTooManyFiles, gallery, fileTags, maximum, compact*/
      147433 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$1g(u, l, f) {
  let { value: p = [] } = l, { label: m = void 0 } = l, { labelPosition: b = "above" } = l, { disabled: y = !1 } = l, { error: v = void 0 } = l, { fileSizeLimit: k = void 0 } = l, { processFiles: S = void 0 } = l, { deleteAttachments: $ = void 0 } = l, { handleFileTooLarge: w = void 0 } = l, { handleTooManyFiles: T = void 0 } = l, { gallery: E = !0 } = l, { fileTags: R = [] } = l, { maximum: O = void 0 } = l, { compact: P = !1 } = l, { helpText: L = void 0 } = l;
  const M = createEventDispatcher(), B = (j) => {
    f(0, p = j.detail), M("change", j.detail);
  };
  return u.$$set = (j) => {
    "value" in j && f(0, p = j.value), "label" in j && f(1, m = j.label), "labelPosition" in j && f(2, b = j.labelPosition), "disabled" in j && f(3, y = j.disabled), "error" in j && f(4, v = j.error), "fileSizeLimit" in j && f(5, k = j.fileSizeLimit), "processFiles" in j && f(6, S = j.processFiles), "deleteAttachments" in j && f(7, $ = j.deleteAttachments), "handleFileTooLarge" in j && f(8, w = j.handleFileTooLarge), "handleTooManyFiles" in j && f(9, T = j.handleTooManyFiles), "gallery" in j && f(10, E = j.gallery), "fileTags" in j && f(11, R = j.fileTags), "maximum" in j && f(12, O = j.maximum), "compact" in j && f(13, P = j.compact), "helpText" in j && f(14, L = j.helpText);
  }, [
    p,
    m,
    b,
    y,
    v,
    k,
    S,
    $,
    w,
    T,
    E,
    R,
    O,
    P,
    L,
    B
  ];
}
class Dropzone extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1g, create_fragment$1i, safe_not_equal, {
      value: 0,
      label: 1,
      labelPosition: 2,
      disabled: 3,
      error: 4,
      fileSizeLimit: 5,
      processFiles: 6,
      deleteAttachments: 7,
      handleFileTooLarge: 8,
      handleTooManyFiles: 9,
      gallery: 10,
      fileTags: 11,
      maximum: 12,
      compact: 13,
      helpText: 14
    });
  }
}
const indexVars$k = "", Divider_svelte_svelte_type_style_lang = "";
function create_fragment$1h(u) {
  let l, f;
  return {
    c() {
      l = element("hr"), attr(
        l,
        "id",
        /*id*/
        u[4]
      ), attr(l, "class", f = "spectrum-Divider spectrum-Divider--" + /*vertical*/
      (u[1] ? "vertical" : "horizontal") + " spectrum-Dialog-divider spectrum-Divider--size" + /*size*/
      u[0] + " svelte-kjvv8b"), toggle_class(
        l,
        "noMargin",
        /*noMargin*/
        u[2]
      ), toggle_class(
        l,
        "noGrid",
        /*noGrid*/
        u[3]
      );
    },
    m(p, m) {
      insert(p, l, m);
    },
    p(p, [m]) {
      m & /*id*/
      16 && attr(
        l,
        "id",
        /*id*/
        p[4]
      ), m & /*vertical, size*/
      3 && f !== (f = "spectrum-Divider spectrum-Divider--" + /*vertical*/
      (p[1] ? "vertical" : "horizontal") + " spectrum-Dialog-divider spectrum-Divider--size" + /*size*/
      p[0] + " svelte-kjvv8b") && attr(l, "class", f), m & /*vertical, size, noMargin*/
      7 && toggle_class(
        l,
        "noMargin",
        /*noMargin*/
        p[2]
      ), m & /*vertical, size, noGrid*/
      11 && toggle_class(
        l,
        "noGrid",
        /*noGrid*/
        p[3]
      );
    },
    i: noop$4,
    o: noop$4,
    d(p) {
      p && detach(l);
    }
  };
}
function instance$1f(u, l, f) {
  let { size: p = "M" } = l, { vertical: m = !1 } = l, { noMargin: b = !1 } = l, { noGrid: y = !1 } = l, { id: v = void 0 } = l;
  return u.$$set = (k) => {
    "size" in k && f(0, p = k.size), "vertical" in k && f(1, m = k.vertical), "noMargin" in k && f(2, b = k.noMargin), "noGrid" in k && f(3, y = k.noGrid), "id" in k && f(4, v = k.id);
  }, [p, m, b, y, v];
}
class Divider extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1f, create_fragment$1h, safe_not_equal, {
      size: 0,
      vertical: 1,
      noMargin: 2,
      noGrid: 3,
      id: 4
    });
  }
}
const EnvDropdown_svelte_svelte_type_style_lang = "", indexVars$j = "", CheckboxGroup_svelte_svelte_type_style_lang = "", File_svelte_svelte_type_style_lang = "", RadioGroup_svelte_svelte_type_style_lang = "", easymde_min = "", SpectrumMDE_svelte_svelte_type_style_lang = "";
function t(u, l, f) {
  var p = function(v, k) {
    return atob(v);
  }(u), m = p.indexOf(`
`, 10) + 1, b = p.substring(m) + "", y = new Blob([b], { type: "application/javascript" });
  return URL.createObjectURL(y);
}
var g, s, e = (g = "Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgLy8gY29sb3VyIGluZGljZXMgcGVyIHBpeGVsCiAgY29uc3QgUiA9IDA7CiAgY29uc3QgRyA9IDE7CiAgY29uc3QgQiA9IDI7CiAgY29uc3QgQSA9IDM7CgogIGNvbnN0IFBJWEVMID0gNDsKICBjb25zdCBUUkFOU1BBUkVOVCA9IDA7CiAgY29uc3QgT1BBUVVFID0gMjU1OwoKICBjb25zdCBoZXhUb1JnYiA9IChoZXhDb2xvcikgPT4gewogICAgLy8gU2luY2UgaW5wdXQgdHlwZSBjb2xvciBwcm92aWRlcyBoZXggYW5kIEltYWdlRGF0YSBhY2NlcHRzIFJHQiBuZWVkIHRvIHRyYW5zZm9ybQogICAgY29uc3QgbSA9IGhleENvbG9yLm1hdGNoKC9eIz8oW1xkYS1mXXsyfSkoW1xkYS1mXXsyfSkoW1xkYS1mXXsyfSkkL2kpOwogICAgcmV0dXJuIFsKICAgICAgcGFyc2VJbnQobVsxXSwgMTYpLAogICAgICBwYXJzZUludChtWzJdLCAxNiksCiAgICAgIHBhcnNlSW50KG1bM10sIDE2KSwKICAgIF07CiAgfTsKCiAgLy8gUGl4ZWwgY29sb3IgZXF1YWxzIGNvbXAgY29sb3I/CiAgY29uc3QgY29sb3JNYXRjaGVyID0gKGRhdGEsIGNvbXBSLCBjb21wRywgY29tcEIsIGNvbXBBKSA9PiAocGl4ZWxQb3MpID0+ICgKICAgIGRhdGFbcGl4ZWxQb3MgKyBSXSA9PT0gY29tcFIKICAgICYmIGRhdGFbcGl4ZWxQb3MgKyBHXSA9PT0gY29tcEcKICAgICYmIGRhdGFbcGl4ZWxQb3MgKyBCXSA9PT0gY29tcEIKICAgICYmIGRhdGFbcGl4ZWxQb3MgKyBBXSA9PT0gY29tcEEKICApOwoKICBjb25zdCBjb2xvck1hdGNoZXJJZ25vcmVBbHBoYSA9IChkYXRhLCAuLi5hcmdzKSA9PiB7CiAgICBjb25zdCBtYXRjaCA9IGNvbG9yTWF0Y2hlcihkYXRhLCAuLi5hcmdzKTsKCiAgICByZXR1cm4gKHBpeGVsUG9zKSA9PiB7CiAgICAgIGNvbnN0IGFscGhhID0gZGF0YVtwaXhlbFBvcyArIEFdOwogICAgICBpZiAoYWxwaGEgIT09IFRSQU5TUEFSRU5UICYmIGFscGhhICE9PSBPUEFRVUUpIHsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQoKICAgICAgcmV0dXJuIG1hdGNoKHBpeGVsUG9zKTsKICAgIH07CiAgfTsKCiAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi8KICBjb25zdCBwaXhlbFBhaW50ZXIgPSAoZGF0YSwgZmlsbFIsIGZpbGxHLCBmaWxsQiwgZmlsbEEpID0+IChwaXhlbFBvcykgPT4gewogICAgZGF0YVtwaXhlbFBvcyArIFJdID0gZmlsbFI7CiAgICBkYXRhW3BpeGVsUG9zICsgR10gPSBmaWxsRzsKICAgIGRhdGFbcGl4ZWxQb3MgKyBCXSA9IGZpbGxCOwogICAgZGF0YVtwaXhlbFBvcyArIEFdID0gZmlsbEE7CiAgfTsKCiAgY29uc3QgcGl4ZWxQYWludGVyTWl4QWxwaGEgPSAoZGF0YSwgZmlsbFIsIGZpbGxHLCBmaWxsQiwgZmlsbEEpID0+IChwaXhlbFBvcykgPT4gewogICAgY29uc3Qgb2xkQWxwaGEgPSBkYXRhW3BpeGVsUG9zICsgQV07CiAgICAvLyBjYWxjdWxhdGUgcmF0aW8gb2Ygb2xkIHZzLiBuZXcgY29sb3VyIHRvIGJlIGFscGhhLW1peGVkCiAgICBjb25zdCBtaXhBbHBoYU9sZCA9IG9sZEFscGhhID09PSBPUEFRVUUKICAgICAgPyBUUkFOU1BBUkVOVAogICAgICA6IG9sZEFscGhhIC8gT1BBUVVFOwogICAgY29uc3QgbWl4QWxwaGFOZXcgPSAxIC0gbWl4QWxwaGFPbGQ7CgogICAgY29uc3QgcGFpbnQgPSBwaXhlbFBhaW50ZXIoCiAgICAgIGRhdGEsCiAgICAgIE1hdGguZmxvb3IobWl4QWxwaGFPbGQgKiBkYXRhW3BpeGVsUG9zICsgUl0gKyBtaXhBbHBoYU5ldyAqIGZpbGxSKSwKICAgICAgTWF0aC5mbG9vcihtaXhBbHBoYU9sZCAqIGRhdGFbcGl4ZWxQb3MgKyBHXSArIG1peEFscGhhTmV3ICogZmlsbEcpLAogICAgICBNYXRoLmZsb29yKG1peEFscGhhT2xkICogZGF0YVtwaXhlbFBvcyArIEJdICsgbWl4QWxwaGFOZXcgKiBmaWxsQiksCiAgICAgIGZpbGxBLAogICAgKTsKCiAgICByZXR1cm4gcGFpbnQocGl4ZWxQb3MpOwogIH07CiAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqLwoKICAvKioKICAgKiBTdGFjay0gYW5kIHNwYW4tYmFzZWQgZmxvb2QgZmlsbCBhbGdvcml0aG0KICAgKiBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmxvb2RfZmlsbCNTcGFuX2ZpbGxpbmcKICAgKgogICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgb2JqZWN0CiAgICogQHJldHVybnMge1VJbnQ4Q2xhbXBlZEFycmF5fSB0aGUgbW9kaWZpZWQgcGl4ZWxzCiAgICovCiAgY29uc3QgZmxvb2RGaWxsID0gKHsKICAgIGltYWdlLAogICAgd2lkdGgsCiAgICBoZWlnaHQsCiAgICBjb2xvciwKICAgIGdsb2JhbEFscGhhLAogICAgc3RhcnRYLAogICAgc3RhcnRZLAogICAgc3RhcnRDb2xvciwKICB9KSA9PiB7CiAgICBjb25zdCByb3cgPSB3aWR0aCAqIFBJWEVMOwogICAgLy8gbWFrZSBzdXJlIHN0YXJ0IGNvb3JkaW5hdGVzIGFyZSBpbnRlZ2VycwogICAgY29uc3Qgc3RhcnRYQ29vcmQgPSBNYXRoLmZsb29yKHN0YXJ0WCk7CiAgICBjb25zdCBzdGFydFlDb29yZCA9IE1hdGguZmxvb3Ioc3RhcnRZKTsKICAgIC8vIGhleCBuZWVkcyB0byBiZSB0cmFzZm9ybWVkIHRvIHJnYiBzaW5jZSBJbWFnZURhdGEgdXNlcyBSR0IKICAgIGNvbnN0IGZpbGxDb2xvciA9IGhleFRvUmdiKGNvbG9yKTsKICAgIC8vIGVuc3VyZSBhbHBoYSBpcyBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwLTI1NQogICAgY29uc3QgZmlsbEFscGhhID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBNYXRoLm1pbihnbG9iYWxBbHBoYSAqIE9QQVFVRSwgT1BBUVVFKSkpOwogICAgLy8gd2UgbmVlZCBkaWZmZXJlbnQgYmVoYXZpb3VyIGluIGNhc2Ugd2UncmUgZmlsbGluZyBhIG5vbi1vcGFxdWUgYXJlYQogICAgY29uc3QgZmlsbGluZ05vbk9wYXF1ZSA9IHN0YXJ0Q29sb3JbQV0gIT09IE9QQVFVRTsKICAgIC8vIG91ciBwaXhlbCBwYWludGVyIHNob3VsZCBvbmx5IG1peCBhbHBoYSBpZiB3ZSdyZSBzdGFydGluZyBpbiBhIG5vbi1vcGFxdWUgYXJlYQogICAgY29uc3QgcGl4ZWxQYWludGVyT2ZDaG9pY2UgPSBmaWxsaW5nTm9uT3BhcXVlID8gcGl4ZWxQYWludGVyTWl4QWxwaGEgOiBwaXhlbFBhaW50ZXI7CiAgICBjb25zdCBwYWludFBpeGVsID0gcGl4ZWxQYWludGVyT2ZDaG9pY2UoaW1hZ2UsIC4uLmZpbGxDb2xvciwgZmlsbEFscGhhKTsKICAgIC8vIHdoZW4gbG9va2luZyBmb3IgdGhlIHNwYW4gc3RhcnQsIHdlIGlnbm9yZSB0aGUgYWxwaGEgdmFsdWUgaWYgZmlsbGluZyBhIG5vbi1vcGFxdWUgYXJlYQogICAgLy8gdGhpcyBlbnN1cmVzIHRoYXQgd2UnbGwgbWl4IHRoZSBmaWxsIGludG8gYW50aWFsaWFzZWQgZWRnZXMKICAgIGNvbnN0IGNvbG9yTWF0Y2hlclNwYW5TdGFydCA9IGZpbGxpbmdOb25PcGFxdWUgPyBjb2xvck1hdGNoZXJJZ25vcmVBbHBoYSA6IGNvbG9yTWF0Y2hlcjsKICAgIGNvbnN0IG1hdGNoU3BhblN0YXJ0Q29sb3IgPSBjb2xvck1hdGNoZXJTcGFuU3RhcnQoaW1hZ2UsIC4uLnN0YXJ0Q29sb3IpOwogICAgLy8gZm9yIGFsbCBvdGhlciBjYXNlcywgd2UgbG9vayBmb3IgdGhlIHN0YXJ0IGNvbG91ciBleGFjdGx5CiAgICBjb25zdCBtYXRjaFN0YXJ0Q29sb3IgPSBjb2xvck1hdGNoZXJJZ25vcmVBbHBoYShpbWFnZSwgLi4uc3RhcnRDb2xvcik7CgogICAgLy8gY2hlY2sgaWYgd2UncmUgdHJ5aW5nIHRvIGZpbGwgd2l0aCB0aGUgc2FtZSBjb2xvdXIsIGlmIHNvLCBzdG9wCiAgICBjb25zdCBtYXRjaEZpbGxDb2xvciA9IGNvbG9yTWF0Y2hlcihpbWFnZSwgLi4uWy4uLmZpbGxDb2xvciwgT1BBUVVFXSk7CiAgICBpZiAobWF0Y2hGaWxsQ29sb3IoKHN0YXJ0WUNvb3JkICogd2lkdGggKyBzdGFydFhDb29yZCkgKiBQSVhFTCkpIHsKICAgICAgcmV0dXJuIGltYWdlOwogICAgfQogICAgLy8gYmVnaW4gd2l0aCBvdXIgc3RhcnQgcGl4ZWwKICAgIGNvbnN0IHBpeGVsU3RhY2sgPSBbW3N0YXJ0WENvb3JkLCBzdGFydFlDb29yZF1dOwogICAgd2hpbGUgKHBpeGVsU3RhY2subGVuZ3RoKSB7CiAgICAgIGNvbnN0IFt4LCB5XSA9IHBpeGVsU3RhY2sucG9wKCk7CiAgICAgIC8vIGNvbHVtbiBwb3NpdGlvbiBpcyBpbiBjYXJ0ZXNpYW4gc3BhY2UgKHgseSkKICAgICAgbGV0IGNvbHVtblBvc2l0aW9uID0geTsKICAgICAgLy8gcGl4ZWwgcG9zaXRpb24gaXMgaW4gMUQgc3BhY2UgKHRoZSByYXcgaW1hZ2UgZGF0YSBVSW50OENsYW1wZWRBcnJheSkKICAgICAgbGV0IHBpeGVsUG9zID0gKGNvbHVtblBvc2l0aW9uICogd2lkdGggKyB4KSAqIFBJWEVMOwogICAgICAvLyBzdGFydCBtb3ZpbmcgZGlyZWN0bHkgdXAgZnJvbSBvdXIgc3RhcnQgcG9zaXRpb24KICAgICAgLy8gdW50aWwgd2UgZmluZCBhIGRpZmZlcmVudCBjb2xvdXIgdG8gdGhlIHN0YXJ0IGNvbG91cgogICAgICAvLyB0aGlzIGlzIHRoZSBiZWdpbm5pbmcgb2Ygb3VyIHNwYW4KICAgICAgd2hpbGUgKGNvbHVtblBvc2l0aW9uLS0gPj0gMCAmJiBtYXRjaFNwYW5TdGFydENvbG9yKHBpeGVsUG9zKSkgewogICAgICAgIHBpeGVsUG9zIC09IHJvdzsKICAgICAgfQogICAgICAvLyBtb3ZlIG9uZSByb3cgZG93biAodG9wbW9zdCBwaXhlbCBvZiBmaWxsYWJsZSBhcmVhKQogICAgICBwaXhlbFBvcyArPSByb3c7CgogICAgICBsZXQgcmVhY2hMZWZ0ID0gZmFsc2U7CiAgICAgIGxldCByZWFjaFJpZ2h0ID0gZmFsc2U7CiAgICAgIC8vIGZvciBlYWNoIHJvdywgY2hlY2sgaWYgdGhlIGZpcnN0IHBpeGVsIHN0aWxsIGhhcyB0aGUgc3RhcnQgY29sb3VyCiAgICAgIC8vIGlmIGl0IGRvZXMsIHBhaW50IGl0IGFuZCBwdXNoIHN1cnJvdW5kaW5nIHBpeGVscyB0byB0aGUgc3RhY2sgb2YgcGl4ZWxzIHRvIGNoZWNrCiAgICAgIHdoaWxlICgrK2NvbHVtblBvc2l0aW9uIDwgaGVpZ2h0IC0gMSAmJiBtYXRjaFN0YXJ0Q29sb3IocGl4ZWxQb3MpKSB7CiAgICAgICAgcGFpbnRQaXhlbChwaXhlbFBvcyk7CiAgICAgICAgLy8gY2hlY2sgdGhlIHBpeGVsIHRvIHRoZSBsZWZ0CiAgICAgICAgaWYgKHggPiAwKSB7CiAgICAgICAgICBpZiAobWF0Y2hTdGFydENvbG9yKHBpeGVsUG9zIC0gUElYRUwpKSB7CiAgICAgICAgICAgIGlmICghcmVhY2hMZWZ0KSB7CiAgICAgICAgICAgICAgcGl4ZWxTdGFjay5wdXNoKFt4IC0gMSwgY29sdW1uUG9zaXRpb25dKTsKICAgICAgICAgICAgICByZWFjaExlZnQgPSB0cnVlOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKHJlYWNoTGVmdCkgewogICAgICAgICAgICByZWFjaExlZnQgPSBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgLy8gY2hlY2sgdGhlIHBpeGVsIHRvIHRoZSByaWdodAogICAgICAgIGlmICh4IDwgd2lkdGggLSAxKSB7CiAgICAgICAgICBpZiAobWF0Y2hTdGFydENvbG9yKHBpeGVsUG9zICsgUElYRUwpKSB7CiAgICAgICAgICAgIGlmICghcmVhY2hSaWdodCkgewogICAgICAgICAgICAgIHBpeGVsU3RhY2sucHVzaChbeCArIDEsIGNvbHVtblBvc2l0aW9uXSk7CiAgICAgICAgICAgICAgcmVhY2hSaWdodCA9IHRydWU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAocmVhY2hSaWdodCkgewogICAgICAgICAgICByZWFjaFJpZ2h0ID0gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgcm93CiAgICAgICAgcGl4ZWxQb3MgKz0gcm93OwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIGltYWdlOwogIH07CgogIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsICh7IGRhdGEgfSkgPT4gewogICAgY29uc3QgcmVzdWx0ID0gZmxvb2RGaWxsKGRhdGEpOwoKICAgIGdsb2JhbFRoaXMucG9zdE1lc3NhZ2UoeyB0eXBlOiAnZmlsbC1yZXN1bHQnLCByZXN1bHQgfSwgW3Jlc3VsdC5idWZmZXJdKTsKICB9KTsKCn0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci5qcy5tYXAKCg==", function(u) {
  return s = s || t(g), new Worker(s, u);
});
class i {
  constructor(l, f) {
    this.x = l, this.y = f;
  }
  set(l, f) {
    this.x = l, this.y = f;
  }
}
class o extends i {
  constructor() {
    super(0, 0), this.down = !1, this.previous = new i(0, 0);
  }
}
class I {
  constructor() {
    this.eventListeners = /* @__PURE__ */ new Map();
  }
  addEventListener(l, f) {
    const p = this.eventListeners.get(l) || /* @__PURE__ */ new Set();
    p.add(f), this.eventListeners.set(l, p);
  }
  removeEventListener(l, f) {
    const p = this.eventListeners.get(l);
    p && p.delete(f);
  }
  dispatchEvent(l, f) {
    const p = this.eventListeners.get(l);
    p && [...p].forEach((m) => m(f));
  }
}
const h = (u, l, f, p) => {
  const m = (f - u) ** 2, b = (p - l) ** 2;
  return Math.sqrt(m + b);
}, C = (u) => (l) => {
  !l.isPrimary || l.button > 0 || (l.cancelable && l.preventDefault(), u(l));
}, c = Symbol("atrament mode - draw"), n = Symbol("atrament mode - erase"), a = Symbol("atrament mode - fill"), r = Symbol("atrament mode - disabled"), d = [c, n], G = ["weight", "smoothing", "adaptiveStroke", "mode"];
var Ee, qe, Xe, Ze, tt, Fe, Te, nt, rt, Qe, xe, je, ct, It, ut, Rt, ft, Ot, ot, vt, pt, Pt, dt, Lt, ht, Bt, _t, Mt, at, kt;
const Ye = class Ye extends I {
  constructor(f, p = {}) {
    var m, b;
    if (typeof window > "u")
      throw new Error("atrament: looks like we're not running in a browser");
    super();
    Oe(this, ct);
    Oe(this, ot);
    Oe(this, pt);
    Oe(this, dt);
    Oe(this, ht);
    Oe(this, _t);
    Oe(this, at);
    me(this, "adaptiveStroke", !0);
    me(this, "canvas");
    me(this, "recordStrokes", !1);
    me(this, "resolution", window.devicePixelRatio);
    me(this, "smoothing", 0.85);
    me(this, "thickness", 2);
    Oe(this, Ee, void 0);
    Oe(this, qe, !1);
    Oe(this, Xe, !1);
    Oe(this, Ze, []);
    Oe(this, tt, new e());
    Oe(this, Fe, c);
    Oe(this, Te, new o());
    Oe(this, nt, 0.5);
    Oe(this, rt, void 0);
    Oe(this, Qe, []);
    Oe(this, xe, 2);
    Oe(this, je, 2);
    this.canvas = Ne(m = Ye, ut, Rt).call(m, f, p), Be(this, Ee, Ne(b = Ye, ft, Ot).call(b, this.canvas, p)), Ne(this, ht, Bt).call(this), Be(this, rt, (({ canvas: y, move: v, down: k, up: S }) => {
      const $ = C(v), w = C(k), T = C(S);
      return y.addEventListener("pointermove", $), y.addEventListener("pointerdown", w), document.addEventListener("pointerup", T), document.addEventListener("pointerout", T), () => {
        y.removeEventListener("pointermove", $), y.removeEventListener("pointerdown", w), document.removeEventListener("pointerup", T), document.removeEventListener("pointerout", T);
      };
    })({ canvas: this.canvas, move: Ne(this, ot, vt).bind(this), down: Ne(this, pt, Pt).bind(this), up: Ne(this, dt, Lt).bind(this) })), G.forEach((y) => {
      p[y] !== void 0 && (this[y] = p[y]);
    });
  }
  beginStroke(f, p) {
    ge(this, Ee).moveTo(f, p), Be(this, xe, ge(this, je)), this.recordStrokes && (this.strokeTimestamp = performance.now()), this.dispatchEvent("strokestart", { x: f, y: p });
  }
  endStroke(f, p) {
    this.dispatchEvent("strokeend", { x: f, y: p }), this.recordStrokes && this.dispatchEvent("strokerecorded", { stroke: this.currentStroke }), Be(this, Qe, []), delete this.strokeTimestamp;
  }
  draw(f, p, m, b) {
    const y = m || f, v = b || p, k = this.getSmoothingFactor(h(f, p, y, v)), S = f - (f - y) * k, $ = p - (p - v) * k, w = h(S, $, y, v);
    if (this.adaptiveStroke) {
      const T = (w - 2) / (98 * (1 - ge(this, nt))) * (ge(this, ct, It) - ge(this, je)) + ge(this, je);
      ge(this, xe) > T ? Be(this, xe, ge(this, xe) - 0.25) : ge(this, xe) < T && Be(this, xe, ge(this, xe) + 0.25);
    } else
      Be(this, xe, ge(this, je));
    return ge(this, Ee).lineWidth = ge(this, xe), ge(this, Ee).beginPath(), ge(this, Ee).moveTo(y, v), ge(this, Ee).quadraticCurveTo(y, v, S, $), ge(this, Ee).closePath(), ge(this, Ee).stroke(), this.recordStrokes && (ge(this, Qe).push({ point: new i(f, p), time: performance.now() - this.strokeTimestamp }), this.dispatchEvent("segmentdrawn", { stroke: this.currentStroke })), ge(this, qe) || ge(this, Fe) !== c || (Be(this, qe, !0), this.dispatchEvent("dirty")), { x: S, y: $ };
  }
  clear() {
    Be(this, qe, !1), this.dispatchEvent("clean");
    const f = this.mode === n;
    f && (this.mode = c), ge(this, Ee).save(), ge(this, Ee).setTransform(1, 0, 0, 1, 0, 0), ge(this, Ee).clearRect(0, 0, this.canvas.width, this.canvas.height), ge(this, Ee).restore(), f && (this.mode = n);
  }
  destroy() {
    var f;
    this.clear(), (f = ge(this, rt)) == null || f.call(this);
  }
  get color() {
    return ge(this, Ee).strokeStyle;
  }
  set color(f) {
    if (typeof f != "string")
      throw new Error("atrament: wrong argument type setting color");
    ge(this, Ee).strokeStyle = f;
  }
  get weight() {
    return ge(this, je);
  }
  set weight(f) {
    if (typeof f != "number")
      throw new Error("atrament: wrong argument type setting weight");
    Be(this, xe, f), Be(this, je, f);
  }
  getSmoothingFactor(f) {
    return Math.min(0.87, this.smoothing + (f - 60) / 3e3);
  }
  get mode() {
    return ge(this, Fe);
  }
  set mode(f) {
    switch (f) {
      case n:
        Be(this, Fe, n), ge(this, Ee).globalCompositeOperation = "destination-out";
        break;
      case a:
        Be(this, Fe, a), ge(this, Ee).globalCompositeOperation = "source-over";
        break;
      case r:
        Be(this, Fe, r);
        break;
      case c:
        Be(this, Fe, c), ge(this, Ee).globalCompositeOperation = "source-over";
        break;
      default:
        throw new Error("atrament: mode is not one of the allowed modes.");
    }
  }
  get currentStroke() {
    return { segments: ge(this, Qe).slice(), mode: this.mode, weight: this.weight, smoothing: this.smoothing, color: this.color, adaptiveStroke: this.adaptiveStroke };
  }
  get dirty() {
    return ge(this, qe);
  }
};
Ee = new WeakMap(), qe = new WeakMap(), Xe = new WeakMap(), Ze = new WeakMap(), tt = new WeakMap(), Fe = new WeakMap(), Te = new WeakMap(), nt = new WeakMap(), rt = new WeakMap(), Qe = new WeakMap(), xe = new WeakMap(), je = new WeakMap(), ct = new WeakSet(), It = function() {
  return ge(this, je) + 30;
}, ut = new WeakSet(), Rt = function(f, p) {
  let m;
  if (f instanceof window.Node && f.tagName === "CANVAS")
    m = f;
  else {
    if (typeof f != "string")
      throw new Error(`atrament: can't look for canvas based on '${f}'`);
    m = document.querySelector(f);
  }
  if (!m)
    throw new Error("atrament: canvas not found");
  const b = p.resolution || window.devicePixelRatio;
  return m.width = (p.width || m.width) * b, m.height = (p.height || m.height) * b, m.style.touchAction = "none", m;
}, ft = new WeakSet(), Ot = function(f, p) {
  const m = f.getContext("2d"), b = p.resolution || window.devicePixelRatio;
  return m.scale(b, b), m.globalCompositeOperation = "source-over", m.globalAlpha = 1, m.strokeStyle = p.color || "rgba(0,0,0,1)", m.lineCap = "round", m.lineJoin = "round", m;
}, ot = new WeakSet(), vt = function(f) {
  var p;
  (((p = f.getCoalescedEvents) == null ? void 0 : p.call(f)) || [f]).forEach((m) => {
    const b = m.offsetX, y = m.offsetY;
    if (ge(this, Te).down && d.includes(ge(this, Fe))) {
      const { x: v, y: k } = this.draw(b, y, ge(this, Te).previous.x, ge(this, Te).previous.y);
      ge(this, Te).set(b, y), ge(this, Te).previous.set(v, k), Be(this, nt, m.pressure === 1 ? 0.5 : m.pressure || 0.5);
    } else
      ge(this, Te).set(b, y), ge(this, Te).previous.set(b, y);
  });
}, pt = new WeakSet(), Pt = function(f) {
  this.mode !== a ? (ge(this, Te).down = !0, Ne(this, ot, vt).call(this, f), this.beginStroke(ge(this, Te).previous.x, ge(this, Te).previous.y)) : Ne(this, _t, Mt).call(this);
}, dt = new WeakSet(), Lt = function(f) {
  ge(this, Fe) !== a && ge(this, Te).down && (ge(this, Te).down = !1, ge(this, Te).x === f.offsetX && ge(this, Te).y === f.offsetY && d.includes(this.mode) && this.draw(ge(this, Te).x, ge(this, Te).y, ge(this, Te).previous.x, ge(this, Te).previous.y), ge(this, Te).previous.set(0, 0), this.endStroke(ge(this, Te).x, ge(this, Te).y));
}, ht = new WeakSet(), Bt = function() {
  ge(this, tt).addEventListener("message", ({ data: f }) => {
    if (f.type === "fill-result") {
      Be(this, Xe, !1), this.dispatchEvent("fillend", {});
      const p = new ImageData(f.result, this.canvas.width, this.canvas.height);
      ge(this, Ee).putImageData(p, 0, 0), ge(this, Ze).length > 0 && Ne(this, at, kt).call(this, ge(this, Ze).shift());
    }
  });
}, _t = new WeakSet(), Mt = function() {
  const { x: f, y: p } = ge(this, Te);
  this.dispatchEvent("fillstart", { x: f, y: p });
  const m = Array.from(ge(this, Ee).getImageData(f, p, 1, 1).data), b = { color: this.color, globalAlpha: ge(this, Ee).globalAlpha, width: this.canvas.width, height: this.canvas.height, startColor: m, startX: f * this.resolution, startY: p * this.resolution };
  ge(this, Xe) ? ge(this, Ze).push(b) : (Be(this, Xe, !0), Ne(this, at, kt).call(this, b));
}, at = new WeakSet(), kt = function(f) {
  const p = ge(this, Ee).getImageData(0, 0, this.canvas.width, this.canvas.height).data;
  ge(this, tt).postMessage({ image: p, ...f }, [p.buffer]);
}, Oe(Ye, ut), Oe(Ye, ft);
let A = Ye;
const Signature_svelte_svelte_type_style_lang = "";
function create_if_block_3$8(u) {
  var y;
  let l, f, p, m = (
    /*updated*/
    u[11] && /*saveIcon*/
    u[4] && create_if_block_5$5(u)
  ), b = (
    /*signatureFile*/
    ((y = u[8]) == null ? void 0 : y.url) && !/*updated*/
    u[11] && create_if_block_4$5(u)
  );
  return {
    c() {
      l = element("div"), m && m.c(), f = space(), b && b.c(), attr(l, "class", "overlay svelte-jdhkye");
    },
    m(v, k) {
      insert(v, l, k), m && m.m(l, null), append$1(l, f), b && b.m(l, null), p = !0;
    },
    p(v, k) {
      var S;
      /*updated*/
      v[11] && /*saveIcon*/
      v[4] ? m ? (m.p(v, k), k & /*updated, saveIcon*/
      2064 && transition_in(m, 1)) : (m = create_if_block_5$5(v), m.c(), transition_in(m, 1), m.m(l, f)) : m && (group_outros(), transition_out(m, 1, 1, () => {
        m = null;
      }), check_outros()), /*signatureFile*/
      (S = v[8]) != null && S.url && !/*updated*/
      v[11] ? b ? (b.p(v, k), k & /*signatureFile, updated*/
      2304 && transition_in(b, 1)) : (b = create_if_block_4$5(v), b.c(), transition_in(b, 1), b.m(l, null)) : b && (group_outros(), transition_out(b, 1, 1, () => {
        b = null;
      }), check_outros());
    },
    i(v) {
      p || (transition_in(m), transition_in(b), p = !0);
    },
    o(v) {
      transition_out(m), transition_out(b), p = !1;
    },
    d(v) {
      v && detach(l), m && m.d(), b && b.d();
    }
  };
}
function create_if_block_5$5(u) {
  let l, f, p;
  return f = new Icon({
    props: {
      name: "check",
      hoverable: !0,
      tooltip: "Save",
      tooltipPosition: "top",
      tooltipType: "info"
    }
  }), f.$on(
    "click",
    /*click_handler*/
    u[17]
  ), {
    c() {
      l = element("span"), create_component(f.$$.fragment), attr(l, "class", "save svelte-jdhkye");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p: noop$4,
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block_4$5(u) {
  let l, f, p;
  return f = new Icon({
    props: {
      name: "trash",
      hoverable: !0,
      tooltip: "Delete",
      tooltipPosition: "top",
      tooltipType: "info"
    }
  }), f.$on(
    "click",
    /*click_handler_1*/
    u[18]
  ), {
    c() {
      l = element("span"), create_component(f.$$.fragment), attr(l, "class", "delete svelte-jdhkye");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p: noop$4,
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_else_block_1$3(u) {
  let l, f, p, m, b = (
    /*editable*/
    u[1] && create_if_block_2$g()
  );
  return {
    c() {
      l = element("div"), f = element("canvas"), p = space(), b && b.c(), attr(f, "id", "signature-canvas"), set_style(
        f,
        "--max-sig-width",
        /*width*/
        u[2] + "px"
      ), set_style(
        f,
        "--max-sig-height",
        /*height*/
        u[3] + "px"
      ), attr(f, "class", "svelte-jdhkye"), attr(l, "class", "canvas-wrap svelte-jdhkye");
    },
    m(y, v) {
      insert(y, l, v), append$1(l, f), u[20](f), append$1(l, p), b && b.m(l, null), u[21](l), m = !0;
    },
    p(y, v) {
      (!m || v & /*width*/
      4) && set_style(
        f,
        "--max-sig-width",
        /*width*/
        y[2] + "px"
      ), (!m || v & /*height*/
      8) && set_style(
        f,
        "--max-sig-height",
        /*height*/
        y[3] + "px"
      ), /*editable*/
      y[1] ? b ? v & /*editable*/
      2 && transition_in(b, 1) : (b = create_if_block_2$g(), b.c(), transition_in(b, 1), b.m(l, null)) : b && (group_outros(), transition_out(b, 1, 1, () => {
        b = null;
      }), check_outros());
    },
    i(y) {
      m || (transition_in(b), m = !0);
    },
    o(y) {
      transition_out(b), m = !1;
    },
    d(y) {
      y && detach(l), u[20](null), b && b.d(), u[21](null);
    }
  };
}
function create_if_block$F(u) {
  let l;
  function f(b, y) {
    return (
      /*urlFailed*/
      b[12] ? create_else_block$d : create_if_block_1$l
    );
  }
  let p = f(u), m = p(u);
  return {
    c() {
      m.c(), l = empty$1();
    },
    m(b, y) {
      m.m(b, y), insert(b, l, y);
    },
    p(b, y) {
      p === (p = f(b)) && m ? m.p(b, y) : (m.d(1), m = p(b), m && (m.c(), m.m(l.parentNode, l)));
    },
    i: noop$4,
    o: noop$4,
    d(b) {
      b && detach(l), m.d(b);
    }
  };
}
function create_if_block_2$g(u) {
  let l, f, p, m, b, y;
  return p = new Icon({ props: { name: "x" } }), {
    c() {
      l = element("div"), f = element("div"), create_component(p.$$.fragment), m = space(), b = element("hr"), attr(b, "class", "svelte-jdhkye"), attr(f, "class", "sign-here svelte-jdhkye"), attr(l, "class", "indicator-overlay svelte-jdhkye");
    },
    m(v, k) {
      insert(v, l, k), append$1(l, f), mount_component(p, f, null), append$1(f, m), append$1(f, b), y = !0;
    },
    i(v) {
      y || (transition_in(p.$$.fragment, v), y = !0);
    },
    o(v) {
      transition_out(p.$$.fragment, v), y = !1;
    },
    d(v) {
      v && detach(l), destroy_component(p);
    }
  };
}
function create_else_block$d(u) {
  let l;
  return {
    c() {
      l = text$2("Could not load signature");
    },
    m(f, p) {
      insert(f, l, p);
    },
    p: noop$4,
    d(f) {
      f && detach(l);
    }
  };
}
function create_if_block_1$l(u) {
  let l, f, p, m;
  return {
    c() {
      var b;
      l = element("img"), src_url_equal(l.src, f = /*signatureFile*/
      (b = u[8]) == null ? void 0 : b.url) || attr(l, "src", f), attr(l, "class", "svelte-jdhkye");
    },
    m(b, y) {
      insert(b, l, y), p || (m = listen(
        l,
        "error",
        /*error_handler*/
        u[19]
      ), p = !0);
    },
    p(b, y) {
      var v;
      y & /*signatureFile*/
      256 && !src_url_equal(l.src, f = /*signatureFile*/
      (v = b[8]) == null ? void 0 : v.url) && attr(l, "src", f);
    },
    d(b) {
      b && detach(l), p = !1, m();
    }
  };
}
function create_fragment$1g(u) {
  let l, f, p, m, b, y = !/*disabled*/
  u[0] && create_if_block_3$8(u);
  const v = [create_if_block$F, create_else_block_1$3], k = [];
  function S($, w) {
    var T;
    return !/*editable*/
    $[1] && /*signatureFile*/
    ((T = $[8]) != null && T.url) ? 0 : 1;
  }
  return p = S(u), m = k[p] = v[p](u), {
    c() {
      l = element("div"), y && y.c(), f = space(), m.c(), attr(l, "class", "signature svelte-jdhkye"), toggle_class(l, "light", !/*darkMode*/
      u[5]), toggle_class(
        l,
        "image-error",
        /*urlFailed*/
        u[12]
      );
    },
    m($, w) {
      insert($, l, w), y && y.m(l, null), append$1(l, f), k[p].m(l, null), b = !0;
    },
    p($, [w]) {
      /*disabled*/
      $[0] ? y && (group_outros(), transition_out(y, 1, 1, () => {
        y = null;
      }), check_outros()) : y ? (y.p($, w), w & /*disabled*/
      1 && transition_in(y, 1)) : (y = create_if_block_3$8($), y.c(), transition_in(y, 1), y.m(l, f));
      let T = p;
      p = S($), p === T ? k[p].p($, w) : (group_outros(), transition_out(k[T], 1, 1, () => {
        k[T] = null;
      }), check_outros(), m = k[p], m ? m.p($, w) : (m = k[p] = v[p]($), m.c()), transition_in(m, 1), m.m(l, null)), (!b || w & /*darkMode*/
      32) && toggle_class(l, "light", !/*darkMode*/
      $[5]), (!b || w & /*urlFailed*/
      4096) && toggle_class(
        l,
        "image-error",
        /*urlFailed*/
        $[12]
      );
    },
    i($) {
      b || (transition_in(y), transition_in(m), b = !0);
    },
    o($) {
      transition_out(y), transition_out(m), b = !1;
    },
    d($) {
      $ && detach(l), y && y.d(), k[p].d();
    }
  };
}
function instance$1e(u, l, f) {
  const p = createEventDispatcher();
  let m, { value: b } = l, { disabled: y = !1 } = l, { editable: v = !0 } = l, { width: k = 400 } = l, { height: S = 220 } = l, { saveIcon: $ = !1 } = l, { darkMode: w } = l;
  function T() {
    return O.toDataURL("image/png");
  }
  function E() {
    if (!P.getImageData(0, 0, k, S).data.some((oe) => oe !== 0))
      return;
    let Q = T().split(",");
    Q.length || console.error("Could not retrieve signature data");
    let z = atob(Q[1]), H = new Uint8Array(z.length), X = 0;
    for (; X < z.length; )
      H[X] = z.charCodeAt(X), X++;
    const Z = new Blob([H], { type: "image/png" });
    return new File([Z], "signature.png", { type: Z.type });
  }
  function R() {
    return P.clearRect(0, 0, M, B);
  }
  let O, P, L, M, B, j, x = !1, N, D;
  onMount(() => {
    if (!v)
      return;
    const q = (X) => {
      var ie, de;
      let Z = O.getBoundingClientRect();
      const oe = X.offsetX || ((ie = X.targetTouches) == null ? void 0 : ie[0].pageX) - Z.left, ee = X.offsetY || ((de = X.targetTouches) == null ? void 0 : de[0].pageY) - Z.top;
      return { x: oe, y: ee };
    }, Q = (X) => {
      f(16, m = q(X));
    };
    O.addEventListener("pointerdown", (X) => {
      const Z = q(X);
      (m == null ? void 0 : m.x) === (Z == null ? void 0 : Z.x) && (m == null ? void 0 : m.y) === (Z == null ? void 0 : Z.y) && (X.preventDefault(), X.stopImmediatePropagation());
    }), document.addEventListener("pointerup", Q), j = new A(O, { width: k, height: S, color: "white" }), j.weight = 4, j.smoothing = 2, f(10, L.style.width = `${k}px`, L), f(10, L.style.height = `${S}px`, L);
    const { width: z, height: H } = L.getBoundingClientRect();
    return B = H, M = z, P = O.getContext("2d"), () => {
      j.destroy(), document.removeEventListener("pointerup", Q);
    };
  });
  const V = () => {
    p("change", T());
  }, W = () => {
    v && R(), p("clear");
  }, F = () => {
    f(12, D = !0);
  };
  function U(q) {
    binding_callbacks[q ? "unshift" : "push"](() => {
      O = q, f(9, O);
    });
  }
  function Y(q) {
    binding_callbacks[q ? "unshift" : "push"](() => {
      L = q, f(10, L);
    });
  }
  return u.$$set = (q) => {
    "value" in q && f(14, b = q.value), "disabled" in q && f(0, y = q.disabled), "editable" in q && f(1, v = q.editable), "width" in q && f(2, k = q.width), "height" in q && f(3, S = q.height), "saveIcon" in q && f(4, $ = q.saveIcon), "darkMode" in q && f(5, w = q.darkMode);
  }, u.$$.update = () => {
    u.$$.dirty & /*value*/
    16384 && b && f(8, N = b), u.$$.dirty & /*signatureFile*/
    256 && N != null && N.url && f(11, x = !1), u.$$.dirty & /*last*/
    65536 && m && p("update");
  }, [
    y,
    v,
    k,
    S,
    $,
    w,
    T,
    R,
    N,
    O,
    L,
    x,
    D,
    p,
    b,
    E,
    m,
    V,
    W,
    F,
    U,
    Y
  ];
}
class Signature extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1e, create_fragment$1g, safe_not_equal, {
      value: 14,
      disabled: 0,
      editable: 1,
      width: 2,
      height: 3,
      saveIcon: 4,
      darkMode: 5,
      toDataUrl: 6,
      toFile: 15,
      clearCanvas: 7
    });
  }
  get toDataUrl() {
    return this.$$.ctx[6];
  }
  get toFile() {
    return this.$$.ctx[15];
  }
  get clearCanvas() {
    return this.$$.ctx[7];
  }
}
const indexVars$i = "", Slider_svelte_svelte_type_style_lang = "", indexVars$h = "", Stepper_svelte_svelte_type_style_lang = "", indexVars$g = "", Switch_svelte_svelte_type_style_lang = "";
function create_if_block$E(u) {
  let l, f;
  return {
    c() {
      l = element("label"), f = text$2(
        /*text*/
        u[2]
      ), attr(l, "class", "spectrum-Switch-label"), attr(
        l,
        "for",
        /*id*/
        u[1]
      );
    },
    m(p, m) {
      insert(p, l, m), append$1(l, f);
    },
    p(p, m) {
      m & /*text*/
      4 && set_data(
        f,
        /*text*/
        p[2]
      ), m & /*id*/
      2 && attr(
        l,
        "for",
        /*id*/
        p[1]
      );
    },
    d(p) {
      p && detach(l);
    }
  };
}
function create_fragment$1f(u) {
  let l, f, p, m, b, y, v, k = (
    /*text*/
    u[2] && create_if_block$E(u)
  );
  return {
    c() {
      l = element("div"), f = element("input"), p = space(), m = element("span"), b = space(), k && k.c(), f.checked = /*value*/
      u[0], f.disabled = /*disabled*/
      u[3], attr(
        f,
        "id",
        /*id*/
        u[1]
      ), attr(f, "type", "checkbox"), attr(f, "class", "spectrum-Switch-input svelte-7919tl"), attr(m, "class", "spectrum-Switch-switch"), attr(l, "class", "spectrum-Switch spectrum-Switch--emphasized svelte-7919tl"), toggle_class(
        l,
        "noPadding",
        /*noPadding*/
        u[4]
      );
    },
    m(S, $) {
      insert(S, l, $), append$1(l, f), append$1(l, p), append$1(l, m), append$1(l, b), k && k.m(l, null), y || (v = [
        listen(
          f,
          "change",
          /*onChange*/
          u[5]
        ),
        listen(
          f,
          "click",
          /*click_handler*/
          u[6]
        ),
        listen(f, "click", stop_propagation(
          /*click_handler_1*/
          u[7]
        ))
      ], y = !0);
    },
    p(S, [$]) {
      $ & /*value*/
      1 && (f.checked = /*value*/
      S[0]), $ & /*disabled*/
      8 && (f.disabled = /*disabled*/
      S[3]), $ & /*id*/
      2 && attr(
        f,
        "id",
        /*id*/
        S[1]
      ), /*text*/
      S[2] ? k ? k.p(S, $) : (k = create_if_block$E(S), k.c(), k.m(l, null)) : k && (k.d(1), k = null), $ & /*noPadding*/
      16 && toggle_class(
        l,
        "noPadding",
        /*noPadding*/
        S[4]
      );
    },
    i: noop$4,
    o: noop$4,
    d(S) {
      S && detach(l), k && k.d(), y = !1, run_all(v);
    }
  };
}
function instance$1d(u, l, f) {
  let { value: p = !1 } = l, { id: m = null } = l, { text: b = null } = l, { disabled: y = !1 } = l, { noPadding: v = !1 } = l;
  const k = createEventDispatcher(), S = (T) => {
    const E = T.target;
    k("change", E.checked);
  };
  function $(T) {
    bubble.call(this, u, T);
  }
  function w(T) {
    bubble.call(this, u, T);
  }
  return u.$$set = (T) => {
    "value" in T && f(0, p = T.value), "id" in T && f(1, m = T.id), "text" in T && f(2, b = T.text), "disabled" in T && f(3, y = T.disabled), "noPadding" in T && f(4, v = T.noPadding);
  }, [p, m, b, y, v, S, $, w];
}
class Switch extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1d, create_fragment$1f, safe_not_equal, {
      value: 0,
      id: 1,
      text: 2,
      disabled: 3,
      noPadding: 4
    });
  }
}
const TextArea_svelte_svelte_type_style_lang = "", TextField_svelte_svelte_type_style_lang = "";
function create_fragment$1e(u) {
  let l, f, p, m, b, y, v, k, S, $;
  const w = (
    /*#slots*/
    u[20].default
  ), T = create_slot(
    w,
    u,
    /*$$scope*/
    u[19],
    null
  );
  return {
    c() {
      l = element("div"), f = element("input"), v = space(), T && T.c(), f.disabled = /*disabled*/
      u[3], f.readOnly = /*readonly*/
      u[5], attr(
        f,
        "id",
        /*id*/
        u[4]
      ), f.value = p = /*value*/
      u[0] ?? "", attr(f, "placeholder", m = /*placeholder*/
      u[1] ?? ""), attr(
        f,
        "type",
        /*type*/
        u[2]
      ), attr(f, "class", "spectrum-Textfield-input svelte-15e87u6"), attr(f, "style", b = /*align*/
      u[7] ? `text-align: ${/*align*/
      u[7]};` : ""), attr(f, "inputmode", y = /*getInputMode*/
      u[15](
        /*type*/
        u[2]
      )), attr(
        f,
        "autocomplete",
        /*autocompleteValue*/
        u[10]
      ), attr(l, "class", "spectrum-Textfield svelte-15e87u6"), toggle_class(
        l,
        "spectrum-Textfield--quiet",
        /*quiet*/
        u[6]
      ), toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        u[3]
      ), toggle_class(
        l,
        "is-focused",
        /*focus*/
        u[9]
      );
    },
    m(E, R) {
      insert(E, l, R), append$1(l, f), u[27](f), append$1(l, v), T && T.m(l, null), k = !0, S || ($ = [
        listen(
          f,
          "click",
          /*click_handler*/
          u[21]
        ),
        listen(
          f,
          "blur",
          /*blur_handler*/
          u[22]
        ),
        listen(
          f,
          "focus",
          /*focus_handler*/
          u[23]
        ),
        listen(
          f,
          "input",
          /*input_handler*/
          u[24]
        ),
        listen(
          f,
          "keyup",
          /*keyup_handler*/
          u[25]
        ),
        listen(
          f,
          "keydown",
          /*keydown_handler*/
          u[26]
        ),
        listen(
          f,
          "blur",
          /*onBlur*/
          u[12]
        ),
        listen(
          f,
          "focus",
          /*onFocus*/
          u[11]
        ),
        listen(
          f,
          "input",
          /*onInput*/
          u[13]
        ),
        listen(
          f,
          "keyup",
          /*updateValueOnEnter*/
          u[14]
        )
      ], S = !0);
    },
    p(E, [R]) {
      (!k || R & /*disabled*/
      8) && (f.disabled = /*disabled*/
      E[3]), (!k || R & /*readonly*/
      32) && (f.readOnly = /*readonly*/
      E[5]), (!k || R & /*id*/
      16) && attr(
        f,
        "id",
        /*id*/
        E[4]
      ), (!k || R & /*value*/
      1 && p !== (p = /*value*/
      E[0] ?? "") && f.value !== p) && (f.value = p), (!k || R & /*placeholder*/
      2 && m !== (m = /*placeholder*/
      E[1] ?? "")) && attr(f, "placeholder", m), (!k || R & /*type*/
      4) && attr(
        f,
        "type",
        /*type*/
        E[2]
      ), (!k || R & /*align*/
      128 && b !== (b = /*align*/
      E[7] ? `text-align: ${/*align*/
      E[7]};` : "")) && attr(f, "style", b), (!k || R & /*type*/
      4 && y !== (y = /*getInputMode*/
      E[15](
        /*type*/
        E[2]
      ))) && attr(f, "inputmode", y), (!k || R & /*autocompleteValue*/
      1024) && attr(
        f,
        "autocomplete",
        /*autocompleteValue*/
        E[10]
      ), T && T.p && (!k || R & /*$$scope*/
      524288) && update_slot_base(
        T,
        w,
        E,
        /*$$scope*/
        E[19],
        k ? get_slot_changes(
          w,
          /*$$scope*/
          E[19],
          R,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          E[19]
        ),
        null
      ), (!k || R & /*quiet*/
      64) && toggle_class(
        l,
        "spectrum-Textfield--quiet",
        /*quiet*/
        E[6]
      ), (!k || R & /*disabled*/
      8) && toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        E[3]
      ), (!k || R & /*focus*/
      512) && toggle_class(
        l,
        "is-focused",
        /*focus*/
        E[9]
      );
    },
    i(E) {
      k || (transition_in(T, E), k = !0);
    },
    o(E) {
      transition_out(T, E), k = !1;
    },
    d(E) {
      E && detach(l), u[27](null), T && T.d(E), S = !1, run_all($);
    }
  };
}
function instance$1c(u, l, f) {
  let p, { $$slots: m = {}, $$scope: b } = l, { value: y = null } = l, { placeholder: v = void 0 } = l, { type: k = "text" } = l, { disabled: S = !1 } = l, { id: $ = null } = l, { readonly: w = !1 } = l, { updateOnChange: T = !0 } = l, { quiet: E = !1 } = l, { align: R = void 0 } = l, { autofocus: O = !1 } = l, { autocomplete: P } = l;
  const L = createEventDispatcher();
  let M, B = !1;
  const j = (X) => {
    if (!(w || S)) {
      if (k === "number") {
        const Z = parseFloat(X);
        X = isNaN(Z) ? null : Z;
      }
      L("change", X);
    }
  }, x = () => {
    w || S || f(9, B = !0);
  }, N = (X) => {
    var Z;
    w || S || (f(9, B = !1), j((Z = X == null ? void 0 : X.target) == null ? void 0 : Z.value));
  }, D = (X) => {
    var Z;
    w || !T || S || j((Z = X.target) == null ? void 0 : Z.value);
  }, V = (X) => {
    var Z;
    w || S || X.key === "Enter" && j((Z = X.target) == null ? void 0 : Z.value);
  }, W = (X) => X === "bigint" ? "numeric" : X === "number" ? "decimal" : "text";
  onMount(async () => {
    S || (f(9, B = O || !1), B && (await tick(), M.focus()));
  });
  function F(X) {
    bubble.call(this, u, X);
  }
  function U(X) {
    bubble.call(this, u, X);
  }
  function Y(X) {
    bubble.call(this, u, X);
  }
  function q(X) {
    bubble.call(this, u, X);
  }
  function Q(X) {
    bubble.call(this, u, X);
  }
  function z(X) {
    bubble.call(this, u, X);
  }
  function H(X) {
    binding_callbacks[X ? "unshift" : "push"](() => {
      M = X, f(8, M);
    });
  }
  return u.$$set = (X) => {
    "value" in X && f(0, y = X.value), "placeholder" in X && f(1, v = X.placeholder), "type" in X && f(2, k = X.type), "disabled" in X && f(3, S = X.disabled), "id" in X && f(4, $ = X.id), "readonly" in X && f(5, w = X.readonly), "updateOnChange" in X && f(16, T = X.updateOnChange), "quiet" in X && f(6, E = X.quiet), "align" in X && f(7, R = X.align), "autofocus" in X && f(17, O = X.autofocus), "autocomplete" in X && f(18, P = X.autocomplete), "$$scope" in X && f(19, b = X.$$scope);
  }, u.$$.update = () => {
    u.$$.dirty & /*autocomplete*/
    262144 && f(10, p = typeof P == "boolean" ? P ? "on" : "off" : void 0);
  }, [
    y,
    v,
    k,
    S,
    $,
    w,
    E,
    R,
    M,
    B,
    p,
    x,
    N,
    D,
    V,
    W,
    T,
    O,
    P,
    b,
    m,
    F,
    U,
    Y,
    q,
    Q,
    z,
    H
  ];
}
class TextField extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1c, create_fragment$1e, safe_not_equal, {
      value: 0,
      placeholder: 1,
      type: 2,
      disabled: 3,
      id: 4,
      readonly: 5,
      updateOnChange: 16,
      quiet: 6,
      align: 7,
      autofocus: 17,
      autocomplete: 18
    });
  }
}
function create_default_slot_1$f(u) {
  let l;
  const f = (
    /*#slots*/
    u[16].default
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[22],
    null
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, b) {
      p && p.p && (!l || b & /*$$scope*/
      4194304) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[22],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[22],
          b,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[22]
        ),
        null
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function create_default_slot$E(u) {
  let l, f;
  return l = new TextField({
    props: {
      updateOnChange: (
        /*updateOnChange*/
        u[8]
      ),
      disabled: (
        /*disabled*/
        u[5]
      ),
      readonly: (
        /*readonly*/
        u[6]
      ),
      value: (
        /*value*/
        u[0]
      ),
      placeholder: (
        /*placeholder*/
        u[3]
      ),
      type: (
        /*type*/
        u[4]
      ),
      quiet: (
        /*quiet*/
        u[9]
      ),
      autofocus: (
        /*autofocus*/
        u[10]
      ),
      autocomplete: (
        /*autocomplete*/
        u[11]
      ),
      $$slots: { default: [create_default_slot_1$f] },
      $$scope: { ctx: u }
    }
  }), l.$on(
    "change",
    /*onChange*/
    u[13]
  ), l.$on(
    "click",
    /*click_handler*/
    u[17]
  ), l.$on(
    "input",
    /*input_handler*/
    u[18]
  ), l.$on(
    "blur",
    /*onBlur*/
    u[14]
  ), l.$on(
    "focus",
    /*focus_handler*/
    u[19]
  ), l.$on(
    "keyup",
    /*keyup_handler*/
    u[20]
  ), l.$on(
    "keydown",
    /*keydown_handler*/
    u[21]
  ), l.$on(
    "keydown",
    /*onKeyDown*/
    u[15]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*updateOnChange*/
      256 && (b.updateOnChange = /*updateOnChange*/
      p[8]), m & /*disabled*/
      32 && (b.disabled = /*disabled*/
      p[5]), m & /*readonly*/
      64 && (b.readonly = /*readonly*/
      p[6]), m & /*value*/
      1 && (b.value = /*value*/
      p[0]), m & /*placeholder*/
      8 && (b.placeholder = /*placeholder*/
      p[3]), m & /*type*/
      16 && (b.type = /*type*/
      p[4]), m & /*quiet*/
      512 && (b.quiet = /*quiet*/
      p[9]), m & /*autofocus*/
      1024 && (b.autofocus = /*autofocus*/
      p[10]), m & /*autocomplete*/
      2048 && (b.autocomplete = /*autocomplete*/
      p[11]), m & /*$$scope*/
      4194304 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$1d(u) {
  let l, f;
  return l = new Field({
    props: {
      helpText: (
        /*helpText*/
        u[12]
      ),
      label: (
        /*label*/
        u[1]
      ),
      labelPosition: (
        /*labelPosition*/
        u[2]
      ),
      error: (
        /*error*/
        u[7]
      ),
      $$slots: { default: [create_default_slot$E] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*helpText*/
      4096 && (b.helpText = /*helpText*/
      p[12]), m & /*label*/
      2 && (b.label = /*label*/
      p[1]), m & /*labelPosition*/
      4 && (b.labelPosition = /*labelPosition*/
      p[2]), m & /*error*/
      128 && (b.error = /*error*/
      p[7]), m & /*$$scope, updateOnChange, disabled, readonly, value, placeholder, type, quiet, autofocus, autocomplete*/
      4198265 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$1b(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l, { value: b = void 0 } = l, { label: y = void 0 } = l, { labelPosition: v = "above" } = l, { placeholder: k = void 0 } = l, { type: S = "text" } = l, { disabled: $ = !1 } = l, { readonly: w = !1 } = l, { error: T = void 0 } = l, { updateOnChange: E = !0 } = l, { quiet: R = !1 } = l, { autofocus: O = void 0 } = l, { autocomplete: P = void 0 } = l, { helpText: L = void 0 } = l;
  const M = createEventDispatcher(), B = (U) => {
    f(0, b = U.detail), M("change", U.detail);
  }, j = () => {
    M("blur", b);
  }, x = (U) => {
    w || $ || U.key === "Enter" && M("enterkey", U);
  };
  function N(U) {
    bubble.call(this, u, U);
  }
  function D(U) {
    bubble.call(this, u, U);
  }
  function V(U) {
    bubble.call(this, u, U);
  }
  function W(U) {
    bubble.call(this, u, U);
  }
  function F(U) {
    bubble.call(this, u, U);
  }
  return u.$$set = (U) => {
    "value" in U && f(0, b = U.value), "label" in U && f(1, y = U.label), "labelPosition" in U && f(2, v = U.labelPosition), "placeholder" in U && f(3, k = U.placeholder), "type" in U && f(4, S = U.type), "disabled" in U && f(5, $ = U.disabled), "readonly" in U && f(6, w = U.readonly), "error" in U && f(7, T = U.error), "updateOnChange" in U && f(8, E = U.updateOnChange), "quiet" in U && f(9, R = U.quiet), "autofocus" in U && f(10, O = U.autofocus), "autocomplete" in U && f(11, P = U.autocomplete), "helpText" in U && f(12, L = U.helpText), "$$scope" in U && f(22, m = U.$$scope);
  }, [
    b,
    y,
    v,
    k,
    S,
    $,
    w,
    T,
    E,
    R,
    O,
    P,
    L,
    B,
    j,
    x,
    p,
    N,
    D,
    V,
    W,
    F,
    m
  ];
}
class Input extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1b, create_fragment$1d, safe_not_equal, {
      value: 0,
      label: 1,
      labelPosition: 2,
      placeholder: 3,
      type: 4,
      disabled: 5,
      readonly: 6,
      error: 7,
      updateOnChange: 8,
      quiet: 9,
      autofocus: 10,
      autocomplete: 11,
      helpText: 12
    });
  }
}
const InputDropdown_svelte_svelte_type_style_lang = "";
function create_default_slot$D(u) {
  let l, f;
  return l = new Switch({
    props: {
      disabled: (
        /*disabled*/
        u[4]
      ),
      text: (
        /*text*/
        u[3]
      ),
      noPadding: (
        /*noPadding*/
        u[7]
      ),
      value: (
        /*value*/
        u[0] ?? void 0
      )
    }
  }), l.$on(
    "change",
    /*onChange*/
    u[8]
  ), l.$on(
    "click",
    /*click_handler*/
    u[9]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*disabled*/
      16 && (b.disabled = /*disabled*/
      p[4]), m & /*text*/
      8 && (b.text = /*text*/
      p[3]), m & /*noPadding*/
      128 && (b.noPadding = /*noPadding*/
      p[7]), m & /*value*/
      1 && (b.value = /*value*/
      p[0] ?? void 0), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$1c(u) {
  let l, f;
  return l = new Field({
    props: {
      helpText: (
        /*helpText*/
        u[6]
      ),
      label: (
        /*label*/
        u[1]
      ),
      labelPosition: (
        /*labelPosition*/
        u[2]
      ),
      error: (
        /*error*/
        u[5]
      ),
      $$slots: { default: [create_default_slot$D] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*helpText*/
      64 && (b.helpText = /*helpText*/
      p[6]), m & /*label*/
      2 && (b.label = /*label*/
      p[1]), m & /*labelPosition*/
      4 && (b.labelPosition = /*labelPosition*/
      p[2]), m & /*error*/
      32 && (b.error = /*error*/
      p[5]), m & /*$$scope, disabled, text, noPadding, value*/
      2201 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$1a(u, l, f) {
  let { value: p = void 0 } = l, { label: m = void 0 } = l, { labelPosition: b = "above" } = l, { text: y = void 0 } = l, { disabled: v = !1 } = l, { error: k = void 0 } = l, { helpText: S = void 0 } = l, { noPadding: $ = !1 } = l;
  const w = createEventDispatcher(), T = (R) => {
    f(0, p = R.detail), w("change", R.detail);
  };
  function E(R) {
    bubble.call(this, u, R);
  }
  return u.$$set = (R) => {
    "value" in R && f(0, p = R.value), "label" in R && f(1, m = R.label), "labelPosition" in R && f(2, b = R.labelPosition), "text" in R && f(3, y = R.text), "disabled" in R && f(4, v = R.disabled), "error" in R && f(5, k = R.error), "helpText" in R && f(6, S = R.helpText), "noPadding" in R && f(7, $ = R.noPadding);
  }, [
    p,
    m,
    b,
    y,
    v,
    k,
    S,
    $,
    T,
    E
  ];
}
class Toggle extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1a, create_fragment$1c, safe_not_equal, {
      value: 0,
      label: 1,
      labelPosition: 2,
      text: 3,
      disabled: 4,
      error: 5,
      helpText: 6,
      noPadding: 7
    });
  }
}
const ErrorMessage_svelte_svelte_type_style_lang = "", FancyField_svelte_svelte_type_style_lang = "", FancyButton_svelte_svelte_type_style_lang = "", FancyFieldLabel_svelte_svelte_type_style_lang = "", FancyButtonRadio_svelte_svelte_type_style_lang = "", FancyCheckbox_svelte_svelte_type_style_lang = "", FancyForm_svelte_svelte_type_style_lang = "", FancyCheckboxGroup_svelte_svelte_type_style_lang = "", FancyInput_svelte_svelte_type_style_lang = "", FancySelect_svelte_svelte_type_style_lang = "", indexVars$f = "", Accordion_svelte_svelte_type_style_lang = "", indexVars$e = "", indexVars$d = "", Badge_svelte_svelte_type_style_lang = "", Banner_svelte_svelte_type_style_lang = "", indexVars$c = "", BANNER_TYPES = {
  NEUTRAL: "neutral",
  INFO: "info",
  NEGATIVE: "negative",
  WARNING: "warning"
};
function createBannerStore() {
  const l = writable({
    messages: []
  }), f = async (b = {}) => {
    l.update((y) => ({
      ...y,
      ...b
    }));
  }, p = async () => {
    const b = {
      message: "Some systems are experiencing issues",
      type: BANNER_TYPES.NEGATIVE,
      extraButtonText: "View Status",
      extraButtonAction: () => window.open("https://status.budibase.com/")
    };
    await m([b]);
  }, m = async (b) => {
    const y = {
      [BANNER_TYPES.NEGATIVE]: 0,
      [BANNER_TYPES.WARNING]: 1,
      [BANNER_TYPES.INFO]: 2
    };
    l.update((v) => {
      const k = [...v.messages, ...b].sort((S, $) => y[S.type] === y[$.type] ? 0 : y[S.type] < y[$.type] ? -1 : 1);
      return {
        ...v,
        messages: k
      };
    });
  };
  return {
    subscribe: l.subscribe,
    showStatus: p,
    show: f,
    queue: m
  };
}
createBannerStore();
const BannerDisplay_svelte_svelte_type_style_lang = "", indexVars$b = "", Button_svelte_svelte_type_style_lang = "";
function create_if_block_2$f(u) {
  let l, f;
  const p = (
    /*#slots*/
    u[18].default
  ), m = create_slot(
    p,
    u,
    /*$$scope*/
    u[21],
    null
  );
  return {
    c() {
      l = element("span"), m && m.c(), attr(l, "class", "spectrum-Button-label svelte-13vwr7s");
    },
    m(b, y) {
      insert(b, l, y), m && m.m(l, null), f = !0;
    },
    p(b, y) {
      m && m.p && (!f || y & /*$$scope*/
      2097152) && update_slot_base(
        m,
        p,
        b,
        /*$$scope*/
        b[21],
        f ? get_slot_changes(
          p,
          /*$$scope*/
          b[21],
          y,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          b[21]
        ),
        null
      );
    },
    i(b) {
      f || (transition_in(m, b), f = !0);
    },
    o(b) {
      transition_out(m, b), f = !1;
    },
    d(b) {
      b && detach(l), m && m.d(b);
    }
  };
}
function create_if_block_1$k(u) {
  let l, f, p;
  return f = new Icon({
    props: {
      name: (
        /*icon*/
        u[10]
      ),
      size: (
        /*size*/
        u[3].toUpperCase()
      )
    }
  }), {
    c() {
      l = element("span"), create_component(f.$$.fragment), attr(l, "class", "icon");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b & /*icon*/
      1024 && (y.name = /*icon*/
      m[10]), b & /*size*/
      8 && (y.size = /*size*/
      m[3].toUpperCase()), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block$D(u) {
  let l, f;
  const p = (
    /*#slots*/
    u[18].default
  ), m = create_slot(
    p,
    u,
    /*$$scope*/
    u[21],
    null
  );
  return {
    c() {
      l = element("span"), m && m.c(), attr(l, "class", "spectrum-Button-label svelte-13vwr7s");
    },
    m(b, y) {
      insert(b, l, y), m && m.m(l, null), f = !0;
    },
    p(b, y) {
      m && m.p && (!f || y & /*$$scope*/
      2097152) && update_slot_base(
        m,
        p,
        b,
        /*$$scope*/
        b[21],
        f ? get_slot_changes(
          p,
          /*$$scope*/
          b[21],
          y,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          b[21]
        ),
        null
      );
    },
    i(b) {
      f || (transition_in(m, b), f = !0);
    },
    o(b) {
      transition_out(m, b), f = !1;
    },
    d(b) {
      b && detach(l), m && m.d(b);
    }
  };
}
function create_default_slot$C(u) {
  let l, f, p, m, b, y, v, k = (
    /*$$slots*/
    u[17] && /*reverse*/
    u[15] && create_if_block_2$f(u)
  ), S = (
    /*icon*/
    u[10] && create_if_block_1$k(u)
  ), $ = (
    /*$$slots*/
    u[17] && !/*reverse*/
    u[15] && create_if_block$D(u)
  );
  return {
    c() {
      l = element("button"), k && k.c(), f = space(), S && S.c(), p = space(), $ && $.c(), attr(
        l,
        "id",
        /*id*/
        u[14]
      ), attr(
        l,
        "type",
        /*type*/
        u[1]
      ), attr(l, "class", m = "spectrum-Button spectrum-Button--size" + /*size*/
      u[3].toUpperCase() + " svelte-13vwr7s"), toggle_class(
        l,
        "spectrum-Button--cta",
        /*cta*/
        u[4]
      ), toggle_class(
        l,
        "spectrum-Button--primary",
        /*primary*/
        u[5]
      ), toggle_class(
        l,
        "spectrum-Button--secondary",
        /*secondary*/
        u[6]
      ), toggle_class(
        l,
        "spectrum-Button--warning",
        /*warning*/
        u[7]
      ), toggle_class(
        l,
        "spectrum-Button--overBackground",
        /*overBackground*/
        u[8]
      ), toggle_class(
        l,
        "spectrum-Button--quiet",
        /*quiet*/
        u[9]
      ), toggle_class(
        l,
        "new-styles",
        /*newStyles*/
        u[13]
      ), toggle_class(
        l,
        "active",
        /*active*/
        u[11]
      ), toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        u[2]
      );
    },
    m(w, T) {
      insert(w, l, T), k && k.m(l, null), append$1(l, f), S && S.m(l, null), append$1(l, p), $ && $.m(l, null), u[19](l), b = !0, y || (v = listen(l, "click", prevent_default(
        /*click_handler*/
        u[20]
      )), y = !0);
    },
    p(w, T) {
      /*$$slots*/
      w[17] && /*reverse*/
      w[15] ? k ? (k.p(w, T), T & /*$$slots, reverse*/
      163840 && transition_in(k, 1)) : (k = create_if_block_2$f(w), k.c(), transition_in(k, 1), k.m(l, f)) : k && (group_outros(), transition_out(k, 1, 1, () => {
        k = null;
      }), check_outros()), /*icon*/
      w[10] ? S ? (S.p(w, T), T & /*icon*/
      1024 && transition_in(S, 1)) : (S = create_if_block_1$k(w), S.c(), transition_in(S, 1), S.m(l, p)) : S && (group_outros(), transition_out(S, 1, 1, () => {
        S = null;
      }), check_outros()), /*$$slots*/
      w[17] && !/*reverse*/
      w[15] ? $ ? ($.p(w, T), T & /*$$slots, reverse*/
      163840 && transition_in($, 1)) : ($ = create_if_block$D(w), $.c(), transition_in($, 1), $.m(l, null)) : $ && (group_outros(), transition_out($, 1, 1, () => {
        $ = null;
      }), check_outros()), (!b || T & /*id*/
      16384) && attr(
        l,
        "id",
        /*id*/
        w[14]
      ), (!b || T & /*type*/
      2) && attr(
        l,
        "type",
        /*type*/
        w[1]
      ), (!b || T & /*size*/
      8 && m !== (m = "spectrum-Button spectrum-Button--size" + /*size*/
      w[3].toUpperCase() + " svelte-13vwr7s")) && attr(l, "class", m), (!b || T & /*size, cta*/
      24) && toggle_class(
        l,
        "spectrum-Button--cta",
        /*cta*/
        w[4]
      ), (!b || T & /*size, primary*/
      40) && toggle_class(
        l,
        "spectrum-Button--primary",
        /*primary*/
        w[5]
      ), (!b || T & /*size, secondary*/
      72) && toggle_class(
        l,
        "spectrum-Button--secondary",
        /*secondary*/
        w[6]
      ), (!b || T & /*size, warning*/
      136) && toggle_class(
        l,
        "spectrum-Button--warning",
        /*warning*/
        w[7]
      ), (!b || T & /*size, overBackground*/
      264) && toggle_class(
        l,
        "spectrum-Button--overBackground",
        /*overBackground*/
        w[8]
      ), (!b || T & /*size, quiet*/
      520) && toggle_class(
        l,
        "spectrum-Button--quiet",
        /*quiet*/
        w[9]
      ), (!b || T & /*size, newStyles*/
      8200) && toggle_class(
        l,
        "new-styles",
        /*newStyles*/
        w[13]
      ), (!b || T & /*size, active*/
      2056) && toggle_class(
        l,
        "active",
        /*active*/
        w[11]
      ), (!b || T & /*size, disabled*/
      12) && toggle_class(
        l,
        "is-disabled",
        /*disabled*/
        w[2]
      );
    },
    i(w) {
      b || (transition_in(k), transition_in(S), transition_in($), b = !0);
    },
    o(w) {
      transition_out(k), transition_out(S), transition_out($), b = !1;
    },
    d(w) {
      w && detach(l), k && k.d(), S && S.d(), $ && $.d(), u[19](null), y = !1, v();
    }
  };
}
function create_fragment$1b(u) {
  let l, f;
  return l = new AbsTooltip({
    props: {
      text: (
        /*tooltip*/
        u[12]
      ),
      $$slots: { default: [create_default_slot$C] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*tooltip*/
      4096 && (b.text = /*tooltip*/
      p[12]), m & /*$$scope, id, type, size, ref, cta, primary, secondary, warning, overBackground, quiet, newStyles, active, disabled, $$slots, reverse, icon*/
      2289663 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$19(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l;
  const b = compute_slots(p);
  let { type: y = void 0 } = l, { disabled: v = !1 } = l, { size: k = "M" } = l, { cta: S = !1 } = l, { primary: $ = !1 } = l, { secondary: w = !1 } = l, { warning: T = !1 } = l, { overBackground: E = !1 } = l, { quiet: R = !1 } = l, { icon: O = void 0 } = l, { active: P = !1 } = l, { tooltip: L = void 0 } = l, { newStyles: M = !0 } = l, { id: B = void 0 } = l, { ref: j = void 0 } = l, { reverse: x = !1 } = l;
  const N = createEventDispatcher();
  function D(W) {
    binding_callbacks[W ? "unshift" : "push"](() => {
      j = W, f(0, j);
    });
  }
  const V = () => {
    v || N("click");
  };
  return u.$$set = (W) => {
    "type" in W && f(1, y = W.type), "disabled" in W && f(2, v = W.disabled), "size" in W && f(3, k = W.size), "cta" in W && f(4, S = W.cta), "primary" in W && f(5, $ = W.primary), "secondary" in W && f(6, w = W.secondary), "warning" in W && f(7, T = W.warning), "overBackground" in W && f(8, E = W.overBackground), "quiet" in W && f(9, R = W.quiet), "icon" in W && f(10, O = W.icon), "active" in W && f(11, P = W.active), "tooltip" in W && f(12, L = W.tooltip), "newStyles" in W && f(13, M = W.newStyles), "id" in W && f(14, B = W.id), "ref" in W && f(0, j = W.ref), "reverse" in W && f(15, x = W.reverse), "$$scope" in W && f(21, m = W.$$scope);
  }, [
    j,
    y,
    v,
    k,
    S,
    $,
    w,
    T,
    E,
    R,
    O,
    P,
    L,
    M,
    B,
    x,
    N,
    b,
    p,
    D,
    V,
    m
  ];
}
class Button extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$19, create_fragment$1b, safe_not_equal, {
      type: 1,
      disabled: 2,
      size: 3,
      cta: 4,
      primary: 5,
      secondary: 6,
      warning: 7,
      overBackground: 8,
      quiet: 9,
      icon: 10,
      active: 11,
      tooltip: 12,
      newStyles: 13,
      id: 14,
      ref: 0,
      reverse: 15
    });
  }
}
const indexVars$a = "", Item_svelte_svelte_type_style_lang = "", Layout_svelte_svelte_type_style_lang = "";
function create_fragment$1a(u) {
  let l, f, p;
  const m = (
    /*#slots*/
    u[9].default
  ), b = create_slot(
    m,
    u,
    /*$$scope*/
    u[8],
    null
  );
  return {
    c() {
      l = element("div"), b && b.c(), set_style(
        l,
        "align-content",
        /*alignContent*/
        u[6]
      ), set_style(
        l,
        "justify-items",
        /*justifyItems*/
        u[7]
      ), attr(l, "class", f = "container paddingX-" + (!/*noPadding*/
      u[3] && /*paddingX*/
      u[1]) + " paddingY-" + (!/*noPadding*/
      u[3] && /*paddingY*/
      u[2]) + " gap-" + (!/*noGap*/
      u[5] && /*gap*/
      u[4]) + " svelte-12t4e3i"), toggle_class(
        l,
        "horizontal",
        /*horizontal*/
        u[0]
      );
    },
    m(y, v) {
      insert(y, l, v), b && b.m(l, null), p = !0;
    },
    p(y, [v]) {
      b && b.p && (!p || v & /*$$scope*/
      256) && update_slot_base(
        b,
        m,
        y,
        /*$$scope*/
        y[8],
        p ? get_slot_changes(
          m,
          /*$$scope*/
          y[8],
          v,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          y[8]
        ),
        null
      ), (!p || v & /*alignContent*/
      64) && set_style(
        l,
        "align-content",
        /*alignContent*/
        y[6]
      ), (!p || v & /*justifyItems*/
      128) && set_style(
        l,
        "justify-items",
        /*justifyItems*/
        y[7]
      ), (!p || v & /*noPadding, paddingX, paddingY, noGap, gap*/
      62 && f !== (f = "container paddingX-" + (!/*noPadding*/
      y[3] && /*paddingX*/
      y[1]) + " paddingY-" + (!/*noPadding*/
      y[3] && /*paddingY*/
      y[2]) + " gap-" + (!/*noGap*/
      y[5] && /*gap*/
      y[4]) + " svelte-12t4e3i")) && attr(l, "class", f), (!p || v & /*noPadding, paddingX, paddingY, noGap, gap, horizontal*/
      63) && toggle_class(
        l,
        "horizontal",
        /*horizontal*/
        y[0]
      );
    },
    i(y) {
      p || (transition_in(b, y), p = !0);
    },
    o(y) {
      transition_out(b, y), p = !1;
    },
    d(y) {
      y && detach(l), b && b.d(y);
    }
  };
}
function instance$18(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l, { horizontal: b = !1 } = l, { paddingX: y = "M" } = l, { paddingY: v = "M" } = l, { noPadding: k = !1 } = l, { gap: S = "M" } = l, { noGap: $ = !1 } = l, { alignContent: w = "normal" } = l, { justifyItems: T = "stretch" } = l;
  return u.$$set = (E) => {
    "horizontal" in E && f(0, b = E.horizontal), "paddingX" in E && f(1, y = E.paddingX), "paddingY" in E && f(2, v = E.paddingY), "noPadding" in E && f(3, k = E.noPadding), "gap" in E && f(4, S = E.gap), "noGap" in E && f(5, $ = E.noGap), "alignContent" in E && f(6, w = E.alignContent), "justifyItems" in E && f(7, T = E.justifyItems), "$$scope" in E && f(8, m = E.$$scope);
  }, [
    b,
    y,
    v,
    k,
    S,
    $,
    w,
    T,
    m,
    p
  ];
}
class Layout extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$18, create_fragment$1a, safe_not_equal, {
      horizontal: 0,
      paddingX: 1,
      paddingY: 2,
      noPadding: 3,
      gap: 4,
      noGap: 5,
      alignContent: 6,
      justifyItems: 7
    });
  }
}
const ColorPicker_svelte_svelte_type_style_lang = "";
function get_each_context$c(u, l, f) {
  const p = u.slice();
  return p[23] = l[f], p;
}
function get_each_context_1$3(u, l, f) {
  const p = u.slice();
  return p[26] = l[f], p;
}
function create_if_block$C(u) {
  let l, f;
  return l = new Icon({ props: { name: "check", size: "S" } }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_each_block_1$3(u) {
  let l, f, p, m, b, y, v = (
    /*value*/
    u[0] === `var(--spectrum-global-color-${/*color*/
    u[26]})` && create_if_block$C()
  );
  function k() {
    return (
      /*click_handler_1*/
      u[15](
        /*color*/
        u[26]
      )
    );
  }
  return {
    c() {
      l = element("div"), f = element("div"), v && v.c(), attr(f, "class", p = "fill " + /*themeClasses*/
      u[6] + " svelte-1lkpxti"), set_style(f, "background", "var(--spectrum-global-color-" + /*color*/
      u[26] + ")"), set_style(
        f,
        "color",
        /*checkColor*/
        u[7]
      ), attr(l, "class", "color svelte-1lkpxti"), attr(
        l,
        "title",
        /*prettyPrint*/
        u[11](
          /*color*/
          u[26]
        )
      );
    },
    m(S, $) {
      insert(S, l, $), append$1(l, f), v && v.m(f, null), m = !0, b || (y = listen(l, "click", k), b = !0);
    },
    p(S, $) {
      u = S, /*value*/
      u[0] === `var(--spectrum-global-color-${/*color*/
      u[26]})` ? v ? $ & /*value*/
      1 && transition_in(v, 1) : (v = create_if_block$C(), v.c(), transition_in(v, 1), v.m(f, null)) : v && (group_outros(), transition_out(v, 1, 1, () => {
        v = null;
      }), check_outros()), (!m || $ & /*themeClasses*/
      64 && p !== (p = "fill " + /*themeClasses*/
      u[6] + " svelte-1lkpxti")) && attr(f, "class", p), (!m || $ & /*checkColor*/
      128) && set_style(
        f,
        "color",
        /*checkColor*/
        u[7]
      );
    },
    i(S) {
      m || (transition_in(v), m = !0);
    },
    o(S) {
      transition_out(v), m = !1;
    },
    d(S) {
      S && detach(l), v && v.d(), b = !1, y();
    }
  };
}
function create_each_block$c(u) {
  let l, f, p, m, b, y = ensure_array_like(
    /*category*/
    u[23].colors
  ), v = [];
  for (let S = 0; S < y.length; S += 1)
    v[S] = create_each_block_1$3(get_each_context_1$3(u, y, S));
  const k = (S) => transition_out(v[S], 1, 1, () => {
    v[S] = null;
  });
  return {
    c() {
      l = element("div"), f = element("div"), f.textContent = `${/*category*/
      u[23].label}`, p = space(), m = element("div");
      for (let S = 0; S < v.length; S += 1)
        v[S].c();
      attr(f, "class", "heading svelte-1lkpxti"), attr(m, "class", "colors svelte-1lkpxti"), attr(l, "class", "category");
    },
    m(S, $) {
      insert(S, l, $), append$1(l, f), append$1(l, p), append$1(l, m);
      for (let w = 0; w < v.length; w += 1)
        v[w] && v[w].m(m, null);
      b = !0;
    },
    p(S, $) {
      if ($ & /*prettyPrint, categories, onChange, themeClasses, checkColor, value*/
      3777) {
        y = ensure_array_like(
          /*category*/
          S[23].colors
        );
        let w;
        for (w = 0; w < y.length; w += 1) {
          const T = get_each_context_1$3(S, y, w);
          v[w] ? (v[w].p(T, $), transition_in(v[w], 1)) : (v[w] = create_each_block_1$3(T), v[w].c(), transition_in(v[w], 1), v[w].m(m, null));
        }
        for (group_outros(), w = y.length; w < v.length; w += 1)
          k(w);
        check_outros();
      }
    },
    i(S) {
      if (!b) {
        for (let $ = 0; $ < y.length; $ += 1)
          transition_in(v[$]);
        b = !0;
      }
    },
    o(S) {
      v = v.filter(Boolean);
      for (let $ = 0; $ < v.length; $ += 1)
        transition_out(v[$]);
      b = !1;
    },
    d(S) {
      S && detach(l), destroy_each(v, S);
    }
  };
}
function create_default_slot_1$e(u) {
  let l, f, p, m, b, y, v, k, S, $, w = ensure_array_like(
    /*categories*/
    u[9]
  ), T = [];
  for (let R = 0; R < w.length; R += 1)
    T[R] = create_each_block$c(get_each_context$c(u, w, R));
  const E = (R) => transition_out(T[R], 1, 1, () => {
    T[R] = null;
  });
  return v = new Input({
    props: {
      updateOnChange: !1,
      quiet: !0,
      placeholder: "Hex, RGB, HSL...",
      value: (
        /*customValue*/
        u[8]
      )
    }
  }), v.$on(
    "change",
    /*change_handler*/
    u[16]
  ), S = new Icon({
    props: { size: "S", name: "x", hoverable: !0 }
  }), S.$on(
    "click",
    /*click_handler_2*/
    u[17]
  ), {
    c() {
      l = element("div");
      for (let R = 0; R < T.length; R += 1)
        T[R].c();
      f = space(), p = element("div"), m = element("div"), m.textContent = "Custom", b = space(), y = element("div"), create_component(v.$$.fragment), k = space(), create_component(S.$$.fragment), attr(m, "class", "heading svelte-1lkpxti"), attr(y, "class", "custom svelte-1lkpxti"), attr(p, "class", "category category--custom svelte-1lkpxti"), attr(l, "class", "container svelte-1lkpxti");
    },
    m(R, O) {
      insert(R, l, O);
      for (let P = 0; P < T.length; P += 1)
        T[P] && T[P].m(l, null);
      append$1(l, f), append$1(l, p), append$1(p, m), append$1(p, b), append$1(p, y), mount_component(v, y, null), append$1(y, k), mount_component(S, y, null), $ = !0;
    },
    p(R, O) {
      if (O & /*categories, prettyPrint, onChange, themeClasses, checkColor, value*/
      3777) {
        w = ensure_array_like(
          /*categories*/
          R[9]
        );
        let L;
        for (L = 0; L < w.length; L += 1) {
          const M = get_each_context$c(R, w, L);
          T[L] ? (T[L].p(M, O), transition_in(T[L], 1)) : (T[L] = create_each_block$c(M), T[L].c(), transition_in(T[L], 1), T[L].m(l, f));
        }
        for (group_outros(), L = w.length; L < T.length; L += 1)
          E(L);
        check_outros();
      }
      const P = {};
      O & /*customValue*/
      256 && (P.value = /*customValue*/
      R[8]), v.$set(P);
    },
    i(R) {
      if (!$) {
        for (let O = 0; O < w.length; O += 1)
          transition_in(T[O]);
        transition_in(v.$$.fragment, R), transition_in(S.$$.fragment, R), $ = !0;
      }
    },
    o(R) {
      T = T.filter(Boolean);
      for (let O = 0; O < T.length; O += 1)
        transition_out(T[O]);
      transition_out(v.$$.fragment, R), transition_out(S.$$.fragment, R), $ = !1;
    },
    d(R) {
      R && detach(l), destroy_each(T, R), destroy_component(v), destroy_component(S);
    }
  };
}
function create_default_slot$B(u) {
  let l, f;
  return l = new Layout({
    props: {
      paddingX: "XL",
      paddingY: "L",
      $$slots: { default: [create_default_slot_1$e] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, customValue, themeClasses, checkColor, value*/
      536871361 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$19(u) {
  let l, f, p, m, b, y, v, k, S, $, w = {
    anchor: (
      /*preview*/
      u[5]
    ),
    maxHeight: 350,
    offset: (
      /*offset*/
      u[2]
    ),
    align: (
      /*align*/
      u[3]
    ),
    $$slots: { default: [create_default_slot$B] },
    $$scope: { ctx: u }
  };
  return v = new Popover({ props: w }), u[18](v), {
    c() {
      l = element("div"), f = element("div"), y = space(), create_component(v.$$.fragment), attr(f, "class", p = "fill " + /*themeClasses*/
      u[6] + " svelte-1lkpxti"), attr(f, "style", m = /*value*/
      u[0] ? `background: ${/*value*/
      u[0]};` : ""), toggle_class(f, "placeholder", !/*value*/
      u[0]), attr(l, "class", b = "preview size--" + /*size*/
      (u[1] || "M") + " svelte-1lkpxti");
    },
    m(T, E) {
      insert(T, l, E), append$1(l, f), u[13](l), insert(T, y, E), mount_component(v, T, E), k = !0, S || ($ = listen(
        l,
        "click",
        /*click_handler*/
        u[14]
      ), S = !0);
    },
    p(T, [E]) {
      (!k || E & /*themeClasses*/
      64 && p !== (p = "fill " + /*themeClasses*/
      T[6] + " svelte-1lkpxti")) && attr(f, "class", p), (!k || E & /*value*/
      1 && m !== (m = /*value*/
      T[0] ? `background: ${/*value*/
      T[0]};` : "")) && attr(f, "style", m), (!k || E & /*themeClasses, value*/
      65) && toggle_class(f, "placeholder", !/*value*/
      T[0]), (!k || E & /*size*/
      2 && b !== (b = "preview size--" + /*size*/
      (T[1] || "M") + " svelte-1lkpxti")) && attr(l, "class", b);
      const R = {};
      E & /*preview*/
      32 && (R.anchor = /*preview*/
      T[5]), E & /*offset*/
      4 && (R.offset = /*offset*/
      T[2]), E & /*align*/
      8 && (R.align = /*align*/
      T[3]), E & /*$$scope, customValue, themeClasses, checkColor, value*/
      536871361 && (R.$$scope = { dirty: E, ctx: T }), v.$set(R);
    },
    i(T) {
      k || (transition_in(v.$$.fragment, T), k = !0);
    },
    o(T) {
      transition_out(v.$$.fragment, T), k = !1;
    },
    d(T) {
      T && (detach(l), detach(y)), u[13](null), u[18](null), destroy_component(v, T), S = !1, $();
    }
  };
}
function instance$17(u, l, f) {
  let p, m, b, { value: y = void 0 } = l, { size: v = "M" } = l, { spectrumTheme: k = void 0 } = l, { offset: S = void 0 } = l, { align: $ = void 0 } = l, w, T;
  const E = createEventDispatcher(), R = [
    {
      label: "Theme colors",
      colors: [
        "red-100",
        "orange-100",
        "yellow-100",
        "green-100",
        "seafoam-100",
        "blue-100",
        "indigo-100",
        "magenta-100",
        "red-400",
        "orange-400",
        "yellow-400",
        "green-400",
        "seafoam-400",
        "blue-400",
        "indigo-400",
        "magenta-400",
        "red-500",
        "orange-500",
        "yellow-500",
        "green-500",
        "seafoam-500",
        "blue-500",
        "indigo-500",
        "magenta-500",
        "red-600",
        "orange-600",
        "yellow-600",
        "green-600",
        "seafoam-600",
        "blue-600",
        "indigo-600",
        "magenta-600",
        "red-700",
        "orange-700",
        "yellow-700",
        "green-700",
        "seafoam-700",
        "blue-700",
        "indigo-700",
        "magenta-700",
        "gray-50",
        "gray-75",
        "gray-100",
        "gray-200",
        "gray-300",
        "gray-400",
        "gray-500",
        "gray-600",
        "gray-700",
        "gray-800",
        "gray-900"
      ]
    },
    {
      label: "Static colors",
      colors: [
        "static-red-400",
        "static-orange-400",
        "static-yellow-400",
        "static-green-400",
        "static-seafoam-400",
        "static-blue-400",
        "static-indigo-400",
        "static-magenta-400",
        "static-red-800",
        "static-orange-800",
        "static-yellow-800",
        "static-green-800",
        "static-seafoam-800",
        "static-blue-800",
        "static-indigo-800",
        "static-magenta-800",
        "static-red-1200",
        "static-orange-1200",
        "static-yellow-1200",
        "static-green-1200",
        "static-seafoam-1200",
        "static-blue-1200",
        "static-indigo-1200",
        "static-magenta-1200",
        "static-white",
        "static-black"
      ]
    }
  ], O = (F) => F ? (F = ensureValidTheme(F, DefaultAppTheme), getThemeClassNames(F)) : "", P = (F) => {
    E("change", F), w == null || w.hide();
  }, L = (F) => {
    if (!F)
      return F;
    let U = !1;
    const Y = F.substring(28, F.length - 1);
    for (let q of R)
      if (U = q.colors.includes(Y), U)
        break;
    return U ? null : F;
  }, M = (F) => capitalise(F.split("-").join(" ")), B = (F) => F != null && F.includes("-gray-") ? /^.*(gray-(50|75|100|200|300|400|500))\)$/.test(F) ? "var(--spectrum-global-color-gray-900)" : "var(--spectrum-global-color-gray-50)" : F != null && F.includes("-100") ? "var(--spectrum-global-color-gray-900)" : F != null && F.includes("-1200") || F != null && F.includes("-800") || F != null && F.includes("static-black") ? "var(--spectrum-global-color-static-gray-50)" : "var(--spectrum-global-color-static-gray-900)";
  function j(F) {
    binding_callbacks[F ? "unshift" : "push"](() => {
      T = F, f(5, T);
    });
  }
  const x = () => {
    w == null || w.toggle();
  }, N = (F) => {
    P(`var(--spectrum-global-color-${F})`);
  };
  function D(F) {
    bubble.call(this, u, F);
  }
  const V = () => P(void 0);
  function W(F) {
    binding_callbacks[F ? "unshift" : "push"](() => {
      w = F, f(4, w);
    });
  }
  return u.$$set = (F) => {
    "value" in F && f(0, y = F.value), "size" in F && f(1, v = F.size), "spectrumTheme" in F && f(12, k = F.spectrumTheme), "offset" in F && f(2, S = F.offset), "align" in F && f(3, $ = F.align);
  }, u.$$.update = () => {
    u.$$.dirty & /*value*/
    1 && f(8, p = L(y)), u.$$.dirty & /*value*/
    1 && f(7, m = B(y)), u.$$.dirty & /*spectrumTheme*/
    4096 && f(6, b = O(k));
  }, [
    y,
    v,
    S,
    $,
    w,
    T,
    b,
    m,
    p,
    R,
    P,
    M,
    k,
    j,
    x,
    N,
    D,
    V,
    W
  ];
}
class ColorPicker extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$17, create_fragment$19, safe_not_equal, {
      value: 0,
      size: 1,
      spectrumTheme: 12,
      offset: 2,
      align: 3
    });
  }
}
const DetailSummary_svelte_svelte_type_style_lang = "";
var lib$2 = { exports: {} }, seed$1 = 1;
function getNextValue$1() {
  return seed$1 = (seed$1 * 9301 + 49297) % 233280, seed$1 / 233280;
}
function setSeed$3(u) {
  seed$1 = u;
}
var randomFromSeed$3 = {
  nextValue: getNextValue$1,
  seed: setSeed$3
}, randomFromSeed$2 = randomFromSeed$3, ORIGINAL$1 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-", alphabet$5, previousSeed$1, shuffled$1;
function reset$1() {
  shuffled$1 = !1;
}
function setCharacters$1(u) {
  if (!u) {
    alphabet$5 !== ORIGINAL$1 && (alphabet$5 = ORIGINAL$1, reset$1());
    return;
  }
  if (u !== alphabet$5) {
    if (u.length !== ORIGINAL$1.length)
      throw new Error("Custom alphabet for shortid must be " + ORIGINAL$1.length + " unique characters. You submitted " + u.length + " characters: " + u);
    var l = u.split("").filter(function(f, p, m) {
      return p !== m.lastIndexOf(f);
    });
    if (l.length)
      throw new Error("Custom alphabet for shortid must be " + ORIGINAL$1.length + " unique characters. These characters were not unique: " + l.join(", "));
    alphabet$5 = u, reset$1();
  }
}
function characters$1(u) {
  return setCharacters$1(u), alphabet$5;
}
function setSeed$2(u) {
  randomFromSeed$2.seed(u), previousSeed$1 !== u && (reset$1(), previousSeed$1 = u);
}
function shuffle$1() {
  alphabet$5 || setCharacters$1(ORIGINAL$1);
  for (var u = alphabet$5.split(""), l = [], f = randomFromSeed$2.nextValue(), p; u.length > 0; )
    f = randomFromSeed$2.nextValue(), p = Math.floor(f * u.length), l.push(u.splice(p, 1)[0]);
  return l.join("");
}
function getShuffled$1() {
  return shuffled$1 || (shuffled$1 = shuffle$1(), shuffled$1);
}
function lookup$4(u) {
  var l = getShuffled$1();
  return l[u];
}
function get$2() {
  return alphabet$5 || ORIGINAL$1;
}
var alphabet_1$1 = {
  get: get$2,
  characters: characters$1,
  seed: setSeed$2,
  lookup: lookup$4,
  shuffled: getShuffled$1
}, crypto$2 = typeof window == "object" && (window.crypto || window.msCrypto), randomByte$1;
!crypto$2 || !crypto$2.getRandomValues ? randomByte$1 = function(u) {
  for (var l = [], f = 0; f < u; f++)
    l.push(Math.floor(Math.random() * 256));
  return l;
} : randomByte$1 = function(u) {
  return crypto$2.getRandomValues(new Uint8Array(u));
};
var randomByteBrowser$1 = randomByte$1, format_browser = function(u, l, f) {
  for (var p = (2 << Math.log(l.length - 1) / Math.LN2) - 1, m = -~(1.6 * p * f / l.length), b = ""; ; )
    for (var y = u(m), v = m; v--; )
      if (b += l[y[v] & p] || "", b.length === +f)
        return b;
}, alphabet$4 = alphabet_1$1, random$2 = randomByteBrowser$1, format$2 = format_browser;
function generate$3(u) {
  for (var l = 0, f, p = ""; !f; )
    p = p + format$2(random$2, alphabet$4.get(), 1), f = u < Math.pow(16, l + 1), l++;
  return p;
}
var generate_1$1 = generate$3, generate$2 = generate_1$1, REDUCE_TIME$1 = 1567752802062, version$2 = 7, counter$1, previousSeconds$1;
function build$1(u) {
  var l = "", f = Math.floor((Date.now() - REDUCE_TIME$1) * 1e-3);
  return f === previousSeconds$1 ? counter$1++ : (counter$1 = 0, previousSeconds$1 = f), l = l + generate$2(version$2), l = l + generate$2(u), counter$1 > 0 && (l = l + generate$2(counter$1)), l = l + generate$2(f), l;
}
var build_1$1 = build$1, alphabet$3 = alphabet_1$1;
function isShortId$1(u) {
  if (!u || typeof u != "string" || u.length < 6)
    return !1;
  var l = new RegExp("[^" + alphabet$3.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]");
  return !l.test(u);
}
var isValid$2 = isShortId$1;
(function(u) {
  var l = alphabet_1$1, f = build_1$1, p = isValid$2, m = 0;
  function b(S) {
    return l.seed(S), u.exports;
  }
  function y(S) {
    return m = S, u.exports;
  }
  function v(S) {
    return S !== void 0 && l.characters(S), l.shuffled();
  }
  function k() {
    return f(m);
  }
  u.exports = k, u.exports.generate = k, u.exports.seed = b, u.exports.worker = y, u.exports.characters = v, u.exports.isValid = p;
})(lib$2);
var libExports$1 = lib$2.exports, shortid$1 = libExports$1;
const Drawer_svelte_svelte_type_style_lang = "", DrawerContent_svelte_svelte_type_style_lang = "", IconAvatar_svelte_svelte_type_style_lang = "", IconPicker_svelte_svelte_type_style_lang = "", indexVars$9 = "", InlineAlert_svelte_svelte_type_style_lang = "", NOTIFICATION_TIMEOUT = 3e3, createNotificationStore$1 = () => {
  const u = /* @__PURE__ */ new Set(), l = writable([], () => () => {
    u.forEach((v) => {
      clearTimeout(v);
    }), l.set([]);
  });
  let f = !1;
  const p = (v = 1e3) => {
    f = !0, setTimeout(() => f = !1, v);
  }, m = (v, {
    type: k = "default",
    icon: S = "",
    autoDismiss: $ = !0,
    action: w = null,
    actionMessage: T = null,
    wide: E = !1,
    dismissTimeout: R = NOTIFICATION_TIMEOUT
  } = {}) => {
    if (f)
      return;
    let O = id$2();
    if (l.update((P) => [
      ...P,
      {
        id: O,
        type: k,
        message: v,
        icon: S,
        dismissable: !$,
        action: w,
        actionMessage: T,
        wide: E,
        dismissTimeout: R
      }
    ]), $) {
      const P = setTimeout(() => {
        b(O);
      }, R);
      u.add(P);
    }
  }, b = (v) => {
    l.update((k) => k.filter((S) => S.id !== v));
  }, { subscribe: y } = l;
  return {
    subscribe: y,
    send: m,
    info: (v) => m(v, { type: "info", icon: "info" }),
    error: (v) => m(v, { type: "error", icon: "warning", autoDismiss: !1 }),
    warning: (v) => m(v, { type: "warning", icon: "warning" }),
    success: (v) => m(v, { type: "success", icon: "check-circle" }),
    blockNotifications: p,
    dismiss: b
  };
};
function id$2() {
  return "_" + Math.random().toString(36).slice(2, 9);
}
const notifications = createNotificationStore$1(), CopyInput_svelte_svelte_type_style_lang = "", Label_svelte_svelte_type_style_lang = "", Page_svelte_svelte_type_style_lang = "", List_svelte_svelte_type_style_lang = "", ListItem_svelte_svelte_type_style_lang = "";
function _getDefaults() {
  return {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null
  };
}
var _defaults = _getDefaults();
function changeDefaults(u) {
  _defaults = u;
}
var noopTest = { exec: () => null };
function edit(u, l = "") {
  let f = typeof u == "string" ? u : u.source;
  const p = {
    replace: (m, b) => {
      let y = typeof b == "string" ? b : b.source;
      return y = y.replace(other.caret, "$1"), f = f.replace(m, y), p;
    },
    getRegex: () => new RegExp(f, l)
  };
  return p;
}
var other = {
  codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
  outputLinkReplace: /\\([\[\]])/g,
  indentCodeCompensation: /^(\s+)(?:```)/,
  beginningSpace: /^\s+/,
  endingHash: /#$/,
  startingSpaceChar: /^ /,
  endingSpaceChar: / $/,
  nonSpaceChar: /[^ ]/,
  newLineCharGlobal: /\n/g,
  tabCharGlobal: /\t/g,
  multipleSpaceGlobal: /\s+/g,
  blankLine: /^[ \t]*$/,
  doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
  blockquoteStart: /^ {0,3}>/,
  blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
  blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
  listReplaceTabs: /^\t+/,
  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
  listIsTask: /^\[[ xX]\] /,
  listReplaceTask: /^\[[ xX]\] +/,
  anyLine: /\n.*\n/,
  hrefBrackets: /^<(.*)>$/,
  tableDelimiter: /[:|]/,
  tableAlignChars: /^\||\| *$/g,
  tableRowBlankLine: /\n[ \t]*$/,
  tableAlignRight: /^ *-+: *$/,
  tableAlignCenter: /^ *:-+: *$/,
  tableAlignLeft: /^ *:-+ *$/,
  startATag: /^<a /i,
  endATag: /^<\/a>/i,
  startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
  endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
  startAngleBracket: /^</,
  endAngleBracket: />$/,
  pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
  unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
  escapeTest: /[&<>"']/,
  escapeReplace: /[&<>"']/g,
  escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
  unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
  caret: /(^|[^\[])\^/g,
  percentDecode: /%25/g,
  findPipe: /\|/g,
  splitPipe: / \|/,
  slashPipe: /\\\|/g,
  carriageReturn: /\r\n|\r/g,
  spaceLine: /^ +$/gm,
  notSpaceStart: /^\S*/,
  endingNewline: /\n$/,
  listItemRegex: (u) => new RegExp(`^( {0,3}${u})((?:[	 ][^\\n]*)?(?:\\n|$))`),
  nextBulletRegex: (u) => new RegExp(`^ {0,${Math.min(3, u - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
  hrRegex: (u) => new RegExp(`^ {0,${Math.min(3, u - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
  fencesBeginRegex: (u) => new RegExp(`^ {0,${Math.min(3, u - 1)}}(?:\`\`\`|~~~)`),
  headingBeginRegex: (u) => new RegExp(`^ {0,${Math.min(3, u - 1)}}#`),
  htmlBeginRegex: (u) => new RegExp(`^ {0,${Math.min(3, u - 1)}}<(?:[a-z].*>|!--)`, "i")
}, newline = /^(?:[ \t]*(?:\n|$))+/, blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, heading$2 = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, bullet = /(?:[*+-]|\d{1,9}[.)])/, lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, lheading = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, blockText = /^[^\n]+/, _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/, def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex(), _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, html = edit(
  "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))",
  "i"
).replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex(), blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex(), blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading: heading$2,
  hr,
  html,
  lheading,
  list,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
}, gfmTable = edit(
  "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex(), blockGfm = {
  ...blockNormal,
  lheading: lheadingGfm,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
}, blockPedantic = {
  ...blockNormal,
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, escape$1 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br = /^( {2,}|\\)\n(?!\s*$)/, inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, _punctuation = /[\p{P}\p{S}]/u, _punctuationOrSpace = /[\s\p{P}\p{S}]/u, _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u, punctuation = edit(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, _punctuationOrSpace).getRegex(), _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u, _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u, _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u, blockSkip = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g, emStrongLDelimCore = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, emStrongLDelim = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuation).getRegex(), emStrongLDelimGfm = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuationGfmStrongEm).getRegex(), emStrongRDelimAstCore = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", emStrongRDelimAst = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex(), emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex(), emStrongRDelimUnd = edit(
  "^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)",
  "gu"
).replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex(), anyPunctuation = edit(/\\(punct)/, "gu").replace(/punct/g, _punctuation).getRegex(), autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex(), tag$2 = edit(
  "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>"
).replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, link$3 = edit(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex(), nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex(), reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex(), inlineNormal = {
  _backpedal: noopTest,
  // only used for GFM url
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape: escape$1,
  link: link$3,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag: tag$2,
  text: inlineText,
  url: noopTest
}, inlinePedantic = {
  ...inlineNormal,
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
}, inlineGfm = {
  ...inlineNormal,
  emStrongRDelimAst: emStrongRDelimAstGfm,
  emStrongLDelim: emStrongLDelimGfm,
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
}, inlineBreaks = {
  ...inlineGfm,
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
}, block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
}, inline$1 = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
}, escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
}, getEscapeReplacement = (u) => escapeReplacements[u];
function escape2(u, l) {
  if (l) {
    if (other.escapeTest.test(u))
      return u.replace(other.escapeReplace, getEscapeReplacement);
  } else if (other.escapeTestNoEncode.test(u))
    return u.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
  return u;
}
function cleanUrl(u) {
  try {
    u = encodeURI(u).replace(other.percentDecode, "%");
  } catch {
    return null;
  }
  return u;
}
function splitCells(u, l) {
  var b;
  const f = u.replace(other.findPipe, (y, v, k) => {
    let S = !1, $ = v;
    for (; --$ >= 0 && k[$] === "\\"; )
      S = !S;
    return S ? "|" : " |";
  }), p = f.split(other.splitPipe);
  let m = 0;
  if (p[0].trim() || p.shift(), p.length > 0 && !((b = p.at(-1)) != null && b.trim()) && p.pop(), l)
    if (p.length > l)
      p.splice(l);
    else
      for (; p.length < l; )
        p.push("");
  for (; m < p.length; m++)
    p[m] = p[m].trim().replace(other.slashPipe, "|");
  return p;
}
function rtrim(u, l, f) {
  const p = u.length;
  if (p === 0)
    return "";
  let m = 0;
  for (; m < p; ) {
    const b = u.charAt(p - m - 1);
    if (b === l && !f)
      m++;
    else if (b !== l && f)
      m++;
    else
      break;
  }
  return u.slice(0, p - m);
}
function findClosingBracket(u, l) {
  if (u.indexOf(l[1]) === -1)
    return -1;
  let f = 0;
  for (let p = 0; p < u.length; p++)
    if (u[p] === "\\")
      p++;
    else if (u[p] === l[0])
      f++;
    else if (u[p] === l[1] && (f--, f < 0))
      return p;
  return f > 0 ? -2 : -1;
}
function outputLink(u, l, f, p, m) {
  const b = l.href, y = l.title || null, v = u[1].replace(m.other.outputLinkReplace, "$1");
  p.state.inLink = !0;
  const k = {
    type: u[0].charAt(0) === "!" ? "image" : "link",
    raw: f,
    href: b,
    title: y,
    text: v,
    tokens: p.inlineTokens(v)
  };
  return p.state.inLink = !1, k;
}
function indentCodeCompensation(u, l, f) {
  const p = u.match(f.other.indentCodeCompensation);
  if (p === null)
    return l;
  const m = p[1];
  return l.split(`
`).map((b) => {
    const y = b.match(f.other.beginningSpace);
    if (y === null)
      return b;
    const [v] = y;
    return v.length >= m.length ? b.slice(m.length) : b;
  }).join(`
`);
}
var _Tokenizer = class {
  // set by the lexer
  constructor(u) {
    me(this, "options");
    me(this, "rules");
    // set by the lexer
    me(this, "lexer");
    this.options = u || _defaults;
  }
  space(u) {
    const l = this.rules.block.newline.exec(u);
    if (l && l[0].length > 0)
      return {
        type: "space",
        raw: l[0]
      };
  }
  code(u) {
    const l = this.rules.block.code.exec(u);
    if (l) {
      const f = l[0].replace(this.rules.other.codeRemoveIndent, "");
      return {
        type: "code",
        raw: l[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic ? f : rtrim(f, `
`)
      };
    }
  }
  fences(u) {
    const l = this.rules.block.fences.exec(u);
    if (l) {
      const f = l[0], p = indentCodeCompensation(f, l[3] || "", this.rules);
      return {
        type: "code",
        raw: f,
        lang: l[2] ? l[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : l[2],
        text: p
      };
    }
  }
  heading(u) {
    const l = this.rules.block.heading.exec(u);
    if (l) {
      let f = l[2].trim();
      if (this.rules.other.endingHash.test(f)) {
        const p = rtrim(f, "#");
        (this.options.pedantic || !p || this.rules.other.endingSpaceChar.test(p)) && (f = p.trim());
      }
      return {
        type: "heading",
        raw: l[0],
        depth: l[1].length,
        text: f,
        tokens: this.lexer.inline(f)
      };
    }
  }
  hr(u) {
    const l = this.rules.block.hr.exec(u);
    if (l)
      return {
        type: "hr",
        raw: rtrim(l[0], `
`)
      };
  }
  blockquote(u) {
    const l = this.rules.block.blockquote.exec(u);
    if (l) {
      let f = rtrim(l[0], `
`).split(`
`), p = "", m = "";
      const b = [];
      for (; f.length > 0; ) {
        let y = !1;
        const v = [];
        let k;
        for (k = 0; k < f.length; k++)
          if (this.rules.other.blockquoteStart.test(f[k]))
            v.push(f[k]), y = !0;
          else if (!y)
            v.push(f[k]);
          else
            break;
        f = f.slice(k);
        const S = v.join(`
`), $ = S.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        p = p ? `${p}
${S}` : S, m = m ? `${m}
${$}` : $;
        const w = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens($, b, !0), this.lexer.state.top = w, f.length === 0)
          break;
        const T = b.at(-1);
        if ((T == null ? void 0 : T.type) === "code")
          break;
        if ((T == null ? void 0 : T.type) === "blockquote") {
          const E = T, R = E.raw + `
` + f.join(`
`), O = this.blockquote(R);
          b[b.length - 1] = O, p = p.substring(0, p.length - E.raw.length) + O.raw, m = m.substring(0, m.length - E.text.length) + O.text;
          break;
        } else if ((T == null ? void 0 : T.type) === "list") {
          const E = T, R = E.raw + `
` + f.join(`
`), O = this.list(R);
          b[b.length - 1] = O, p = p.substring(0, p.length - T.raw.length) + O.raw, m = m.substring(0, m.length - E.raw.length) + O.raw, f = R.substring(b.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return {
        type: "blockquote",
        raw: p,
        tokens: b,
        text: m
      };
    }
  }
  list(u) {
    let l = this.rules.block.list.exec(u);
    if (l) {
      let f = l[1].trim();
      const p = f.length > 1, m = {
        type: "list",
        raw: "",
        ordered: p,
        start: p ? +f.slice(0, -1) : "",
        loose: !1,
        items: []
      };
      f = p ? `\\d{1,9}\\${f.slice(-1)}` : `\\${f}`, this.options.pedantic && (f = p ? f : "[*+-]");
      const b = this.rules.other.listItemRegex(f);
      let y = !1;
      for (; u; ) {
        let k = !1, S = "", $ = "";
        if (!(l = b.exec(u)) || this.rules.block.hr.test(u))
          break;
        S = l[0], u = u.substring(S.length);
        let w = l[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (L) => " ".repeat(3 * L.length)), T = u.split(`
`, 1)[0], E = !w.trim(), R = 0;
        if (this.options.pedantic ? (R = 2, $ = w.trimStart()) : E ? R = l[1].length + 1 : (R = l[2].search(this.rules.other.nonSpaceChar), R = R > 4 ? 1 : R, $ = w.slice(R), R += l[1].length), E && this.rules.other.blankLine.test(T) && (S += T + `
`, u = u.substring(T.length + 1), k = !0), !k) {
          const L = this.rules.other.nextBulletRegex(R), M = this.rules.other.hrRegex(R), B = this.rules.other.fencesBeginRegex(R), j = this.rules.other.headingBeginRegex(R), x = this.rules.other.htmlBeginRegex(R);
          for (; u; ) {
            const N = u.split(`
`, 1)[0];
            let D;
            if (T = N, this.options.pedantic ? (T = T.replace(this.rules.other.listReplaceNesting, "  "), D = T) : D = T.replace(this.rules.other.tabCharGlobal, "    "), B.test(T) || j.test(T) || x.test(T) || L.test(T) || M.test(T))
              break;
            if (D.search(this.rules.other.nonSpaceChar) >= R || !T.trim())
              $ += `
` + D.slice(R);
            else {
              if (E || w.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || B.test(w) || j.test(w) || M.test(w))
                break;
              $ += `
` + T;
            }
            !E && !T.trim() && (E = !0), S += N + `
`, u = u.substring(N.length + 1), w = D.slice(R);
          }
        }
        m.loose || (y ? m.loose = !0 : this.rules.other.doubleBlankLine.test(S) && (y = !0));
        let O = null, P;
        this.options.gfm && (O = this.rules.other.listIsTask.exec($), O && (P = O[0] !== "[ ] ", $ = $.replace(this.rules.other.listReplaceTask, ""))), m.items.push({
          type: "list_item",
          raw: S,
          task: !!O,
          checked: P,
          loose: !1,
          text: $,
          tokens: []
        }), m.raw += S;
      }
      const v = m.items.at(-1);
      if (v)
        v.raw = v.raw.trimEnd(), v.text = v.text.trimEnd();
      else
        return;
      m.raw = m.raw.trimEnd();
      for (let k = 0; k < m.items.length; k++)
        if (this.lexer.state.top = !1, m.items[k].tokens = this.lexer.blockTokens(m.items[k].text, []), !m.loose) {
          const S = m.items[k].tokens.filter((w) => w.type === "space"), $ = S.length > 0 && S.some((w) => this.rules.other.anyLine.test(w.raw));
          m.loose = $;
        }
      if (m.loose)
        for (let k = 0; k < m.items.length; k++)
          m.items[k].loose = !0;
      return m;
    }
  }
  html(u) {
    const l = this.rules.block.html.exec(u);
    if (l)
      return {
        type: "html",
        block: !0,
        raw: l[0],
        pre: l[1] === "pre" || l[1] === "script" || l[1] === "style",
        text: l[0]
      };
  }
  def(u) {
    const l = this.rules.block.def.exec(u);
    if (l) {
      const f = l[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), p = l[2] ? l[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", m = l[3] ? l[3].substring(1, l[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : l[3];
      return {
        type: "def",
        tag: f,
        raw: l[0],
        href: p,
        title: m
      };
    }
  }
  table(u) {
    var y;
    const l = this.rules.block.table.exec(u);
    if (!l || !this.rules.other.tableDelimiter.test(l[2]))
      return;
    const f = splitCells(l[1]), p = l[2].replace(this.rules.other.tableAlignChars, "").split("|"), m = (y = l[3]) != null && y.trim() ? l[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], b = {
      type: "table",
      raw: l[0],
      header: [],
      align: [],
      rows: []
    };
    if (f.length === p.length) {
      for (const v of p)
        this.rules.other.tableAlignRight.test(v) ? b.align.push("right") : this.rules.other.tableAlignCenter.test(v) ? b.align.push("center") : this.rules.other.tableAlignLeft.test(v) ? b.align.push("left") : b.align.push(null);
      for (let v = 0; v < f.length; v++)
        b.header.push({
          text: f[v],
          tokens: this.lexer.inline(f[v]),
          header: !0,
          align: b.align[v]
        });
      for (const v of m)
        b.rows.push(splitCells(v, b.header.length).map((k, S) => ({
          text: k,
          tokens: this.lexer.inline(k),
          header: !1,
          align: b.align[S]
        })));
      return b;
    }
  }
  lheading(u) {
    const l = this.rules.block.lheading.exec(u);
    if (l)
      return {
        type: "heading",
        raw: l[0],
        depth: l[2].charAt(0) === "=" ? 1 : 2,
        text: l[1],
        tokens: this.lexer.inline(l[1])
      };
  }
  paragraph(u) {
    const l = this.rules.block.paragraph.exec(u);
    if (l) {
      const f = l[1].charAt(l[1].length - 1) === `
` ? l[1].slice(0, -1) : l[1];
      return {
        type: "paragraph",
        raw: l[0],
        text: f,
        tokens: this.lexer.inline(f)
      };
    }
  }
  text(u) {
    const l = this.rules.block.text.exec(u);
    if (l)
      return {
        type: "text",
        raw: l[0],
        text: l[0],
        tokens: this.lexer.inline(l[0])
      };
  }
  escape(u) {
    const l = this.rules.inline.escape.exec(u);
    if (l)
      return {
        type: "escape",
        raw: l[0],
        text: l[1]
      };
  }
  tag(u) {
    const l = this.rules.inline.tag.exec(u);
    if (l)
      return !this.lexer.state.inLink && this.rules.other.startATag.test(l[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(l[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(l[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(l[0]) && (this.lexer.state.inRawBlock = !1), {
        type: "html",
        raw: l[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: !1,
        text: l[0]
      };
  }
  link(u) {
    const l = this.rules.inline.link.exec(u);
    if (l) {
      const f = l[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(f)) {
        if (!this.rules.other.endAngleBracket.test(f))
          return;
        const b = rtrim(f.slice(0, -1), "\\");
        if ((f.length - b.length) % 2 === 0)
          return;
      } else {
        const b = findClosingBracket(l[2], "()");
        if (b === -2)
          return;
        if (b > -1) {
          const v = (l[0].indexOf("!") === 0 ? 5 : 4) + l[1].length + b;
          l[2] = l[2].substring(0, b), l[0] = l[0].substring(0, v).trim(), l[3] = "";
        }
      }
      let p = l[2], m = "";
      if (this.options.pedantic) {
        const b = this.rules.other.pedanticHrefTitle.exec(p);
        b && (p = b[1], m = b[3]);
      } else
        m = l[3] ? l[3].slice(1, -1) : "";
      return p = p.trim(), this.rules.other.startAngleBracket.test(p) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(f) ? p = p.slice(1) : p = p.slice(1, -1)), outputLink(l, {
        href: p && p.replace(this.rules.inline.anyPunctuation, "$1"),
        title: m && m.replace(this.rules.inline.anyPunctuation, "$1")
      }, l[0], this.lexer, this.rules);
    }
  }
  reflink(u, l) {
    let f;
    if ((f = this.rules.inline.reflink.exec(u)) || (f = this.rules.inline.nolink.exec(u))) {
      const p = (f[2] || f[1]).replace(this.rules.other.multipleSpaceGlobal, " "), m = l[p.toLowerCase()];
      if (!m) {
        const b = f[0].charAt(0);
        return {
          type: "text",
          raw: b,
          text: b
        };
      }
      return outputLink(f, m, f[0], this.lexer, this.rules);
    }
  }
  emStrong(u, l, f = "") {
    let p = this.rules.inline.emStrongLDelim.exec(u);
    if (!p || p[3] && f.match(this.rules.other.unicodeAlphaNumeric))
      return;
    if (!(p[1] || p[2] || "") || !f || this.rules.inline.punctuation.exec(f)) {
      const b = [...p[0]].length - 1;
      let y, v, k = b, S = 0;
      const $ = p[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for ($.lastIndex = 0, l = l.slice(-1 * u.length + b); (p = $.exec(l)) != null; ) {
        if (y = p[1] || p[2] || p[3] || p[4] || p[5] || p[6], !y)
          continue;
        if (v = [...y].length, p[3] || p[4]) {
          k += v;
          continue;
        } else if ((p[5] || p[6]) && b % 3 && !((b + v) % 3)) {
          S += v;
          continue;
        }
        if (k -= v, k > 0)
          continue;
        v = Math.min(v, v + k + S);
        const w = [...p[0]][0].length, T = u.slice(0, b + p.index + w + v);
        if (Math.min(b, v) % 2) {
          const R = T.slice(1, -1);
          return {
            type: "em",
            raw: T,
            text: R,
            tokens: this.lexer.inlineTokens(R)
          };
        }
        const E = T.slice(2, -2);
        return {
          type: "strong",
          raw: T,
          text: E,
          tokens: this.lexer.inlineTokens(E)
        };
      }
    }
  }
  codespan(u) {
    const l = this.rules.inline.code.exec(u);
    if (l) {
      let f = l[2].replace(this.rules.other.newLineCharGlobal, " ");
      const p = this.rules.other.nonSpaceChar.test(f), m = this.rules.other.startingSpaceChar.test(f) && this.rules.other.endingSpaceChar.test(f);
      return p && m && (f = f.substring(1, f.length - 1)), {
        type: "codespan",
        raw: l[0],
        text: f
      };
    }
  }
  br(u) {
    const l = this.rules.inline.br.exec(u);
    if (l)
      return {
        type: "br",
        raw: l[0]
      };
  }
  del(u) {
    const l = this.rules.inline.del.exec(u);
    if (l)
      return {
        type: "del",
        raw: l[0],
        text: l[2],
        tokens: this.lexer.inlineTokens(l[2])
      };
  }
  autolink(u) {
    const l = this.rules.inline.autolink.exec(u);
    if (l) {
      let f, p;
      return l[2] === "@" ? (f = l[1], p = "mailto:" + f) : (f = l[1], p = f), {
        type: "link",
        raw: l[0],
        text: f,
        href: p,
        tokens: [
          {
            type: "text",
            raw: f,
            text: f
          }
        ]
      };
    }
  }
  url(u) {
    var f;
    let l;
    if (l = this.rules.inline.url.exec(u)) {
      let p, m;
      if (l[2] === "@")
        p = l[0], m = "mailto:" + p;
      else {
        let b;
        do
          b = l[0], l[0] = ((f = this.rules.inline._backpedal.exec(l[0])) == null ? void 0 : f[0]) ?? "";
        while (b !== l[0]);
        p = l[0], l[1] === "www." ? m = "http://" + l[0] : m = l[0];
      }
      return {
        type: "link",
        raw: l[0],
        text: p,
        href: m,
        tokens: [
          {
            type: "text",
            raw: p,
            text: p
          }
        ]
      };
    }
  }
  inlineText(u) {
    const l = this.rules.inline.text.exec(u);
    if (l) {
      const f = this.lexer.state.inRawBlock;
      return {
        type: "text",
        raw: l[0],
        text: l[0],
        escaped: f
      };
    }
  }
}, _Lexer = class St {
  constructor(l) {
    me(this, "tokens");
    me(this, "options");
    me(this, "state");
    me(this, "tokenizer");
    me(this, "inlineQueue");
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = l || _defaults, this.options.tokenizer = this.options.tokenizer || new _Tokenizer(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
      inLink: !1,
      inRawBlock: !1,
      top: !0
    };
    const f = {
      other,
      block: block.normal,
      inline: inline$1.normal
    };
    this.options.pedantic ? (f.block = block.pedantic, f.inline = inline$1.pedantic) : this.options.gfm && (f.block = block.gfm, this.options.breaks ? f.inline = inline$1.breaks : f.inline = inline$1.gfm), this.tokenizer.rules = f;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline: inline$1
    };
  }
  /**
   * Static Lex Method
   */
  static lex(l, f) {
    return new St(f).lex(l);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(l, f) {
    return new St(f).inlineTokens(l);
  }
  /**
   * Preprocessing
   */
  lex(l) {
    l = l.replace(other.carriageReturn, `
`), this.blockTokens(l, this.tokens);
    for (let f = 0; f < this.inlineQueue.length; f++) {
      const p = this.inlineQueue[f];
      this.inlineTokens(p.src, p.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(l, f = [], p = !1) {
    var m, b, y;
    for (this.options.pedantic && (l = l.replace(other.tabCharGlobal, "    ").replace(other.spaceLine, "")); l; ) {
      let v;
      if ((b = (m = this.options.extensions) == null ? void 0 : m.block) != null && b.some((S) => (v = S.call({ lexer: this }, l, f)) ? (l = l.substring(v.raw.length), f.push(v), !0) : !1))
        continue;
      if (v = this.tokenizer.space(l)) {
        l = l.substring(v.raw.length);
        const S = f.at(-1);
        v.raw.length === 1 && S !== void 0 ? S.raw += `
` : f.push(v);
        continue;
      }
      if (v = this.tokenizer.code(l)) {
        l = l.substring(v.raw.length);
        const S = f.at(-1);
        (S == null ? void 0 : S.type) === "paragraph" || (S == null ? void 0 : S.type) === "text" ? (S.raw += `
` + v.raw, S.text += `
` + v.text, this.inlineQueue.at(-1).src = S.text) : f.push(v);
        continue;
      }
      if (v = this.tokenizer.fences(l)) {
        l = l.substring(v.raw.length), f.push(v);
        continue;
      }
      if (v = this.tokenizer.heading(l)) {
        l = l.substring(v.raw.length), f.push(v);
        continue;
      }
      if (v = this.tokenizer.hr(l)) {
        l = l.substring(v.raw.length), f.push(v);
        continue;
      }
      if (v = this.tokenizer.blockquote(l)) {
        l = l.substring(v.raw.length), f.push(v);
        continue;
      }
      if (v = this.tokenizer.list(l)) {
        l = l.substring(v.raw.length), f.push(v);
        continue;
      }
      if (v = this.tokenizer.html(l)) {
        l = l.substring(v.raw.length), f.push(v);
        continue;
      }
      if (v = this.tokenizer.def(l)) {
        l = l.substring(v.raw.length);
        const S = f.at(-1);
        (S == null ? void 0 : S.type) === "paragraph" || (S == null ? void 0 : S.type) === "text" ? (S.raw += `
` + v.raw, S.text += `
` + v.raw, this.inlineQueue.at(-1).src = S.text) : this.tokens.links[v.tag] || (this.tokens.links[v.tag] = {
          href: v.href,
          title: v.title
        });
        continue;
      }
      if (v = this.tokenizer.table(l)) {
        l = l.substring(v.raw.length), f.push(v);
        continue;
      }
      if (v = this.tokenizer.lheading(l)) {
        l = l.substring(v.raw.length), f.push(v);
        continue;
      }
      let k = l;
      if ((y = this.options.extensions) != null && y.startBlock) {
        let S = 1 / 0;
        const $ = l.slice(1);
        let w;
        this.options.extensions.startBlock.forEach((T) => {
          w = T.call({ lexer: this }, $), typeof w == "number" && w >= 0 && (S = Math.min(S, w));
        }), S < 1 / 0 && S >= 0 && (k = l.substring(0, S + 1));
      }
      if (this.state.top && (v = this.tokenizer.paragraph(k))) {
        const S = f.at(-1);
        p && (S == null ? void 0 : S.type) === "paragraph" ? (S.raw += `
` + v.raw, S.text += `
` + v.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = S.text) : f.push(v), p = k.length !== l.length, l = l.substring(v.raw.length);
        continue;
      }
      if (v = this.tokenizer.text(l)) {
        l = l.substring(v.raw.length);
        const S = f.at(-1);
        (S == null ? void 0 : S.type) === "text" ? (S.raw += `
` + v.raw, S.text += `
` + v.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = S.text) : f.push(v);
        continue;
      }
      if (l) {
        const S = "Infinite loop on byte: " + l.charCodeAt(0);
        if (this.options.silent) {
          console.error(S);
          break;
        } else
          throw new Error(S);
      }
    }
    return this.state.top = !0, f;
  }
  inline(l, f = []) {
    return this.inlineQueue.push({ src: l, tokens: f }), f;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(l, f = []) {
    var v, k, S;
    let p = l, m = null;
    if (this.tokens.links) {
      const $ = Object.keys(this.tokens.links);
      if ($.length > 0)
        for (; (m = this.tokenizer.rules.inline.reflinkSearch.exec(p)) != null; )
          $.includes(m[0].slice(m[0].lastIndexOf("[") + 1, -1)) && (p = p.slice(0, m.index) + "[" + "a".repeat(m[0].length - 2) + "]" + p.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (m = this.tokenizer.rules.inline.anyPunctuation.exec(p)) != null; )
      p = p.slice(0, m.index) + "++" + p.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; (m = this.tokenizer.rules.inline.blockSkip.exec(p)) != null; )
      p = p.slice(0, m.index) + "[" + "a".repeat(m[0].length - 2) + "]" + p.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    let b = !1, y = "";
    for (; l; ) {
      b || (y = ""), b = !1;
      let $;
      if ((k = (v = this.options.extensions) == null ? void 0 : v.inline) != null && k.some((T) => ($ = T.call({ lexer: this }, l, f)) ? (l = l.substring($.raw.length), f.push($), !0) : !1))
        continue;
      if ($ = this.tokenizer.escape(l)) {
        l = l.substring($.raw.length), f.push($);
        continue;
      }
      if ($ = this.tokenizer.tag(l)) {
        l = l.substring($.raw.length), f.push($);
        continue;
      }
      if ($ = this.tokenizer.link(l)) {
        l = l.substring($.raw.length), f.push($);
        continue;
      }
      if ($ = this.tokenizer.reflink(l, this.tokens.links)) {
        l = l.substring($.raw.length);
        const T = f.at(-1);
        $.type === "text" && (T == null ? void 0 : T.type) === "text" ? (T.raw += $.raw, T.text += $.text) : f.push($);
        continue;
      }
      if ($ = this.tokenizer.emStrong(l, p, y)) {
        l = l.substring($.raw.length), f.push($);
        continue;
      }
      if ($ = this.tokenizer.codespan(l)) {
        l = l.substring($.raw.length), f.push($);
        continue;
      }
      if ($ = this.tokenizer.br(l)) {
        l = l.substring($.raw.length), f.push($);
        continue;
      }
      if ($ = this.tokenizer.del(l)) {
        l = l.substring($.raw.length), f.push($);
        continue;
      }
      if ($ = this.tokenizer.autolink(l)) {
        l = l.substring($.raw.length), f.push($);
        continue;
      }
      if (!this.state.inLink && ($ = this.tokenizer.url(l))) {
        l = l.substring($.raw.length), f.push($);
        continue;
      }
      let w = l;
      if ((S = this.options.extensions) != null && S.startInline) {
        let T = 1 / 0;
        const E = l.slice(1);
        let R;
        this.options.extensions.startInline.forEach((O) => {
          R = O.call({ lexer: this }, E), typeof R == "number" && R >= 0 && (T = Math.min(T, R));
        }), T < 1 / 0 && T >= 0 && (w = l.substring(0, T + 1));
      }
      if ($ = this.tokenizer.inlineText(w)) {
        l = l.substring($.raw.length), $.raw.slice(-1) !== "_" && (y = $.raw.slice(-1)), b = !0;
        const T = f.at(-1);
        (T == null ? void 0 : T.type) === "text" ? (T.raw += $.raw, T.text += $.text) : f.push($);
        continue;
      }
      if (l) {
        const T = "Infinite loop on byte: " + l.charCodeAt(0);
        if (this.options.silent) {
          console.error(T);
          break;
        } else
          throw new Error(T);
      }
    }
    return f;
  }
}, _Renderer = class {
  // set by the parser
  constructor(u) {
    me(this, "options");
    me(this, "parser");
    this.options = u || _defaults;
  }
  space(u) {
    return "";
  }
  code({ text: u, lang: l, escaped: f }) {
    var b;
    const p = (b = (l || "").match(other.notSpaceStart)) == null ? void 0 : b[0], m = u.replace(other.endingNewline, "") + `
`;
    return p ? '<pre><code class="language-' + escape2(p) + '">' + (f ? m : escape2(m, !0)) + `</code></pre>
` : "<pre><code>" + (f ? m : escape2(m, !0)) + `</code></pre>
`;
  }
  blockquote({ tokens: u }) {
    return `<blockquote>
${this.parser.parse(u)}</blockquote>
`;
  }
  html({ text: u }) {
    return u;
  }
  heading({ tokens: u, depth: l }) {
    return `<h${l}>${this.parser.parseInline(u)}</h${l}>
`;
  }
  hr(u) {
    return `<hr>
`;
  }
  list(u) {
    const l = u.ordered, f = u.start;
    let p = "";
    for (let y = 0; y < u.items.length; y++) {
      const v = u.items[y];
      p += this.listitem(v);
    }
    const m = l ? "ol" : "ul", b = l && f !== 1 ? ' start="' + f + '"' : "";
    return "<" + m + b + `>
` + p + "</" + m + `>
`;
  }
  listitem(u) {
    var f;
    let l = "";
    if (u.task) {
      const p = this.checkbox({ checked: !!u.checked });
      u.loose ? ((f = u.tokens[0]) == null ? void 0 : f.type) === "paragraph" ? (u.tokens[0].text = p + " " + u.tokens[0].text, u.tokens[0].tokens && u.tokens[0].tokens.length > 0 && u.tokens[0].tokens[0].type === "text" && (u.tokens[0].tokens[0].text = p + " " + escape2(u.tokens[0].tokens[0].text), u.tokens[0].tokens[0].escaped = !0)) : u.tokens.unshift({
        type: "text",
        raw: p + " ",
        text: p + " ",
        escaped: !0
      }) : l += p + " ";
    }
    return l += this.parser.parse(u.tokens, !!u.loose), `<li>${l}</li>
`;
  }
  checkbox({ checked: u }) {
    return "<input " + (u ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: u }) {
    return `<p>${this.parser.parseInline(u)}</p>
`;
  }
  table(u) {
    let l = "", f = "";
    for (let m = 0; m < u.header.length; m++)
      f += this.tablecell(u.header[m]);
    l += this.tablerow({ text: f });
    let p = "";
    for (let m = 0; m < u.rows.length; m++) {
      const b = u.rows[m];
      f = "";
      for (let y = 0; y < b.length; y++)
        f += this.tablecell(b[y]);
      p += this.tablerow({ text: f });
    }
    return p && (p = `<tbody>${p}</tbody>`), `<table>
<thead>
` + l + `</thead>
` + p + `</table>
`;
  }
  tablerow({ text: u }) {
    return `<tr>
${u}</tr>
`;
  }
  tablecell(u) {
    const l = this.parser.parseInline(u.tokens), f = u.header ? "th" : "td";
    return (u.align ? `<${f} align="${u.align}">` : `<${f}>`) + l + `</${f}>
`;
  }
  /**
   * span level renderer
   */
  strong({ tokens: u }) {
    return `<strong>${this.parser.parseInline(u)}</strong>`;
  }
  em({ tokens: u }) {
    return `<em>${this.parser.parseInline(u)}</em>`;
  }
  codespan({ text: u }) {
    return `<code>${escape2(u, !0)}</code>`;
  }
  br(u) {
    return "<br>";
  }
  del({ tokens: u }) {
    return `<del>${this.parser.parseInline(u)}</del>`;
  }
  link({ href: u, title: l, tokens: f }) {
    const p = this.parser.parseInline(f), m = cleanUrl(u);
    if (m === null)
      return p;
    u = m;
    let b = '<a href="' + u + '"';
    return l && (b += ' title="' + escape2(l) + '"'), b += ">" + p + "</a>", b;
  }
  image({ href: u, title: l, text: f, tokens: p }) {
    p && (f = this.parser.parseInline(p, this.parser.textRenderer));
    const m = cleanUrl(u);
    if (m === null)
      return escape2(f);
    u = m;
    let b = `<img src="${u}" alt="${f}"`;
    return l && (b += ` title="${escape2(l)}"`), b += ">", b;
  }
  text(u) {
    return "tokens" in u && u.tokens ? this.parser.parseInline(u.tokens) : "escaped" in u && u.escaped ? u.text : escape2(u.text);
  }
}, _TextRenderer = class {
  // no need for block level renderers
  strong({ text: u }) {
    return u;
  }
  em({ text: u }) {
    return u;
  }
  codespan({ text: u }) {
    return u;
  }
  del({ text: u }) {
    return u;
  }
  html({ text: u }) {
    return u;
  }
  text({ text: u }) {
    return u;
  }
  link({ text: u }) {
    return "" + u;
  }
  image({ text: u }) {
    return "" + u;
  }
  br() {
    return "";
  }
}, _Parser = class $t {
  constructor(l) {
    me(this, "options");
    me(this, "renderer");
    me(this, "textRenderer");
    this.options = l || _defaults, this.options.renderer = this.options.renderer || new _Renderer(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(l, f) {
    return new $t(f).parse(l);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(l, f) {
    return new $t(f).parseInline(l);
  }
  /**
   * Parse Loop
   */
  parse(l, f = !0) {
    var m, b;
    let p = "";
    for (let y = 0; y < l.length; y++) {
      const v = l[y];
      if ((b = (m = this.options.extensions) == null ? void 0 : m.renderers) != null && b[v.type]) {
        const S = v, $ = this.options.extensions.renderers[S.type].call({ parser: this }, S);
        if ($ !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(S.type)) {
          p += $ || "";
          continue;
        }
      }
      const k = v;
      switch (k.type) {
        case "space": {
          p += this.renderer.space(k);
          continue;
        }
        case "hr": {
          p += this.renderer.hr(k);
          continue;
        }
        case "heading": {
          p += this.renderer.heading(k);
          continue;
        }
        case "code": {
          p += this.renderer.code(k);
          continue;
        }
        case "table": {
          p += this.renderer.table(k);
          continue;
        }
        case "blockquote": {
          p += this.renderer.blockquote(k);
          continue;
        }
        case "list": {
          p += this.renderer.list(k);
          continue;
        }
        case "html": {
          p += this.renderer.html(k);
          continue;
        }
        case "paragraph": {
          p += this.renderer.paragraph(k);
          continue;
        }
        case "text": {
          let S = k, $ = this.renderer.text(S);
          for (; y + 1 < l.length && l[y + 1].type === "text"; )
            S = l[++y], $ += `
` + this.renderer.text(S);
          f ? p += this.renderer.paragraph({
            type: "paragraph",
            raw: $,
            text: $,
            tokens: [{ type: "text", raw: $, text: $, escaped: !0 }]
          }) : p += $;
          continue;
        }
        default: {
          const S = 'Token with "' + k.type + '" type was not found.';
          if (this.options.silent)
            return console.error(S), "";
          throw new Error(S);
        }
      }
    }
    return p;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(l, f = this.renderer) {
    var m, b;
    let p = "";
    for (let y = 0; y < l.length; y++) {
      const v = l[y];
      if ((b = (m = this.options.extensions) == null ? void 0 : m.renderers) != null && b[v.type]) {
        const S = this.options.extensions.renderers[v.type].call({ parser: this }, v);
        if (S !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(v.type)) {
          p += S || "";
          continue;
        }
      }
      const k = v;
      switch (k.type) {
        case "escape": {
          p += f.text(k);
          break;
        }
        case "html": {
          p += f.html(k);
          break;
        }
        case "link": {
          p += f.link(k);
          break;
        }
        case "image": {
          p += f.image(k);
          break;
        }
        case "strong": {
          p += f.strong(k);
          break;
        }
        case "em": {
          p += f.em(k);
          break;
        }
        case "codespan": {
          p += f.codespan(k);
          break;
        }
        case "br": {
          p += f.br(k);
          break;
        }
        case "del": {
          p += f.del(k);
          break;
        }
        case "text": {
          p += f.text(k);
          break;
        }
        default: {
          const S = 'Token with "' + k.type + '" type was not found.';
          if (this.options.silent)
            return console.error(S), "";
          throw new Error(S);
        }
      }
    }
    return p;
  }
}, yt, _Hooks = (yt = class {
  constructor(u) {
    me(this, "options");
    me(this, "block");
    this.options = u || _defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(u) {
    return u;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(u) {
    return u;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(u) {
    return u;
  }
  /**
   * Provide function to tokenize markdown
   */
  provideLexer() {
    return this.block ? _Lexer.lex : _Lexer.lexInline;
  }
  /**
   * Provide function to parse tokens
   */
  provideParser() {
    return this.block ? _Parser.parse : _Parser.parseInline;
  }
}, me(yt, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess",
  "processAllTokens"
])), yt), Marked = class {
  constructor(...u) {
    me(this, "defaults", _getDefaults());
    me(this, "options", this.setOptions);
    me(this, "parse", this.parseMarkdown(!0));
    me(this, "parseInline", this.parseMarkdown(!1));
    me(this, "Parser", _Parser);
    me(this, "Renderer", _Renderer);
    me(this, "TextRenderer", _TextRenderer);
    me(this, "Lexer", _Lexer);
    me(this, "Tokenizer", _Tokenizer);
    me(this, "Hooks", _Hooks);
    this.use(...u);
  }
  /**
   * Run callback for every token
   */
  walkTokens(u, l) {
    var p, m;
    let f = [];
    for (const b of u)
      switch (f = f.concat(l.call(this, b)), b.type) {
        case "table": {
          const y = b;
          for (const v of y.header)
            f = f.concat(this.walkTokens(v.tokens, l));
          for (const v of y.rows)
            for (const k of v)
              f = f.concat(this.walkTokens(k.tokens, l));
          break;
        }
        case "list": {
          const y = b;
          f = f.concat(this.walkTokens(y.items, l));
          break;
        }
        default: {
          const y = b;
          (m = (p = this.defaults.extensions) == null ? void 0 : p.childTokens) != null && m[y.type] ? this.defaults.extensions.childTokens[y.type].forEach((v) => {
            const k = y[v].flat(1 / 0);
            f = f.concat(this.walkTokens(k, l));
          }) : y.tokens && (f = f.concat(this.walkTokens(y.tokens, l)));
        }
      }
    return f;
  }
  use(...u) {
    const l = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return u.forEach((f) => {
      const p = { ...f };
      if (p.async = this.defaults.async || p.async || !1, f.extensions && (f.extensions.forEach((m) => {
        if (!m.name)
          throw new Error("extension name required");
        if ("renderer" in m) {
          const b = l.renderers[m.name];
          b ? l.renderers[m.name] = function(...y) {
            let v = m.renderer.apply(this, y);
            return v === !1 && (v = b.apply(this, y)), v;
          } : l.renderers[m.name] = m.renderer;
        }
        if ("tokenizer" in m) {
          if (!m.level || m.level !== "block" && m.level !== "inline")
            throw new Error("extension level must be 'block' or 'inline'");
          const b = l[m.level];
          b ? b.unshift(m.tokenizer) : l[m.level] = [m.tokenizer], m.start && (m.level === "block" ? l.startBlock ? l.startBlock.push(m.start) : l.startBlock = [m.start] : m.level === "inline" && (l.startInline ? l.startInline.push(m.start) : l.startInline = [m.start]));
        }
        "childTokens" in m && m.childTokens && (l.childTokens[m.name] = m.childTokens);
      }), p.extensions = l), f.renderer) {
        const m = this.defaults.renderer || new _Renderer(this.defaults);
        for (const b in f.renderer) {
          if (!(b in m))
            throw new Error(`renderer '${b}' does not exist`);
          if (["options", "parser"].includes(b))
            continue;
          const y = b, v = f.renderer[y], k = m[y];
          m[y] = (...S) => {
            let $ = v.apply(m, S);
            return $ === !1 && ($ = k.apply(m, S)), $ || "";
          };
        }
        p.renderer = m;
      }
      if (f.tokenizer) {
        const m = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const b in f.tokenizer) {
          if (!(b in m))
            throw new Error(`tokenizer '${b}' does not exist`);
          if (["options", "rules", "lexer"].includes(b))
            continue;
          const y = b, v = f.tokenizer[y], k = m[y];
          m[y] = (...S) => {
            let $ = v.apply(m, S);
            return $ === !1 && ($ = k.apply(m, S)), $;
          };
        }
        p.tokenizer = m;
      }
      if (f.hooks) {
        const m = this.defaults.hooks || new _Hooks();
        for (const b in f.hooks) {
          if (!(b in m))
            throw new Error(`hook '${b}' does not exist`);
          if (["options", "block"].includes(b))
            continue;
          const y = b, v = f.hooks[y], k = m[y];
          _Hooks.passThroughHooks.has(b) ? m[y] = (S) => {
            if (this.defaults.async)
              return Promise.resolve(v.call(m, S)).then((w) => k.call(m, w));
            const $ = v.call(m, S);
            return k.call(m, $);
          } : m[y] = (...S) => {
            let $ = v.apply(m, S);
            return $ === !1 && ($ = k.apply(m, S)), $;
          };
        }
        p.hooks = m;
      }
      if (f.walkTokens) {
        const m = this.defaults.walkTokens, b = f.walkTokens;
        p.walkTokens = function(y) {
          let v = [];
          return v.push(b.call(this, y)), m && (v = v.concat(m.call(this, y))), v;
        };
      }
      this.defaults = { ...this.defaults, ...p };
    }), this;
  }
  setOptions(u) {
    return this.defaults = { ...this.defaults, ...u }, this;
  }
  lexer(u, l) {
    return _Lexer.lex(u, l ?? this.defaults);
  }
  parser(u, l) {
    return _Parser.parse(u, l ?? this.defaults);
  }
  parseMarkdown(u) {
    return (f, p) => {
      const m = { ...p }, b = { ...this.defaults, ...m }, y = this.onError(!!b.silent, !!b.async);
      if (this.defaults.async === !0 && m.async === !1)
        return y(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof f > "u" || f === null)
        return y(new Error("marked(): input parameter is undefined or null"));
      if (typeof f != "string")
        return y(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(f) + ", string expected"));
      b.hooks && (b.hooks.options = b, b.hooks.block = u);
      const v = b.hooks ? b.hooks.provideLexer() : u ? _Lexer.lex : _Lexer.lexInline, k = b.hooks ? b.hooks.provideParser() : u ? _Parser.parse : _Parser.parseInline;
      if (b.async)
        return Promise.resolve(b.hooks ? b.hooks.preprocess(f) : f).then((S) => v(S, b)).then((S) => b.hooks ? b.hooks.processAllTokens(S) : S).then((S) => b.walkTokens ? Promise.all(this.walkTokens(S, b.walkTokens)).then(() => S) : S).then((S) => k(S, b)).then((S) => b.hooks ? b.hooks.postprocess(S) : S).catch(y);
      try {
        b.hooks && (f = b.hooks.preprocess(f));
        let S = v(f, b);
        b.hooks && (S = b.hooks.processAllTokens(S)), b.walkTokens && this.walkTokens(S, b.walkTokens);
        let $ = k(S, b);
        return b.hooks && ($ = b.hooks.postprocess($)), $;
      } catch (S) {
        return y(S);
      }
    };
  }
  onError(u, l) {
    return (f) => {
      if (f.message += `
Please report this to https://github.com/markedjs/marked.`, u) {
        const p = "<p>An error occurred:</p><pre>" + escape2(f.message + "", !0) + "</pre>";
        return l ? Promise.resolve(p) : p;
      }
      if (l)
        return Promise.reject(f);
      throw f;
    };
  }
}, markedInstance = new Marked();
function marked(u, l) {
  return markedInstance.parse(u, l);
}
marked.options = marked.setOptions = function(u) {
  return markedInstance.setOptions(u), marked.defaults = markedInstance.defaults, changeDefaults(marked.defaults), marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...u) {
  return markedInstance.use(...u), marked.defaults = markedInstance.defaults, changeDefaults(marked.defaults), marked;
};
marked.walkTokens = function(u, l) {
  return markedInstance.walkTokens(u, l);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
_Parser.parse;
_Lexer.lex;
const MarkdownViewer_svelte_svelte_type_style_lang = "", indexVars$8 = "", indexVars$7 = "", Modal_svelte_svelte_type_style_lang = "", get_outside_slot_changes = (u) => ({}), get_outside_slot_context = (u) => ({});
function create_else_block$c(u) {
  let l, f, p;
  return f = new Portal({
    props: {
      target: ".modal-container",
      $$slots: { default: [create_default_slot$A] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "portal svelte-em5khd");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b & /*$$scope, zIndex, modal, visible*/
      524314 && (y.$$scope = { dirty: b, ctx: m }), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block$B(u) {
  let l, f, p = (
    /*visible*/
    u[3] && create_if_block_1$j(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, b) {
      /*visible*/
      m[3] ? p ? (p.p(m, b), b & /*visible*/
      8 && transition_in(p, 1)) : (p = create_if_block_1$j(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
function create_if_block_2$e(u) {
  let l, f, p, m, b, y, v, k, S, $, w, T, E, R;
  const O = (
    /*#slots*/
    u[13].outside
  ), P = create_slot(
    O,
    u,
    /*$$scope*/
    u[19],
    get_outside_slot_context
  ), L = (
    /*#slots*/
    u[13].default
  ), M = create_slot(
    L,
    u,
    /*$$scope*/
    u[19],
    null
  );
  return {
    c() {
      l = element("div"), f = element("div"), b = space(), y = element("div"), v = element("div"), P && P.c(), k = space(), S = element("div"), M && M.c(), attr(f, "class", "background svelte-em5khd"), attr(S, "class", null_to_empty(`spectrum-Modal spectrum-Modal-${/*uniqueId*/
      u[5]} is-open`) + " svelte-em5khd"), attr(v, "class", "modal-inner-wrapper svelte-em5khd"), attr(y, "class", "modal-wrapper svelte-em5khd"), attr(l, "class", "spectrum-Underlay is-open svelte-em5khd"), set_style(
        l,
        "z-index",
        /*zIndex*/
        u[1] || 999
      );
    },
    m(B, j) {
      insert(B, l, j), append$1(l, f), append$1(l, b), append$1(l, y), append$1(y, v), P && P.m(v, null), append$1(v, k), append$1(v, S), M && M.m(S, null), u[15](S), T = !0, E || (R = [
        action_destroyer(
          /*focusModal*/
          u[6].call(null, S)
        ),
        listen(v, "mousedown", self$1(
          /*mousedown_handler*/
          u[16]
        )),
        listen(y, "mousedown", self$1(
          /*mousedown_handler_1*/
          u[17]
        )),
        listen(l, "mousedown", self$1(
          /*mousedown_handler_2*/
          u[18]
        ))
      ], E = !0);
    },
    p(B, j) {
      P && P.p && (!T || j & /*$$scope*/
      524288) && update_slot_base(
        P,
        O,
        B,
        /*$$scope*/
        B[19],
        T ? get_slot_changes(
          O,
          /*$$scope*/
          B[19],
          j,
          get_outside_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          B[19]
        ),
        get_outside_slot_context
      ), M && M.p && (!T || j & /*$$scope*/
      524288) && update_slot_base(
        M,
        L,
        B,
        /*$$scope*/
        B[19],
        T ? get_slot_changes(
          L,
          /*$$scope*/
          B[19],
          j,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          B[19]
        ),
        null
      ), (!T || j & /*zIndex*/
      2) && set_style(
        l,
        "z-index",
        /*zIndex*/
        B[1] || 999
      );
    },
    i(B) {
      T || (B && add_render_callback(() => {
        T && (m && m.end(1), p = create_in_transition(f, fade, { duration: 200 }), p.start());
      }), transition_in(P, B), transition_in(M, B), B && add_render_callback(() => {
        T && (w && w.end(1), $ = create_in_transition(S, fly, { y: 30, duration: 200 }), $.start());
      }), T = !0);
    },
    o(B) {
      p && p.invalidate(), B && (m = create_out_transition(f, fade, { duration: 200 })), transition_out(P, B), transition_out(M, B), $ && $.invalidate(), B && (w = create_out_transition(S, fly, { y: 30, duration: 200 })), T = !1;
    },
    d(B) {
      B && detach(l), B && m && m.end(), P && P.d(B), M && M.d(B), u[15](null), B && w && w.end(), E = !1, run_all(R);
    }
  };
}
function create_default_slot$A(u) {
  let l, f, p = (
    /*visible*/
    u[3] && create_if_block_2$e(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, b) {
      /*visible*/
      m[3] ? p ? (p.p(m, b), b & /*visible*/
      8 && transition_in(p, 1)) : (p = create_if_block_2$e(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
function create_if_block_1$j(u) {
  let l, f, p, m;
  const b = (
    /*#slots*/
    u[13].default
  ), y = create_slot(
    b,
    u,
    /*$$scope*/
    u[19],
    null
  );
  return {
    c() {
      l = element("div"), y && y.c(), attr(l, "class", null_to_empty(`spectrum-Modal spectrum-Modal-${/*uniqueId*/
      u[5]} inline is-open`) + " svelte-em5khd");
    },
    m(v, k) {
      insert(v, l, k), y && y.m(l, null), u[14](l), f = !0, p || (m = action_destroyer(
        /*focusModal*/
        u[6].call(null, l)
      ), p = !0);
    },
    p(v, k) {
      y && y.p && (!f || k & /*$$scope*/
      524288) && update_slot_base(
        y,
        b,
        v,
        /*$$scope*/
        v[19],
        f ? get_slot_changes(
          b,
          /*$$scope*/
          v[19],
          k,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          v[19]
        ),
        null
      );
    },
    i(v) {
      f || (transition_in(y, v), f = !0);
    },
    o(v) {
      transition_out(y, v), f = !1;
    },
    d(v) {
      v && detach(l), y && y.d(v), u[14](null), p = !1, m();
    }
  };
}
function create_fragment$18(u) {
  let l, f, p, m;
  const b = [create_if_block$B, create_else_block$c], y = [];
  function v(k, S) {
    return (
      /*inline*/
      k[0] ? 0 : 1
    );
  }
  return l = v(u), f = y[l] = b[l](u), {
    c() {
      f.c(), p = empty$1();
    },
    m(k, S) {
      y[l].m(k, S), insert(k, p, S), m = !0;
    },
    p(k, [S]) {
      let $ = l;
      l = v(k), l === $ ? y[l].p(k, S) : (group_outros(), transition_out(y[$], 1, 1, () => {
        y[$] = null;
      }), check_outros(), f = y[l], f ? f.p(k, S) : (f = y[l] = b[l](k), f.c()), transition_in(f, 1), f.m(p.parentNode, p));
    },
    i(k) {
      m || (transition_in(f), m = !0);
    },
    o(k) {
      transition_out(f), m = !1;
    },
    d(k) {
      k && detach(p), y[l].d(k);
    }
  };
}
function instance$16(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l, { fixed: b = !1 } = l, { inline: y = !1 } = l, { disableCancel: v = !1 } = l, { autoFocus: k = !0 } = l, { zIndex: S = 1001 } = l;
  const $ = shortid$1.generate();
  setContext(Context$1.PopoverRoot, `.spectrum-Modal-${$}`);
  const w = createEventDispatcher();
  let T = b || y, E;
  function R() {
    T || f(3, T = !0);
  }
  function O() {
    !T || b || y || f(3, T = !1);
  }
  function P() {
    T ? O() : R();
  }
  function L(W) {
    !T || v || (w("cancel", W), O());
  }
  function M(W) {
    T && W.key === "Escape" && L(ModalCancelFrom.ESCAPE_KEY);
  }
  function B(W) {
    k && tick().then(() => {
      const F = W.querySelectorAll("input");
      if (F != null && F.length)
        F[0].focus();
      else if (E) {
        const U = E.querySelector(".confirm-wrap .spectrum-Button");
        U && U.focus();
      }
    });
  }
  setContext(Context$1.Modal, { show: R, hide: O, toggle: P, cancel: L }), onMount(() => (document.addEventListener("keydown", M), () => {
    document.removeEventListener("keydown", M);
  }));
  function j(W) {
    binding_callbacks[W ? "unshift" : "push"](() => {
      E = W, f(4, E);
    });
  }
  function x(W) {
    binding_callbacks[W ? "unshift" : "push"](() => {
      E = W, f(4, E);
    });
  }
  const N = () => L(ModalCancelFrom.OUTSIDE_CLICK), D = () => L(ModalCancelFrom.OUTSIDE_CLICK), V = () => L(ModalCancelFrom.OUTSIDE_CLICK);
  return u.$$set = (W) => {
    "fixed" in W && f(7, b = W.fixed), "inline" in W && f(0, y = W.inline), "disableCancel" in W && f(8, v = W.disableCancel), "autoFocus" in W && f(9, k = W.autoFocus), "zIndex" in W && f(1, S = W.zIndex), "$$scope" in W && f(19, m = W.$$scope);
  }, u.$$.update = () => {
    u.$$.dirty & /*visible*/
    8 && w(T ? "show" : "hide");
  }, [
    y,
    S,
    L,
    T,
    E,
    $,
    B,
    b,
    v,
    k,
    R,
    O,
    P,
    p,
    j,
    x,
    N,
    D,
    V,
    m
  ];
}
class Modal extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$16, create_fragment$18, safe_not_equal, {
      fixed: 7,
      inline: 0,
      disableCancel: 8,
      autoFocus: 9,
      zIndex: 1,
      show: 10,
      hide: 11,
      toggle: 12,
      cancel: 2
    });
  }
  get show() {
    return this.$$.ctx[10];
  }
  get hide() {
    return this.$$.ctx[11];
  }
  get toggle() {
    return this.$$.ctx[12];
  }
  get cancel() {
    return this.$$.ctx[2];
  }
}
const indexVars$6 = "", ModalContent_svelte_svelte_type_style_lang = "", get_footer_slot_changes = (u) => ({}), get_footer_slot_context = (u) => ({}), get_default_slot_changes = (u) => ({ loading: u & /*loading*/
16384 }), get_default_slot_context = (u) => ({ loading: (
  /*loading*/
  u[14]
) }), get_header_slot_changes = (u) => ({}), get_header_slot_context = (u) => ({});
function create_if_block_7$3(u) {
  let l, f, p, m, b, y;
  const v = [create_if_block_9$1, create_if_block_10$1], k = [];
  function S(w, T) {
    return (
      /*title*/
      w[0] ? 0 : (
        /*$$slots*/
        w[19].header ? 1 : -1
      )
    );
  }
  ~(f = S(u)) && (p = k[f] = v[f](u));
  let $ = (
    /*showDivider*/
    u[7] && create_if_block_8$1()
  );
  return {
    c() {
      l = element("h1"), p && p.c(), m = space(), $ && $.c(), b = empty$1(), attr(l, "class", "spectrum-Dialog-heading spectrum-Dialog-heading--noHeader svelte-n0k36s"), toggle_class(l, "noDivider", !/*showDivider*/
      u[7]), toggle_class(
        l,
        "header-spacing",
        /*$$slots*/
        u[19].header
      );
    },
    m(w, T) {
      insert(w, l, T), ~f && k[f].m(l, null), insert(w, m, T), $ && $.m(w, T), insert(w, b, T), y = !0;
    },
    p(w, T) {
      let E = f;
      f = S(w), f === E ? ~f && k[f].p(w, T) : (p && (group_outros(), transition_out(k[E], 1, 1, () => {
        k[E] = null;
      }), check_outros()), ~f ? (p = k[f], p ? p.p(w, T) : (p = k[f] = v[f](w), p.c()), transition_in(p, 1), p.m(l, null)) : p = null), (!y || T & /*showDivider*/
      128) && toggle_class(l, "noDivider", !/*showDivider*/
      w[7]), (!y || T & /*$$slots*/
      524288) && toggle_class(
        l,
        "header-spacing",
        /*$$slots*/
        w[19].header
      ), /*showDivider*/
      w[7] ? $ ? T & /*showDivider*/
      128 && transition_in($, 1) : ($ = create_if_block_8$1(), $.c(), transition_in($, 1), $.m(b.parentNode, b)) : $ && (group_outros(), transition_out($, 1, 1, () => {
        $ = null;
      }), check_outros());
    },
    i(w) {
      y || (transition_in(p), transition_in($), y = !0);
    },
    o(w) {
      transition_out(p), transition_out($), y = !1;
    },
    d(w) {
      w && (detach(l), detach(m), detach(b)), ~f && k[f].d(), $ && $.d(w);
    }
  };
}
function create_if_block_10$1(u) {
  let l;
  const f = (
    /*#slots*/
    u[24].header
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[26],
    get_header_slot_context
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, b) {
      p && p.p && (!l || b & /*$$scope*/
      67108864) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[26],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[26],
          b,
          get_header_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[26]
        ),
        get_header_slot_context
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function create_if_block_9$1(u) {
  let l;
  return {
    c() {
      l = text$2(
        /*title*/
        u[0]
      );
    },
    m(f, p) {
      insert(f, l, p);
    },
    p(f, p) {
      p & /*title*/
      1 && set_data(
        l,
        /*title*/
        f[0]
      );
    },
    i: noop$4,
    o: noop$4,
    d(f) {
      f && detach(l);
    }
  };
}
function create_if_block_8$1(u) {
  let l, f;
  return l = new Divider({}), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_1$i(u) {
  let l, f, p, m, b;
  const y = (
    /*#slots*/
    u[24].footer
  ), v = create_slot(
    y,
    u,
    /*$$scope*/
    u[26],
    get_footer_slot_context
  );
  let k = (
    /*showSecondaryButton*/
    u[8] && /*secondaryButtonText*/
    u[9] && /*secondaryAction*/
    u[10] && create_if_block_6$3(u)
  ), S = (
    /*showCancelButton*/
    u[4] && create_if_block_5$4(u)
  ), $ = (
    /*showConfirmButton*/
    u[5] && create_if_block_2$d(u)
  );
  return {
    c() {
      l = element("div"), v && v.c(), f = space(), k && k.c(), p = space(), S && S.c(), m = space(), $ && $.c(), attr(l, "class", "spectrum-ButtonGroup spectrum-Dialog-buttonGroup spectrum-Dialog-buttonGroup--noFooter svelte-n0k36s");
    },
    m(w, T) {
      insert(w, l, T), v && v.m(l, null), append$1(l, f), k && k.m(l, null), append$1(l, p), S && S.m(l, null), append$1(l, m), $ && $.m(l, null), b = !0;
    },
    p(w, T) {
      v && v.p && (!b || T & /*$$scope*/
      67108864) && update_slot_base(
        v,
        y,
        w,
        /*$$scope*/
        w[26],
        b ? get_slot_changes(
          y,
          /*$$scope*/
          w[26],
          T,
          get_footer_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          w[26]
        ),
        get_footer_slot_context
      ), /*showSecondaryButton*/
      w[8] && /*secondaryButtonText*/
      w[9] && /*secondaryAction*/
      w[10] ? k ? (k.p(w, T), T & /*showSecondaryButton, secondaryButtonText, secondaryAction*/
      1792 && transition_in(k, 1)) : (k = create_if_block_6$3(w), k.c(), transition_in(k, 1), k.m(l, p)) : k && (group_outros(), transition_out(k, 1, 1, () => {
        k = null;
      }), check_outros()), /*showCancelButton*/
      w[4] ? S ? (S.p(w, T), T & /*showCancelButton*/
      16 && transition_in(S, 1)) : (S = create_if_block_5$4(w), S.c(), transition_in(S, 1), S.m(l, m)) : S && (group_outros(), transition_out(S, 1, 1, () => {
        S = null;
      }), check_outros()), /*showConfirmButton*/
      w[5] ? $ ? ($.p(w, T), T & /*showConfirmButton*/
      32 && transition_in($, 1)) : ($ = create_if_block_2$d(w), $.c(), transition_in($, 1), $.m(l, null)) : $ && (group_outros(), transition_out($, 1, 1, () => {
        $ = null;
      }), check_outros());
    },
    i(w) {
      b || (transition_in(v, w), transition_in(k), transition_in(S), transition_in($), b = !0);
    },
    o(w) {
      transition_out(v, w), transition_out(k), transition_out(S), transition_out($), b = !1;
    },
    d(w) {
      w && detach(l), v && v.d(w), k && k.d(), S && S.d(), $ && $.d();
    }
  };
}
function create_if_block_6$3(u) {
  let l, f, p;
  return f = new Button({
    props: {
      secondary: !0,
      warning: (
        /*secondaryButtonWarning*/
        u[11]
      ),
      $$slots: { default: [create_default_slot_2$9] },
      $$scope: { ctx: u }
    }
  }), f.$on(
    "click",
    /*secondary*/
    u[17]
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "secondary-action svelte-n0k36s");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b & /*secondaryButtonWarning*/
      2048 && (y.warning = /*secondaryButtonWarning*/
      m[11]), b & /*$$scope, secondaryButtonText*/
      67109376 && (y.$$scope = { dirty: b, ctx: m }), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_default_slot_2$9(u) {
  let l;
  return {
    c() {
      l = text$2(
        /*secondaryButtonText*/
        u[9]
      );
    },
    m(f, p) {
      insert(f, l, p);
    },
    p(f, p) {
      p & /*secondaryButtonText*/
      512 && set_data(
        l,
        /*secondaryButtonText*/
        f[9]
      );
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_if_block_5$4(u) {
  let l, f;
  return l = new Button({
    props: {
      secondary: !0,
      $$slots: { default: [create_default_slot_1$d] },
      $$scope: { ctx: u }
    }
  }), l.$on(
    "click",
    /*close*/
    u[18]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, cancelText*/
      67108868 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_1$d(u) {
  let l;
  return {
    c() {
      l = text$2(
        /*cancelText*/
        u[2]
      );
    },
    m(f, p) {
      insert(f, l, p);
    },
    p(f, p) {
      p & /*cancelText*/
      4 && set_data(
        l,
        /*cancelText*/
        f[2]
      );
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_if_block_2$d(u) {
  let l, f, p;
  const m = [
    { cta: !0 },
    /*$$restProps*/
    u[20],
    { disabled: (
      /*confirmDisabled*/
      u[15]
    ) }
  ];
  let b = {
    $$slots: { default: [create_default_slot$z] },
    $$scope: { ctx: u }
  };
  for (let y = 0; y < m.length; y += 1)
    b = assign(b, m[y]);
  return f = new Button({ props: b }), f.$on(
    "click",
    /*confirm*/
    u[13]
  ), {
    c() {
      l = element("span"), create_component(f.$$.fragment), attr(l, "class", "confirm-wrap svelte-n0k36s");
    },
    m(y, v) {
      insert(y, l, v), mount_component(f, l, null), p = !0;
    },
    p(y, v) {
      const k = v & /*$$restProps, confirmDisabled*/
      1081344 ? get_spread_update(m, [
        m[0],
        v & /*$$restProps*/
        1048576 && get_spread_object(
          /*$$restProps*/
          y[20]
        ),
        v & /*confirmDisabled*/
        32768 && { disabled: (
          /*confirmDisabled*/
          y[15]
        ) }
      ]) : {};
      v & /*$$scope, confirmText, loading*/
      67125256 && (k.$$scope = { dirty: v, ctx: y }), f.$set(k);
    },
    i(y) {
      p || (transition_in(f.$$.fragment, y), p = !0);
    },
    o(y) {
      transition_out(f.$$.fragment, y), p = !1;
    },
    d(y) {
      y && detach(l), destroy_component(f);
    }
  };
}
function create_if_block_4$4(u) {
  let l, f;
  return l = new ProgressCircle({
    props: { overBackground: !0, size: "S" }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_3$7(u) {
  let l;
  return {
    c() {
      l = text$2(
        /*confirmText*/
        u[3]
      );
    },
    m(f, p) {
      insert(f, l, p);
    },
    p(f, p) {
      p & /*confirmText*/
      8 && set_data(
        l,
        /*confirmText*/
        f[3]
      );
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot$z(u) {
  let l, f, p, m = (
    /*loading*/
    u[14] && create_if_block_4$4()
  ), b = !/*loading*/
  u[14] && create_if_block_3$7(u);
  return {
    c() {
      m && m.c(), l = space(), b && b.c(), f = empty$1();
    },
    m(y, v) {
      m && m.m(y, v), insert(y, l, v), b && b.m(y, v), insert(y, f, v), p = !0;
    },
    p(y, v) {
      /*loading*/
      y[14] ? m ? v & /*loading*/
      16384 && transition_in(m, 1) : (m = create_if_block_4$4(), m.c(), transition_in(m, 1), m.m(l.parentNode, l)) : m && (group_outros(), transition_out(m, 1, 1, () => {
        m = null;
      }), check_outros()), /*loading*/
      y[14] ? b && (b.d(1), b = null) : b ? b.p(y, v) : (b = create_if_block_3$7(y), b.c(), b.m(f.parentNode, f));
    },
    i(y) {
      p || (transition_in(m), p = !0);
    },
    o(y) {
      transition_out(m), p = !1;
    },
    d(y) {
      y && (detach(l), detach(f)), m && m.d(y), b && b.d(y);
    }
  };
}
function create_if_block$A(u) {
  let l, f, p;
  return f = new Icon({ props: { hoverable: !0, name: "x" } }), f.$on(
    "click",
    /*click_handler*/
    u[25]
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "close-icon svelte-n0k36s");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p: noop$4,
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_fragment$17(u) {
  let l, f, p, m, b, y, v, k = (
    /*title*/
    (u[0] || /*$$slots*/
    u[19].header) && create_if_block_7$3(u)
  );
  const S = (
    /*#slots*/
    u[24].default
  ), $ = create_slot(
    S,
    u,
    /*$$scope*/
    u[26],
    get_default_slot_context
  );
  let w = (
    /*showCancelButton*/
    (u[4] || /*showConfirmButton*/
    u[5] || /*$$slots*/
    u[19].footer) && create_if_block_1$i(u)
  ), T = (
    /*showCloseIcon*/
    u[6] && create_if_block$A(u)
  );
  return {
    c() {
      l = element("div"), f = element("div"), k && k.c(), p = space(), m = element("section"), $ && $.c(), b = space(), w && w.c(), y = space(), T && T.c(), attr(m, "class", "spectrum-Dialog-content content-grid svelte-n0k36s"), attr(f, "class", "modal-core"), toggle_class(f, "spectrum-Dialog-grid", !/*custom*/
      u[12]), attr(l, "class", "spectrum-Dialog svelte-n0k36s"), set_style(l, "position", "relative"), attr(l, "role", "dialog"), attr(l, "tabindex", "-1"), attr(l, "aria-modal", "true"), toggle_class(
        l,
        "spectrum-Dialog--small",
        /*size*/
        u[1] === "S"
      ), toggle_class(
        l,
        "spectrum-Dialog--medium",
        /*size*/
        u[1] === "M"
      ), toggle_class(
        l,
        "spectrum-Dialog--large",
        /*size*/
        u[1] === "L"
      ), toggle_class(
        l,
        "spectrum-Dialog--extraLarge",
        /*size*/
        u[1] === "XL"
      ), toggle_class(
        l,
        "no-grid",
        /*custom*/
        u[12]
      );
    },
    m(E, R) {
      insert(E, l, R), append$1(l, f), k && k.m(f, null), append$1(f, p), append$1(f, m), $ && $.m(m, null), append$1(f, b), w && w.m(f, null), append$1(f, y), T && T.m(f, null), v = !0;
    },
    p(E, [R]) {
      /*title*/
      E[0] || /*$$slots*/
      E[19].header ? k ? (k.p(E, R), R & /*title, $$slots*/
      524289 && transition_in(k, 1)) : (k = create_if_block_7$3(E), k.c(), transition_in(k, 1), k.m(f, p)) : k && (group_outros(), transition_out(k, 1, 1, () => {
        k = null;
      }), check_outros()), $ && $.p && (!v || R & /*$$scope, loading*/
      67125248) && update_slot_base(
        $,
        S,
        E,
        /*$$scope*/
        E[26],
        v ? get_slot_changes(
          S,
          /*$$scope*/
          E[26],
          R,
          get_default_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          E[26]
        ),
        get_default_slot_context
      ), /*showCancelButton*/
      E[4] || /*showConfirmButton*/
      E[5] || /*$$slots*/
      E[19].footer ? w ? (w.p(E, R), R & /*showCancelButton, showConfirmButton, $$slots*/
      524336 && transition_in(w, 1)) : (w = create_if_block_1$i(E), w.c(), transition_in(w, 1), w.m(f, y)) : w && (group_outros(), transition_out(w, 1, 1, () => {
        w = null;
      }), check_outros()), /*showCloseIcon*/
      E[6] ? T ? (T.p(E, R), R & /*showCloseIcon*/
      64 && transition_in(T, 1)) : (T = create_if_block$A(E), T.c(), transition_in(T, 1), T.m(f, null)) : T && (group_outros(), transition_out(T, 1, 1, () => {
        T = null;
      }), check_outros()), (!v || R & /*custom*/
      4096) && toggle_class(f, "spectrum-Dialog-grid", !/*custom*/
      E[12]), (!v || R & /*size*/
      2) && toggle_class(
        l,
        "spectrum-Dialog--small",
        /*size*/
        E[1] === "S"
      ), (!v || R & /*size*/
      2) && toggle_class(
        l,
        "spectrum-Dialog--medium",
        /*size*/
        E[1] === "M"
      ), (!v || R & /*size*/
      2) && toggle_class(
        l,
        "spectrum-Dialog--large",
        /*size*/
        E[1] === "L"
      ), (!v || R & /*size*/
      2) && toggle_class(
        l,
        "spectrum-Dialog--extraLarge",
        /*size*/
        E[1] === "XL"
      ), (!v || R & /*custom*/
      4096) && toggle_class(
        l,
        "no-grid",
        /*custom*/
        E[12]
      );
    },
    i(E) {
      v || (transition_in(k), transition_in($, E), transition_in(w), transition_in(T), v = !0);
    },
    o(E) {
      transition_out(k), transition_out($, E), transition_out(w), transition_out(T), v = !1;
    },
    d(E) {
      E && detach(l), k && k.d(), $ && $.d(E), w && w.d(), T && T.d();
    }
  };
}
const keepOpen = Symbol("keepOpen");
function instance$15(u, l, f) {
  const p = [
    "title",
    "size",
    "cancelText",
    "confirmText",
    "showCancelButton",
    "showConfirmButton",
    "showCloseIcon",
    "onConfirm",
    "onCancel",
    "disabled",
    "showDivider",
    "showSecondaryButton",
    "secondaryButtonText",
    "secondaryAction",
    "secondaryButtonWarning",
    "custom",
    "confirm"
  ];
  let m = compute_rest_props(l, p), { $$slots: b = {}, $$scope: y } = l;
  const v = compute_slots(b);
  let { title: k = void 0 } = l, { size: S = "S" } = l, { cancelText: $ = "Cancel" } = l, { confirmText: w = "Confirm" } = l, { showCancelButton: T = !0 } = l, { showConfirmButton: E = !0 } = l, { showCloseIcon: R = !0 } = l, { onConfirm: O = void 0 } = l, { onCancel: P = void 0 } = l, { disabled: L = !1 } = l, { showDivider: M = !0 } = l, { showSecondaryButton: B = !1 } = l, { secondaryButtonText: j = void 0 } = l, { secondaryAction: x = void 0 } = l, { secondaryButtonWarning: N = !1 } = l, { custom: D = !1 } = l;
  const { hide: V, cancel: W } = getContext$1(Context$1.Modal);
  let F = !1, U;
  async function Y(H) {
    f(14, F = !0), (!x || await x(H) !== keepOpen) && V(), f(14, F = !1);
  }
  async function q() {
    f(14, F = !0), (!O || await O() !== keepOpen) && V(), f(14, F = !1);
  }
  async function Q() {
    f(14, F = !0), (!P || await P() !== keepOpen) && W(ModalCancelFrom.CANCEL_BUTTON), f(14, F = !1);
  }
  const z = () => W(ModalCancelFrom.CLOSE_BUTTON);
  return u.$$set = (H) => {
    l = assign(assign({}, l), exclude_internal_props(H)), f(20, m = compute_rest_props(l, p)), "title" in H && f(0, k = H.title), "size" in H && f(1, S = H.size), "cancelText" in H && f(2, $ = H.cancelText), "confirmText" in H && f(3, w = H.confirmText), "showCancelButton" in H && f(4, T = H.showCancelButton), "showConfirmButton" in H && f(5, E = H.showConfirmButton), "showCloseIcon" in H && f(6, R = H.showCloseIcon), "onConfirm" in H && f(21, O = H.onConfirm), "onCancel" in H && f(22, P = H.onCancel), "disabled" in H && f(23, L = H.disabled), "showDivider" in H && f(7, M = H.showDivider), "showSecondaryButton" in H && f(8, B = H.showSecondaryButton), "secondaryButtonText" in H && f(9, j = H.secondaryButtonText), "secondaryAction" in H && f(10, x = H.secondaryAction), "secondaryButtonWarning" in H && f(11, N = H.secondaryButtonWarning), "custom" in H && f(12, D = H.custom), "$$scope" in H && f(26, y = H.$$scope);
  }, u.$$.update = () => {
    u.$$.dirty & /*disabled, loading*/
    8404992 && f(15, U = L || F);
  }, [
    k,
    S,
    $,
    w,
    T,
    E,
    R,
    M,
    B,
    j,
    x,
    N,
    D,
    q,
    F,
    U,
    W,
    Y,
    Q,
    v,
    m,
    O,
    P,
    L,
    b,
    z,
    y
  ];
}
class ModalContent extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$15, create_fragment$17, safe_not_equal, {
      title: 0,
      size: 1,
      cancelText: 2,
      confirmText: 3,
      showCancelButton: 4,
      showConfirmButton: 5,
      showCloseIcon: 6,
      onConfirm: 21,
      onCancel: 22,
      disabled: 23,
      showDivider: 7,
      showSecondaryButton: 8,
      secondaryButtonText: 9,
      secondaryAction: 10,
      secondaryButtonWarning: 11,
      custom: 12,
      confirm: 13
    });
  }
  get confirm() {
    return this.$$.ctx[13];
  }
}
const Notification_svelte_svelte_type_style_lang = "";
function create_if_block_2$c(u) {
  let l, f, p;
  return f = new Icon({
    props: {
      name: (
        /*icon*/
        u[1]
      ),
      size: "L",
      color: "var(--spectrum-global-color-static-white)",
      weight: "bold"
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "toast-icon svelte-9ckj1m");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b & /*icon*/
      2 && (y.name = /*icon*/
      m[1]), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block_1$h(u) {
  let l, f;
  return l = new ActionButton({
    props: {
      quiet: !0,
      $$slots: { default: [create_default_slot$y] },
      $$scope: { ctx: u }
    }
  }), l.$on(
    "click",
    /*click_handler*/
    u[8]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, actionMessage*/
      1040 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot$y(u) {
  let l, f;
  return {
    c() {
      l = element("div"), f = text$2(
        /*actionMessage*/
        u[4]
      ), set_style(l, "color", "white"), set_style(l, "font-weight", "600");
    },
    m(p, m) {
      insert(p, l, m), append$1(l, f);
    },
    p(p, m) {
      m & /*actionMessage*/
      16 && set_data(
        f,
        /*actionMessage*/
        p[4]
      );
    },
    d(p) {
      p && detach(l);
    }
  };
}
function create_if_block$z(u) {
  let l, f, p, m, b, y, v;
  return m = new Icon({ props: { name: "x", size: "M" } }), {
    c() {
      l = element("div"), f = element("button"), p = element("div"), create_component(m.$$.fragment), attr(p, "class", "spectrum-ClearButton-fill"), attr(f, "class", "spectrum-ClearButton spectrum-ClearButton--overBackground spectrum-ClearButton--sizeM"), attr(l, "class", "spectrum-Toast-buttons");
    },
    m(k, S) {
      insert(k, l, S), append$1(l, f), append$1(f, p), mount_component(m, p, null), b = !0, y || (v = listen(
        f,
        "click",
        /*click_handler_1*/
        u[9]
      ), y = !0);
    },
    p: noop$4,
    i(k) {
      b || (transition_in(m.$$.fragment, k), b = !0);
    },
    o(k) {
      transition_out(m.$$.fragment, k), b = !1;
    },
    d(k) {
      k && detach(l), destroy_component(m), y = !1, v();
    }
  };
}
function create_fragment$16(u) {
  let l, f, p, m, b = (
    /*message*/
    (u[2] || "") + ""
  ), y, v, k, S, $, w = (
    /*icon*/
    u[1] && create_if_block_2$c(u)
  ), T = (
    /*action*/
    u[5] && create_if_block_1$h(u)
  ), E = (
    /*dismissable*/
    u[3] && create_if_block$z(u)
  );
  return {
    c() {
      l = element("div"), w && w.c(), f = space(), p = element("div"), m = element("div"), y = text$2(b), v = space(), T && T.c(), k = space(), E && E.c(), attr(m, "class", "wrap spectrum-Toast-content svelte-9ckj1m"), attr(p, "class", "spectrum-Toast-body svelte-9ckj1m"), toggle_class(p, "actionBody", !!/*action*/
      u[5]), attr(l, "class", S = "spectrum-Toast spectrum-Toast--" + /*type*/
      u[0] + " svelte-9ckj1m"), toggle_class(
        l,
        "wide",
        /*wide*/
        u[6]
      );
    },
    m(R, O) {
      insert(R, l, O), w && w.m(l, null), append$1(l, f), append$1(l, p), append$1(p, m), append$1(m, y), append$1(p, v), T && T.m(p, null), append$1(l, k), E && E.m(l, null), $ = !0;
    },
    p(R, [O]) {
      /*icon*/
      R[1] ? w ? (w.p(R, O), O & /*icon*/
      2 && transition_in(w, 1)) : (w = create_if_block_2$c(R), w.c(), transition_in(w, 1), w.m(l, f)) : w && (group_outros(), transition_out(w, 1, 1, () => {
        w = null;
      }), check_outros()), (!$ || O & /*message*/
      4) && b !== (b = /*message*/
      (R[2] || "") + "") && set_data(y, b), /*action*/
      R[5] ? T ? (T.p(R, O), O & /*action*/
      32 && transition_in(T, 1)) : (T = create_if_block_1$h(R), T.c(), transition_in(T, 1), T.m(p, null)) : T && (group_outros(), transition_out(T, 1, 1, () => {
        T = null;
      }), check_outros()), (!$ || O & /*action*/
      32) && toggle_class(p, "actionBody", !!/*action*/
      R[5]), /*dismissable*/
      R[3] ? E ? (E.p(R, O), O & /*dismissable*/
      8 && transition_in(E, 1)) : (E = create_if_block$z(R), E.c(), transition_in(E, 1), E.m(l, null)) : E && (group_outros(), transition_out(E, 1, 1, () => {
        E = null;
      }), check_outros()), (!$ || O & /*type*/
      1 && S !== (S = "spectrum-Toast spectrum-Toast--" + /*type*/
      R[0] + " svelte-9ckj1m")) && attr(l, "class", S), (!$ || O & /*type, wide*/
      65) && toggle_class(
        l,
        "wide",
        /*wide*/
        R[6]
      );
    },
    i(R) {
      $ || (transition_in(w), transition_in(T), transition_in(E), $ = !0);
    },
    o(R) {
      transition_out(w), transition_out(T), transition_out(E), $ = !1;
    },
    d(R) {
      R && detach(l), w && w.d(), T && T.d(), E && E.d();
    }
  };
}
function instance$14(u, l, f) {
  let { type: p = "info" } = l, { icon: m = "info" } = l, { message: b = "" } = l, { dismissable: y = !1 } = l, { actionMessage: v = null } = l, { action: k = null } = l, { wide: S = !1 } = l;
  const $ = createEventDispatcher(), w = () => k(() => $("dismiss")), T = () => $("dismiss");
  return u.$$set = (E) => {
    "type" in E && f(0, p = E.type), "icon" in E && f(1, m = E.icon), "message" in E && f(2, b = E.message), "dismissable" in E && f(3, y = E.dismissable), "actionMessage" in E && f(4, v = E.actionMessage), "action" in E && f(5, k = E.action), "wide" in E && f(6, S = E.wide);
  }, [
    p,
    m,
    b,
    y,
    v,
    k,
    S,
    $,
    w,
    T
  ];
}
class Notification extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$14, create_fragment$16, safe_not_equal, {
      type: 0,
      icon: 1,
      message: 2,
      dismissable: 3,
      actionMessage: 4,
      action: 5,
      wide: 6
    });
  }
}
const NotificationDisplay_svelte_svelte_type_style_lang$1 = "", indexVars$5 = "", Pagination_svelte_svelte_type_style_lang = "", PhosphorIconPicker_svelte_svelte_type_style_lang = "", indexVars$4 = "", ProgressBar_svelte_svelte_type_style_lang = "", Switcher_svelte_svelte_type_style_lang = "", indexVars$3 = "", StringRenderer_svelte_svelte_type_style_lang = "", BooleanRenderer_svelte_svelte_type_style_lang = "", DateTimeRenderer_svelte_svelte_type_style_lang = "", AttachmentRenderer_svelte_svelte_type_style_lang = "";
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(u) {
  return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
}
function createCommonjsModule(u) {
  var l = { exports: {} };
  return u(l, l.exports), l.exports;
}
var indexOf$1 = [].indexOf, indexof = function(u, l) {
  if (indexOf$1)
    return u.indexOf(l);
  for (var f = 0; f < u.length; ++f)
    if (u[f] === l)
      return f;
  return -1;
}, vmBrowserify = createCommonjsModule(function(module, exports) {
  var iFrame = null, Object_keys = function(u) {
    if (Object.keys)
      return Object.keys(u);
    var l = [];
    for (var f in u)
      l.push(f);
    return l;
  }, forEach = function(u, l) {
    if (u.forEach)
      return u.forEach(l);
    for (var f = 0; f < u.length; f++)
      l(u[f], f, u);
  }, defineProp = function() {
    try {
      return Object.defineProperty({}, "_", {}), function(u, l, f) {
        Object.defineProperty(u, l, { writable: !0, enumerable: !1, configurable: !0, value: f });
      };
    } catch {
      return function(l, f, p) {
        l[f] = p;
      };
    }
  }(), globals = ["Array", "Boolean", "Date", "Error", "EvalError", "Function", "Infinity", "JSON", "Math", "NaN", "Number", "Object", "RangeError", "ReferenceError", "RegExp", "String", "SyntaxError", "TypeError", "URIError", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "undefined", "unescape", "window", "document"];
  function Context() {
  }
  Context.prototype = {};
  var Script = exports.Script = function(u) {
    if (!(this instanceof Script))
      return new Script(u);
    iFrame || ((iFrame = document.createElement("iframe")).setAttribute("sandbox", "allow-scripts allow-same-origin"), iFrame.style || (iFrame.style = {}), iFrame.style.display = "none", document.body.appendChild(iFrame)), this.code = u, this.iFrame = iFrame;
  };
  Script.prototype.runInContext = function(u) {
    if (!(u instanceof Context))
      throw new TypeError("needs a 'context' argument.");
    var l = this.iFrame.contentWindow, f = Object_keys(l);
    let p = [];
    var m = l.eval, b = l.execScript;
    forEach(Object_keys(u), function(k) {
      if (l[k] !== void 0) {
        let S = { key: k, value: l[k] };
        p.push(S);
      }
      l[k] = u[k];
    }), !m && b && (b.call(l, "null"), m = l.eval);
    var y = Object_keys(l), v = m.call(l, this.code);
    return forEach(Object_keys(l), function(k) {
      (k in u || indexof(y, k) === -1) && (indexof(globals, k) === -1 ? u[k] = l[k] : defineProp(u, k, l[k])), indexof(f, k) === -1 && delete l[k];
    }), forEach(p, function(k) {
      l[k.key] = k.value;
    }), v;
  }, Script.prototype.runInThisContext = function() {
    return eval(this.code);
  }, Script.prototype.runInNewContext = function(u) {
    var l = Script.createContext(u), f = this.runInContext(l);
    return forEach(Object_keys(l), function(p) {
      u[p] = l[p];
    }), f;
  }, forEach(Object_keys(Script.prototype), function(u) {
    exports[u] = Script[u] = function(l) {
      var f = Script(l);
      return f[u].apply(f, [].slice.call(arguments, 1));
    };
  }), exports.createScript = function(u) {
    return exports.Script(u);
  }, exports.createContext = Script.createContext = function(u) {
    var l = new Context();
    return typeof u == "object" && forEach(Object_keys(u), function(f) {
      l[f] = u[f];
    }), l;
  };
}), global$1 = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {}, _defineProp;
function Object_keys(u) {
  if (Object.keys)
    return Object.keys(u);
  var l = [];
  for (var f in u)
    l.push(f);
  return l;
}
function forEach(u, l) {
  if (u.forEach)
    return u.forEach(l);
  for (var f = 0; f < u.length; f++)
    l(u[f], f, u);
}
function defineProp(u, l, f) {
  typeof _defineProp != "function" && (_defineProp = createDefineProp), _defineProp(u, l, f);
}
function createDefineProp() {
  try {
    return Object.defineProperty({}, "_", {}), function(u, l, f) {
      Object.defineProperty(u, l, { writable: !0, enumerable: !1, configurable: !0, value: f });
    };
  } catch {
    return function(l, f, p) {
      l[f] = p;
    };
  }
}
var globals = ["Array", "Boolean", "Date", "Error", "EvalError", "Function", "Infinity", "JSON", "Math", "NaN", "Number", "Object", "RangeError", "ReferenceError", "RegExp", "String", "SyntaxError", "TypeError", "URIError", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "undefined", "unescape"];
function Context() {
}
function Script(u) {
  if (!(this instanceof Script))
    return new Script(u);
  this.code = u;
}
function otherRunInContext(u, l) {
  var f = Object_keys(global$1);
  return f.push("with (this.__ctx__){return eval(this.__code__)}"), Function.apply(null, f).apply({ __code__: u, __ctx__: l });
}
function createScript(u) {
  return new Script(u);
}
function createContext(u) {
  if (isContext(u))
    return u;
  var l = new Context();
  return typeof u == "object" && forEach(Object_keys(u), function(f) {
    l[f] = u[f];
  }), l;
}
function runInContext(u, l, f) {
  return new Script(u).runInContext(l, f);
}
function runInThisContext(u, l) {
  return new Script(u).runInThisContext(l);
}
function isContext(u) {
  return u instanceof Context;
}
function runInNewContext(u, l, f) {
  return new Script(u).runInNewContext(l, f);
}
Context.prototype = {}, Script.prototype.runInContext = function(u) {
  if (!(u instanceof Context))
    throw new TypeError("needs a 'context' argument.");
  if (global$1.document) {
    var l = global$1.document.createElement("iframe");
    l.style || (l.style = {}), l.style.display = "none", global$1.document.body.appendChild(l);
    var f = l.contentWindow, p = f.eval, m = f.execScript;
    !p && m && (m.call(f, "null"), p = f.eval), forEach(Object_keys(u), function(v) {
      f[v] = u[v];
    }), forEach(globals, function(v) {
      u[v] && (f[v] = u[v]);
    });
    var b = Object_keys(f), y = p.call(f, this.code);
    return forEach(Object_keys(f), function(v) {
      (v in u || indexOf(b, v) === -1) && (u[v] = f[v]);
    }), forEach(globals, function(v) {
      v in u || defineProp(u, v, f[v]);
    }), global$1.document.body.removeChild(l), y;
  }
  return otherRunInContext(this.code, u);
}, Script.prototype.runInThisContext = function() {
  return new Function("code", "return eval(code);").call(global$1, this.code);
}, Script.prototype.runInNewContext = function(u) {
  var l = createContext(u), f = this.runInContext(l);
  return u && forEach(Object_keys(l), function(p) {
    u[p] = l[p];
  }), f;
};
var vm = { runInContext, isContext, createContext, createScript, Script, runInThisContext, runInNewContext }, _indexOf = [].indexOf;
function indexOf(u, l) {
  if (_indexOf)
    return u.indexOf(l);
  for (var f = 0; f < u.length; ++f)
    if (u[f] === l)
      return f;
  return -1;
}
var utils$3 = createCommonjsModule(function(u, l) {
  l.__esModule = !0, l.extend = y, l.indexOf = function($, w) {
    for (var T = 0, E = $.length; T < E; T++)
      if ($[T] === w)
        return T;
    return -1;
  }, l.escapeExpression = function($) {
    if (typeof $ != "string") {
      if ($ && $.toHTML)
        return $.toHTML();
      if ($ == null)
        return "";
      if (!$)
        return $ + "";
      $ = "" + $;
    }
    return m.test($) ? $.replace(p, b) : $;
  }, l.isEmpty = function($) {
    return !$ && $ !== 0 || !(!S($) || $.length !== 0);
  }, l.createFrame = function($) {
    var w = y({}, $);
    return w._parent = $, w;
  }, l.blockParams = function($, w) {
    return $.path = w, $;
  }, l.appendContextPath = function($, w) {
    return ($ ? $ + "." : "") + w;
  };
  var f = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;", "=": "&#x3D;" }, p = /[&<>"'`=]/g, m = /[&<>"'`=]/;
  function b($) {
    return f[$];
  }
  function y($) {
    for (var w = 1; w < arguments.length; w++)
      for (var T in arguments[w])
        Object.prototype.hasOwnProperty.call(arguments[w], T) && ($[T] = arguments[w][T]);
    return $;
  }
  var v = Object.prototype.toString;
  l.toString = v;
  var k = function($) {
    return typeof $ == "function";
  };
  k(/x/) && (l.isFunction = k = function($) {
    return typeof $ == "function" && v.call($) === "[object Function]";
  }), l.isFunction = k;
  var S = Array.isArray || function($) {
    return !(!$ || typeof $ != "object") && v.call($) === "[object Array]";
  };
  l.isArray = S;
}), exception = createCommonjsModule(function(u, l) {
  l.__esModule = !0;
  var f = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
  function p(m, b) {
    var y = b && b.loc, v = void 0, k = void 0, S = void 0, $ = void 0;
    y && (v = y.start.line, k = y.end.line, S = y.start.column, $ = y.end.column, m += " - " + v + ":" + S);
    for (var w = Error.prototype.constructor.call(this, m), T = 0; T < f.length; T++)
      this[f[T]] = w[f[T]];
    Error.captureStackTrace && Error.captureStackTrace(this, p);
    try {
      y && (this.lineNumber = v, this.endLineNumber = k, Object.defineProperty ? (Object.defineProperty(this, "column", { value: S, enumerable: !0 }), Object.defineProperty(this, "endColumn", { value: $, enumerable: !0 })) : (this.column = S, this.endColumn = $));
    } catch {
    }
  }
  p.prototype = new Error(), l.default = p, u.exports = l.default;
}), blockHelperMissing = createCommonjsModule(function(u, l) {
  l.__esModule = !0, l.default = function(f) {
    f.registerHelper("blockHelperMissing", function(p, m) {
      var b = m.inverse, y = m.fn;
      if (p === !0)
        return y(this);
      if (p === !1 || p == null)
        return b(this);
      if (utils$3.isArray(p))
        return p.length > 0 ? (m.ids && (m.ids = [m.name]), f.helpers.each(p, m)) : b(this);
      if (m.data && m.ids) {
        var v = utils$3.createFrame(m.data);
        v.contextPath = utils$3.appendContextPath(m.data.contextPath, m.name), m = { data: v };
      }
      return y(p, m);
    });
  }, u.exports = l.default;
}), each = createCommonjsModule(function(u, l) {
  l.__esModule = !0;
  var f, p = (f = exception) && f.__esModule ? f : { default: f };
  l.default = function(m) {
    m.registerHelper("each", function(b, y) {
      if (!y)
        throw new p.default("Must pass iterator to #each");
      var v, k = y.fn, S = y.inverse, $ = 0, w = "", T = void 0, E = void 0;
      function R(B, j, x) {
        T && (T.key = B, T.index = j, T.first = j === 0, T.last = !!x, E && (T.contextPath = E + B)), w += k(b[B], { data: T, blockParams: utils$3.blockParams([b[B], B], [E + B, null]) });
      }
      if (y.data && y.ids && (E = utils$3.appendContextPath(y.data.contextPath, y.ids[0]) + "."), utils$3.isFunction(b) && (b = b.call(this)), y.data && (T = utils$3.createFrame(y.data)), b && typeof b == "object")
        if (utils$3.isArray(b))
          for (var O = b.length; $ < O; $++)
            $ in b && R($, $, $ === b.length - 1);
        else if (typeof Symbol == "function" && b[Symbol.iterator]) {
          for (var P = [], L = b[Symbol.iterator](), M = L.next(); !M.done; M = L.next())
            P.push(M.value);
          for (O = (b = P).length; $ < O; $++)
            R($, $, $ === b.length - 1);
        } else
          v = void 0, Object.keys(b).forEach(function(B) {
            v !== void 0 && R(v, $ - 1), v = B, $++;
          }), v !== void 0 && R(v, $ - 1, !0);
      return $ === 0 && (w = S(this)), w;
    });
  }, u.exports = l.default;
}), helperMissing = createCommonjsModule(function(u, l) {
  l.__esModule = !0;
  var f, p = (f = exception) && f.__esModule ? f : { default: f };
  l.default = function(m) {
    m.registerHelper("helperMissing", function() {
      if (arguments.length !== 1)
        throw new p.default('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    });
  }, u.exports = l.default;
}), _if = createCommonjsModule(function(u, l) {
  l.__esModule = !0;
  var f, p = (f = exception) && f.__esModule ? f : { default: f };
  l.default = function(m) {
    m.registerHelper("if", function(b, y) {
      if (arguments.length != 2)
        throw new p.default("#if requires exactly one argument");
      return utils$3.isFunction(b) && (b = b.call(this)), !y.hash.includeZero && !b || utils$3.isEmpty(b) ? y.inverse(this) : y.fn(this);
    }), m.registerHelper("unless", function(b, y) {
      if (arguments.length != 2)
        throw new p.default("#unless requires exactly one argument");
      return m.helpers.if.call(this, b, { fn: y.inverse, inverse: y.fn, hash: y.hash });
    });
  }, u.exports = l.default;
}), log$2 = createCommonjsModule(function(u, l) {
  l.__esModule = !0, l.default = function(f) {
    f.registerHelper("log", function() {
      for (var p = [void 0], m = arguments[arguments.length - 1], b = 0; b < arguments.length - 1; b++)
        p.push(arguments[b]);
      var y = 1;
      m.hash.level != null ? y = m.hash.level : m.data && m.data.level != null && (y = m.data.level), p[0] = y, f.log.apply(f, p);
    });
  }, u.exports = l.default;
}), lookup$1$1 = createCommonjsModule(function(u, l) {
  l.__esModule = !0, l.default = function(f) {
    f.registerHelper("lookup", function(p, m, b) {
      return p && b.lookupProperty(p, m);
    });
  }, u.exports = l.default;
}), _with = createCommonjsModule(function(u, l) {
  l.__esModule = !0;
  var f, p = (f = exception) && f.__esModule ? f : { default: f };
  l.default = function(m) {
    m.registerHelper("with", function(b, y) {
      if (arguments.length != 2)
        throw new p.default("#with requires exactly one argument");
      utils$3.isFunction(b) && (b = b.call(this));
      var v = y.fn;
      if (utils$3.isEmpty(b))
        return y.inverse(this);
      var k = y.data;
      return y.data && y.ids && ((k = utils$3.createFrame(y.data)).contextPath = utils$3.appendContextPath(y.data.contextPath, y.ids[0])), v(b, { data: k, blockParams: utils$3.blockParams([b], [k && k.contextPath]) });
    });
  }, u.exports = l.default;
}), registerDefaultHelpers_1 = registerDefaultHelpers, moveHelperToHooks_1 = moveHelperToHooks;
function _interopRequireDefault$7(u) {
  return u && u.__esModule ? u : { default: u };
}
var _helpersBlockHelperMissing2 = _interopRequireDefault$7(blockHelperMissing), _helpersEach2 = _interopRequireDefault$7(each), _helpersHelperMissing2 = _interopRequireDefault$7(helperMissing), _helpersIf2 = _interopRequireDefault$7(_if), _helpersLog2 = _interopRequireDefault$7(log$2), _helpersLookup2 = _interopRequireDefault$7(lookup$1$1), _helpersWith2 = _interopRequireDefault$7(_with);
function registerDefaultHelpers(u) {
  _helpersBlockHelperMissing2.default(u), _helpersEach2.default(u), _helpersHelperMissing2.default(u), _helpersIf2.default(u), _helpersLog2.default(u), _helpersLookup2.default(u), _helpersWith2.default(u);
}
function moveHelperToHooks(u, l, f) {
  u.helpers[l] && (u.hooks[l] = u.helpers[l], f || delete u.helpers[l]);
}
var helpers$2 = Object.defineProperty({ registerDefaultHelpers: registerDefaultHelpers_1, moveHelperToHooks: moveHelperToHooks_1 }, "__esModule", { value: !0 }), inline = createCommonjsModule(function(u, l) {
  l.__esModule = !0, l.default = function(f) {
    f.registerDecorator("inline", function(p, m, b, y) {
      var v = p;
      return m.partials || (m.partials = {}, v = function(k, S) {
        var $ = b.partials;
        b.partials = utils$3.extend({}, $, m.partials);
        var w = p(k, S);
        return b.partials = $, w;
      }), m.partials[y.args[0]] = y.fn, v;
    });
  }, u.exports = l.default;
}), registerDefaultDecorators_1 = registerDefaultDecorators;
function _interopRequireDefault$6(u) {
  return u && u.__esModule ? u : { default: u };
}
var _decoratorsInline2 = _interopRequireDefault$6(inline);
function registerDefaultDecorators(u) {
  _decoratorsInline2.default(u);
}
var decorators = Object.defineProperty({ registerDefaultDecorators: registerDefaultDecorators_1 }, "__esModule", { value: !0 }), logger_1 = createCommonjsModule(function(u, l) {
  l.__esModule = !0;
  var f = { methodMap: ["debug", "info", "warn", "error"], level: "info", lookupLevel: function(p) {
    if (typeof p == "string") {
      var m = utils$3.indexOf(f.methodMap, p.toLowerCase());
      p = m >= 0 ? m : parseInt(p, 10);
    }
    return p;
  }, log: function(p) {
    if (p = f.lookupLevel(p), typeof console < "u" && f.lookupLevel(f.level) <= p) {
      var m = f.methodMap[p];
      console[m] || (m = "log");
      for (var b = arguments.length, y = Array(b > 1 ? b - 1 : 0), v = 1; v < b; v++)
        y[v - 1] = arguments[v];
      console[m].apply(console, y);
    }
  } };
  l.default = f, u.exports = l.default;
}), createNewLookupObject_2 = createNewLookupObject;
function createNewLookupObject() {
  for (var u = arguments.length, l = Array(u), f = 0; f < u; f++)
    l[f] = arguments[f];
  return utils$3.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(l));
}
var createNewLookupObject_1 = Object.defineProperty({ createNewLookupObject: createNewLookupObject_2 }, "__esModule", { value: !0 }), createProtoAccessControl_1 = createProtoAccessControl, resultIsAllowed_1 = resultIsAllowed, resetLoggedProperties_1 = resetLoggedProperties;
function _interopRequireDefault$5(u) {
  return u && u.__esModule ? u : { default: u };
}
var _logger2$1 = _interopRequireDefault$5(logger_1), loggedProperties = /* @__PURE__ */ Object.create(null);
function createProtoAccessControl(u) {
  var l = /* @__PURE__ */ Object.create(null);
  l.constructor = !1, l.__defineGetter__ = !1, l.__defineSetter__ = !1, l.__lookupGetter__ = !1;
  var f = /* @__PURE__ */ Object.create(null);
  return f.__proto__ = !1, { properties: { whitelist: createNewLookupObject_1.createNewLookupObject(f, u.allowedProtoProperties), defaultValue: u.allowProtoPropertiesByDefault }, methods: { whitelist: createNewLookupObject_1.createNewLookupObject(l, u.allowedProtoMethods), defaultValue: u.allowProtoMethodsByDefault } };
}
function resultIsAllowed(u, l, f) {
  return checkWhiteList(typeof u == "function" ? l.methods : l.properties, f);
}
function checkWhiteList(u, l) {
  return u.whitelist[l] !== void 0 ? u.whitelist[l] === !0 : u.defaultValue !== void 0 ? u.defaultValue : (logUnexpecedPropertyAccessOnce(l), !1);
}
function logUnexpecedPropertyAccessOnce(u) {
  loggedProperties[u] !== !0 && (loggedProperties[u] = !0, _logger2$1.default.log("error", 'Handlebars: Access has been denied to resolve the property "' + u + `" because it is not an "own property" of its parent.
You can add a runtime option to disable the check or this warning:
See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details`));
}
function resetLoggedProperties() {
  Object.keys(loggedProperties).forEach(function(u) {
    delete loggedProperties[u];
  });
}
var protoAccess = Object.defineProperty({ createProtoAccessControl: createProtoAccessControl_1, resultIsAllowed: resultIsAllowed_1, resetLoggedProperties: resetLoggedProperties_1 }, "__esModule", { value: !0 }), HandlebarsEnvironment_1 = HandlebarsEnvironment;
function _interopRequireDefault$4(u) {
  return u && u.__esModule ? u : { default: u };
}
var _exception2$3 = _interopRequireDefault$4(exception), _logger2 = _interopRequireDefault$4(logger_1), VERSION = "4.7.8", VERSION_1 = VERSION, COMPILER_REVISION = 8, COMPILER_REVISION_1 = COMPILER_REVISION, LAST_COMPATIBLE_COMPILER_REVISION = 7, LAST_COMPATIBLE_COMPILER_REVISION_1 = LAST_COMPATIBLE_COMPILER_REVISION, REVISION_CHANGES = { 1: "<= 1.0.rc.2", 2: "== 1.0.0-rc.3", 3: "== 1.0.0-rc.4", 4: "== 1.x.x", 5: "== 2.0.0-alpha.x", 6: ">= 2.0.0-beta.1", 7: ">= 4.0.0 <4.3.0", 8: ">= 4.3.0" }, REVISION_CHANGES_1 = REVISION_CHANGES, objectType = "[object Object]";
function HandlebarsEnvironment(u, l, f) {
  this.helpers = u || {}, this.partials = l || {}, this.decorators = f || {}, helpers$2.registerDefaultHelpers(this), decorators.registerDefaultDecorators(this);
}
HandlebarsEnvironment.prototype = { constructor: HandlebarsEnvironment, logger: _logger2.default, log: _logger2.default.log, registerHelper: function(u, l) {
  if (utils$3.toString.call(u) === objectType) {
    if (l)
      throw new _exception2$3.default("Arg not supported with multiple helpers");
    utils$3.extend(this.helpers, u);
  } else
    this.helpers[u] = l;
}, unregisterHelper: function(u) {
  delete this.helpers[u];
}, registerPartial: function(u, l) {
  if (utils$3.toString.call(u) === objectType)
    utils$3.extend(this.partials, u);
  else {
    if (l === void 0)
      throw new _exception2$3.default('Attempting to register a partial called "' + u + '" as undefined');
    this.partials[u] = l;
  }
}, unregisterPartial: function(u) {
  delete this.partials[u];
}, registerDecorator: function(u, l) {
  if (utils$3.toString.call(u) === objectType) {
    if (l)
      throw new _exception2$3.default("Arg not supported with multiple decorators");
    utils$3.extend(this.decorators, u);
  } else
    this.decorators[u] = l;
}, unregisterDecorator: function(u) {
  delete this.decorators[u];
}, resetLoggedPropertyAccesses: function() {
  protoAccess.resetLoggedProperties();
} };
var log$1 = _logger2.default.log, log_1 = log$1, createFrame$1 = utils$3.createFrame, logger = _logger2.default, base$2 = Object.defineProperty({ HandlebarsEnvironment: HandlebarsEnvironment_1, VERSION: VERSION_1, COMPILER_REVISION: COMPILER_REVISION_1, LAST_COMPATIBLE_COMPILER_REVISION: LAST_COMPATIBLE_COMPILER_REVISION_1, REVISION_CHANGES: REVISION_CHANGES_1, log: log_1, createFrame: createFrame$1, logger }, "__esModule", { value: !0 }), safeString = createCommonjsModule(function(u, l) {
  function f(p) {
    this.string = p;
  }
  l.__esModule = !0, f.prototype.toString = f.prototype.toHTML = function() {
    return "" + this.string;
  }, l.default = f, u.exports = l.default;
}), wrapHelper_2 = wrapHelper;
function wrapHelper(u, l) {
  return typeof u != "function" ? u : function() {
    return arguments[arguments.length - 1] = l(arguments[arguments.length - 1]), u.apply(this, arguments);
  };
}
var wrapHelper_1 = Object.defineProperty({ wrapHelper: wrapHelper_2 }, "__esModule", { value: !0 }), checkRevision_1 = checkRevision, template_1 = template, wrapProgram_1 = wrapProgram, resolvePartial_1 = resolvePartial, invokePartial_1 = invokePartial, noop_1$1 = noop$2;
function _interopRequireDefault$3(u) {
  return u && u.__esModule ? u : { default: u };
}
function _interopRequireWildcard$1(u) {
  if (u && u.__esModule)
    return u;
  var l = {};
  if (u != null)
    for (var f in u)
      Object.prototype.hasOwnProperty.call(u, f) && (l[f] = u[f]);
  return l.default = u, l;
}
var Utils = _interopRequireWildcard$1(utils$3), _exception2$2 = _interopRequireDefault$3(exception);
function checkRevision(u) {
  var l = u && u[0] || 1, f = base$2.COMPILER_REVISION;
  if (!(l >= base$2.LAST_COMPATIBLE_COMPILER_REVISION && l <= base$2.COMPILER_REVISION)) {
    if (l < base$2.LAST_COMPATIBLE_COMPILER_REVISION) {
      var p = base$2.REVISION_CHANGES[f], m = base$2.REVISION_CHANGES[l];
      throw new _exception2$2.default("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + p + ") or downgrade your runtime to an older version (" + m + ").");
    }
    throw new _exception2$2.default("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + u[1] + ").");
  }
}
function template(u, l) {
  if (!l)
    throw new _exception2$2.default("No environment passed to template");
  if (!u || !u.main)
    throw new _exception2$2.default("Unknown template object: " + typeof u);
  u.main.decorator = u.main_d, l.VM.checkRevision(u.compiler);
  var f = u.compiler && u.compiler[0] === 7, p = { strict: function(b, y, v) {
    if (!b || !(y in b))
      throw new _exception2$2.default('"' + y + '" not defined in ' + b, { loc: v });
    return p.lookupProperty(b, y);
  }, lookupProperty: function(b, y) {
    var v = b[y];
    return v == null || Object.prototype.hasOwnProperty.call(b, y) || protoAccess.resultIsAllowed(v, p.protoAccessControl, y) ? v : void 0;
  }, lookup: function(b, y) {
    for (var v = b.length, k = 0; k < v; k++)
      if ((b[k] && p.lookupProperty(b[k], y)) != null)
        return b[k][y];
  }, lambda: function(b, y) {
    return typeof b == "function" ? b.call(y) : b;
  }, escapeExpression: Utils.escapeExpression, invokePartial: function(b, y, v) {
    v.hash && (y = Utils.extend({}, y, v.hash), v.ids && (v.ids[0] = !0)), b = l.VM.resolvePartial.call(this, b, y, v);
    var k = Utils.extend({}, v, { hooks: this.hooks, protoAccessControl: this.protoAccessControl }), S = l.VM.invokePartial.call(this, b, y, k);
    if (S == null && l.compile && (v.partials[v.name] = l.compile(b, u.compilerOptions, l), S = v.partials[v.name](y, k)), S != null) {
      if (v.indent) {
        for (var $ = S.split(`
`), w = 0, T = $.length; w < T && ($[w] || w + 1 !== T); w++)
          $[w] = v.indent + $[w];
        S = $.join(`
`);
      }
      return S;
    }
    throw new _exception2$2.default("The partial " + v.name + " could not be compiled when running in runtime-only mode");
  }, fn: function(b) {
    var y = u[b];
    return y.decorator = u[b + "_d"], y;
  }, programs: [], program: function(b, y, v, k, S) {
    var $ = this.programs[b], w = this.fn(b);
    return y || S || k || v ? $ = wrapProgram(this, b, w, y, v, k, S) : $ || ($ = this.programs[b] = wrapProgram(this, b, w)), $;
  }, data: function(b, y) {
    for (; b && y--; )
      b = b._parent;
    return b;
  }, mergeIfNeeded: function(b, y) {
    var v = b || y;
    return b && y && b !== y && (v = Utils.extend({}, y, b)), v;
  }, nullContext: Object.seal({}), noop: l.VM.noop, compilerInfo: u.compiler };
  function m(b) {
    var y = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1], v = y.data;
    m._setup(y), !y.partial && u.useData && (v = initData(b, v));
    var k = void 0, S = u.useBlockParams ? [] : void 0;
    function $(w) {
      return "" + u.main(p, w, p.helpers, p.partials, v, S, k);
    }
    return u.useDepths && (k = y.depths ? b != y.depths[0] ? [b].concat(y.depths) : y.depths : [b]), ($ = executeDecorators(u.main, $, p, y.depths || [], v, S))(b, y);
  }
  return m.isTop = !0, m._setup = function(b) {
    if (b.partial)
      p.protoAccessControl = b.protoAccessControl, p.helpers = b.helpers, p.partials = b.partials, p.decorators = b.decorators, p.hooks = b.hooks;
    else {
      var y = Utils.extend({}, l.helpers, b.helpers);
      wrapHelpersToPassLookupProperty(y, p), p.helpers = y, u.usePartial && (p.partials = p.mergeIfNeeded(b.partials, l.partials)), (u.usePartial || u.useDecorators) && (p.decorators = Utils.extend({}, l.decorators, b.decorators)), p.hooks = {}, p.protoAccessControl = protoAccess.createProtoAccessControl(b);
      var v = b.allowCallsToHelperMissing || f;
      helpers$2.moveHelperToHooks(p, "helperMissing", v), helpers$2.moveHelperToHooks(p, "blockHelperMissing", v);
    }
  }, m._child = function(b, y, v, k) {
    if (u.useBlockParams && !v)
      throw new _exception2$2.default("must pass block params");
    if (u.useDepths && !k)
      throw new _exception2$2.default("must pass parent depths");
    return wrapProgram(p, b, u[b], y, 0, v, k);
  }, m;
}
function wrapProgram(u, l, f, p, m, b, y) {
  function v(k) {
    var S = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1], $ = y;
    return !y || k == y[0] || k === u.nullContext && y[0] === null || ($ = [k].concat(y)), f(u, k, u.helpers, u.partials, S.data || p, b && [S.blockParams].concat(b), $);
  }
  return (v = executeDecorators(f, v, u, y, p, b)).program = l, v.depth = y ? y.length : 0, v.blockParams = m || 0, v;
}
function resolvePartial(u, l, f) {
  return u ? u.call || f.name || (f.name = u, u = f.partials[u]) : u = f.name === "@partial-block" ? f.data["partial-block"] : f.partials[f.name], u;
}
function invokePartial(u, l, f) {
  var p = f.data && f.data["partial-block"];
  f.partial = !0, f.ids && (f.data.contextPath = f.ids[0] || f.data.contextPath);
  var m = void 0;
  if (f.fn && f.fn !== noop$2 && function() {
    f.data = base$2.createFrame(f.data);
    var b = f.fn;
    m = f.data["partial-block"] = function(y) {
      var v = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
      return v.data = base$2.createFrame(v.data), v.data["partial-block"] = p, b(y, v);
    }, b.partials && (f.partials = Utils.extend({}, f.partials, b.partials));
  }(), u === void 0 && m && (u = m), u === void 0)
    throw new _exception2$2.default("The partial " + f.name + " could not be found");
  if (u instanceof Function)
    return u(l, f);
}
function noop$2() {
  return "";
}
function initData(u, l) {
  return l && "root" in l || ((l = l ? base$2.createFrame(l) : {}).root = u), l;
}
function executeDecorators(u, l, f, p, m, b) {
  if (u.decorator) {
    var y = {};
    l = u.decorator(l, y, f, p && p[0], m, b, p), Utils.extend(l, y);
  }
  return l;
}
function wrapHelpersToPassLookupProperty(u, l) {
  Object.keys(u).forEach(function(f) {
    var p = u[f];
    u[f] = passLookupPropertyOption(p, l);
  });
}
function passLookupPropertyOption(u, l) {
  var f = l.lookupProperty;
  return wrapHelper_1.wrapHelper(u, function(p) {
    return Utils.extend({ lookupProperty: f }, p);
  });
}
var runtime = Object.defineProperty({ checkRevision: checkRevision_1, template: template_1, wrapProgram: wrapProgram_1, resolvePartial: resolvePartial_1, invokePartial: invokePartial_1, noop: noop_1$1 }, "__esModule", { value: !0 }), noConflict = createCommonjsModule(function(u, l) {
  l.__esModule = !0, l.default = function(f) {
    typeof globalThis != "object" && (Object.prototype.__defineGetter__("__magic__", function() {
      return this;
    }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__);
    var p = globalThis.Handlebars;
    f.noConflict = function() {
      return globalThis.Handlebars === f && (globalThis.Handlebars = p), f;
    };
  }, u.exports = l.default;
}), handlebars_runtime = createCommonjsModule(function(u, l) {
  function f(T) {
    return T && T.__esModule ? T : { default: T };
  }
  function p(T) {
    if (T && T.__esModule)
      return T;
    var E = {};
    if (T != null)
      for (var R in T)
        Object.prototype.hasOwnProperty.call(T, R) && (E[R] = T[R]);
    return E.default = T, E;
  }
  l.__esModule = !0;
  var m = p(base$2), b = f(safeString), y = f(exception), v = p(utils$3), k = p(runtime), S = f(noConflict);
  function $() {
    var T = new m.HandlebarsEnvironment();
    return v.extend(T, m), T.SafeString = b.default, T.Exception = y.default, T.Utils = v, T.escapeExpression = v.escapeExpression, T.VM = k, T.template = function(E) {
      return k.template(E, T);
    }, T;
  }
  var w = $();
  w.create = $, S.default(w), w.default = w, l.default = w, u.exports = l.default;
}), ast = createCommonjsModule(function(u, l) {
  l.__esModule = !0;
  var f = { helpers: { helperExpression: function(p) {
    return p.type === "SubExpression" || (p.type === "MustacheStatement" || p.type === "BlockStatement") && !!(p.params && p.params.length || p.hash);
  }, scopedId: function(p) {
    return /^\.|this\b/.test(p.original);
  }, simpleId: function(p) {
    return p.parts.length === 1 && !f.helpers.scopedId(p) && !p.depth;
  } } };
  l.default = f, u.exports = l.default;
}), parser$1 = createCommonjsModule(function(u, l) {
  l.__esModule = !0;
  var f = function() {
    var p = { trace: function() {
    }, yy: {}, symbols_: { error: 2, root: 3, program: 4, EOF: 5, program_repetition0: 6, statement: 7, mustache: 8, block: 9, rawBlock: 10, partial: 11, partialBlock: 12, content: 13, COMMENT: 14, CONTENT: 15, openRawBlock: 16, rawBlock_repetition0: 17, END_RAW_BLOCK: 18, OPEN_RAW_BLOCK: 19, helperName: 20, openRawBlock_repetition0: 21, openRawBlock_option0: 22, CLOSE_RAW_BLOCK: 23, openBlock: 24, block_option0: 25, closeBlock: 26, openInverse: 27, block_option1: 28, OPEN_BLOCK: 29, openBlock_repetition0: 30, openBlock_option0: 31, openBlock_option1: 32, CLOSE: 33, OPEN_INVERSE: 34, openInverse_repetition0: 35, openInverse_option0: 36, openInverse_option1: 37, openInverseChain: 38, OPEN_INVERSE_CHAIN: 39, openInverseChain_repetition0: 40, openInverseChain_option0: 41, openInverseChain_option1: 42, inverseAndProgram: 43, INVERSE: 44, inverseChain: 45, inverseChain_option0: 46, OPEN_ENDBLOCK: 47, OPEN: 48, mustache_repetition0: 49, mustache_option0: 50, OPEN_UNESCAPED: 51, mustache_repetition1: 52, mustache_option1: 53, CLOSE_UNESCAPED: 54, OPEN_PARTIAL: 55, partialName: 56, partial_repetition0: 57, partial_option0: 58, openPartialBlock: 59, OPEN_PARTIAL_BLOCK: 60, openPartialBlock_repetition0: 61, openPartialBlock_option0: 62, param: 63, sexpr: 64, OPEN_SEXPR: 65, sexpr_repetition0: 66, sexpr_option0: 67, CLOSE_SEXPR: 68, hash: 69, hash_repetition_plus0: 70, hashSegment: 71, ID: 72, EQUALS: 73, blockParams: 74, OPEN_BLOCK_PARAMS: 75, blockParams_repetition_plus0: 76, CLOSE_BLOCK_PARAMS: 77, path: 78, dataName: 79, STRING: 80, NUMBER: 81, BOOLEAN: 82, UNDEFINED: 83, NULL: 84, DATA: 85, pathSegments: 86, SEP: 87, $accept: 0, $end: 1 }, terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" }, productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]], performAction: function(y, v, k, S, $, w, T) {
      var E = w.length - 1;
      switch ($) {
        case 1:
          return w[E - 1];
        case 2:
          this.$ = S.prepareProgram(w[E]);
          break;
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 20:
        case 27:
        case 28:
        case 33:
        case 34:
        case 40:
        case 41:
          this.$ = w[E];
          break;
        case 9:
          this.$ = { type: "CommentStatement", value: S.stripComment(w[E]), strip: S.stripFlags(w[E], w[E]), loc: S.locInfo(this._$) };
          break;
        case 10:
          this.$ = { type: "ContentStatement", original: w[E], value: w[E], loc: S.locInfo(this._$) };
          break;
        case 11:
          this.$ = S.prepareRawBlock(w[E - 2], w[E - 1], w[E], this._$);
          break;
        case 12:
          this.$ = { path: w[E - 3], params: w[E - 2], hash: w[E - 1] };
          break;
        case 13:
          this.$ = S.prepareBlock(w[E - 3], w[E - 2], w[E - 1], w[E], !1, this._$);
          break;
        case 14:
          this.$ = S.prepareBlock(w[E - 3], w[E - 2], w[E - 1], w[E], !0, this._$);
          break;
        case 15:
          this.$ = { open: w[E - 5], path: w[E - 4], params: w[E - 3], hash: w[E - 2], blockParams: w[E - 1], strip: S.stripFlags(w[E - 5], w[E]) };
          break;
        case 16:
        case 17:
          this.$ = { path: w[E - 4], params: w[E - 3], hash: w[E - 2], blockParams: w[E - 1], strip: S.stripFlags(w[E - 5], w[E]) };
          break;
        case 18:
          this.$ = { strip: S.stripFlags(w[E - 1], w[E - 1]), program: w[E] };
          break;
        case 19:
          var R = S.prepareBlock(w[E - 2], w[E - 1], w[E], w[E], !1, this._$), O = S.prepareProgram([R], w[E - 1].loc);
          O.chained = !0, this.$ = { strip: w[E - 2].strip, program: O, chain: !0 };
          break;
        case 21:
          this.$ = { path: w[E - 1], strip: S.stripFlags(w[E - 2], w[E]) };
          break;
        case 22:
        case 23:
          this.$ = S.prepareMustache(w[E - 3], w[E - 2], w[E - 1], w[E - 4], S.stripFlags(w[E - 4], w[E]), this._$);
          break;
        case 24:
          this.$ = { type: "PartialStatement", name: w[E - 3], params: w[E - 2], hash: w[E - 1], indent: "", strip: S.stripFlags(w[E - 4], w[E]), loc: S.locInfo(this._$) };
          break;
        case 25:
          this.$ = S.preparePartialBlock(w[E - 2], w[E - 1], w[E], this._$);
          break;
        case 26:
          this.$ = { path: w[E - 3], params: w[E - 2], hash: w[E - 1], strip: S.stripFlags(w[E - 4], w[E]) };
          break;
        case 29:
          this.$ = { type: "SubExpression", path: w[E - 3], params: w[E - 2], hash: w[E - 1], loc: S.locInfo(this._$) };
          break;
        case 30:
          this.$ = { type: "Hash", pairs: w[E], loc: S.locInfo(this._$) };
          break;
        case 31:
          this.$ = { type: "HashPair", key: S.id(w[E - 2]), value: w[E], loc: S.locInfo(this._$) };
          break;
        case 32:
          this.$ = S.id(w[E - 1]);
          break;
        case 35:
          this.$ = { type: "StringLiteral", value: w[E], original: w[E], loc: S.locInfo(this._$) };
          break;
        case 36:
          this.$ = { type: "NumberLiteral", value: Number(w[E]), original: Number(w[E]), loc: S.locInfo(this._$) };
          break;
        case 37:
          this.$ = { type: "BooleanLiteral", value: w[E] === "true", original: w[E] === "true", loc: S.locInfo(this._$) };
          break;
        case 38:
          this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: S.locInfo(this._$) };
          break;
        case 39:
          this.$ = { type: "NullLiteral", original: null, value: null, loc: S.locInfo(this._$) };
          break;
        case 42:
          this.$ = S.preparePath(!0, w[E], this._$);
          break;
        case 43:
          this.$ = S.preparePath(!1, w[E], this._$);
          break;
        case 44:
          w[E - 2].push({ part: S.id(w[E]), original: w[E], separator: w[E - 1] }), this.$ = w[E - 2];
          break;
        case 45:
          this.$ = [{ part: S.id(w[E]), original: w[E] }];
          break;
        case 46:
        case 48:
        case 50:
        case 58:
        case 64:
        case 70:
        case 78:
        case 82:
        case 86:
        case 90:
        case 94:
          this.$ = [];
          break;
        case 47:
        case 49:
        case 51:
        case 59:
        case 65:
        case 71:
        case 79:
        case 83:
        case 87:
        case 91:
        case 95:
        case 99:
        case 101:
          w[E - 1].push(w[E]);
          break;
        case 98:
        case 100:
          this.$ = [w[E]];
      }
    }, table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }], defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] }, parseError: function(y, v) {
      throw new Error(y);
    }, parse: function(y) {
      var v = this, k = [0], S = [null], $ = [], w = this.table, T = "", E = 0, R = 0;
      this.lexer.setInput(y), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, this.lexer.yylloc === void 0 && (this.lexer.yylloc = {});
      var O = this.lexer.yylloc;
      $.push(O);
      var P = this.lexer.options && this.lexer.options.ranges;
      function L() {
        var Y;
        return typeof (Y = v.lexer.lex() || 1) != "number" && (Y = v.symbols_[Y] || Y), Y;
      }
      typeof this.yy.parseError == "function" && (this.parseError = this.yy.parseError);
      for (var M, B, j, x, N, D, V, W, F = {}; ; ) {
        if (B = k[k.length - 1], this.defaultActions[B] ? j = this.defaultActions[B] : (M == null && (M = L()), j = w[B] && w[B][M]), j === void 0 || !j.length || !j[0]) {
          var U = "";
          for (N in W = [], w[B])
            this.terminals_[N] && N > 2 && W.push("'" + this.terminals_[N] + "'");
          U = this.lexer.showPosition ? "Parse error on line " + (E + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + W.join(", ") + ", got '" + (this.terminals_[M] || M) + "'" : "Parse error on line " + (E + 1) + ": Unexpected " + (M == 1 ? "end of input" : "'" + (this.terminals_[M] || M) + "'"), this.parseError(U, { text: this.lexer.match, token: this.terminals_[M] || M, line: this.lexer.yylineno, loc: O, expected: W });
        }
        if (j[0] instanceof Array && j.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + B + ", token: " + M);
        switch (j[0]) {
          case 1:
            k.push(M), S.push(this.lexer.yytext), $.push(this.lexer.yylloc), k.push(j[1]), M = null, R = this.lexer.yyleng, T = this.lexer.yytext, E = this.lexer.yylineno, O = this.lexer.yylloc;
            break;
          case 2:
            if (D = this.productions_[j[1]][1], F.$ = S[S.length - D], F._$ = { first_line: $[$.length - (D || 1)].first_line, last_line: $[$.length - 1].last_line, first_column: $[$.length - (D || 1)].first_column, last_column: $[$.length - 1].last_column }, P && (F._$.range = [$[$.length - (D || 1)].range[0], $[$.length - 1].range[1]]), (x = this.performAction.call(F, T, R, E, this.yy, j[1], S, $)) !== void 0)
              return x;
            D && (k = k.slice(0, -1 * D * 2), S = S.slice(0, -1 * D), $ = $.slice(0, -1 * D)), k.push(this.productions_[j[1]][0]), S.push(F.$), $.push(F._$), V = w[k[k.length - 2]][k[k.length - 1]], k.push(V);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    } }, m = function() {
      var y = { EOF: 1, parseError: function(v, k) {
        if (!this.yy.parser)
          throw new Error(v);
        this.yy.parser.parseError(v, k);
      }, setInput: function(v) {
        return this._input = v, this._more = this._less = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, input: function() {
        var v = this._input[0];
        return this.yytext += v, this.yyleng++, this.offset++, this.match += v, this.matched += v, v.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), v;
      }, unput: function(v) {
        var k = v.length, S = v.split(/(?:\r\n?|\n)/g);
        this._input = v + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - k - 1), this.offset -= k;
        var $ = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), S.length - 1 && (this.yylineno -= S.length - 1);
        var w = this.yylloc.range;
        return this.yylloc = { first_line: this.yylloc.first_line, last_line: this.yylineno + 1, first_column: this.yylloc.first_column, last_column: S ? (S.length === $.length ? this.yylloc.first_column : 0) + $[$.length - S.length].length - S[0].length : this.yylloc.first_column - k }, this.options.ranges && (this.yylloc.range = [w[0], w[0] + this.yyleng - k]), this;
      }, more: function() {
        return this._more = !0, this;
      }, less: function(v) {
        this.unput(this.match.slice(v));
      }, pastInput: function() {
        var v = this.matched.substr(0, this.matched.length - this.match.length);
        return (v.length > 20 ? "..." : "") + v.substr(-20).replace(/\n/g, "");
      }, upcomingInput: function() {
        var v = this.match;
        return v.length < 20 && (v += this._input.substr(0, 20 - v.length)), (v.substr(0, 20) + (v.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, showPosition: function() {
        var v = this.pastInput(), k = new Array(v.length + 1).join("-");
        return v + this.upcomingInput() + `
` + k + "^";
      }, next: function() {
        if (this.done)
          return this.EOF;
        var v, k, S, $, w;
        this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
        for (var T = this._currentRules(), E = 0; E < T.length && (!(S = this._input.match(this.rules[T[E]])) || k && !(S[0].length > k[0].length) || (k = S, $ = E, this.options.flex)); E++)
          ;
        return k ? ((w = k[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += w.length), this.yylloc = { first_line: this.yylloc.last_line, last_line: this.yylineno + 1, first_column: this.yylloc.last_column, last_column: w ? w[w.length - 1].length - w[w.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + k[0].length }, this.yytext += k[0], this.match += k[0], this.matches = k, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._input = this._input.slice(k[0].length), this.matched += k[0], v = this.performAction.call(this, this.yy, this, T[$], this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), v || void 0) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), { text: "", token: null, line: this.yylineno });
      }, lex: function() {
        var v = this.next();
        return v !== void 0 ? v : this.lex();
      }, begin: function(v) {
        this.conditionStack.push(v);
      }, popState: function() {
        return this.conditionStack.pop();
      }, _currentRules: function() {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
      }, topState: function() {
        return this.conditionStack[this.conditionStack.length - 2];
      }, pushState: function(v) {
        this.begin(v);
      }, options: {}, performAction: function(v, k, S, $) {
        function w(T, E) {
          return k.yytext = k.yytext.substring(T, k.yyleng - E + T);
        }
        switch (S) {
          case 0:
            if (k.yytext.slice(-2) === "\\\\" ? (w(0, 1), this.begin("mu")) : k.yytext.slice(-1) === "\\" ? (w(0, 1), this.begin("emu")) : this.begin("mu"), k.yytext)
              return 15;
            break;
          case 1:
          case 5:
            return 15;
          case 2:
            return this.popState(), 15;
          case 3:
            return this.begin("raw"), 15;
          case 4:
            return this.popState(), this.conditionStack[this.conditionStack.length - 1] === "raw" ? 15 : (w(5, 9), "END_RAW_BLOCK");
          case 6:
          case 22:
            return this.popState(), 14;
          case 7:
            return 65;
          case 8:
            return 68;
          case 9:
            return 19;
          case 10:
            return this.popState(), this.begin("raw"), 23;
          case 11:
            return 55;
          case 12:
            return 60;
          case 13:
            return 29;
          case 14:
            return 47;
          case 15:
          case 16:
            return this.popState(), 44;
          case 17:
            return 34;
          case 18:
            return 39;
          case 19:
            return 51;
          case 20:
          case 23:
            return 48;
          case 21:
            this.unput(k.yytext), this.popState(), this.begin("com");
            break;
          case 24:
            return 73;
          case 25:
          case 26:
          case 41:
            return 72;
          case 27:
            return 87;
          case 28:
            break;
          case 29:
            return this.popState(), 54;
          case 30:
            return this.popState(), 33;
          case 31:
            return k.yytext = w(1, 2).replace(/\\"/g, '"'), 80;
          case 32:
            return k.yytext = w(1, 2).replace(/\\'/g, "'"), 80;
          case 33:
            return 85;
          case 34:
          case 35:
            return 82;
          case 36:
            return 83;
          case 37:
            return 84;
          case 38:
            return 81;
          case 39:
            return 75;
          case 40:
            return 77;
          case 42:
            return k.yytext = k.yytext.replace(/\\([\\\]])/g, "$1"), 72;
          case 43:
            return "INVALID";
          case 44:
            return 5;
        }
      }, rules: [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/], conditions: { mu: { rules: [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], inclusive: !1 }, emu: { rules: [2], inclusive: !1 }, com: { rules: [6], inclusive: !1 }, raw: { rules: [3, 4, 5], inclusive: !1 }, INITIAL: { rules: [0, 1, 44], inclusive: !0 } } };
      return y;
    }();
    function b() {
      this.yy = {};
    }
    return p.lexer = m, b.prototype = p, p.Parser = b, new b();
  }();
  l.default = f, u.exports = l.default;
}), visitor = createCommonjsModule(function(u, l) {
  l.__esModule = !0;
  var f, p = (f = exception) && f.__esModule ? f : { default: f };
  function m() {
    this.parents = [];
  }
  function b(k) {
    this.acceptRequired(k, "path"), this.acceptArray(k.params), this.acceptKey(k, "hash");
  }
  function y(k) {
    b.call(this, k), this.acceptKey(k, "program"), this.acceptKey(k, "inverse");
  }
  function v(k) {
    this.acceptRequired(k, "name"), this.acceptArray(k.params), this.acceptKey(k, "hash");
  }
  m.prototype = { constructor: m, mutating: !1, acceptKey: function(k, S) {
    var $ = this.accept(k[S]);
    if (this.mutating) {
      if ($ && !m.prototype[$.type])
        throw new p.default('Unexpected node type "' + $.type + '" found when accepting ' + S + " on " + k.type);
      k[S] = $;
    }
  }, acceptRequired: function(k, S) {
    if (this.acceptKey(k, S), !k[S])
      throw new p.default(k.type + " requires " + S);
  }, acceptArray: function(k) {
    for (var S = 0, $ = k.length; S < $; S++)
      this.acceptKey(k, S), k[S] || (k.splice(S, 1), S--, $--);
  }, accept: function(k) {
    if (k) {
      if (!this[k.type])
        throw new p.default("Unknown type: " + k.type, k);
      this.current && this.parents.unshift(this.current), this.current = k;
      var S = this[k.type](k);
      return this.current = this.parents.shift(), !this.mutating || S ? S : S !== !1 ? k : void 0;
    }
  }, Program: function(k) {
    this.acceptArray(k.body);
  }, MustacheStatement: b, Decorator: b, BlockStatement: y, DecoratorBlock: y, PartialStatement: v, PartialBlockStatement: function(k) {
    v.call(this, k), this.acceptKey(k, "program");
  }, ContentStatement: function() {
  }, CommentStatement: function() {
  }, SubExpression: b, PathExpression: function() {
  }, StringLiteral: function() {
  }, NumberLiteral: function() {
  }, BooleanLiteral: function() {
  }, UndefinedLiteral: function() {
  }, NullLiteral: function() {
  }, Hash: function(k) {
    this.acceptArray(k.pairs);
  }, HashPair: function(k) {
    this.acceptRequired(k, "value");
  } }, l.default = m, u.exports = l.default;
}), whitespaceControl = createCommonjsModule(function(u, l) {
  l.__esModule = !0;
  var f, p = (f = visitor) && f.__esModule ? f : { default: f };
  function m() {
    var S = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
    this.options = S;
  }
  function b(S, $, w) {
    $ === void 0 && ($ = S.length);
    var T = S[$ - 1], E = S[$ - 2];
    return T ? T.type === "ContentStatement" ? (E || !w ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(T.original) : void 0 : w;
  }
  function y(S, $, w) {
    $ === void 0 && ($ = -1);
    var T = S[$ + 1], E = S[$ + 2];
    return T ? T.type === "ContentStatement" ? (E || !w ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(T.original) : void 0 : w;
  }
  function v(S, $, w) {
    var T = S[$ == null ? 0 : $ + 1];
    if (T && T.type === "ContentStatement" && (w || !T.rightStripped)) {
      var E = T.value;
      T.value = T.value.replace(w ? /^\s+/ : /^[ \t]*\r?\n?/, ""), T.rightStripped = T.value !== E;
    }
  }
  function k(S, $, w) {
    var T = S[$ == null ? S.length - 1 : $ - 1];
    if (T && T.type === "ContentStatement" && (w || !T.leftStripped)) {
      var E = T.value;
      return T.value = T.value.replace(w ? /\s+$/ : /[ \t]+$/, ""), T.leftStripped = T.value !== E, T.leftStripped;
    }
  }
  m.prototype = new p.default(), m.prototype.Program = function(S) {
    var $ = !this.options.ignoreStandalone, w = !this.isRootSeen;
    this.isRootSeen = !0;
    for (var T = S.body, E = 0, R = T.length; E < R; E++) {
      var O = T[E], P = this.accept(O);
      if (P) {
        var L = b(T, E, w), M = y(T, E, w), B = P.openStandalone && L, j = P.closeStandalone && M, x = P.inlineStandalone && L && M;
        P.close && v(T, E, !0), P.open && k(T, E, !0), $ && x && (v(T, E), k(T, E) && O.type === "PartialStatement" && (O.indent = /([ \t]+$)/.exec(T[E - 1].original)[1])), $ && B && (v((O.program || O.inverse).body), k(T, E)), $ && j && (v(T, E), k((O.inverse || O.program).body));
      }
    }
    return S;
  }, m.prototype.BlockStatement = m.prototype.DecoratorBlock = m.prototype.PartialBlockStatement = function(S) {
    this.accept(S.program), this.accept(S.inverse);
    var $ = S.program || S.inverse, w = S.program && S.inverse, T = w, E = w;
    if (w && w.chained)
      for (T = w.body[0].program; E.chained; )
        E = E.body[E.body.length - 1].program;
    var R = { open: S.openStrip.open, close: S.closeStrip.close, openStandalone: y($.body), closeStandalone: b((T || $).body) };
    if (S.openStrip.close && v($.body, null, !0), w) {
      var O = S.inverseStrip;
      O.open && k($.body, null, !0), O.close && v(T.body, null, !0), S.closeStrip.open && k(E.body, null, !0), !this.options.ignoreStandalone && b($.body) && y(T.body) && (k($.body), v(T.body));
    } else
      S.closeStrip.open && k($.body, null, !0);
    return R;
  }, m.prototype.Decorator = m.prototype.MustacheStatement = function(S) {
    return S.strip;
  }, m.prototype.PartialStatement = m.prototype.CommentStatement = function(S) {
    var $ = S.strip || {};
    return { inlineStandalone: !0, open: $.open, close: $.close };
  }, l.default = m, u.exports = l.default;
}), SourceLocation_1 = SourceLocation, id_1 = id$1, stripFlags_1 = stripFlags, stripComment_1 = stripComment, preparePath_1 = preparePath, prepareMustache_1 = prepareMustache, prepareRawBlock_1 = prepareRawBlock, prepareBlock_1 = prepareBlock, prepareProgram_1 = prepareProgram, preparePartialBlock_1 = preparePartialBlock;
function _interopRequireDefault$2(u) {
  return u && u.__esModule ? u : { default: u };
}
var _exception2$1 = _interopRequireDefault$2(exception);
function validateClose(u, l) {
  if (l = l.path ? l.path.original : l, u.path.original !== l) {
    var f = { loc: u.path.loc };
    throw new _exception2$1.default(u.path.original + " doesn't match " + l, f);
  }
}
function SourceLocation(u, l) {
  this.source = u, this.start = { line: l.first_line, column: l.first_column }, this.end = { line: l.last_line, column: l.last_column };
}
function id$1(u) {
  return /^\[.*\]$/.test(u) ? u.substring(1, u.length - 1) : u;
}
function stripFlags(u, l) {
  return { open: u.charAt(2) === "~", close: l.charAt(l.length - 3) === "~" };
}
function stripComment(u) {
  return u.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
}
function preparePath(u, l, f) {
  f = this.locInfo(f);
  for (var p = u ? "@" : "", m = [], b = 0, y = 0, v = l.length; y < v; y++) {
    var k = l[y].part, S = l[y].original !== k;
    if (p += (l[y].separator || "") + k, S || k !== ".." && k !== "." && k !== "this")
      m.push(k);
    else {
      if (m.length > 0)
        throw new _exception2$1.default("Invalid path: " + p, { loc: f });
      k === ".." && b++;
    }
  }
  return { type: "PathExpression", data: u, depth: b, parts: m, original: p, loc: f };
}
function prepareMustache(u, l, f, p, m, b) {
  var y = p.charAt(3) || p.charAt(2), v = y !== "{" && y !== "&";
  return { type: /\*/.test(p) ? "Decorator" : "MustacheStatement", path: u, params: l, hash: f, escaped: v, strip: m, loc: this.locInfo(b) };
}
function prepareRawBlock(u, l, f, p) {
  validateClose(u, f);
  var m = { type: "Program", body: l, strip: {}, loc: p = this.locInfo(p) };
  return { type: "BlockStatement", path: u.path, params: u.params, hash: u.hash, program: m, openStrip: {}, inverseStrip: {}, closeStrip: {}, loc: p };
}
function prepareBlock(u, l, f, p, m, b) {
  p && p.path && validateClose(u, p);
  var y = /\*/.test(u.open);
  l.blockParams = u.blockParams;
  var v = void 0, k = void 0;
  if (f) {
    if (y)
      throw new _exception2$1.default("Unexpected inverse block on decorator", f);
    f.chain && (f.program.body[0].closeStrip = p.strip), k = f.strip, v = f.program;
  }
  return m && (m = v, v = l, l = m), { type: y ? "DecoratorBlock" : "BlockStatement", path: u.path, params: u.params, hash: u.hash, program: l, inverse: v, openStrip: u.strip, inverseStrip: k, closeStrip: p && p.strip, loc: this.locInfo(b) };
}
function prepareProgram(u, l) {
  if (!l && u.length) {
    var f = u[0].loc, p = u[u.length - 1].loc;
    f && p && (l = { source: f.source, start: { line: f.start.line, column: f.start.column }, end: { line: p.end.line, column: p.end.column } });
  }
  return { type: "Program", body: u, strip: {}, loc: l };
}
function preparePartialBlock(u, l, f, p) {
  return validateClose(u, f), { type: "PartialBlockStatement", name: u.path, params: u.params, hash: u.hash, program: l, openStrip: u.strip, closeStrip: f && f.strip, loc: this.locInfo(p) };
}
var helpers$1 = Object.defineProperty({ SourceLocation: SourceLocation_1, id: id_1, stripFlags: stripFlags_1, stripComment: stripComment_1, preparePath: preparePath_1, prepareMustache: prepareMustache_1, prepareRawBlock: prepareRawBlock_1, prepareBlock: prepareBlock_1, prepareProgram: prepareProgram_1, preparePartialBlock: preparePartialBlock_1 }, "__esModule", { value: !0 }), parseWithoutProcessing_1 = parseWithoutProcessing, parse_1$3 = parse$4;
function _interopRequireWildcard(u) {
  if (u && u.__esModule)
    return u;
  var l = {};
  if (u != null)
    for (var f in u)
      Object.prototype.hasOwnProperty.call(u, f) && (l[f] = u[f]);
  return l.default = u, l;
}
function _interopRequireDefault$1(u) {
  return u && u.__esModule ? u : { default: u };
}
var _parser2 = _interopRequireDefault$1(parser$1), _whitespaceControl2 = _interopRequireDefault$1(whitespaceControl), Helpers = _interopRequireWildcard(helpers$1), parser$2 = _parser2.default, yy = {};
function parseWithoutProcessing(u, l) {
  return u.type === "Program" ? u : (_parser2.default.yy = yy, yy.locInfo = function(f) {
    return new yy.SourceLocation(l && l.srcName, f);
  }, _parser2.default.parse(u));
}
function parse$4(u, l) {
  var f = parseWithoutProcessing(u, l);
  return new _whitespaceControl2.default(l).accept(f);
}
utils$3.extend(yy, Helpers);
var base$1 = Object.defineProperty({ parseWithoutProcessing: parseWithoutProcessing_1, parse: parse_1$3, parser: parser$2 }, "__esModule", { value: !0 }), Compiler_1 = Compiler, precompile_1 = precompile, compile_1$1 = compile$1;
function _interopRequireDefault(u) {
  return u && u.__esModule ? u : { default: u };
}
var _exception2 = _interopRequireDefault(exception), _ast2 = _interopRequireDefault(ast), slice = [].slice;
function Compiler() {
}
function precompile(u, l, f) {
  if (u == null || typeof u != "string" && u.type !== "Program")
    throw new _exception2.default("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + u);
  "data" in (l = l || {}) || (l.data = !0), l.compat && (l.useDepths = !0);
  var p = f.parse(u, l), m = new f.Compiler().compile(p, l);
  return new f.JavaScriptCompiler().compile(m, l);
}
function compile$1(u, l, f) {
  if (l === void 0 && (l = {}), u == null || typeof u != "string" && u.type !== "Program")
    throw new _exception2.default("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + u);
  "data" in (l = utils$3.extend({}, l)) || (l.data = !0), l.compat && (l.useDepths = !0);
  var p = void 0;
  function m() {
    var y = f.parse(u, l), v = new f.Compiler().compile(y, l), k = new f.JavaScriptCompiler().compile(v, l, void 0, !0);
    return f.template(k);
  }
  function b(y, v) {
    return p || (p = m()), p.call(this, y, v);
  }
  return b._setup = function(y) {
    return p || (p = m()), p._setup(y);
  }, b._child = function(y, v, k, S) {
    return p || (p = m()), p._child(y, v, k, S);
  }, b;
}
function argEquals(u, l) {
  if (u === l)
    return !0;
  if (utils$3.isArray(u) && utils$3.isArray(l) && u.length === l.length) {
    for (var f = 0; f < u.length; f++)
      if (!argEquals(u[f], l[f]))
        return !1;
    return !0;
  }
}
function transformLiteralToPath(u) {
  if (!u.path.parts) {
    var l = u.path;
    u.path = { type: "PathExpression", data: !1, depth: 0, parts: [l.original + ""], original: l.original + "", loc: l.loc };
  }
}
Compiler.prototype = { compiler: Compiler, equals: function(u) {
  var l = this.opcodes.length;
  if (u.opcodes.length !== l)
    return !1;
  for (var f = 0; f < l; f++) {
    var p = this.opcodes[f], m = u.opcodes[f];
    if (p.opcode !== m.opcode || !argEquals(p.args, m.args))
      return !1;
  }
  for (l = this.children.length, f = 0; f < l; f++)
    if (!this.children[f].equals(u.children[f]))
      return !1;
  return !0;
}, guid: 0, compile: function(u, l) {
  return this.sourceNode = [], this.opcodes = [], this.children = [], this.options = l, this.stringParams = l.stringParams, this.trackIds = l.trackIds, l.blockParams = l.blockParams || [], l.knownHelpers = utils$3.extend(/* @__PURE__ */ Object.create(null), { helperMissing: !0, blockHelperMissing: !0, each: !0, if: !0, unless: !0, with: !0, log: !0, lookup: !0 }, l.knownHelpers), this.accept(u);
}, compileProgram: function(u) {
  var l = new this.compiler().compile(u, this.options), f = this.guid++;
  return this.usePartial = this.usePartial || l.usePartial, this.children[f] = l, this.useDepths = this.useDepths || l.useDepths, f;
}, accept: function(u) {
  if (!this[u.type])
    throw new _exception2.default("Unknown type: " + u.type, u);
  this.sourceNode.unshift(u);
  var l = this[u.type](u);
  return this.sourceNode.shift(), l;
}, Program: function(u) {
  this.options.blockParams.unshift(u.blockParams);
  for (var l = u.body, f = l.length, p = 0; p < f; p++)
    this.accept(l[p]);
  return this.options.blockParams.shift(), this.isSimple = f === 1, this.blockParams = u.blockParams ? u.blockParams.length : 0, this;
}, BlockStatement: function(u) {
  transformLiteralToPath(u);
  var l = u.program, f = u.inverse;
  l = l && this.compileProgram(l), f = f && this.compileProgram(f);
  var p = this.classifySexpr(u);
  p === "helper" ? this.helperSexpr(u, l, f) : p === "simple" ? (this.simpleSexpr(u), this.opcode("pushProgram", l), this.opcode("pushProgram", f), this.opcode("emptyHash"), this.opcode("blockValue", u.path.original)) : (this.ambiguousSexpr(u, l, f), this.opcode("pushProgram", l), this.opcode("pushProgram", f), this.opcode("emptyHash"), this.opcode("ambiguousBlockValue")), this.opcode("append");
}, DecoratorBlock: function(u) {
  var l = u.program && this.compileProgram(u.program), f = this.setupFullMustacheParams(u, l, void 0), p = u.path;
  this.useDecorators = !0, this.opcode("registerDecorator", f.length, p.original);
}, PartialStatement: function(u) {
  this.usePartial = !0;
  var l = u.program;
  l && (l = this.compileProgram(u.program));
  var f = u.params;
  if (f.length > 1)
    throw new _exception2.default("Unsupported number of partial arguments: " + f.length, u);
  f.length || (this.options.explicitPartialContext ? this.opcode("pushLiteral", "undefined") : f.push({ type: "PathExpression", parts: [], depth: 0 }));
  var p = u.name.original, m = u.name.type === "SubExpression";
  m && this.accept(u.name), this.setupFullMustacheParams(u, l, void 0, !0);
  var b = u.indent || "";
  this.options.preventIndent && b && (this.opcode("appendContent", b), b = ""), this.opcode("invokePartial", m, p, b), this.opcode("append");
}, PartialBlockStatement: function(u) {
  this.PartialStatement(u);
}, MustacheStatement: function(u) {
  this.SubExpression(u), u.escaped && !this.options.noEscape ? this.opcode("appendEscaped") : this.opcode("append");
}, Decorator: function(u) {
  this.DecoratorBlock(u);
}, ContentStatement: function(u) {
  u.value && this.opcode("appendContent", u.value);
}, CommentStatement: function() {
}, SubExpression: function(u) {
  transformLiteralToPath(u);
  var l = this.classifySexpr(u);
  l === "simple" ? this.simpleSexpr(u) : l === "helper" ? this.helperSexpr(u) : this.ambiguousSexpr(u);
}, ambiguousSexpr: function(u, l, f) {
  var p = u.path, m = p.parts[0], b = l != null || f != null;
  this.opcode("getContext", p.depth), this.opcode("pushProgram", l), this.opcode("pushProgram", f), p.strict = !0, this.accept(p), this.opcode("invokeAmbiguous", m, b);
}, simpleSexpr: function(u) {
  var l = u.path;
  l.strict = !0, this.accept(l), this.opcode("resolvePossibleLambda");
}, helperSexpr: function(u, l, f) {
  var p = this.setupFullMustacheParams(u, l, f), m = u.path, b = m.parts[0];
  if (this.options.knownHelpers[b])
    this.opcode("invokeKnownHelper", p.length, b);
  else {
    if (this.options.knownHelpersOnly)
      throw new _exception2.default("You specified knownHelpersOnly, but used the unknown helper " + b, u);
    m.strict = !0, m.falsy = !0, this.accept(m), this.opcode("invokeHelper", p.length, m.original, _ast2.default.helpers.simpleId(m));
  }
}, PathExpression: function(u) {
  this.addDepth(u.depth), this.opcode("getContext", u.depth);
  var l = u.parts[0], f = _ast2.default.helpers.scopedId(u), p = !u.depth && !f && this.blockParamIndex(l);
  p ? this.opcode("lookupBlockParam", p, u.parts) : l ? u.data ? (this.options.data = !0, this.opcode("lookupData", u.depth, u.parts, u.strict)) : this.opcode("lookupOnContext", u.parts, u.falsy, u.strict, f) : this.opcode("pushContext");
}, StringLiteral: function(u) {
  this.opcode("pushString", u.value);
}, NumberLiteral: function(u) {
  this.opcode("pushLiteral", u.value);
}, BooleanLiteral: function(u) {
  this.opcode("pushLiteral", u.value);
}, UndefinedLiteral: function() {
  this.opcode("pushLiteral", "undefined");
}, NullLiteral: function() {
  this.opcode("pushLiteral", "null");
}, Hash: function(u) {
  var l = u.pairs, f = 0, p = l.length;
  for (this.opcode("pushHash"); f < p; f++)
    this.pushParam(l[f].value);
  for (; f--; )
    this.opcode("assignToHash", l[f].key);
  this.opcode("popHash");
}, opcode: function(u) {
  this.opcodes.push({ opcode: u, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
}, addDepth: function(u) {
  u && (this.useDepths = !0);
}, classifySexpr: function(u) {
  var l = _ast2.default.helpers.simpleId(u.path), f = l && !!this.blockParamIndex(u.path.parts[0]), p = !f && _ast2.default.helpers.helperExpression(u), m = !f && (p || l);
  if (m && !p) {
    var b = u.path.parts[0], y = this.options;
    y.knownHelpers[b] ? p = !0 : y.knownHelpersOnly && (m = !1);
  }
  return p ? "helper" : m ? "ambiguous" : "simple";
}, pushParams: function(u) {
  for (var l = 0, f = u.length; l < f; l++)
    this.pushParam(u[l]);
}, pushParam: function(u) {
  var l = u.value != null ? u.value : u.original || "";
  if (this.stringParams)
    l.replace && (l = l.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".")), u.depth && this.addDepth(u.depth), this.opcode("getContext", u.depth || 0), this.opcode("pushStringParam", l, u.type), u.type === "SubExpression" && this.accept(u);
  else {
    if (this.trackIds) {
      var f = void 0;
      if (!u.parts || _ast2.default.helpers.scopedId(u) || u.depth || (f = this.blockParamIndex(u.parts[0])), f) {
        var p = u.parts.slice(1).join(".");
        this.opcode("pushId", "BlockParam", f, p);
      } else
        (l = u.original || l).replace && (l = l.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "")), this.opcode("pushId", u.type, l);
    }
    this.accept(u);
  }
}, setupFullMustacheParams: function(u, l, f, p) {
  var m = u.params;
  return this.pushParams(m), this.opcode("pushProgram", l), this.opcode("pushProgram", f), u.hash ? this.accept(u.hash) : this.opcode("emptyHash", p), m;
}, blockParamIndex: function(u) {
  for (var l = 0, f = this.options.blockParams.length; l < f; l++) {
    var p = this.options.blockParams[l], m = p && utils$3.indexOf(p, u);
    if (p && m >= 0)
      return [l, m];
  }
} };
var compiler = Object.defineProperty({ Compiler: Compiler_1, precompile: precompile_1, compile: compile_1$1 }, "__esModule", { value: !0 }), intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), encode$2 = function(u) {
  if (0 <= u && u < intToCharMap.length)
    return intToCharMap[u];
  throw new TypeError("Must be between 0 and 63: " + u);
}, decode$1$1 = function(u) {
  return 65 <= u && u <= 90 ? u - 65 : 97 <= u && u <= 122 ? u - 97 + 26 : 48 <= u && u <= 57 ? u - 48 + 52 : u == 43 ? 62 : u == 47 ? 63 : -1;
}, base64 = { encode: encode$2, decode: decode$1$1 }, VLQ_BASE_SHIFT = 5, VLQ_BASE = 1 << VLQ_BASE_SHIFT, VLQ_BASE_MASK = VLQ_BASE - 1, VLQ_CONTINUATION_BIT = VLQ_BASE;
function toVLQSigned(u) {
  return u < 0 ? 1 + (-u << 1) : 0 + (u << 1);
}
function fromVLQSigned(u) {
  var l = u >> 1;
  return 1 & ~u ? l : -l;
}
var encode$1 = function(u) {
  var l, f = "", p = toVLQSigned(u);
  do
    l = p & VLQ_BASE_MASK, (p >>>= VLQ_BASE_SHIFT) > 0 && (l |= VLQ_CONTINUATION_BIT), f += base64.encode(l);
  while (p > 0);
  return f;
}, decode$2 = function(u, l, f) {
  var p, m, b = u.length, y = 0, v = 0;
  do {
    if (l >= b)
      throw new Error("Expected more digits in base 64 VLQ value.");
    if ((m = base64.decode(u.charCodeAt(l++))) === -1)
      throw new Error("Invalid base64 digit: " + u.charAt(l - 1));
    p = !!(m & VLQ_CONTINUATION_BIT), y += (m &= VLQ_BASE_MASK) << v, v += VLQ_BASE_SHIFT;
  } while (p);
  f.value = fromVLQSigned(y), f.rest = l;
}, base64Vlq = { encode: encode$1, decode: decode$2 }, util$1 = createCommonjsModule(function(u, l) {
  l.getArg = function(T, E, R) {
    if (E in T)
      return T[E];
    if (arguments.length === 3)
      return R;
    throw new Error('"' + E + '" is a required argument.');
  };
  var f = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, p = /^data:.+\,.+$/;
  function m(T) {
    var E = T.match(f);
    return E ? { scheme: E[1], auth: E[2], host: E[3], port: E[4], path: E[5] } : null;
  }
  function b(T) {
    var E = "";
    return T.scheme && (E += T.scheme + ":"), E += "//", T.auth && (E += T.auth + "@"), T.host && (E += T.host), T.port && (E += ":" + T.port), T.path && (E += T.path), E;
  }
  function y(T) {
    var E = T, R = m(T);
    if (R) {
      if (!R.path)
        return T;
      E = R.path;
    }
    for (var O, P = l.isAbsolute(E), L = E.split(/\/+/), M = 0, B = L.length - 1; B >= 0; B--)
      (O = L[B]) === "." ? L.splice(B, 1) : O === ".." ? M++ : M > 0 && (O === "" ? (L.splice(B + 1, M), M = 0) : (L.splice(B, 2), M--));
    return (E = L.join("/")) === "" && (E = P ? "/" : "."), R ? (R.path = E, b(R)) : E;
  }
  function v(T, E) {
    T === "" && (T = "."), E === "" && (E = ".");
    var R = m(E), O = m(T);
    if (O && (T = O.path || "/"), R && !R.scheme)
      return O && (R.scheme = O.scheme), b(R);
    if (R || E.match(p))
      return E;
    if (O && !O.host && !O.path)
      return O.host = E, b(O);
    var P = E.charAt(0) === "/" ? E : y(T.replace(/\/+$/, "") + "/" + E);
    return O ? (O.path = P, b(O)) : P;
  }
  l.urlParse = m, l.urlGenerate = b, l.normalize = y, l.join = v, l.isAbsolute = function(T) {
    return T.charAt(0) === "/" || f.test(T);
  }, l.relative = function(T, E) {
    T === "" && (T = "."), T = T.replace(/\/$/, "");
    for (var R = 0; E.indexOf(T + "/") !== 0; ) {
      var O = T.lastIndexOf("/");
      if (O < 0 || (T = T.slice(0, O)).match(/^([^\/]+:\/)?\/*$/))
        return E;
      ++R;
    }
    return Array(R + 1).join("../") + E.substr(T.length + 1);
  };
  var k = !("__proto__" in /* @__PURE__ */ Object.create(null));
  function S(T) {
    return T;
  }
  function $(T) {
    if (!T)
      return !1;
    var E = T.length;
    if (E < 9 || T.charCodeAt(E - 1) !== 95 || T.charCodeAt(E - 2) !== 95 || T.charCodeAt(E - 3) !== 111 || T.charCodeAt(E - 4) !== 116 || T.charCodeAt(E - 5) !== 111 || T.charCodeAt(E - 6) !== 114 || T.charCodeAt(E - 7) !== 112 || T.charCodeAt(E - 8) !== 95 || T.charCodeAt(E - 9) !== 95)
      return !1;
    for (var R = E - 10; R >= 0; R--)
      if (T.charCodeAt(R) !== 36)
        return !1;
    return !0;
  }
  function w(T, E) {
    return T === E ? 0 : T === null ? 1 : E === null ? -1 : T > E ? 1 : -1;
  }
  l.toSetString = k ? S : function(T) {
    return $(T) ? "$" + T : T;
  }, l.fromSetString = k ? S : function(T) {
    return $(T) ? T.slice(1) : T;
  }, l.compareByOriginalPositions = function(T, E, R) {
    var O = w(T.source, E.source);
    return O !== 0 || (O = T.originalLine - E.originalLine) !== 0 || (O = T.originalColumn - E.originalColumn) !== 0 || R || (O = T.generatedColumn - E.generatedColumn) !== 0 || (O = T.generatedLine - E.generatedLine) !== 0 ? O : w(T.name, E.name);
  }, l.compareByGeneratedPositionsDeflated = function(T, E, R) {
    var O = T.generatedLine - E.generatedLine;
    return O !== 0 || (O = T.generatedColumn - E.generatedColumn) !== 0 || R || (O = w(T.source, E.source)) !== 0 || (O = T.originalLine - E.originalLine) !== 0 || (O = T.originalColumn - E.originalColumn) !== 0 ? O : w(T.name, E.name);
  }, l.compareByGeneratedPositionsInflated = function(T, E) {
    var R = T.generatedLine - E.generatedLine;
    return R !== 0 || (R = T.generatedColumn - E.generatedColumn) !== 0 || (R = w(T.source, E.source)) !== 0 || (R = T.originalLine - E.originalLine) !== 0 || (R = T.originalColumn - E.originalColumn) !== 0 ? R : w(T.name, E.name);
  }, l.parseSourceMapInput = function(T) {
    return JSON.parse(T.replace(/^\)]}'[^\n]*\n/, ""));
  }, l.computeSourceURL = function(T, E, R) {
    if (E = E || "", T && (T[T.length - 1] !== "/" && E[0] !== "/" && (T += "/"), E = T + E), R) {
      var O = m(R);
      if (!O)
        throw new Error("sourceMapURL could not be parsed");
      if (O.path) {
        var P = O.path.lastIndexOf("/");
        P >= 0 && (O.path = O.path.substring(0, P + 1));
      }
      E = v(b(O), E);
    }
    return y(E);
  };
}), has = Object.prototype.hasOwnProperty, hasNativeMap = typeof Map < "u";
function ArraySet$2() {
  this._array = [], this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
}
ArraySet$2.fromArray = function(u, l) {
  for (var f = new ArraySet$2(), p = 0, m = u.length; p < m; p++)
    f.add(u[p], l);
  return f;
}, ArraySet$2.prototype.size = function() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
}, ArraySet$2.prototype.add = function(u, l) {
  var f = hasNativeMap ? u : util$1.toSetString(u), p = hasNativeMap ? this.has(u) : has.call(this._set, f), m = this._array.length;
  p && !l || this._array.push(u), p || (hasNativeMap ? this._set.set(u, m) : this._set[f] = m);
}, ArraySet$2.prototype.has = function(u) {
  if (hasNativeMap)
    return this._set.has(u);
  var l = util$1.toSetString(u);
  return has.call(this._set, l);
}, ArraySet$2.prototype.indexOf = function(u) {
  if (hasNativeMap) {
    var l = this._set.get(u);
    if (l >= 0)
      return l;
  } else {
    var f = util$1.toSetString(u);
    if (has.call(this._set, f))
      return this._set[f];
  }
  throw new Error('"' + u + '" is not in the set.');
}, ArraySet$2.prototype.at = function(u) {
  if (u >= 0 && u < this._array.length)
    return this._array[u];
  throw new Error("No element indexed by " + u);
}, ArraySet$2.prototype.toArray = function() {
  return this._array.slice();
};
var ArraySet_1 = ArraySet$2, arraySet = { ArraySet: ArraySet_1 };
function generatedPositionAfter(u, l) {
  var f = u.generatedLine, p = l.generatedLine, m = u.generatedColumn, b = l.generatedColumn;
  return p > f || p == f && b >= m || util$1.compareByGeneratedPositionsInflated(u, l) <= 0;
}
function MappingList$1() {
  this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
}
MappingList$1.prototype.unsortedForEach = function(u, l) {
  this._array.forEach(u, l);
}, MappingList$1.prototype.add = function(u) {
  generatedPositionAfter(this._last, u) ? (this._last = u, this._array.push(u)) : (this._sorted = !1, this._array.push(u));
}, MappingList$1.prototype.toArray = function() {
  return this._sorted || (this._array.sort(util$1.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
};
var MappingList_1 = MappingList$1, mappingList = { MappingList: MappingList_1 }, ArraySet$1 = arraySet.ArraySet, MappingList = mappingList.MappingList;
function SourceMapGenerator$2(u) {
  u || (u = {}), this._file = util$1.getArg(u, "file", null), this._sourceRoot = util$1.getArg(u, "sourceRoot", null), this._skipValidation = util$1.getArg(u, "skipValidation", !1), this._sources = new ArraySet$1(), this._names = new ArraySet$1(), this._mappings = new MappingList(), this._sourcesContents = null;
}
SourceMapGenerator$2.prototype._version = 3, SourceMapGenerator$2.fromSourceMap = function(u) {
  var l = u.sourceRoot, f = new SourceMapGenerator$2({ file: u.file, sourceRoot: l });
  return u.eachMapping(function(p) {
    var m = { generated: { line: p.generatedLine, column: p.generatedColumn } };
    p.source != null && (m.source = p.source, l != null && (m.source = util$1.relative(l, m.source)), m.original = { line: p.originalLine, column: p.originalColumn }, p.name != null && (m.name = p.name)), f.addMapping(m);
  }), u.sources.forEach(function(p) {
    var m = p;
    l !== null && (m = util$1.relative(l, p)), f._sources.has(m) || f._sources.add(m);
    var b = u.sourceContentFor(p);
    b != null && f.setSourceContent(p, b);
  }), f;
}, SourceMapGenerator$2.prototype.addMapping = function(u) {
  var l = util$1.getArg(u, "generated"), f = util$1.getArg(u, "original", null), p = util$1.getArg(u, "source", null), m = util$1.getArg(u, "name", null);
  this._skipValidation || this._validateMapping(l, f, p, m), p != null && (p = String(p), this._sources.has(p) || this._sources.add(p)), m != null && (m = String(m), this._names.has(m) || this._names.add(m)), this._mappings.add({ generatedLine: l.line, generatedColumn: l.column, originalLine: f != null && f.line, originalColumn: f != null && f.column, source: p, name: m });
}, SourceMapGenerator$2.prototype.setSourceContent = function(u, l) {
  var f = u;
  this._sourceRoot != null && (f = util$1.relative(this._sourceRoot, f)), l != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[util$1.toSetString(f)] = l) : this._sourcesContents && (delete this._sourcesContents[util$1.toSetString(f)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
}, SourceMapGenerator$2.prototype.applySourceMap = function(u, l, f) {
  var p = l;
  if (l == null) {
    if (u.file == null)
      throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
    p = u.file;
  }
  var m = this._sourceRoot;
  m != null && (p = util$1.relative(m, p));
  var b = new ArraySet$1(), y = new ArraySet$1();
  this._mappings.unsortedForEach(function(v) {
    if (v.source === p && v.originalLine != null) {
      var k = u.originalPositionFor({ line: v.originalLine, column: v.originalColumn });
      k.source != null && (v.source = k.source, f != null && (v.source = util$1.join(f, v.source)), m != null && (v.source = util$1.relative(m, v.source)), v.originalLine = k.line, v.originalColumn = k.column, k.name != null && (v.name = k.name));
    }
    var S = v.source;
    S == null || b.has(S) || b.add(S);
    var $ = v.name;
    $ == null || y.has($) || y.add($);
  }, this), this._sources = b, this._names = y, u.sources.forEach(function(v) {
    var k = u.sourceContentFor(v);
    k != null && (f != null && (v = util$1.join(f, v)), m != null && (v = util$1.relative(m, v)), this.setSourceContent(v, k));
  }, this);
}, SourceMapGenerator$2.prototype._validateMapping = function(u, l, f, p) {
  if (l && typeof l.line != "number" && typeof l.column != "number")
    throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
  if ((!(u && "line" in u && "column" in u && u.line > 0 && u.column >= 0) || l || f || p) && !(u && "line" in u && "column" in u && l && "line" in l && "column" in l && u.line > 0 && u.column >= 0 && l.line > 0 && l.column >= 0 && f))
    throw new Error("Invalid mapping: " + JSON.stringify({ generated: u, source: f, original: l, name: p }));
}, SourceMapGenerator$2.prototype._serializeMappings = function() {
  for (var u, l, f, p, m = 0, b = 1, y = 0, v = 0, k = 0, S = 0, $ = "", w = this._mappings.toArray(), T = 0, E = w.length; T < E; T++) {
    if (u = "", (l = w[T]).generatedLine !== b)
      for (m = 0; l.generatedLine !== b; )
        u += ";", b++;
    else if (T > 0) {
      if (!util$1.compareByGeneratedPositionsInflated(l, w[T - 1]))
        continue;
      u += ",";
    }
    u += base64Vlq.encode(l.generatedColumn - m), m = l.generatedColumn, l.source != null && (p = this._sources.indexOf(l.source), u += base64Vlq.encode(p - S), S = p, u += base64Vlq.encode(l.originalLine - 1 - v), v = l.originalLine - 1, u += base64Vlq.encode(l.originalColumn - y), y = l.originalColumn, l.name != null && (f = this._names.indexOf(l.name), u += base64Vlq.encode(f - k), k = f)), $ += u;
  }
  return $;
}, SourceMapGenerator$2.prototype._generateSourcesContent = function(u, l) {
  return u.map(function(f) {
    if (!this._sourcesContents)
      return null;
    l != null && (f = util$1.relative(l, f));
    var p = util$1.toSetString(f);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, p) ? this._sourcesContents[p] : null;
  }, this);
}, SourceMapGenerator$2.prototype.toJSON = function() {
  var u = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
  return this._file != null && (u.file = this._file), this._sourceRoot != null && (u.sourceRoot = this._sourceRoot), this._sourcesContents && (u.sourcesContent = this._generateSourcesContent(u.sources, u.sourceRoot)), u;
}, SourceMapGenerator$2.prototype.toString = function() {
  return JSON.stringify(this.toJSON());
};
var SourceMapGenerator_1 = SourceMapGenerator$2, sourceMapGenerator = { SourceMapGenerator: SourceMapGenerator_1 }, binarySearch = createCommonjsModule(function(u, l) {
  function f(p, m, b, y, v, k) {
    var S = Math.floor((m - p) / 2) + p, $ = v(b, y[S], !0);
    return $ === 0 ? S : $ > 0 ? m - S > 1 ? f(S, m, b, y, v, k) : k == l.LEAST_UPPER_BOUND ? m < y.length ? m : -1 : S : S - p > 1 ? f(p, S, b, y, v, k) : k == l.LEAST_UPPER_BOUND ? S : p < 0 ? -1 : p;
  }
  l.GREATEST_LOWER_BOUND = 1, l.LEAST_UPPER_BOUND = 2, l.search = function(p, m, b, y) {
    if (m.length === 0)
      return -1;
    var v = f(-1, m.length, p, m, b, y || l.GREATEST_LOWER_BOUND);
    if (v < 0)
      return -1;
    for (; v - 1 >= 0 && b(m[v], m[v - 1], !0) === 0; )
      --v;
    return v;
  };
});
function swap$1(u, l, f) {
  var p = u[l];
  u[l] = u[f], u[f] = p;
}
function randomIntInRange(u, l) {
  return Math.round(u + Math.random() * (l - u));
}
function doQuickSort(u, l, f, p) {
  if (f < p) {
    var m = f - 1;
    swap$1(u, randomIntInRange(f, p), p);
    for (var b = u[p], y = f; y < p; y++)
      l(u[y], b) <= 0 && swap$1(u, m += 1, y);
    swap$1(u, m + 1, y);
    var v = m + 1;
    doQuickSort(u, l, f, v - 1), doQuickSort(u, l, v + 1, p);
  }
}
var quickSort_1 = function(u, l) {
  doQuickSort(u, l, 0, u.length - 1);
}, quickSort$1 = { quickSort: quickSort_1 }, ArraySet = arraySet.ArraySet, quickSort = quickSort$1.quickSort;
function SourceMapConsumer$1(u, l) {
  var f = u;
  return typeof u == "string" && (f = util$1.parseSourceMapInput(u)), f.sections != null ? new IndexedSourceMapConsumer(f, l) : new BasicSourceMapConsumer(f, l);
}
SourceMapConsumer$1.fromSourceMap = function(u, l) {
  return BasicSourceMapConsumer.fromSourceMap(u, l);
}, SourceMapConsumer$1.prototype._version = 3, SourceMapConsumer$1.prototype.__generatedMappings = null, Object.defineProperty(SourceMapConsumer$1.prototype, "_generatedMappings", { configurable: !0, enumerable: !0, get: function() {
  return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
} }), SourceMapConsumer$1.prototype.__originalMappings = null, Object.defineProperty(SourceMapConsumer$1.prototype, "_originalMappings", { configurable: !0, enumerable: !0, get: function() {
  return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
} }), SourceMapConsumer$1.prototype._charIsMappingSeparator = function(u, l) {
  var f = u.charAt(l);
  return f === ";" || f === ",";
}, SourceMapConsumer$1.prototype._parseMappings = function(u, l) {
  throw new Error("Subclasses must implement _parseMappings");
}, SourceMapConsumer$1.GENERATED_ORDER = 1, SourceMapConsumer$1.ORIGINAL_ORDER = 2, SourceMapConsumer$1.GREATEST_LOWER_BOUND = 1, SourceMapConsumer$1.LEAST_UPPER_BOUND = 2, SourceMapConsumer$1.prototype.eachMapping = function(u, l, f) {
  var p, m = l || null;
  switch (f || SourceMapConsumer$1.GENERATED_ORDER) {
    case SourceMapConsumer$1.GENERATED_ORDER:
      p = this._generatedMappings;
      break;
    case SourceMapConsumer$1.ORIGINAL_ORDER:
      p = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }
  var b = this.sourceRoot;
  p.map(function(y) {
    var v = y.source === null ? null : this._sources.at(y.source);
    return { source: v = util$1.computeSourceURL(b, v, this._sourceMapURL), generatedLine: y.generatedLine, generatedColumn: y.generatedColumn, originalLine: y.originalLine, originalColumn: y.originalColumn, name: y.name === null ? null : this._names.at(y.name) };
  }, this).forEach(u, m);
}, SourceMapConsumer$1.prototype.allGeneratedPositionsFor = function(u) {
  var l = util$1.getArg(u, "line"), f = { source: util$1.getArg(u, "source"), originalLine: l, originalColumn: util$1.getArg(u, "column", 0) };
  if (f.source = this._findSourceIndex(f.source), f.source < 0)
    return [];
  var p = [], m = this._findMapping(f, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
  if (m >= 0) {
    var b = this._originalMappings[m];
    if (u.column === void 0)
      for (var y = b.originalLine; b && b.originalLine === y; )
        p.push({ line: util$1.getArg(b, "generatedLine", null), column: util$1.getArg(b, "generatedColumn", null), lastColumn: util$1.getArg(b, "lastGeneratedColumn", null) }), b = this._originalMappings[++m];
    else
      for (var v = b.originalColumn; b && b.originalLine === l && b.originalColumn == v; )
        p.push({ line: util$1.getArg(b, "generatedLine", null), column: util$1.getArg(b, "generatedColumn", null), lastColumn: util$1.getArg(b, "lastGeneratedColumn", null) }), b = this._originalMappings[++m];
  }
  return p;
};
var SourceMapConsumer_1 = SourceMapConsumer$1;
function BasicSourceMapConsumer(u, l) {
  var f = u;
  typeof u == "string" && (f = util$1.parseSourceMapInput(u));
  var p = util$1.getArg(f, "version"), m = util$1.getArg(f, "sources"), b = util$1.getArg(f, "names", []), y = util$1.getArg(f, "sourceRoot", null), v = util$1.getArg(f, "sourcesContent", null), k = util$1.getArg(f, "mappings"), S = util$1.getArg(f, "file", null);
  if (p != this._version)
    throw new Error("Unsupported version: " + p);
  y && (y = util$1.normalize(y)), m = m.map(String).map(util$1.normalize).map(function($) {
    return y && util$1.isAbsolute(y) && util$1.isAbsolute($) ? util$1.relative(y, $) : $;
  }), this._names = ArraySet.fromArray(b.map(String), !0), this._sources = ArraySet.fromArray(m, !0), this._absoluteSources = this._sources.toArray().map(function($) {
    return util$1.computeSourceURL(y, $, l);
  }), this.sourceRoot = y, this.sourcesContent = v, this._mappings = k, this._sourceMapURL = l, this.file = S;
}
function Mapping() {
  this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
}
function IndexedSourceMapConsumer(u, l) {
  var f = u;
  typeof u == "string" && (f = util$1.parseSourceMapInput(u));
  var p = util$1.getArg(f, "version"), m = util$1.getArg(f, "sections");
  if (p != this._version)
    throw new Error("Unsupported version: " + p);
  this._sources = new ArraySet(), this._names = new ArraySet();
  var b = { line: -1, column: 0 };
  this._sections = m.map(function(y) {
    if (y.url)
      throw new Error("Support for url field in sections not implemented.");
    var v = util$1.getArg(y, "offset"), k = util$1.getArg(v, "line"), S = util$1.getArg(v, "column");
    if (k < b.line || k === b.line && S < b.column)
      throw new Error("Section offsets must be ordered and non-overlapping.");
    return b = v, { generatedOffset: { generatedLine: k + 1, generatedColumn: S + 1 }, consumer: new SourceMapConsumer$1(util$1.getArg(y, "map"), l) };
  });
}
BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype), BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$1, BasicSourceMapConsumer.prototype._findSourceIndex = function(u) {
  var l, f = u;
  if (this.sourceRoot != null && (f = util$1.relative(this.sourceRoot, f)), this._sources.has(f))
    return this._sources.indexOf(f);
  for (l = 0; l < this._absoluteSources.length; ++l)
    if (this._absoluteSources[l] == u)
      return l;
  return -1;
}, BasicSourceMapConsumer.fromSourceMap = function(u, l) {
  var f = Object.create(BasicSourceMapConsumer.prototype), p = f._names = ArraySet.fromArray(u._names.toArray(), !0), m = f._sources = ArraySet.fromArray(u._sources.toArray(), !0);
  f.sourceRoot = u._sourceRoot, f.sourcesContent = u._generateSourcesContent(f._sources.toArray(), f.sourceRoot), f.file = u._file, f._sourceMapURL = l, f._absoluteSources = f._sources.toArray().map(function(T) {
    return util$1.computeSourceURL(f.sourceRoot, T, l);
  });
  for (var b = u._mappings.toArray().slice(), y = f.__generatedMappings = [], v = f.__originalMappings = [], k = 0, S = b.length; k < S; k++) {
    var $ = b[k], w = new Mapping();
    w.generatedLine = $.generatedLine, w.generatedColumn = $.generatedColumn, $.source && (w.source = m.indexOf($.source), w.originalLine = $.originalLine, w.originalColumn = $.originalColumn, $.name && (w.name = p.indexOf($.name)), v.push(w)), y.push(w);
  }
  return quickSort(f.__originalMappings, util$1.compareByOriginalPositions), f;
}, BasicSourceMapConsumer.prototype._version = 3, Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", { get: function() {
  return this._absoluteSources.slice();
} }), BasicSourceMapConsumer.prototype._parseMappings = function(u, l) {
  for (var f, p, m, b, y, v = 1, k = 0, S = 0, $ = 0, w = 0, T = 0, E = u.length, R = 0, O = {}, P = {}, L = [], M = []; R < E; )
    if (u.charAt(R) === ";")
      v++, R++, k = 0;
    else if (u.charAt(R) === ",")
      R++;
    else {
      for ((f = new Mapping()).generatedLine = v, b = R; b < E && !this._charIsMappingSeparator(u, b); b++)
        ;
      if (m = O[p = u.slice(R, b)])
        R += p.length;
      else {
        for (m = []; R < b; )
          base64Vlq.decode(u, R, P), y = P.value, R = P.rest, m.push(y);
        if (m.length === 2)
          throw new Error("Found a source, but no line and column");
        if (m.length === 3)
          throw new Error("Found a source and line, but no column");
        O[p] = m;
      }
      f.generatedColumn = k + m[0], k = f.generatedColumn, m.length > 1 && (f.source = w + m[1], w += m[1], f.originalLine = S + m[2], S = f.originalLine, f.originalLine += 1, f.originalColumn = $ + m[3], $ = f.originalColumn, m.length > 4 && (f.name = T + m[4], T += m[4])), M.push(f), typeof f.originalLine == "number" && L.push(f);
    }
  quickSort(M, util$1.compareByGeneratedPositionsDeflated), this.__generatedMappings = M, quickSort(L, util$1.compareByOriginalPositions), this.__originalMappings = L;
}, BasicSourceMapConsumer.prototype._findMapping = function(u, l, f, p, m, b) {
  if (u[f] <= 0)
    throw new TypeError("Line must be greater than or equal to 1, got " + u[f]);
  if (u[p] < 0)
    throw new TypeError("Column must be greater than or equal to 0, got " + u[p]);
  return binarySearch.search(u, l, m, b);
}, BasicSourceMapConsumer.prototype.computeColumnSpans = function() {
  for (var u = 0; u < this._generatedMappings.length; ++u) {
    var l = this._generatedMappings[u];
    if (u + 1 < this._generatedMappings.length) {
      var f = this._generatedMappings[u + 1];
      if (l.generatedLine === f.generatedLine) {
        l.lastGeneratedColumn = f.generatedColumn - 1;
        continue;
      }
    }
    l.lastGeneratedColumn = 1 / 0;
  }
}, BasicSourceMapConsumer.prototype.originalPositionFor = function(u) {
  var l = { generatedLine: util$1.getArg(u, "line"), generatedColumn: util$1.getArg(u, "column") }, f = this._findMapping(l, this._generatedMappings, "generatedLine", "generatedColumn", util$1.compareByGeneratedPositionsDeflated, util$1.getArg(u, "bias", SourceMapConsumer$1.GREATEST_LOWER_BOUND));
  if (f >= 0) {
    var p = this._generatedMappings[f];
    if (p.generatedLine === l.generatedLine) {
      var m = util$1.getArg(p, "source", null);
      m !== null && (m = this._sources.at(m), m = util$1.computeSourceURL(this.sourceRoot, m, this._sourceMapURL));
      var b = util$1.getArg(p, "name", null);
      return b !== null && (b = this._names.at(b)), { source: m, line: util$1.getArg(p, "originalLine", null), column: util$1.getArg(p, "originalColumn", null), name: b };
    }
  }
  return { source: null, line: null, column: null, name: null };
}, BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
  return !!this.sourcesContent && this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(u) {
    return u == null;
  });
}, BasicSourceMapConsumer.prototype.sourceContentFor = function(u, l) {
  if (!this.sourcesContent)
    return null;
  var f = this._findSourceIndex(u);
  if (f >= 0)
    return this.sourcesContent[f];
  var p, m = u;
  if (this.sourceRoot != null && (m = util$1.relative(this.sourceRoot, m)), this.sourceRoot != null && (p = util$1.urlParse(this.sourceRoot))) {
    var b = m.replace(/^file:\/\//, "");
    if (p.scheme == "file" && this._sources.has(b))
      return this.sourcesContent[this._sources.indexOf(b)];
    if ((!p.path || p.path == "/") && this._sources.has("/" + m))
      return this.sourcesContent[this._sources.indexOf("/" + m)];
  }
  if (l)
    return null;
  throw new Error('"' + m + '" is not in the SourceMap.');
}, BasicSourceMapConsumer.prototype.generatedPositionFor = function(u) {
  var l = util$1.getArg(u, "source");
  if ((l = this._findSourceIndex(l)) < 0)
    return { line: null, column: null, lastColumn: null };
  var f = { source: l, originalLine: util$1.getArg(u, "line"), originalColumn: util$1.getArg(u, "column") }, p = this._findMapping(f, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, util$1.getArg(u, "bias", SourceMapConsumer$1.GREATEST_LOWER_BOUND));
  if (p >= 0) {
    var m = this._originalMappings[p];
    if (m.source === f.source)
      return { line: util$1.getArg(m, "generatedLine", null), column: util$1.getArg(m, "generatedColumn", null), lastColumn: util$1.getArg(m, "lastGeneratedColumn", null) };
  }
  return { line: null, column: null, lastColumn: null };
}, IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype), IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$1, IndexedSourceMapConsumer.prototype._version = 3, Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", { get: function() {
  for (var u = [], l = 0; l < this._sections.length; l++)
    for (var f = 0; f < this._sections[l].consumer.sources.length; f++)
      u.push(this._sections[l].consumer.sources[f]);
  return u;
} }), IndexedSourceMapConsumer.prototype.originalPositionFor = function(u) {
  var l = { generatedLine: util$1.getArg(u, "line"), generatedColumn: util$1.getArg(u, "column") }, f = binarySearch.search(l, this._sections, function(m, b) {
    var y = m.generatedLine - b.generatedOffset.generatedLine;
    return y || m.generatedColumn - b.generatedOffset.generatedColumn;
  }), p = this._sections[f];
  return p ? p.consumer.originalPositionFor({ line: l.generatedLine - (p.generatedOffset.generatedLine - 1), column: l.generatedColumn - (p.generatedOffset.generatedLine === l.generatedLine ? p.generatedOffset.generatedColumn - 1 : 0), bias: u.bias }) : { source: null, line: null, column: null, name: null };
}, IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
  return this._sections.every(function(u) {
    return u.consumer.hasContentsOfAllSources();
  });
}, IndexedSourceMapConsumer.prototype.sourceContentFor = function(u, l) {
  for (var f = 0; f < this._sections.length; f++) {
    var p = this._sections[f].consumer.sourceContentFor(u, !0);
    if (p)
      return p;
  }
  if (l)
    return null;
  throw new Error('"' + u + '" is not in the SourceMap.');
}, IndexedSourceMapConsumer.prototype.generatedPositionFor = function(u) {
  for (var l = 0; l < this._sections.length; l++) {
    var f = this._sections[l];
    if (f.consumer._findSourceIndex(util$1.getArg(u, "source")) !== -1) {
      var p = f.consumer.generatedPositionFor(u);
      if (p)
        return { line: p.line + (f.generatedOffset.generatedLine - 1), column: p.column + (f.generatedOffset.generatedLine === p.line ? f.generatedOffset.generatedColumn - 1 : 0) };
    }
  }
  return { line: null, column: null };
}, IndexedSourceMapConsumer.prototype._parseMappings = function(u, l) {
  this.__generatedMappings = [], this.__originalMappings = [];
  for (var f = 0; f < this._sections.length; f++)
    for (var p = this._sections[f], m = p.consumer._generatedMappings, b = 0; b < m.length; b++) {
      var y = m[b], v = p.consumer._sources.at(y.source);
      v = util$1.computeSourceURL(p.consumer.sourceRoot, v, this._sourceMapURL), this._sources.add(v), v = this._sources.indexOf(v);
      var k = null;
      y.name && (k = p.consumer._names.at(y.name), this._names.add(k), k = this._names.indexOf(k));
      var S = { source: v, generatedLine: y.generatedLine + (p.generatedOffset.generatedLine - 1), generatedColumn: y.generatedColumn + (p.generatedOffset.generatedLine === y.generatedLine ? p.generatedOffset.generatedColumn - 1 : 0), originalLine: y.originalLine, originalColumn: y.originalColumn, name: k };
      this.__generatedMappings.push(S), typeof S.originalLine == "number" && this.__originalMappings.push(S);
    }
  quickSort(this.__generatedMappings, util$1.compareByGeneratedPositionsDeflated), quickSort(this.__originalMappings, util$1.compareByOriginalPositions);
};
var sourceMapConsumer = { SourceMapConsumer: SourceMapConsumer_1 }, SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator, REGEX_NEWLINE = /(\r?\n)/, NEWLINE_CODE = 10, isSourceNode = "$$$isSourceNode$$$";
function SourceNode$1(u, l, f, p, m) {
  this.children = [], this.sourceContents = {}, this.line = u ?? null, this.column = l ?? null, this.source = f ?? null, this.name = m ?? null, this[isSourceNode] = !0, p != null && this.add(p);
}
SourceNode$1.fromStringWithSourceMap = function(u, l, f) {
  var p = new SourceNode$1(), m = u.split(REGEX_NEWLINE), b = 0, y = function() {
    return w() + (w() || "");
    function w() {
      return b < m.length ? m[b++] : void 0;
    }
  }, v = 1, k = 0, S = null;
  return l.eachMapping(function(w) {
    if (S !== null) {
      if (!(v < w.generatedLine)) {
        var T = (E = m[b] || "").substr(0, w.generatedColumn - k);
        return m[b] = E.substr(w.generatedColumn - k), k = w.generatedColumn, $(S, T), void (S = w);
      }
      $(S, y()), v++, k = 0;
    }
    for (; v < w.generatedLine; )
      p.add(y()), v++;
    if (k < w.generatedColumn) {
      var E = m[b] || "";
      p.add(E.substr(0, w.generatedColumn)), m[b] = E.substr(w.generatedColumn), k = w.generatedColumn;
    }
    S = w;
  }, this), b < m.length && (S && $(S, y()), p.add(m.splice(b).join(""))), l.sources.forEach(function(w) {
    var T = l.sourceContentFor(w);
    T != null && (f != null && (w = util$1.join(f, w)), p.setSourceContent(w, T));
  }), p;
  function $(w, T) {
    if (w === null || w.source === void 0)
      p.add(T);
    else {
      var E = f ? util$1.join(f, w.source) : w.source;
      p.add(new SourceNode$1(w.originalLine, w.originalColumn, E, T, w.name));
    }
  }
}, SourceNode$1.prototype.add = function(u) {
  if (Array.isArray(u))
    u.forEach(function(l) {
      this.add(l);
    }, this);
  else {
    if (!u[isSourceNode] && typeof u != "string")
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + u);
    u && this.children.push(u);
  }
  return this;
}, SourceNode$1.prototype.prepend = function(u) {
  if (Array.isArray(u))
    for (var l = u.length - 1; l >= 0; l--)
      this.prepend(u[l]);
  else {
    if (!u[isSourceNode] && typeof u != "string")
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + u);
    this.children.unshift(u);
  }
  return this;
}, SourceNode$1.prototype.walk = function(u) {
  for (var l, f = 0, p = this.children.length; f < p; f++)
    (l = this.children[f])[isSourceNode] ? l.walk(u) : l !== "" && u(l, { source: this.source, line: this.line, column: this.column, name: this.name });
}, SourceNode$1.prototype.join = function(u) {
  var l, f, p = this.children.length;
  if (p > 0) {
    for (l = [], f = 0; f < p - 1; f++)
      l.push(this.children[f]), l.push(u);
    l.push(this.children[f]), this.children = l;
  }
  return this;
}, SourceNode$1.prototype.replaceRight = function(u, l) {
  var f = this.children[this.children.length - 1];
  return f[isSourceNode] ? f.replaceRight(u, l) : typeof f == "string" ? this.children[this.children.length - 1] = f.replace(u, l) : this.children.push("".replace(u, l)), this;
}, SourceNode$1.prototype.setSourceContent = function(u, l) {
  this.sourceContents[util$1.toSetString(u)] = l;
}, SourceNode$1.prototype.walkSourceContents = function(u) {
  for (var l = 0, f = this.children.length; l < f; l++)
    this.children[l][isSourceNode] && this.children[l].walkSourceContents(u);
  var p = Object.keys(this.sourceContents);
  for (l = 0, f = p.length; l < f; l++)
    u(util$1.fromSetString(p[l]), this.sourceContents[p[l]]);
}, SourceNode$1.prototype.toString = function() {
  var u = "";
  return this.walk(function(l) {
    u += l;
  }), u;
}, SourceNode$1.prototype.toStringWithSourceMap = function(u) {
  var l = { code: "", line: 1, column: 0 }, f = new SourceMapGenerator$1(u), p = !1, m = null, b = null, y = null, v = null;
  return this.walk(function(k, S) {
    l.code += k, S.source !== null && S.line !== null && S.column !== null ? (m === S.source && b === S.line && y === S.column && v === S.name || f.addMapping({ source: S.source, original: { line: S.line, column: S.column }, generated: { line: l.line, column: l.column }, name: S.name }), m = S.source, b = S.line, y = S.column, v = S.name, p = !0) : p && (f.addMapping({ generated: { line: l.line, column: l.column } }), m = null, p = !1);
    for (var $ = 0, w = k.length; $ < w; $++)
      k.charCodeAt($) === NEWLINE_CODE ? (l.line++, l.column = 0, $ + 1 === w ? (m = null, p = !1) : p && f.addMapping({ source: S.source, original: { line: S.line, column: S.column }, generated: { line: l.line, column: l.column }, name: S.name })) : l.column++;
  }), this.walkSourceContents(function(k, S) {
    f.setSourceContent(k, S);
  }), { code: l.code, map: f };
};
var SourceNode_1 = SourceNode$1, sourceNode = { SourceNode: SourceNode_1 }, SourceMapGenerator = sourceMapGenerator.SourceMapGenerator, SourceMapConsumer = sourceMapConsumer.SourceMapConsumer, SourceNode = sourceNode.SourceNode, sourceMap = { SourceMapGenerator, SourceMapConsumer, SourceNode }, codeGen = createCommonjsModule(function(u, l) {
  l.__esModule = !0;
  var f = void 0;
  try {
    f = sourceMap.SourceNode;
  } catch {
  }
  function p(b, y, v) {
    if (utils$3.isArray(b)) {
      for (var k = [], S = 0, $ = b.length; S < $; S++)
        k.push(y.wrap(b[S], v));
      return k;
    }
    return typeof b == "boolean" || typeof b == "number" ? b + "" : b;
  }
  function m(b) {
    this.srcFile = b, this.source = [];
  }
  f || ((f = function(b, y, v, k) {
    this.src = "", k && this.add(k);
  }).prototype = { add: function(b) {
    utils$3.isArray(b) && (b = b.join("")), this.src += b;
  }, prepend: function(b) {
    utils$3.isArray(b) && (b = b.join("")), this.src = b + this.src;
  }, toStringWithSourceMap: function() {
    return { code: this.toString() };
  }, toString: function() {
    return this.src;
  } }), m.prototype = { isEmpty: function() {
    return !this.source.length;
  }, prepend: function(b, y) {
    this.source.unshift(this.wrap(b, y));
  }, push: function(b, y) {
    this.source.push(this.wrap(b, y));
  }, merge: function() {
    var b = this.empty();
    return this.each(function(y) {
      b.add(["  ", y, `
`]);
    }), b;
  }, each: function(b) {
    for (var y = 0, v = this.source.length; y < v; y++)
      b(this.source[y]);
  }, empty: function() {
    var b = this.currentLocation || { start: {} };
    return new f(b.start.line, b.start.column, this.srcFile);
  }, wrap: function(b) {
    var y = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
    return b instanceof f ? b : (b = p(b, this, y), new f(y.start.line, y.start.column, this.srcFile, b));
  }, functionCall: function(b, y, v) {
    return v = this.generateList(v), this.wrap([b, y ? "." + y + "(" : "(", v, ")"]);
  }, quotedString: function(b) {
    return '"' + (b + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
  }, objectLiteral: function(b) {
    var y = this, v = [];
    Object.keys(b).forEach(function(S) {
      var $ = p(b[S], y);
      $ !== "undefined" && v.push([y.quotedString(S), ":", $]);
    });
    var k = this.generateList(v);
    return k.prepend("{"), k.add("}"), k;
  }, generateList: function(b) {
    for (var y = this.empty(), v = 0, k = b.length; v < k; v++)
      v && y.add(","), y.add(p(b[v], this));
    return y;
  }, generateArray: function(b) {
    var y = this.generateList(b);
    return y.prepend("["), y.add("]"), y;
  } }, l.default = m, u.exports = l.default;
}), javascriptCompiler = createCommonjsModule(function(u, l) {
  function f(v) {
    return v && v.__esModule ? v : { default: v };
  }
  l.__esModule = !0;
  var p = f(exception), m = f(codeGen);
  function b(v) {
    this.value = v;
  }
  function y() {
  }
  y.prototype = { nameLookup: function(v, k) {
    return this.internalNameLookup(v, k);
  }, depthedLookup: function(v) {
    return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(v), ")"];
  }, compilerInfo: function() {
    var v = base$2.COMPILER_REVISION;
    return [v, base$2.REVISION_CHANGES[v]];
  }, appendToBuffer: function(v, k, S) {
    return utils$3.isArray(v) || (v = [v]), v = this.source.wrap(v, k), this.environment.isSimple ? ["return ", v, ";"] : S ? ["buffer += ", v, ";"] : (v.appendToBuffer = !0, v);
  }, initializeBuffer: function() {
    return this.quotedString("");
  }, internalNameLookup: function(v, k) {
    return this.lookupPropertyFunctionIsUsed = !0, ["lookupProperty(", v, ",", JSON.stringify(k), ")"];
  }, lookupPropertyFunctionIsUsed: !1, compile: function(v, k, S, $) {
    this.environment = v, this.options = k, this.stringParams = this.options.stringParams, this.trackIds = this.options.trackIds, this.precompile = !$, this.name = this.environment.name, this.isChild = !!S, this.context = S || { decorators: [], programs: [], environments: [] }, this.preamble(), this.stackSlot = 0, this.stackVars = [], this.aliases = {}, this.registers = { list: [] }, this.hashes = [], this.compileStack = [], this.inlineStack = [], this.blockParams = [], this.compileChildren(v, k), this.useDepths = this.useDepths || v.useDepths || v.useDecorators || this.options.compat, this.useBlockParams = this.useBlockParams || v.useBlockParams;
    var w = v.opcodes, T = void 0, E = void 0, R = void 0, O = void 0;
    for (R = 0, O = w.length; R < O; R++)
      T = w[R], this.source.currentLocation = T.loc, E = E || T.loc, this[T.opcode].apply(this, T.args);
    if (this.source.currentLocation = E, this.pushSource(""), this.stackSlot || this.inlineStack.length || this.compileStack.length)
      throw new p.default("Compile completed with content left on stack");
    this.decorators.isEmpty() ? this.decorators = void 0 : (this.useDecorators = !0, this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), `;
`]), this.decorators.push("return fn;"), $ ? this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]) : (this.decorators.prepend(`function(fn, props, container, depth0, data, blockParams, depths) {
`), this.decorators.push(`}
`), this.decorators = this.decorators.merge()));
    var P = this.createFunctionContext($);
    if (this.isChild)
      return P;
    var L = { compiler: this.compilerInfo(), main: P };
    this.decorators && (L.main_d = this.decorators, L.useDecorators = !0);
    var M = this.context, B = M.programs, j = M.decorators;
    for (R = 0, O = B.length; R < O; R++)
      B[R] && (L[R] = B[R], j[R] && (L[R + "_d"] = j[R], L.useDecorators = !0));
    return this.environment.usePartial && (L.usePartial = !0), this.options.data && (L.useData = !0), this.useDepths && (L.useDepths = !0), this.useBlockParams && (L.useBlockParams = !0), this.options.compat && (L.compat = !0), $ ? L.compilerOptions = this.options : (L.compiler = JSON.stringify(L.compiler), this.source.currentLocation = { start: { line: 1, column: 0 } }, L = this.objectLiteral(L), k.srcName ? (L = L.toStringWithSourceMap({ file: k.destName })).map = L.map && L.map.toString() : L = L.toString()), L;
  }, preamble: function() {
    this.lastContext = 0, this.source = new m.default(this.options.srcName), this.decorators = new m.default(this.options.srcName);
  }, createFunctionContext: function(v) {
    var k = this, S = "", $ = this.stackVars.concat(this.registers.list);
    $.length > 0 && (S += ", " + $.join(", "));
    var w = 0;
    Object.keys(this.aliases).forEach(function(R) {
      var O = k.aliases[R];
      O.children && O.referenceCount > 1 && (S += ", alias" + ++w + "=" + R, O.children[0] = "alias" + w);
    }), this.lookupPropertyFunctionIsUsed && (S += ", " + this.lookupPropertyFunctionVarDeclaration());
    var T = ["container", "depth0", "helpers", "partials", "data"];
    (this.useBlockParams || this.useDepths) && T.push("blockParams"), this.useDepths && T.push("depths");
    var E = this.mergeSource(S);
    return v ? (T.push(E), Function.apply(this, T)) : this.source.wrap(["function(", T.join(","), `) {
  `, E, "}"]);
  }, mergeSource: function(v) {
    var k = this.environment.isSimple, S = !this.forceBuffer, $ = void 0, w = void 0, T = void 0, E = void 0;
    return this.source.each(function(R) {
      R.appendToBuffer ? (T ? R.prepend("  + ") : T = R, E = R) : (T && (w ? T.prepend("buffer += ") : $ = !0, E.add(";"), T = E = void 0), w = !0, k || (S = !1));
    }), S ? T ? (T.prepend("return "), E.add(";")) : w || this.source.push('return "";') : (v += ", buffer = " + ($ ? "" : this.initializeBuffer()), T ? (T.prepend("return buffer + "), E.add(";")) : this.source.push("return buffer;")), v && this.source.prepend("var " + v.substring(2) + ($ ? "" : `;
`)), this.source.merge();
  }, lookupPropertyFunctionVarDeclaration: function() {
    return `
      lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    }
    `.trim();
  }, blockValue: function(v) {
    var k = this.aliasable("container.hooks.blockHelperMissing"), S = [this.contextName(0)];
    this.setupHelperArgs(v, 0, S);
    var $ = this.popStack();
    S.splice(1, 0, $), this.push(this.source.functionCall(k, "call", S));
  }, ambiguousBlockValue: function() {
    var v = this.aliasable("container.hooks.blockHelperMissing"), k = [this.contextName(0)];
    this.setupHelperArgs("", 0, k, !0), this.flushInline();
    var S = this.topStack();
    k.splice(1, 0, S), this.pushSource(["if (!", this.lastHelper, ") { ", S, " = ", this.source.functionCall(v, "call", k), "}"]);
  }, appendContent: function(v) {
    this.pendingContent ? v = this.pendingContent + v : this.pendingLocation = this.source.currentLocation, this.pendingContent = v;
  }, append: function() {
    if (this.isInline())
      this.replaceStack(function(k) {
        return [" != null ? ", k, ' : ""'];
      }), this.pushSource(this.appendToBuffer(this.popStack()));
    else {
      var v = this.popStack();
      this.pushSource(["if (", v, " != null) { ", this.appendToBuffer(v, void 0, !0), " }"]), this.environment.isSimple && this.pushSource(["else { ", this.appendToBuffer("''", void 0, !0), " }"]);
    }
  }, appendEscaped: function() {
    this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
  }, getContext: function(v) {
    this.lastContext = v;
  }, pushContext: function() {
    this.pushStackLiteral(this.contextName(this.lastContext));
  }, lookupOnContext: function(v, k, S, $) {
    var w = 0;
    $ || !this.options.compat || this.lastContext ? this.pushContext() : this.push(this.depthedLookup(v[w++])), this.resolvePath("context", v, w, k, S);
  }, lookupBlockParam: function(v, k) {
    this.useBlockParams = !0, this.push(["blockParams[", v[0], "][", v[1], "]"]), this.resolvePath("context", k, 1);
  }, lookupData: function(v, k, S) {
    v ? this.pushStackLiteral("container.data(data, " + v + ")") : this.pushStackLiteral("data"), this.resolvePath("data", k, 0, !0, S);
  }, resolvePath: function(v, k, S, $, w) {
    var T = this;
    if (this.options.strict || this.options.assumeObjects)
      this.push(function(R, O, P, L, M) {
        var B = O.popStack(), j = P.length;
        for (R && j--; L < j; L++)
          B = O.nameLookup(B, P[L], M);
        return R ? [O.aliasable("container.strict"), "(", B, ", ", O.quotedString(P[L]), ", ", JSON.stringify(O.source.currentLocation), " )"] : B;
      }(this.options.strict && w, this, k, S, v));
    else
      for (var E = k.length; S < E; S++)
        this.replaceStack(function(R) {
          var O = T.nameLookup(R, k[S], v);
          return $ ? [" && ", O] : [" != null ? ", O, " : ", R];
        });
  }, resolvePossibleLambda: function() {
    this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
  }, pushStringParam: function(v, k) {
    this.pushContext(), this.pushString(k), k !== "SubExpression" && (typeof v == "string" ? this.pushString(v) : this.pushStackLiteral(v));
  }, emptyHash: function(v) {
    this.trackIds && this.push("{}"), this.stringParams && (this.push("{}"), this.push("{}")), this.pushStackLiteral(v ? "undefined" : "{}");
  }, pushHash: function() {
    this.hash && this.hashes.push(this.hash), this.hash = { values: {}, types: [], contexts: [], ids: [] };
  }, popHash: function() {
    var v = this.hash;
    this.hash = this.hashes.pop(), this.trackIds && this.push(this.objectLiteral(v.ids)), this.stringParams && (this.push(this.objectLiteral(v.contexts)), this.push(this.objectLiteral(v.types))), this.push(this.objectLiteral(v.values));
  }, pushString: function(v) {
    this.pushStackLiteral(this.quotedString(v));
  }, pushLiteral: function(v) {
    this.pushStackLiteral(v);
  }, pushProgram: function(v) {
    v != null ? this.pushStackLiteral(this.programExpression(v)) : this.pushStackLiteral(null);
  }, registerDecorator: function(v, k) {
    var S = this.nameLookup("decorators", k, "decorator"), $ = this.setupHelperArgs(k, v);
    this.decorators.push(["fn = ", this.decorators.functionCall(S, "", ["fn", "props", "container", $]), " || fn;"]);
  }, invokeHelper: function(v, k, S) {
    var $ = this.popStack(), w = this.setupHelper(v, k), T = [];
    S && T.push(w.name), T.push($), this.options.strict || T.push(this.aliasable("container.hooks.helperMissing"));
    var E = ["(", this.itemsSeparatedBy(T, "||"), ")"], R = this.source.functionCall(E, "call", w.callParams);
    this.push(R);
  }, itemsSeparatedBy: function(v, k) {
    var S = [];
    S.push(v[0]);
    for (var $ = 1; $ < v.length; $++)
      S.push(k, v[$]);
    return S;
  }, invokeKnownHelper: function(v, k) {
    var S = this.setupHelper(v, k);
    this.push(this.source.functionCall(S.name, "call", S.callParams));
  }, invokeAmbiguous: function(v, k) {
    this.useRegister("helper");
    var S = this.popStack();
    this.emptyHash();
    var $ = this.setupHelper(0, v, k), w = ["(", "(helper = ", this.lastHelper = this.nameLookup("helpers", v, "helper"), " || ", S, ")"];
    this.options.strict || (w[0] = "(helper = ", w.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"))), this.push(["(", w, $.paramsInit ? ["),(", $.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", $.callParams), " : helper))"]);
  }, invokePartial: function(v, k, S) {
    var $ = [], w = this.setupParams(k, 1, $);
    v && (k = this.popStack(), delete w.name), S && (w.indent = JSON.stringify(S)), w.helpers = "helpers", w.partials = "partials", w.decorators = "container.decorators", v ? $.unshift(k) : $.unshift(this.nameLookup("partials", k, "partial")), this.options.compat && (w.depths = "depths"), w = this.objectLiteral(w), $.push(w), this.push(this.source.functionCall("container.invokePartial", "", $));
  }, assignToHash: function(v) {
    var k = this.popStack(), S = void 0, $ = void 0, w = void 0;
    this.trackIds && (w = this.popStack()), this.stringParams && ($ = this.popStack(), S = this.popStack());
    var T = this.hash;
    S && (T.contexts[v] = S), $ && (T.types[v] = $), w && (T.ids[v] = w), T.values[v] = k;
  }, pushId: function(v, k, S) {
    v === "BlockParam" ? this.pushStackLiteral("blockParams[" + k[0] + "].path[" + k[1] + "]" + (S ? " + " + JSON.stringify("." + S) : "")) : v === "PathExpression" ? this.pushString(k) : v === "SubExpression" ? this.pushStackLiteral("true") : this.pushStackLiteral("null");
  }, compiler: y, compileChildren: function(v, k) {
    for (var S = v.children, $ = void 0, w = void 0, T = 0, E = S.length; T < E; T++) {
      $ = S[T], w = new this.compiler();
      var R = this.matchExistingProgram($);
      if (R == null) {
        this.context.programs.push("");
        var O = this.context.programs.length;
        $.index = O, $.name = "program" + O, this.context.programs[O] = w.compile($, k, this.context, !this.precompile), this.context.decorators[O] = w.decorators, this.context.environments[O] = $, this.useDepths = this.useDepths || w.useDepths, this.useBlockParams = this.useBlockParams || w.useBlockParams, $.useDepths = this.useDepths, $.useBlockParams = this.useBlockParams;
      } else
        $.index = R.index, $.name = "program" + R.index, this.useDepths = this.useDepths || R.useDepths, this.useBlockParams = this.useBlockParams || R.useBlockParams;
    }
  }, matchExistingProgram: function(v) {
    for (var k = 0, S = this.context.environments.length; k < S; k++) {
      var $ = this.context.environments[k];
      if ($ && $.equals(v))
        return $;
    }
  }, programExpression: function(v) {
    var k = this.environment.children[v], S = [k.index, "data", k.blockParams];
    return (this.useBlockParams || this.useDepths) && S.push("blockParams"), this.useDepths && S.push("depths"), "container.program(" + S.join(", ") + ")";
  }, useRegister: function(v) {
    this.registers[v] || (this.registers[v] = !0, this.registers.list.push(v));
  }, push: function(v) {
    return v instanceof b || (v = this.source.wrap(v)), this.inlineStack.push(v), v;
  }, pushStackLiteral: function(v) {
    this.push(new b(v));
  }, pushSource: function(v) {
    this.pendingContent && (this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation)), this.pendingContent = void 0), v && this.source.push(v);
  }, replaceStack: function(v) {
    var k = ["("], S = void 0, $ = void 0, w = void 0;
    if (!this.isInline())
      throw new p.default("replaceStack on non-inline");
    var T = this.popStack(!0);
    if (T instanceof b)
      k = ["(", S = [T.value]], w = !0;
    else {
      $ = !0;
      var E = this.incrStack();
      k = ["((", this.push(E), " = ", T, ")"], S = this.topStack();
    }
    var R = v.call(this, S);
    w || this.popStack(), $ && this.stackSlot--, this.push(k.concat(R, ")"));
  }, incrStack: function() {
    return this.stackSlot++, this.stackSlot > this.stackVars.length && this.stackVars.push("stack" + this.stackSlot), this.topStackName();
  }, topStackName: function() {
    return "stack" + this.stackSlot;
  }, flushInline: function() {
    var v = this.inlineStack;
    this.inlineStack = [];
    for (var k = 0, S = v.length; k < S; k++) {
      var $ = v[k];
      if ($ instanceof b)
        this.compileStack.push($);
      else {
        var w = this.incrStack();
        this.pushSource([w, " = ", $, ";"]), this.compileStack.push(w);
      }
    }
  }, isInline: function() {
    return this.inlineStack.length;
  }, popStack: function(v) {
    var k = this.isInline(), S = (k ? this.inlineStack : this.compileStack).pop();
    if (!v && S instanceof b)
      return S.value;
    if (!k) {
      if (!this.stackSlot)
        throw new p.default("Invalid stack pop");
      this.stackSlot--;
    }
    return S;
  }, topStack: function() {
    var v = this.isInline() ? this.inlineStack : this.compileStack, k = v[v.length - 1];
    return k instanceof b ? k.value : k;
  }, contextName: function(v) {
    return this.useDepths && v ? "depths[" + v + "]" : "depth" + v;
  }, quotedString: function(v) {
    return this.source.quotedString(v);
  }, objectLiteral: function(v) {
    return this.source.objectLiteral(v);
  }, aliasable: function(v) {
    var k = this.aliases[v];
    return k ? (k.referenceCount++, k) : ((k = this.aliases[v] = this.source.wrap(v)).aliasable = !0, k.referenceCount = 1, k);
  }, setupHelper: function(v, k, S) {
    var $ = [];
    return { params: $, paramsInit: this.setupHelperArgs(k, v, $, S), name: this.nameLookup("helpers", k, "helper"), callParams: [this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})")].concat($) };
  }, setupParams: function(v, k, S) {
    var $ = {}, w = [], T = [], E = [], R = !S, O = void 0;
    R && (S = []), $.name = this.quotedString(v), $.hash = this.popStack(), this.trackIds && ($.hashIds = this.popStack()), this.stringParams && ($.hashTypes = this.popStack(), $.hashContexts = this.popStack());
    var P = this.popStack(), L = this.popStack();
    (L || P) && ($.fn = L || "container.noop", $.inverse = P || "container.noop");
    for (var M = k; M--; )
      O = this.popStack(), S[M] = O, this.trackIds && (E[M] = this.popStack()), this.stringParams && (T[M] = this.popStack(), w[M] = this.popStack());
    return R && ($.args = this.source.generateArray(S)), this.trackIds && ($.ids = this.source.generateArray(E)), this.stringParams && ($.types = this.source.generateArray(T), $.contexts = this.source.generateArray(w)), this.options.data && ($.data = "data"), this.useBlockParams && ($.blockParams = "blockParams"), $;
  }, setupHelperArgs: function(v, k, S, $) {
    var w = this.setupParams(v, k, S);
    return w.loc = JSON.stringify(this.source.currentLocation), w = this.objectLiteral(w), $ ? (this.useRegister("options"), S.push("options"), ["options=", w]) : S ? (S.push(w), "") : w;
  } }, function() {
    for (var v = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" "), k = y.RESERVED_WORDS = {}, S = 0, $ = v.length; S < $; S++)
      k[v[S]] = !0;
  }(), y.isValidJavaScriptVariableName = function(v) {
    return !y.RESERVED_WORDS[v] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(v);
  }, l.default = y, u.exports = l.default;
}), handlebars = createCommonjsModule(function(u, l) {
  function f(w) {
    return w && w.__esModule ? w : { default: w };
  }
  l.__esModule = !0;
  var p = f(handlebars_runtime), m = f(ast), b = f(javascriptCompiler), y = f(visitor), v = f(noConflict), k = p.default.create;
  function S() {
    var w = k();
    return w.compile = function(T, E) {
      return compiler.compile(T, E, w);
    }, w.precompile = function(T, E) {
      return compiler.precompile(T, E, w);
    }, w.AST = m.default, w.Compiler = compiler.Compiler, w.JavaScriptCompiler = b.default, w.Parser = base$1.parser, w.parse = base$1.parse, w.parseWithoutProcessing = base$1.parseWithoutProcessing, w;
  }
  var $ = S();
  $.create = S, v.default($), $.Visitor = y.default, $.default = $, l.default = $, u.exports = l.default;
}), Handlebars = getDefaultExportFromCjs(handlebars);
class Helper {
  constructor(l, f, p = !0) {
    this.name = l, this.fn = f, this.useValueFallback = p;
  }
  register(l) {
    l.registerHelper(this.name, (f, p) => {
      let m = {};
      p && p.data && p.data.root && (m = p.data.root);
      const b = this.fn(f, m);
      return b ?? (this.useValueFallback ? f : null);
    });
  }
  unregister(l) {
    l.unregisterHelper(this.name);
  }
}
var lookup$3 = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, inited = !1;
function init() {
  inited = !0;
  for (var u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", l = 0; l < 64; ++l)
    lookup$3[l] = u[l], revLookup[u.charCodeAt(l)] = l;
  revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(u) {
  var l, f, p, m, b, y;
  inited || init();
  var v = u.length;
  if (v % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  b = u[v - 2] === "=" ? 2 : u[v - 1] === "=" ? 1 : 0, y = new Arr(3 * v / 4 - b), p = b > 0 ? v - 4 : v;
  var k = 0;
  for (l = 0, f = 0; l < p; l += 4, f += 3)
    m = revLookup[u.charCodeAt(l)] << 18 | revLookup[u.charCodeAt(l + 1)] << 12 | revLookup[u.charCodeAt(l + 2)] << 6 | revLookup[u.charCodeAt(l + 3)], y[k++] = m >> 16 & 255, y[k++] = m >> 8 & 255, y[k++] = 255 & m;
  return b === 2 ? (m = revLookup[u.charCodeAt(l)] << 2 | revLookup[u.charCodeAt(l + 1)] >> 4, y[k++] = 255 & m) : b === 1 && (m = revLookup[u.charCodeAt(l)] << 10 | revLookup[u.charCodeAt(l + 1)] << 4 | revLookup[u.charCodeAt(l + 2)] >> 2, y[k++] = m >> 8 & 255, y[k++] = 255 & m), y;
}
function tripletToBase64(u) {
  return lookup$3[u >> 18 & 63] + lookup$3[u >> 12 & 63] + lookup$3[u >> 6 & 63] + lookup$3[63 & u];
}
function encodeChunk(u, l, f) {
  for (var p, m = [], b = l; b < f; b += 3)
    p = (u[b] << 16) + (u[b + 1] << 8) + u[b + 2], m.push(tripletToBase64(p));
  return m.join("");
}
function fromByteArray(u) {
  var l;
  inited || init();
  for (var f = u.length, p = f % 3, m = "", b = [], y = 16383, v = 0, k = f - p; v < k; v += y)
    b.push(encodeChunk(u, v, v + y > k ? k : v + y));
  return p === 1 ? (l = u[f - 1], m += lookup$3[l >> 2], m += lookup$3[l << 4 & 63], m += "==") : p === 2 && (l = (u[f - 2] << 8) + u[f - 1], m += lookup$3[l >> 10], m += lookup$3[l >> 4 & 63], m += lookup$3[l << 2 & 63], m += "="), b.push(m), b.join("");
}
function read(u, l, f, p, m) {
  var b, y, v = 8 * m - p - 1, k = (1 << v) - 1, S = k >> 1, $ = -7, w = f ? m - 1 : 0, T = f ? -1 : 1, E = u[l + w];
  for (w += T, b = E & (1 << -$) - 1, E >>= -$, $ += v; $ > 0; b = 256 * b + u[l + w], w += T, $ -= 8)
    ;
  for (y = b & (1 << -$) - 1, b >>= -$, $ += p; $ > 0; y = 256 * y + u[l + w], w += T, $ -= 8)
    ;
  if (b === 0)
    b = 1 - S;
  else {
    if (b === k)
      return y ? NaN : 1 / 0 * (E ? -1 : 1);
    y += Math.pow(2, p), b -= S;
  }
  return (E ? -1 : 1) * y * Math.pow(2, b - p);
}
function write(u, l, f, p, m, b) {
  var y, v, k, S = 8 * b - m - 1, $ = (1 << S) - 1, w = $ >> 1, T = m === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, E = p ? 0 : b - 1, R = p ? 1 : -1, O = l < 0 || l === 0 && 1 / l < 0 ? 1 : 0;
  for (l = Math.abs(l), isNaN(l) || l === 1 / 0 ? (v = isNaN(l) ? 1 : 0, y = $) : (y = Math.floor(Math.log(l) / Math.LN2), l * (k = Math.pow(2, -y)) < 1 && (y--, k *= 2), (l += y + w >= 1 ? T / k : T * Math.pow(2, 1 - w)) * k >= 2 && (y++, k /= 2), y + w >= $ ? (v = 0, y = $) : y + w >= 1 ? (v = (l * k - 1) * Math.pow(2, m), y += w) : (v = l * Math.pow(2, w - 1) * Math.pow(2, m), y = 0)); m >= 8; u[f + E] = 255 & v, E += R, v /= 256, m -= 8)
    ;
  for (y = y << m | v, S += m; S > 0; u[f + E] = 255 & y, E += R, y /= 256, S -= 8)
    ;
  u[f + E - R] |= 128 * O;
}
var toString$3 = {}.toString, isArray$4 = Array.isArray || function(u) {
  return toString$3.call(u) == "[object Array]";
}, INSPECT_MAX_BYTES = 50;
function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(u, l) {
  if (kMaxLength() < l)
    throw new RangeError("Invalid typed array length");
  return Buffer.TYPED_ARRAY_SUPPORT ? (u = new Uint8Array(l)).__proto__ = Buffer.prototype : (u === null && (u = new Buffer(l)), u.length = l), u;
}
function Buffer(u, l, f) {
  if (!(Buffer.TYPED_ARRAY_SUPPORT || this instanceof Buffer))
    return new Buffer(u, l, f);
  if (typeof u == "number") {
    if (typeof l == "string")
      throw new Error("If encoding is specified then the first argument must be a string");
    return allocUnsafe(this, u);
  }
  return from(this, u, l, f);
}
function from(u, l, f, p) {
  if (typeof l == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && l instanceof ArrayBuffer ? fromArrayBuffer(u, l, f, p) : typeof l == "string" ? fromString(u, l, f) : fromObject(u, l);
}
function assertSize(u) {
  if (typeof u != "number")
    throw new TypeError('"size" argument must be a number');
  if (u < 0)
    throw new RangeError('"size" argument must not be negative');
}
function alloc(u, l, f, p) {
  return assertSize(l), l <= 0 ? createBuffer(u, l) : f !== void 0 ? typeof p == "string" ? createBuffer(u, l).fill(f, p) : createBuffer(u, l).fill(f) : createBuffer(u, l);
}
function allocUnsafe(u, l) {
  if (assertSize(l), u = createBuffer(u, l < 0 ? 0 : 0 | checked(l)), !Buffer.TYPED_ARRAY_SUPPORT)
    for (var f = 0; f < l; ++f)
      u[f] = 0;
  return u;
}
function fromString(u, l, f) {
  if (typeof f == "string" && f !== "" || (f = "utf8"), !Buffer.isEncoding(f))
    throw new TypeError('"encoding" must be a valid string encoding');
  var p = 0 | byteLength$1(l, f), m = (u = createBuffer(u, p)).write(l, f);
  return m !== p && (u = u.slice(0, m)), u;
}
function fromArrayLike(u, l) {
  var f = l.length < 0 ? 0 : 0 | checked(l.length);
  u = createBuffer(u, f);
  for (var p = 0; p < f; p += 1)
    u[p] = 255 & l[p];
  return u;
}
function fromArrayBuffer(u, l, f, p) {
  if (l.byteLength, f < 0 || l.byteLength < f)
    throw new RangeError("'offset' is out of bounds");
  if (l.byteLength < f + (p || 0))
    throw new RangeError("'length' is out of bounds");
  return l = f === void 0 && p === void 0 ? new Uint8Array(l) : p === void 0 ? new Uint8Array(l, f) : new Uint8Array(l, f, p), Buffer.TYPED_ARRAY_SUPPORT ? (u = l).__proto__ = Buffer.prototype : u = fromArrayLike(u, l), u;
}
function fromObject(u, l) {
  if (internalIsBuffer(l)) {
    var f = 0 | checked(l.length);
    return (u = createBuffer(u, f)).length === 0 || l.copy(u, 0, 0, f), u;
  }
  if (l) {
    if (typeof ArrayBuffer < "u" && l.buffer instanceof ArrayBuffer || "length" in l)
      return typeof l.length != "number" || isnan(l.length) ? createBuffer(u, 0) : fromArrayLike(u, l);
    if (l.type === "Buffer" && isArray$4(l.data))
      return fromArrayLike(u, l.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(u) {
  if (u >= kMaxLength())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  return 0 | u;
}
function internalIsBuffer(u) {
  return !(u == null || !u._isBuffer);
}
function byteLength$1(u, l) {
  if (internalIsBuffer(u))
    return u.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(u) || u instanceof ArrayBuffer))
    return u.byteLength;
  typeof u != "string" && (u = "" + u);
  var f = u.length;
  if (f === 0)
    return 0;
  for (var p = !1; ; )
    switch (l) {
      case "ascii":
      case "latin1":
      case "binary":
        return f;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(u).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * f;
      case "hex":
        return f >>> 1;
      case "base64":
        return base64ToBytes(u).length;
      default:
        if (p)
          return utf8ToBytes(u).length;
        l = ("" + l).toLowerCase(), p = !0;
    }
}
function slowToString(u, l, f) {
  var p = !1;
  if ((l === void 0 || l < 0) && (l = 0), l > this.length || ((f === void 0 || f > this.length) && (f = this.length), f <= 0) || (f >>>= 0) <= (l >>>= 0))
    return "";
  for (u || (u = "utf8"); ; )
    switch (u) {
      case "hex":
        return hexSlice(this, l, f);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, l, f);
      case "ascii":
        return asciiSlice(this, l, f);
      case "latin1":
      case "binary":
        return latin1Slice(this, l, f);
      case "base64":
        return base64Slice(this, l, f);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, l, f);
      default:
        if (p)
          throw new TypeError("Unknown encoding: " + u);
        u = (u + "").toLowerCase(), p = !0;
    }
}
function swap(u, l, f) {
  var p = u[l];
  u[l] = u[f], u[f] = p;
}
function bidirectionalIndexOf(u, l, f, p, m) {
  if (u.length === 0)
    return -1;
  if (typeof f == "string" ? (p = f, f = 0) : f > 2147483647 ? f = 2147483647 : f < -2147483648 && (f = -2147483648), f = +f, isNaN(f) && (f = m ? 0 : u.length - 1), f < 0 && (f = u.length + f), f >= u.length) {
    if (m)
      return -1;
    f = u.length - 1;
  } else if (f < 0) {
    if (!m)
      return -1;
    f = 0;
  }
  if (typeof l == "string" && (l = Buffer.from(l, p)), internalIsBuffer(l))
    return l.length === 0 ? -1 : arrayIndexOf(u, l, f, p, m);
  if (typeof l == "number")
    return l &= 255, Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? m ? Uint8Array.prototype.indexOf.call(u, l, f) : Uint8Array.prototype.lastIndexOf.call(u, l, f) : arrayIndexOf(u, [l], f, p, m);
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(u, l, f, p, m) {
  var b, y = 1, v = u.length, k = l.length;
  if (p !== void 0 && ((p = String(p).toLowerCase()) === "ucs2" || p === "ucs-2" || p === "utf16le" || p === "utf-16le")) {
    if (u.length < 2 || l.length < 2)
      return -1;
    y = 2, v /= 2, k /= 2, f /= 2;
  }
  function S(E, R) {
    return y === 1 ? E[R] : E.readUInt16BE(R * y);
  }
  if (m) {
    var $ = -1;
    for (b = f; b < v; b++)
      if (S(u, b) === S(l, $ === -1 ? 0 : b - $)) {
        if ($ === -1 && ($ = b), b - $ + 1 === k)
          return $ * y;
      } else
        $ !== -1 && (b -= b - $), $ = -1;
  } else
    for (f + k > v && (f = v - k), b = f; b >= 0; b--) {
      for (var w = !0, T = 0; T < k; T++)
        if (S(u, b + T) !== S(l, T)) {
          w = !1;
          break;
        }
      if (w)
        return b;
    }
  return -1;
}
function hexWrite(u, l, f, p) {
  f = Number(f) || 0;
  var m = u.length - f;
  p ? (p = Number(p)) > m && (p = m) : p = m;
  var b = l.length;
  if (b % 2 != 0)
    throw new TypeError("Invalid hex string");
  p > b / 2 && (p = b / 2);
  for (var y = 0; y < p; ++y) {
    var v = parseInt(l.substr(2 * y, 2), 16);
    if (isNaN(v))
      return y;
    u[f + y] = v;
  }
  return y;
}
function utf8Write(u, l, f, p) {
  return blitBuffer(utf8ToBytes(l, u.length - f), u, f, p);
}
function asciiWrite(u, l, f, p) {
  return blitBuffer(asciiToBytes(l), u, f, p);
}
function latin1Write(u, l, f, p) {
  return asciiWrite(u, l, f, p);
}
function base64Write(u, l, f, p) {
  return blitBuffer(base64ToBytes(l), u, f, p);
}
function ucs2Write(u, l, f, p) {
  return blitBuffer(utf16leToBytes(l, u.length - f), u, f, p);
}
function base64Slice(u, l, f) {
  return l === 0 && f === u.length ? fromByteArray(u) : fromByteArray(u.slice(l, f));
}
function utf8Slice(u, l, f) {
  f = Math.min(u.length, f);
  for (var p = [], m = l; m < f; ) {
    var b, y, v, k, S = u[m], $ = null, w = S > 239 ? 4 : S > 223 ? 3 : S > 191 ? 2 : 1;
    if (m + w <= f)
      switch (w) {
        case 1:
          S < 128 && ($ = S);
          break;
        case 2:
          (192 & (b = u[m + 1])) == 128 && (k = (31 & S) << 6 | 63 & b) > 127 && ($ = k);
          break;
        case 3:
          b = u[m + 1], y = u[m + 2], (192 & b) == 128 && (192 & y) == 128 && (k = (15 & S) << 12 | (63 & b) << 6 | 63 & y) > 2047 && (k < 55296 || k > 57343) && ($ = k);
          break;
        case 4:
          b = u[m + 1], y = u[m + 2], v = u[m + 3], (192 & b) == 128 && (192 & y) == 128 && (192 & v) == 128 && (k = (15 & S) << 18 | (63 & b) << 12 | (63 & y) << 6 | 63 & v) > 65535 && k < 1114112 && ($ = k);
      }
    $ === null ? ($ = 65533, w = 1) : $ > 65535 && ($ -= 65536, p.push($ >>> 10 & 1023 | 55296), $ = 56320 | 1023 & $), p.push($), m += w;
  }
  return decodeCodePointsArray(p);
}
Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT === void 0 || global$1.TYPED_ARRAY_SUPPORT, kMaxLength(), Buffer.poolSize = 8192, Buffer._augment = function(u) {
  return u.__proto__ = Buffer.prototype, u;
}, Buffer.from = function(u, l, f) {
  return from(null, u, l, f);
}, Buffer.TYPED_ARRAY_SUPPORT && (Buffer.prototype.__proto__ = Uint8Array.prototype, Buffer.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && Buffer[Symbol.species]), Buffer.alloc = function(u, l, f) {
  return alloc(null, u, l, f);
}, Buffer.allocUnsafe = function(u) {
  return allocUnsafe(null, u);
}, Buffer.allocUnsafeSlow = function(u) {
  return allocUnsafe(null, u);
}, Buffer.isBuffer = isBuffer$2, Buffer.compare = function(u, l) {
  if (!internalIsBuffer(u) || !internalIsBuffer(l))
    throw new TypeError("Arguments must be Buffers");
  if (u === l)
    return 0;
  for (var f = u.length, p = l.length, m = 0, b = Math.min(f, p); m < b; ++m)
    if (u[m] !== l[m]) {
      f = u[m], p = l[m];
      break;
    }
  return f < p ? -1 : p < f ? 1 : 0;
}, Buffer.isEncoding = function(u) {
  switch (String(u).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
}, Buffer.concat = function(u, l) {
  if (!isArray$4(u))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (u.length === 0)
    return Buffer.alloc(0);
  var f;
  if (l === void 0)
    for (l = 0, f = 0; f < u.length; ++f)
      l += u[f].length;
  var p = Buffer.allocUnsafe(l), m = 0;
  for (f = 0; f < u.length; ++f) {
    var b = u[f];
    if (!internalIsBuffer(b))
      throw new TypeError('"list" argument must be an Array of Buffers');
    b.copy(p, m), m += b.length;
  }
  return p;
}, Buffer.byteLength = byteLength$1, Buffer.prototype._isBuffer = !0, Buffer.prototype.swap16 = function() {
  var u = this.length;
  if (u % 2 != 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var l = 0; l < u; l += 2)
    swap(this, l, l + 1);
  return this;
}, Buffer.prototype.swap32 = function() {
  var u = this.length;
  if (u % 4 != 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var l = 0; l < u; l += 4)
    swap(this, l, l + 3), swap(this, l + 1, l + 2);
  return this;
}, Buffer.prototype.swap64 = function() {
  var u = this.length;
  if (u % 8 != 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var l = 0; l < u; l += 8)
    swap(this, l, l + 7), swap(this, l + 1, l + 6), swap(this, l + 2, l + 5), swap(this, l + 3, l + 4);
  return this;
}, Buffer.prototype.toString = function() {
  var u = 0 | this.length;
  return u === 0 ? "" : arguments.length === 0 ? utf8Slice(this, 0, u) : slowToString.apply(this, arguments);
}, Buffer.prototype.equals = function(u) {
  if (!internalIsBuffer(u))
    throw new TypeError("Argument must be a Buffer");
  return this === u || Buffer.compare(this, u) === 0;
}, Buffer.prototype.inspect = function() {
  var u = "", l = INSPECT_MAX_BYTES;
  return this.length > 0 && (u = this.toString("hex", 0, l).match(/.{2}/g).join(" "), this.length > l && (u += " ... ")), "<Buffer " + u + ">";
}, Buffer.prototype.compare = function(u, l, f, p, m) {
  if (!internalIsBuffer(u))
    throw new TypeError("Argument must be a Buffer");
  if (l === void 0 && (l = 0), f === void 0 && (f = u ? u.length : 0), p === void 0 && (p = 0), m === void 0 && (m = this.length), l < 0 || f > u.length || p < 0 || m > this.length)
    throw new RangeError("out of range index");
  if (p >= m && l >= f)
    return 0;
  if (p >= m)
    return -1;
  if (l >= f)
    return 1;
  if (this === u)
    return 0;
  for (var b = (m >>>= 0) - (p >>>= 0), y = (f >>>= 0) - (l >>>= 0), v = Math.min(b, y), k = this.slice(p, m), S = u.slice(l, f), $ = 0; $ < v; ++$)
    if (k[$] !== S[$]) {
      b = k[$], y = S[$];
      break;
    }
  return b < y ? -1 : y < b ? 1 : 0;
}, Buffer.prototype.includes = function(u, l, f) {
  return this.indexOf(u, l, f) !== -1;
}, Buffer.prototype.indexOf = function(u, l, f) {
  return bidirectionalIndexOf(this, u, l, f, !0);
}, Buffer.prototype.lastIndexOf = function(u, l, f) {
  return bidirectionalIndexOf(this, u, l, f, !1);
}, Buffer.prototype.write = function(u, l, f, p) {
  if (l === void 0)
    p = "utf8", f = this.length, l = 0;
  else if (f === void 0 && typeof l == "string")
    p = l, f = this.length, l = 0;
  else {
    if (!isFinite(l))
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    l |= 0, isFinite(f) ? (f |= 0, p === void 0 && (p = "utf8")) : (p = f, f = void 0);
  }
  var m = this.length - l;
  if ((f === void 0 || f > m) && (f = m), u.length > 0 && (f < 0 || l < 0) || l > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  p || (p = "utf8");
  for (var b = !1; ; )
    switch (p) {
      case "hex":
        return hexWrite(this, u, l, f);
      case "utf8":
      case "utf-8":
        return utf8Write(this, u, l, f);
      case "ascii":
        return asciiWrite(this, u, l, f);
      case "latin1":
      case "binary":
        return latin1Write(this, u, l, f);
      case "base64":
        return base64Write(this, u, l, f);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, u, l, f);
      default:
        if (b)
          throw new TypeError("Unknown encoding: " + p);
        p = ("" + p).toLowerCase(), b = !0;
    }
}, Buffer.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(u) {
  var l = u.length;
  if (l <= MAX_ARGUMENTS_LENGTH)
    return String.fromCharCode.apply(String, u);
  for (var f = "", p = 0; p < l; )
    f += String.fromCharCode.apply(String, u.slice(p, p += MAX_ARGUMENTS_LENGTH));
  return f;
}
function asciiSlice(u, l, f) {
  var p = "";
  f = Math.min(u.length, f);
  for (var m = l; m < f; ++m)
    p += String.fromCharCode(127 & u[m]);
  return p;
}
function latin1Slice(u, l, f) {
  var p = "";
  f = Math.min(u.length, f);
  for (var m = l; m < f; ++m)
    p += String.fromCharCode(u[m]);
  return p;
}
function hexSlice(u, l, f) {
  var p = u.length;
  (!l || l < 0) && (l = 0), (!f || f < 0 || f > p) && (f = p);
  for (var m = "", b = l; b < f; ++b)
    m += toHex(u[b]);
  return m;
}
function utf16leSlice(u, l, f) {
  for (var p = u.slice(l, f), m = "", b = 0; b < p.length; b += 2)
    m += String.fromCharCode(p[b] + 256 * p[b + 1]);
  return m;
}
function checkOffset(u, l, f) {
  if (u % 1 != 0 || u < 0)
    throw new RangeError("offset is not uint");
  if (u + l > f)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(u, l, f, p, m, b) {
  if (!internalIsBuffer(u))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (l > m || l < b)
    throw new RangeError('"value" argument is out of bounds');
  if (f + p > u.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(u, l, f, p) {
  l < 0 && (l = 65535 + l + 1);
  for (var m = 0, b = Math.min(u.length - f, 2); m < b; ++m)
    u[f + m] = (l & 255 << 8 * (p ? m : 1 - m)) >>> 8 * (p ? m : 1 - m);
}
function objectWriteUInt32(u, l, f, p) {
  l < 0 && (l = 4294967295 + l + 1);
  for (var m = 0, b = Math.min(u.length - f, 4); m < b; ++m)
    u[f + m] = l >>> 8 * (p ? m : 3 - m) & 255;
}
function checkIEEE754(u, l, f, p, m, b) {
  if (f + p > u.length)
    throw new RangeError("Index out of range");
  if (f < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(u, l, f, p, m) {
  return m || checkIEEE754(u, l, f, 4), write(u, l, f, p, 23, 4), f + 4;
}
function writeDouble(u, l, f, p, m) {
  return m || checkIEEE754(u, l, f, 8), write(u, l, f, p, 52, 8), f + 8;
}
Buffer.prototype.slice = function(u, l) {
  var f, p = this.length;
  if ((u = ~~u) < 0 ? (u += p) < 0 && (u = 0) : u > p && (u = p), (l = l === void 0 ? p : ~~l) < 0 ? (l += p) < 0 && (l = 0) : l > p && (l = p), l < u && (l = u), Buffer.TYPED_ARRAY_SUPPORT)
    (f = this.subarray(u, l)).__proto__ = Buffer.prototype;
  else {
    var m = l - u;
    f = new Buffer(m, void 0);
    for (var b = 0; b < m; ++b)
      f[b] = this[b + u];
  }
  return f;
}, Buffer.prototype.readUIntLE = function(u, l, f) {
  u |= 0, l |= 0, f || checkOffset(u, l, this.length);
  for (var p = this[u], m = 1, b = 0; ++b < l && (m *= 256); )
    p += this[u + b] * m;
  return p;
}, Buffer.prototype.readUIntBE = function(u, l, f) {
  u |= 0, l |= 0, f || checkOffset(u, l, this.length);
  for (var p = this[u + --l], m = 1; l > 0 && (m *= 256); )
    p += this[u + --l] * m;
  return p;
}, Buffer.prototype.readUInt8 = function(u, l) {
  return l || checkOffset(u, 1, this.length), this[u];
}, Buffer.prototype.readUInt16LE = function(u, l) {
  return l || checkOffset(u, 2, this.length), this[u] | this[u + 1] << 8;
}, Buffer.prototype.readUInt16BE = function(u, l) {
  return l || checkOffset(u, 2, this.length), this[u] << 8 | this[u + 1];
}, Buffer.prototype.readUInt32LE = function(u, l) {
  return l || checkOffset(u, 4, this.length), (this[u] | this[u + 1] << 8 | this[u + 2] << 16) + 16777216 * this[u + 3];
}, Buffer.prototype.readUInt32BE = function(u, l) {
  return l || checkOffset(u, 4, this.length), 16777216 * this[u] + (this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3]);
}, Buffer.prototype.readIntLE = function(u, l, f) {
  u |= 0, l |= 0, f || checkOffset(u, l, this.length);
  for (var p = this[u], m = 1, b = 0; ++b < l && (m *= 256); )
    p += this[u + b] * m;
  return p >= (m *= 128) && (p -= Math.pow(2, 8 * l)), p;
}, Buffer.prototype.readIntBE = function(u, l, f) {
  u |= 0, l |= 0, f || checkOffset(u, l, this.length);
  for (var p = l, m = 1, b = this[u + --p]; p > 0 && (m *= 256); )
    b += this[u + --p] * m;
  return b >= (m *= 128) && (b -= Math.pow(2, 8 * l)), b;
}, Buffer.prototype.readInt8 = function(u, l) {
  return l || checkOffset(u, 1, this.length), 128 & this[u] ? -1 * (255 - this[u] + 1) : this[u];
}, Buffer.prototype.readInt16LE = function(u, l) {
  l || checkOffset(u, 2, this.length);
  var f = this[u] | this[u + 1] << 8;
  return 32768 & f ? 4294901760 | f : f;
}, Buffer.prototype.readInt16BE = function(u, l) {
  l || checkOffset(u, 2, this.length);
  var f = this[u + 1] | this[u] << 8;
  return 32768 & f ? 4294901760 | f : f;
}, Buffer.prototype.readInt32LE = function(u, l) {
  return l || checkOffset(u, 4, this.length), this[u] | this[u + 1] << 8 | this[u + 2] << 16 | this[u + 3] << 24;
}, Buffer.prototype.readInt32BE = function(u, l) {
  return l || checkOffset(u, 4, this.length), this[u] << 24 | this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3];
}, Buffer.prototype.readFloatLE = function(u, l) {
  return l || checkOffset(u, 4, this.length), read(this, u, !0, 23, 4);
}, Buffer.prototype.readFloatBE = function(u, l) {
  return l || checkOffset(u, 4, this.length), read(this, u, !1, 23, 4);
}, Buffer.prototype.readDoubleLE = function(u, l) {
  return l || checkOffset(u, 8, this.length), read(this, u, !0, 52, 8);
}, Buffer.prototype.readDoubleBE = function(u, l) {
  return l || checkOffset(u, 8, this.length), read(this, u, !1, 52, 8);
}, Buffer.prototype.writeUIntLE = function(u, l, f, p) {
  u = +u, l |= 0, f |= 0, p || checkInt(this, u, l, f, Math.pow(2, 8 * f) - 1, 0);
  var m = 1, b = 0;
  for (this[l] = 255 & u; ++b < f && (m *= 256); )
    this[l + b] = u / m & 255;
  return l + f;
}, Buffer.prototype.writeUIntBE = function(u, l, f, p) {
  u = +u, l |= 0, f |= 0, p || checkInt(this, u, l, f, Math.pow(2, 8 * f) - 1, 0);
  var m = f - 1, b = 1;
  for (this[l + m] = 255 & u; --m >= 0 && (b *= 256); )
    this[l + m] = u / b & 255;
  return l + f;
}, Buffer.prototype.writeUInt8 = function(u, l, f) {
  return u = +u, l |= 0, f || checkInt(this, u, l, 1, 255, 0), Buffer.TYPED_ARRAY_SUPPORT || (u = Math.floor(u)), this[l] = 255 & u, l + 1;
}, Buffer.prototype.writeUInt16LE = function(u, l, f) {
  return u = +u, l |= 0, f || checkInt(this, u, l, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[l] = 255 & u, this[l + 1] = u >>> 8) : objectWriteUInt16(this, u, l, !0), l + 2;
}, Buffer.prototype.writeUInt16BE = function(u, l, f) {
  return u = +u, l |= 0, f || checkInt(this, u, l, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[l] = u >>> 8, this[l + 1] = 255 & u) : objectWriteUInt16(this, u, l, !1), l + 2;
}, Buffer.prototype.writeUInt32LE = function(u, l, f) {
  return u = +u, l |= 0, f || checkInt(this, u, l, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[l + 3] = u >>> 24, this[l + 2] = u >>> 16, this[l + 1] = u >>> 8, this[l] = 255 & u) : objectWriteUInt32(this, u, l, !0), l + 4;
}, Buffer.prototype.writeUInt32BE = function(u, l, f) {
  return u = +u, l |= 0, f || checkInt(this, u, l, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[l] = u >>> 24, this[l + 1] = u >>> 16, this[l + 2] = u >>> 8, this[l + 3] = 255 & u) : objectWriteUInt32(this, u, l, !1), l + 4;
}, Buffer.prototype.writeIntLE = function(u, l, f, p) {
  if (u = +u, l |= 0, !p) {
    var m = Math.pow(2, 8 * f - 1);
    checkInt(this, u, l, f, m - 1, -m);
  }
  var b = 0, y = 1, v = 0;
  for (this[l] = 255 & u; ++b < f && (y *= 256); )
    u < 0 && v === 0 && this[l + b - 1] !== 0 && (v = 1), this[l + b] = (u / y | 0) - v & 255;
  return l + f;
}, Buffer.prototype.writeIntBE = function(u, l, f, p) {
  if (u = +u, l |= 0, !p) {
    var m = Math.pow(2, 8 * f - 1);
    checkInt(this, u, l, f, m - 1, -m);
  }
  var b = f - 1, y = 1, v = 0;
  for (this[l + b] = 255 & u; --b >= 0 && (y *= 256); )
    u < 0 && v === 0 && this[l + b + 1] !== 0 && (v = 1), this[l + b] = (u / y | 0) - v & 255;
  return l + f;
}, Buffer.prototype.writeInt8 = function(u, l, f) {
  return u = +u, l |= 0, f || checkInt(this, u, l, 1, 127, -128), Buffer.TYPED_ARRAY_SUPPORT || (u = Math.floor(u)), u < 0 && (u = 255 + u + 1), this[l] = 255 & u, l + 1;
}, Buffer.prototype.writeInt16LE = function(u, l, f) {
  return u = +u, l |= 0, f || checkInt(this, u, l, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[l] = 255 & u, this[l + 1] = u >>> 8) : objectWriteUInt16(this, u, l, !0), l + 2;
}, Buffer.prototype.writeInt16BE = function(u, l, f) {
  return u = +u, l |= 0, f || checkInt(this, u, l, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[l] = u >>> 8, this[l + 1] = 255 & u) : objectWriteUInt16(this, u, l, !1), l + 2;
}, Buffer.prototype.writeInt32LE = function(u, l, f) {
  return u = +u, l |= 0, f || checkInt(this, u, l, 4, 2147483647, -2147483648), Buffer.TYPED_ARRAY_SUPPORT ? (this[l] = 255 & u, this[l + 1] = u >>> 8, this[l + 2] = u >>> 16, this[l + 3] = u >>> 24) : objectWriteUInt32(this, u, l, !0), l + 4;
}, Buffer.prototype.writeInt32BE = function(u, l, f) {
  return u = +u, l |= 0, f || checkInt(this, u, l, 4, 2147483647, -2147483648), u < 0 && (u = 4294967295 + u + 1), Buffer.TYPED_ARRAY_SUPPORT ? (this[l] = u >>> 24, this[l + 1] = u >>> 16, this[l + 2] = u >>> 8, this[l + 3] = 255 & u) : objectWriteUInt32(this, u, l, !1), l + 4;
}, Buffer.prototype.writeFloatLE = function(u, l, f) {
  return writeFloat(this, u, l, !0, f);
}, Buffer.prototype.writeFloatBE = function(u, l, f) {
  return writeFloat(this, u, l, !1, f);
}, Buffer.prototype.writeDoubleLE = function(u, l, f) {
  return writeDouble(this, u, l, !0, f);
}, Buffer.prototype.writeDoubleBE = function(u, l, f) {
  return writeDouble(this, u, l, !1, f);
}, Buffer.prototype.copy = function(u, l, f, p) {
  if (f || (f = 0), p || p === 0 || (p = this.length), l >= u.length && (l = u.length), l || (l = 0), p > 0 && p < f && (p = f), p === f || u.length === 0 || this.length === 0)
    return 0;
  if (l < 0)
    throw new RangeError("targetStart out of bounds");
  if (f < 0 || f >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (p < 0)
    throw new RangeError("sourceEnd out of bounds");
  p > this.length && (p = this.length), u.length - l < p - f && (p = u.length - l + f);
  var m, b = p - f;
  if (this === u && f < l && l < p)
    for (m = b - 1; m >= 0; --m)
      u[m + l] = this[m + f];
  else if (b < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT)
    for (m = 0; m < b; ++m)
      u[m + l] = this[m + f];
  else
    Uint8Array.prototype.set.call(u, this.subarray(f, f + b), l);
  return b;
}, Buffer.prototype.fill = function(u, l, f, p) {
  if (typeof u == "string") {
    if (typeof l == "string" ? (p = l, l = 0, f = this.length) : typeof f == "string" && (p = f, f = this.length), u.length === 1) {
      var m = u.charCodeAt(0);
      m < 256 && (u = m);
    }
    if (p !== void 0 && typeof p != "string")
      throw new TypeError("encoding must be a string");
    if (typeof p == "string" && !Buffer.isEncoding(p))
      throw new TypeError("Unknown encoding: " + p);
  } else
    typeof u == "number" && (u &= 255);
  if (l < 0 || this.length < l || this.length < f)
    throw new RangeError("Out of range index");
  if (f <= l)
    return this;
  var b;
  if (l >>>= 0, f = f === void 0 ? this.length : f >>> 0, u || (u = 0), typeof u == "number")
    for (b = l; b < f; ++b)
      this[b] = u;
  else {
    var y = internalIsBuffer(u) ? u : utf8ToBytes(new Buffer(u, p).toString()), v = y.length;
    for (b = 0; b < f - l; ++b)
      this[b + l] = y[b % v];
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(u) {
  if ((u = stringtrim(u).replace(INVALID_BASE64_RE, "")).length < 2)
    return "";
  for (; u.length % 4 != 0; )
    u += "=";
  return u;
}
function stringtrim(u) {
  return u.trim ? u.trim() : u.replace(/^\s+|\s+$/g, "");
}
function toHex(u) {
  return u < 16 ? "0" + u.toString(16) : u.toString(16);
}
function utf8ToBytes(u, l) {
  var f;
  l = l || 1 / 0;
  for (var p = u.length, m = null, b = [], y = 0; y < p; ++y) {
    if ((f = u.charCodeAt(y)) > 55295 && f < 57344) {
      if (!m) {
        if (f > 56319) {
          (l -= 3) > -1 && b.push(239, 191, 189);
          continue;
        }
        if (y + 1 === p) {
          (l -= 3) > -1 && b.push(239, 191, 189);
          continue;
        }
        m = f;
        continue;
      }
      if (f < 56320) {
        (l -= 3) > -1 && b.push(239, 191, 189), m = f;
        continue;
      }
      f = 65536 + (m - 55296 << 10 | f - 56320);
    } else
      m && (l -= 3) > -1 && b.push(239, 191, 189);
    if (m = null, f < 128) {
      if ((l -= 1) < 0)
        break;
      b.push(f);
    } else if (f < 2048) {
      if ((l -= 2) < 0)
        break;
      b.push(f >> 6 | 192, 63 & f | 128);
    } else if (f < 65536) {
      if ((l -= 3) < 0)
        break;
      b.push(f >> 12 | 224, f >> 6 & 63 | 128, 63 & f | 128);
    } else {
      if (!(f < 1114112))
        throw new Error("Invalid code point");
      if ((l -= 4) < 0)
        break;
      b.push(f >> 18 | 240, f >> 12 & 63 | 128, f >> 6 & 63 | 128, 63 & f | 128);
    }
  }
  return b;
}
function asciiToBytes(u) {
  for (var l = [], f = 0; f < u.length; ++f)
    l.push(255 & u.charCodeAt(f));
  return l;
}
function utf16leToBytes(u, l) {
  for (var f, p, m, b = [], y = 0; y < u.length && !((l -= 2) < 0); ++y)
    p = (f = u.charCodeAt(y)) >> 8, m = f % 256, b.push(m), b.push(p);
  return b;
}
function base64ToBytes(u) {
  return toByteArray(base64clean(u));
}
function blitBuffer(u, l, f, p) {
  for (var m = 0; m < p && !(m + f >= l.length || m >= u.length); ++m)
    l[m + f] = u[m];
  return m;
}
function isnan(u) {
  return u != u;
}
function isBuffer$2(u) {
  return u != null && (!!u._isBuffer || isFastBuffer(u) || isSlowBuffer(u));
}
function isFastBuffer(u) {
  return !!u.constructor && typeof u.constructor.isBuffer == "function" && u.constructor.isBuffer(u);
}
function isSlowBuffer(u) {
  return typeof u.readFloatLE == "function" && typeof u.slice == "function" && isFastBuffer(u.slice(0, 0));
}
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout, cachedClearTimeout = defaultClearTimeout;
function runTimeout(u) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(u, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(u, 0);
  try {
    return cachedSetTimeout(u, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, u, 0);
    } catch {
      return cachedSetTimeout.call(this, u, 0);
    }
  }
}
function runClearTimeout(u) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(u);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(u);
  try {
    return cachedClearTimeout(u);
  } catch {
    try {
      return cachedClearTimeout.call(null, u);
    } catch {
      return cachedClearTimeout.call(this, u);
    }
  }
}
typeof global$1.setTimeout == "function" && (cachedSetTimeout = setTimeout), typeof global$1.clearTimeout == "function" && (cachedClearTimeout = clearTimeout);
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var u = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var l = queue.length; l; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < l; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, l = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(u);
  }
}
function nextTick$1(u) {
  var l = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var f = 1; f < arguments.length; f++)
      l[f - 1] = arguments[f];
  queue.push(new Item(u, l)), queue.length !== 1 || draining || runTimeout(drainQueue);
}
function Item(u, l) {
  this.fun = u, this.array = l;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser", platform = "browser", browser$1 = !0, env = {}, argv = [], version$1 = "", versions = {}, release = {}, config = {};
function noop$1$1() {
}
var on$1 = noop$1$1, addListener = noop$1$1, once = noop$1$1, off = noop$1$1, removeListener = noop$1$1, removeAllListeners = noop$1$1, emit = noop$1$1;
function binding(u) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(u) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance$1 = global$1.performance || {}, performanceNow = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime(u) {
  var l = 1e-3 * performanceNow.call(performance$1), f = Math.floor(l), p = Math.floor(l % 1 * 1e9);
  return u && (f -= u[0], (p -= u[1]) < 0 && (f--, p += 1e9)), [f, p];
}
var startTime = /* @__PURE__ */ new Date();
function uptime() {
  return (/* @__PURE__ */ new Date() - startTime) / 1e3;
}
var browser$1$1 = { nextTick: nextTick$1, title, browser: browser$1, env, argv, version: version$1, versions, on: on$1, addListener, once, off, removeListener, removeAllListeners, emit, binding, cwd, chdir, umask, hrtime, platform, release, config, uptime }, inherits;
inherits = typeof Object.create == "function" ? function(u, l) {
  u.super_ = l, u.prototype = Object.create(l.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } });
} : function(u, l) {
  u.super_ = l;
  var f = function() {
  };
  f.prototype = l.prototype, u.prototype = new f(), u.prototype.constructor = u;
};
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function(u) {
  for (var l = Object.keys(u), f = {}, p = 0; p < l.length; p++)
    f[l[p]] = Object.getOwnPropertyDescriptor(u, l[p]);
  return f;
}, formatRegExp = /%[sdj%]/g;
function format$1(u) {
  if (!isString(u)) {
    for (var l = [], f = 0; f < arguments.length; f++)
      l.push(inspect(arguments[f]));
    return l.join(" ");
  }
  f = 1;
  for (var p = arguments, m = p.length, b = String(u).replace(formatRegExp, function(v) {
    if (v === "%%")
      return "%";
    if (f >= m)
      return v;
    switch (v) {
      case "%s":
        return String(p[f++]);
      case "%d":
        return Number(p[f++]);
      case "%j":
        try {
          return JSON.stringify(p[f++]);
        } catch {
          return "[Circular]";
        }
      default:
        return v;
    }
  }), y = p[f]; f < m; y = p[++f])
    isNull(y) || !isObject$5(y) ? b += " " + y : b += " " + inspect(y);
  return b;
}
function deprecate(u, l) {
  if (isUndefined(global$1.process))
    return function() {
      return deprecate(u, l).apply(this, arguments);
    };
  if (browser$1$1.noDeprecation === !0)
    return u;
  var f = !1;
  return function() {
    if (!f) {
      if (browser$1$1.throwDeprecation)
        throw new Error(l);
      browser$1$1.traceDeprecation ? console.trace(l) : console.error(l), f = !0;
    }
    return u.apply(this, arguments);
  };
}
var debugs = {}, debugEnviron;
function debuglog(u) {
  return isUndefined(debugEnviron) && (debugEnviron = browser$1$1.env.NODE_DEBUG || ""), u = u.toUpperCase(), !debugs[u] && (new RegExp("\\b" + u + "\\b", "i").test(debugEnviron) ? debugs[u] = function() {
    var l = format$1.apply(null, arguments);
    console.error("%s %d: %s", u, 0, l);
  } : debugs[u] = function() {
  }), debugs[u];
}
function inspect(u, l) {
  var f = { seen: [], stylize: stylizeNoColor };
  return arguments.length >= 3 && (f.depth = arguments[2]), arguments.length >= 4 && (f.colors = arguments[3]), isBoolean(l) ? f.showHidden = l : l && _extend(f, l), isUndefined(f.showHidden) && (f.showHidden = !1), isUndefined(f.depth) && (f.depth = 2), isUndefined(f.colors) && (f.colors = !1), isUndefined(f.customInspect) && (f.customInspect = !0), f.colors && (f.stylize = stylizeWithColor), formatValue(f, u, f.depth);
}
function stylizeWithColor(u, l) {
  var f = inspect.styles[l];
  return f ? "\x1B[" + inspect.colors[f][0] + "m" + u + "\x1B[" + inspect.colors[f][1] + "m" : u;
}
function stylizeNoColor(u, l) {
  return u;
}
function arrayToHash(u) {
  var l = {};
  return u.forEach(function(f, p) {
    l[f] = !0;
  }), l;
}
function formatValue(u, l, f) {
  if (u.customInspect && l && isFunction$1(l.inspect) && l.inspect !== inspect && (!l.constructor || l.constructor.prototype !== l)) {
    var p = l.inspect(f, u);
    return isString(p) || (p = formatValue(u, p, f)), p;
  }
  var m = formatPrimitive(u, l);
  if (m)
    return m;
  var b = Object.keys(l), y = arrayToHash(b);
  if (u.showHidden && (b = Object.getOwnPropertyNames(l)), isError$2(l) && (b.indexOf("message") >= 0 || b.indexOf("description") >= 0))
    return formatError(l);
  if (b.length === 0) {
    if (isFunction$1(l)) {
      var v = l.name ? ": " + l.name : "";
      return u.stylize("[Function" + v + "]", "special");
    }
    if (isRegExp(l))
      return u.stylize(RegExp.prototype.toString.call(l), "regexp");
    if (isDate$1(l))
      return u.stylize(Date.prototype.toString.call(l), "date");
    if (isError$2(l))
      return formatError(l);
  }
  var k, S = "", $ = !1, w = ["{", "}"];
  return isArray$3(l) && ($ = !0, w = ["[", "]"]), isFunction$1(l) && (S = " [Function" + (l.name ? ": " + l.name : "") + "]"), isRegExp(l) && (S = " " + RegExp.prototype.toString.call(l)), isDate$1(l) && (S = " " + Date.prototype.toUTCString.call(l)), isError$2(l) && (S = " " + formatError(l)), b.length !== 0 || $ && l.length != 0 ? f < 0 ? isRegExp(l) ? u.stylize(RegExp.prototype.toString.call(l), "regexp") : u.stylize("[Object]", "special") : (u.seen.push(l), k = $ ? formatArray(u, l, f, y, b) : b.map(function(T) {
    return formatProperty(u, l, f, y, T, $);
  }), u.seen.pop(), reduceToSingleString(k, S, w)) : w[0] + S + w[1];
}
function formatPrimitive(u, l) {
  if (isUndefined(l))
    return u.stylize("undefined", "undefined");
  if (isString(l)) {
    var f = "'" + JSON.stringify(l).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return u.stylize(f, "string");
  }
  return isNumber$3(l) ? u.stylize("" + l, "number") : isBoolean(l) ? u.stylize("" + l, "boolean") : isNull(l) ? u.stylize("null", "null") : void 0;
}
function formatError(u) {
  return "[" + Error.prototype.toString.call(u) + "]";
}
function formatArray(u, l, f, p, m) {
  for (var b = [], y = 0, v = l.length; y < v; ++y)
    hasOwnProperty$g(l, String(y)) ? b.push(formatProperty(u, l, f, p, String(y), !0)) : b.push("");
  return m.forEach(function(k) {
    k.match(/^\d+$/) || b.push(formatProperty(u, l, f, p, k, !0));
  }), b;
}
function formatProperty(u, l, f, p, m, b) {
  var y, v, k;
  if ((k = Object.getOwnPropertyDescriptor(l, m) || { value: l[m] }).get ? v = k.set ? u.stylize("[Getter/Setter]", "special") : u.stylize("[Getter]", "special") : k.set && (v = u.stylize("[Setter]", "special")), hasOwnProperty$g(p, m) || (y = "[" + m + "]"), v || (u.seen.indexOf(k.value) < 0 ? (v = isNull(f) ? formatValue(u, k.value, null) : formatValue(u, k.value, f - 1)).indexOf(`
`) > -1 && (v = b ? v.split(`
`).map(function(S) {
    return "  " + S;
  }).join(`
`).substr(2) : `
` + v.split(`
`).map(function(S) {
    return "   " + S;
  }).join(`
`)) : v = u.stylize("[Circular]", "special")), isUndefined(y)) {
    if (b && m.match(/^\d+$/))
      return v;
    (y = JSON.stringify("" + m)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (y = y.substr(1, y.length - 2), y = u.stylize(y, "name")) : (y = y.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), y = u.stylize(y, "string"));
  }
  return y + ": " + v;
}
function reduceToSingleString(u, l, f) {
  return u.reduce(function(p, m) {
    return m.indexOf(`
`), p + m.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0) > 60 ? f[0] + (l === "" ? "" : l + `
 `) + " " + u.join(`,
  `) + " " + f[1] : f[0] + l + " " + u.join(", ") + " " + f[1];
}
function isArray$3(u) {
  return Array.isArray(u);
}
function isBoolean(u) {
  return typeof u == "boolean";
}
function isNull(u) {
  return u === null;
}
function isNullOrUndefined(u) {
  return u == null;
}
function isNumber$3(u) {
  return typeof u == "number";
}
function isString(u) {
  return typeof u == "string";
}
function isSymbol$1$1(u) {
  return typeof u == "symbol";
}
function isUndefined(u) {
  return u === void 0;
}
function isRegExp(u) {
  return isObject$5(u) && objectToString$1(u) === "[object RegExp]";
}
function isObject$5(u) {
  return typeof u == "object" && u !== null;
}
function isDate$1(u) {
  return isObject$5(u) && objectToString$1(u) === "[object Date]";
}
function isError$2(u) {
  return isObject$5(u) && (objectToString$1(u) === "[object Error]" || u instanceof Error);
}
function isFunction$1(u) {
  return typeof u == "function";
}
function isPrimitive(u) {
  return u === null || typeof u == "boolean" || typeof u == "number" || typeof u == "string" || typeof u == "symbol" || u === void 0;
}
function isBuffer$1(u) {
  return Buffer.isBuffer(u);
}
function objectToString$1(u) {
  return Object.prototype.toString.call(u);
}
function pad$1(u) {
  return u < 10 ? "0" + u.toString(10) : u.toString(10);
}
inspect.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, inspect.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function timestamp() {
  var u = /* @__PURE__ */ new Date(), l = [pad$1(u.getHours()), pad$1(u.getMinutes()), pad$1(u.getSeconds())].join(":");
  return [u.getDate(), months[u.getMonth()], l].join(" ");
}
function log() {
  console.log("%s - %s", timestamp(), format$1.apply(null, arguments));
}
function _extend(u, l) {
  if (!l || !isObject$5(l))
    return u;
  for (var f = Object.keys(l), p = f.length; p--; )
    u[f[p]] = l[f[p]];
  return u;
}
function hasOwnProperty$g(u, l) {
  return Object.prototype.hasOwnProperty.call(u, l);
}
var kCustomPromisifiedSymbol = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
function promisify(u) {
  if (typeof u != "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol && u[kCustomPromisifiedSymbol]) {
    var l;
    if (typeof (l = u[kCustomPromisifiedSymbol]) != "function")
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(l, kCustomPromisifiedSymbol, { value: l, enumerable: !1, writable: !1, configurable: !0 }), l;
  }
  function l() {
    for (var f, p, m = new Promise(function(v, k) {
      f = v, p = k;
    }), b = [], y = 0; y < arguments.length; y++)
      b.push(arguments[y]);
    b.push(function(v, k) {
      v ? p(v) : f(k);
    });
    try {
      u.apply(this, b);
    } catch (v) {
      p(v);
    }
    return m;
  }
  return Object.setPrototypeOf(l, Object.getPrototypeOf(u)), kCustomPromisifiedSymbol && Object.defineProperty(l, kCustomPromisifiedSymbol, { value: l, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(l, getOwnPropertyDescriptors(u));
}
function callbackifyOnRejected(u, l) {
  if (!u) {
    var f = new Error("Promise was rejected with a falsy value");
    f.reason = u, u = f;
  }
  return l(u);
}
function callbackify(u) {
  if (typeof u != "function")
    throw new TypeError('The "original" argument must be of type Function');
  function l() {
    for (var f = [], p = 0; p < arguments.length; p++)
      f.push(arguments[p]);
    var m = f.pop();
    if (typeof m != "function")
      throw new TypeError("The last argument must be of type Function");
    var b = this, y = function() {
      return m.apply(b, arguments);
    };
    u.apply(this, f).then(function(v) {
      browser$1$1.nextTick(y.bind(null, null, v));
    }, function(v) {
      browser$1$1.nextTick(callbackifyOnRejected.bind(null, v, y));
    });
  }
  return Object.setPrototypeOf(l, Object.getPrototypeOf(u)), Object.defineProperties(l, getOwnPropertyDescriptors(u)), l;
}
promisify.custom = kCustomPromisifiedSymbol;
var util$2 = { inherits, _extend, log, isBuffer: isBuffer$1, isPrimitive, isFunction: isFunction$1, isError: isError$2, isDate: isDate$1, isObject: isObject$5, isRegExp, isUndefined, isSymbol: isSymbol$1$1, isString, isNumber: isNumber$3, isNullOrUndefined, isNull, isBoolean, isArray: isArray$3, inspect, deprecate, format: format$1, debuglog, promisify, callbackify }, toString$2 = Object.prototype.toString, kindOf = function(u) {
  if (u === void 0)
    return "undefined";
  if (u === null)
    return "null";
  var l = typeof u;
  if (l === "boolean")
    return "boolean";
  if (l === "string")
    return "string";
  if (l === "number")
    return "number";
  if (l === "symbol")
    return "symbol";
  if (l === "function")
    return isGeneratorFn(u) ? "generatorfunction" : "function";
  if (isArray$2$1(u))
    return "array";
  if (isBuffer$3(u))
    return "buffer";
  if (isArguments$1(u))
    return "arguments";
  if (isDate(u))
    return "date";
  if (isError$1(u))
    return "error";
  if (isRegexp(u))
    return "regexp";
  switch (ctorName(u)) {
    case "Symbol":
      return "symbol";
    case "Promise":
      return "promise";
    case "WeakMap":
      return "weakmap";
    case "WeakSet":
      return "weakset";
    case "Map":
      return "map";
    case "Set":
      return "set";
    case "Int8Array":
      return "int8array";
    case "Uint8Array":
      return "uint8array";
    case "Uint8ClampedArray":
      return "uint8clampedarray";
    case "Int16Array":
      return "int16array";
    case "Uint16Array":
      return "uint16array";
    case "Int32Array":
      return "int32array";
    case "Uint32Array":
      return "uint32array";
    case "Float32Array":
      return "float32array";
    case "Float64Array":
      return "float64array";
  }
  if (isGeneratorObj(u))
    return "generator";
  switch (l = toString$2.call(u)) {
    case "[object Object]":
      return "object";
    case "[object Map Iterator]":
      return "mapiterator";
    case "[object Set Iterator]":
      return "setiterator";
    case "[object String Iterator]":
      return "stringiterator";
    case "[object Array Iterator]":
      return "arrayiterator";
  }
  return l.slice(8, -1).toLowerCase().replace(/\s/g, "");
};
function ctorName(u) {
  return typeof u.constructor == "function" ? u.constructor.name : null;
}
function isArray$2$1(u) {
  return Array.isArray ? Array.isArray(u) : u instanceof Array;
}
function isError$1(u) {
  return u instanceof Error || typeof u.message == "string" && u.constructor && typeof u.constructor.stackTraceLimit == "number";
}
function isDate(u) {
  return u instanceof Date || typeof u.toDateString == "function" && typeof u.getDate == "function" && typeof u.setDate == "function";
}
function isRegexp(u) {
  return u instanceof RegExp || typeof u.flags == "string" && typeof u.ignoreCase == "boolean" && typeof u.multiline == "boolean" && typeof u.global == "boolean";
}
function isGeneratorFn(u, l) {
  return ctorName(u) === "GeneratorFunction";
}
function isGeneratorObj(u) {
  return typeof u.throw == "function" && typeof u.return == "function" && typeof u.next == "function";
}
function isArguments$1(u) {
  try {
    if (typeof u.length == "number" && typeof u.callee == "function")
      return !0;
  } catch (l) {
    if (l.message.indexOf("callee") !== -1)
      return !0;
  }
  return !1;
}
function isBuffer$3(u) {
  return !(!u.constructor || typeof u.constructor.isBuffer != "function") && u.constructor.isBuffer(u);
}
var types = { arguments: "an arguments object", array: "an array", boolean: "a boolean", buffer: "a buffer", date: "a date", error: "an error", float32array: "a float32array", float64array: "a float64array", function: "a function", int16array: "an int16array", int32array: "an int32array", int8array: "an int8array", map: "a Map", null: "null", number: "a number", object: "an object", regexp: "a regular expression", set: "a Set", string: "a string", symbol: "a symbol", uint16array: "an uint16array", uint32array: "an uint32array", uint8array: "an uint8array", uint8clampedarray: "an uint8clampedarray", undefined: "undefined", weakmap: "a WeakMap", weakset: "a WeakSet" };
function type(u) {
  return types[kindOf(u)];
}
type.types = types, type.typeOf = kindOf;
var typeofArticle = type, handlebarsUtils = createCommonjsModule(function(u, l) {
  var f = u.exports;
  f.extend = v, f.indexOf = function(w, T) {
    for (var E = 0, R = w.length; E < R; E++)
      if (w[E] === T)
        return E;
    return -1;
  }, f.escapeExpression = function(w) {
    if (typeof w != "string") {
      if (w && w.toHTML)
        return w.toHTML();
      if (w == null)
        return "";
      if (!w)
        return w + "";
      w = "" + w;
    }
    return b.test(w) ? w.replace(m, y) : w;
  }, f.isEmpty = function(w) {
    return w === 0 || typeof w == "boolean" ? !1 : w == null || (f.isObject(w) && (w = Object.keys(w)), !w.length);
  }, f.createFrame = function(w) {
    var T = v({}, w);
    return T._parent = w, T;
  }, f.blockParams = function(w, T) {
    return w.path = T, w;
  }, f.appendContextPath = function(w, T) {
    return (w ? w + "." : "") + T;
  };
  var p = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;", "=": "&#x3D;" }, m = /[&<>"'`=]/g, b = /[&<>"'`=]/;
  function y(w) {
    return p[w];
  }
  function v(w) {
    for (var T = 1; T < arguments.length; T++)
      for (var E in arguments[T])
        Object.prototype.hasOwnProperty.call(arguments[T], E) && (w[E] = arguments[T][E]);
    return w;
  }
  var k = Object.prototype.toString;
  f.toString = k;
  var S = function(w) {
    return typeof w == "function";
  };
  S(/x/) && (f.isFunction = S = function(w) {
    return typeof w == "function" && k.call(w) === "[object Function]";
  }), f.isFunction = S;
  var $ = Array.isArray || function(w) {
    return !(!w || typeof w != "object") && k.call(w) === "[object Array]";
  };
  f.isArray = $, f.expectedType = function(w, T, E) {
    var R = typeofArticle.types[T], O = util$2.inspect(E);
    return "expected " + w + " to be " + R + " but received " + typeofArticle(E) + ": " + O;
  }, f.isBlock = function(w) {
    return f.isOptions(w) && typeof w.fn == "function" && typeof w.inverse == "function";
  }, f.fn = function(w, T, E) {
    return f.isOptions(w) ? f.fn("", w, E) : f.isOptions(T) ? f.fn(w, {}, T) : f.isBlock(E) ? E.fn(T) : w;
  }, f.inverse = function(w, T, E) {
    return f.isOptions(w) ? f.identity("", w, E) : f.isOptions(T) ? f.inverse(w, {}, T) : f.isBlock(E) ? E.inverse(T) : w;
  }, f.value = function(w, T, E) {
    return f.isOptions(w) ? f.value(null, w, E) : f.isOptions(T) ? f.value(w, {}, T) : f.isBlock(E) ? w ? E.fn(T) : E.inverse(T) : w;
  }, f.isOptions = function(w) {
    return f.isObject(w) && f.isObject(w.hash);
  }, f.isUndefined = function(w) {
    return w == null || f.isOptions(w) && w.hash != null;
  }, f.isApp = function(w) {
    return f.isObject(w) && f.isObject(w.options) && f.isObject(w.app);
  }, f.options = function(w, T, E) {
    if (f.isOptions(w))
      return f.options({}, T, w);
    if (f.isOptions(T))
      return f.options(w, E, T);
    E = E || {}, f.isOptions(E) || (T = Object.assign({}, T, E));
    var R = Object.assign({}, T, E.hash);
    return f.isObject(w) && (R = Object.assign({}, w.options, R)), R[E.name] && (R = Object.assign({}, R[E.name], R)), R;
  }, f.context = function(w, T, E) {
    if (f.isOptions(w))
      return f.context({}, T, w);
    if (f.isOptions(T))
      return f.context(w, E, T);
    var R = f.isApp(w) ? w.context : {};
    E = E || {}, f.isOptions(E) || (T = Object.assign({}, T, E)), f.isOptions(E) && E.hash.root === !0 && (T = Object.assign({}, E.data.root, T));
    var O = Object.assign({}, R, T, E.hash);
    return f.isApp(w) || (O = Object.assign({}, w, O)), f.isApp(w) && w.view && w.view.data && (O = Object.assign({}, O, w.view.data)), O;
  }, f.isObject = function(w) {
    return kindOf(w) === "object";
  }, f.result = function(w) {
    return typeof w == "function" ? w.apply(this, [].slice.call(arguments, 1)) : w;
  }, f.identity = function(w) {
    return w;
  }, f.isString = function(w) {
    return typeof w == "string" && w !== "";
  }, f.arrayify = function(w) {
    return w != null ? Array.isArray(w) ? w : [w] : [];
  }, f.tryParse = function(w) {
    try {
      return JSON.parse(w);
    } catch {
    }
    return {};
  };
}), isobject$1 = function(u) {
  return u != null && typeof u == "object" && Array.isArray(u) === !1;
}, getValue$1 = function(u, l, f) {
  if (isobject$1(f) || (f = { default: f }), !isValidObject(u))
    return f.default !== void 0 ? f.default : u;
  typeof l == "number" && (l = String(l));
  const p = Array.isArray(l), m = typeof l == "string", b = f.separator || ".", y = f.joinChar || (typeof b == "string" ? b : ".");
  if (!m && !p)
    return u;
  if (m && l in u)
    return isValid$1(l, u, f) ? u[l] : f.default;
  let v = p ? l : split(l, b, f), k = v.length, S = 0;
  do {
    let $ = v[S];
    for (typeof $ == "number" && ($ = String($)); $ && $.slice(-1) === "\\"; )
      $ = join$1([$.slice(0, -1), v[++S] || ""], y, f);
    if ($ in u) {
      if (!isValid$1($, u, f))
        return f.default;
      u = u[$];
    } else {
      let w = !1, T = S + 1;
      for (; T < k; )
        if ($ = join$1([$, v[T++]], y, f), w = $ in u) {
          if (!isValid$1($, u, f))
            return f.default;
          u = u[$], S = T - 1;
          break;
        }
      if (!w)
        return f.default;
    }
  } while (++S < k && isValidObject(u));
  return S === k ? u : f.default;
};
function join$1(u, l, f) {
  return typeof f.join == "function" ? f.join(u) : u[0] + l + u[1];
}
function split(u, l, f) {
  return typeof f.split == "function" ? f.split(u) : u.split(l);
}
function isValid$1(u, l, f) {
  return typeof f.isValid != "function" || f.isValid(u, l);
}
function isValidObject(u) {
  return isobject$1(u) || Array.isArray(u) || typeof u == "function";
}
var createFrame = function(u) {
  if (typeof u != "object")
    throw new TypeError("createFrame expects data to be an object");
  var l = Object.assign({}, u);
  if (l._parent = u, l.extend = function(b) {
    Object.assign(this, b);
  }, arguments.length > 1)
    for (var f = [].slice.call(arguments, 1), p = f.length, m = -1; ++m < p; )
      l.extend(f[m] || {});
  return l;
}, array$1 = createCommonjsModule(function(u) {
  var l = u.exports;
  l.after = function(f, p) {
    return handlebarsUtils.isUndefined(f) ? "" : (f = handlebarsUtils.result(f), Array.isArray(f) ? f.slice(p) : "");
  }, l.arrayify = function(f) {
    return handlebarsUtils.isUndefined(f) ? [] : f ? Array.isArray(f) ? f : [f] : [];
  }, l.before = function(f, p) {
    return handlebarsUtils.isUndefined(f) ? "" : (f = handlebarsUtils.result(f), Array.isArray(f) ? f.slice(0, p - 1) : "");
  }, l.eachIndex = function(f, p) {
    var m = "";
    if (handlebarsUtils.isUndefined(f))
      return "";
    if (f = handlebarsUtils.result(f), Array.isArray(f))
      for (var b = 0; b < f.length; b++)
        m += p.fn({ item: f[b], index: b });
    return m;
  }, l.filter = function(f, p, m) {
    if (handlebarsUtils.isUndefined(f))
      return m.inverse(this);
    if (f = handlebarsUtils.result(f), Array.isArray(f)) {
      var b = "", y = [], v = m.hash && (m.hash.property || m.hash.prop);
      if ((y = v ? f.filter(function(S) {
        return p === getValue$1(S, v);
      }) : f.filter(function(S) {
        return p === S;
      })) && y.length > 0) {
        for (var k = 0; k < y.length; k++)
          b += m.fn(y[k]);
        return b;
      }
    }
    return m.inverse(this);
  }, l.first = function(f, p) {
    return handlebarsUtils.isUndefined(f) ? [] : (f = handlebarsUtils.result(f), Array.isArray(f) ? isNaN(p) ? f[0] : f.slice(0, p) : []);
  }, l.forEach = function(f, p) {
    if (handlebarsUtils.isUndefined(f))
      return p.inverse(this);
    if (f = handlebarsUtils.result(f), Array.isArray(f)) {
      for (var m = createFrame(p, p.hash), b = f.length, y = "", v = -1; ++v < b; ) {
        var k = f[v];
        m.index = v, k.index = v + 1, k.total = b, k.isFirst = v === 0, k.isLast = v === b - 1, y += p.fn(k, { data: m });
      }
      return y;
    }
    return p.inverse(this);
  }, l.inArray = function(f, p, m) {
    return handlebarsUtils.isUndefined(f) ? "" : (f = handlebarsUtils.result(f), Array.isArray(f) ? handlebarsUtils.value(handlebarsUtils.indexOf(f, p) > -1, this, m) : "");
  }, l.isArray = function(f) {
    return Array.isArray(f);
  }, l.itemAt = function(f, p) {
    if (handlebarsUtils.isUndefined(f))
      return null;
    if (f = handlebarsUtils.result(f), Array.isArray(f)) {
      if ((p = isNaN(p) ? 0 : +p) < 0)
        return f[f.length + p];
      if (p < f.length)
        return f[p];
    }
    return null;
  }, l.join = function(f, p) {
    return handlebarsUtils.isUndefined(f) ? "" : typeof f == "string" ? f : (f = handlebarsUtils.result(f), Array.isArray(f) ? (p = handlebarsUtils.isString(p) ? p : ", ", f.join(p)) : "");
  }, l.equalsLength = function(f, p, m) {
    handlebarsUtils.isOptions(p) && (m = p, p = 0);
    var b = l.length(f);
    return handlebarsUtils.value(b === p, this, m);
  }, l.last = function(f, p) {
    return handlebarsUtils.isUndefined(f) ? "" : Array.isArray(f) || typeof value == "string" ? isNaN(p) ? f[f.length - 1] : f.slice(-Math.abs(p)) : "";
  }, l.length = function(f) {
    return handlebarsUtils.isUndefined(f) ? 0 : (handlebarsUtils.isObject(f) && !handlebarsUtils.isOptions(f) && (f = Object.keys(f)), typeof f == "string" && f.startsWith("[") && f.endsWith("]") ? f.split(",").length : typeof f == "string" || Array.isArray(f) ? f.length : 0);
  }, l.lengthEqual = l.equalsLength, l.map = function(f, p) {
    if (handlebarsUtils.isUndefined(f) || !Array.isArray(f))
      return "";
    var m = f.length, b = new Array(m), y = -1;
    if (typeof p != "function")
      return f;
    for (; ++y < m; )
      b[y] = p(f[y], y, f);
    return b;
  }, l.pluck = function(f, p) {
    if (handlebarsUtils.isUndefined(f))
      return "";
    if (f = handlebarsUtils.result(f), Array.isArray(f)) {
      for (var m = [], b = 0; b < f.length; b++) {
        var y = getValue$1(f[b], p);
        y !== void 0 && m.push(y);
      }
      return m;
    }
    return "";
  }, l.reverse = function(f) {
    return handlebarsUtils.isUndefined(f) ? "" : (f = handlebarsUtils.result(f), Array.isArray(f) ? (f.reverse(), f) : f && typeof f == "string" ? f.split("").reverse().join("") : "");
  }, l.some = function(f, p, m) {
    if (handlebarsUtils.isUndefined(f))
      return m.inverse(this);
    if (f = handlebarsUtils.result(f), Array.isArray(f)) {
      for (var b = 0; b < f.length; b++)
        if (p(f[b], b, f))
          return m.fn(this);
    }
    return m.inverse(this);
  }, l.sort = function(f, p) {
    return handlebarsUtils.isUndefined(f) ? "" : (f = handlebarsUtils.result(f), Array.isArray(f) ? getValue$1(p, "hash.reverse") ? f.sort().reverse() : f.sort() : "");
  }, l.sortBy = function(f, p, m) {
    return handlebarsUtils.isUndefined(f) ? "" : (f = handlebarsUtils.result(f), Array.isArray(f) ? ([].slice.call(arguments).pop(), handlebarsUtils.isString(p) || typeof p == "function" ? typeof p == "function" ? f.sort(p) : f.sort((b, y) => b[p] > y[p] ? 1 : -1) : f.sort()) : "");
  }, l.withAfter = function(f, p, m) {
    if (handlebarsUtils.isUndefined(f))
      return "";
    if (f = handlebarsUtils.result(f), Array.isArray(f)) {
      f = f.slice(p);
      for (var b = "", y = 0; y < f.length; y++)
        b += m.fn(f[y]);
      return b;
    }
    return "";
  }, l.withBefore = function(f, p, m) {
    if (handlebarsUtils.isUndefined(f))
      return "";
    if (f = handlebarsUtils.result(f), Array.isArray(f)) {
      f = f.slice(0, -p);
      for (var b = "", y = 0; y < f.length; y++)
        b += m.fn(f[y]);
      return b;
    }
    return "";
  }, l.withFirst = function(f, p, m) {
    if (handlebarsUtils.isUndefined(f))
      return "";
    if (f = handlebarsUtils.result(f), Array.isArray(f)) {
      if (handlebarsUtils.isUndefined(p) || (p = parseFloat(handlebarsUtils.result(p))), handlebarsUtils.isUndefined(p))
        return (m = p).fn(f[0]);
      f = f.slice(0, p);
      for (var b = "", y = 0; y < f.length; y++)
        b += m.fn(f[y]);
      return b;
    }
    return "";
  }, l.withGroup = function(f, p, m) {
    if (handlebarsUtils.isUndefined(f))
      return "";
    var b = "";
    if (f = handlebarsUtils.result(f), Array.isArray(f) && f.length > 0) {
      for (var y = [], v = 0; v < f.length; v++)
        v > 0 && v % p === 0 && (b += m.fn(y), y = []), y.push(f[v]);
      b += m.fn(y);
    }
    return b;
  }, l.withLast = function(f, p, m) {
    if (handlebarsUtils.isUndefined(f))
      return "";
    if (f = handlebarsUtils.result(f), Array.isArray(f)) {
      if (handlebarsUtils.isUndefined(p) || (p = parseFloat(handlebarsUtils.result(p))), handlebarsUtils.isUndefined(p))
        return (m = p).fn(f[f.length - 1]);
      for (var b = (f = f.slice(-p)).length, y = -1, v = ""; ++y < b; )
        v += m.fn(f[y]);
      return v;
    }
    return "";
  }, l.withSort = function(f, p, m) {
    if (handlebarsUtils.isUndefined(f))
      return "";
    if (f = handlebarsUtils.result(f), Array.isArray(f)) {
      var b = "";
      if (handlebarsUtils.isUndefined(p)) {
        m = p, f = f.sort(), getValue$1(m, "hash.reverse") && (f = f.reverse());
        for (var y = 0, v = f.length; y < v; y++)
          b += m.fn(f[y]);
        return b;
      }
      f.sort(function($, w) {
        return ($ = getValue$1($, p)) > (w = getValue$1(w, p)) ? 1 : $ < w ? -1 : 0;
      }), getValue$1(m, "hash.reverse") && (f = f.reverse());
      for (var k = f.length, S = -1; ++S < k; )
        b += m.fn(f[S]);
      return b;
    }
    return "";
  }, l.unique = function(f, p) {
    return handlebarsUtils.isUndefined(f) ? "" : (f = handlebarsUtils.result(f), Array.isArray(f) ? f.filter(function(m, b, y) {
      return y.indexOf(m) === b;
    }) : "");
  };
}), fs = {};
function normalizeArray(u, l) {
  for (var f = 0, p = u.length - 1; p >= 0; p--) {
    var m = u[p];
    m === "." ? u.splice(p, 1) : m === ".." ? (u.splice(p, 1), f++) : f && (u.splice(p, 1), f--);
  }
  if (l)
    for (; f--; f)
      u.unshift("..");
  return u;
}
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, splitPath = function(u) {
  return splitPathRe.exec(u).slice(1);
};
function resolve() {
  for (var u = "", l = !1, f = arguments.length - 1; f >= -1 && !l; f--) {
    var p = f >= 0 ? arguments[f] : "/";
    if (typeof p != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    p && (u = p + "/" + u, l = p.charAt(0) === "/");
  }
  return (l ? "/" : "") + (u = normalizeArray(filter$2(u.split("/"), function(m) {
    return !!m;
  }), !l).join("/")) || ".";
}
function normalize(u) {
  var l = isAbsolute(u), f = substr(u, -1) === "/";
  return (u = normalizeArray(filter$2(u.split("/"), function(p) {
    return !!p;
  }), !l).join("/")) || l || (u = "."), u && f && (u += "/"), (l ? "/" : "") + u;
}
function isAbsolute(u) {
  return u.charAt(0) === "/";
}
function join() {
  return normalize(filter$2(Array.prototype.slice.call(arguments, 0), function(u, l) {
    if (typeof u != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return u;
  }).join("/"));
}
function relative$1(u, l) {
  function f(S) {
    for (var $ = 0; $ < S.length && S[$] === ""; $++)
      ;
    for (var w = S.length - 1; w >= 0 && S[w] === ""; w--)
      ;
    return $ > w ? [] : S.slice($, w - $ + 1);
  }
  u = resolve(u).substr(1), l = resolve(l).substr(1);
  for (var p = f(u.split("/")), m = f(l.split("/")), b = Math.min(p.length, m.length), y = b, v = 0; v < b; v++)
    if (p[v] !== m[v]) {
      y = v;
      break;
    }
  var k = [];
  for (v = y; v < p.length; v++)
    k.push("..");
  return (k = k.concat(m.slice(y))).join("/");
}
var sep = "/", delimiter$1 = ":";
function dirname(u) {
  var l = splitPath(u), f = l[0], p = l[1];
  return f || p ? (p && (p = p.substr(0, p.length - 1)), f + p) : ".";
}
function basename(u, l) {
  var f = splitPath(u)[2];
  return l && f.substr(-1 * l.length) === l && (f = f.substr(0, f.length - l.length)), f;
}
function extname(u) {
  return splitPath(u)[3];
}
var path = { extname, basename, dirname, sep, delimiter: delimiter$1, relative: relative$1, join, isAbsolute, normalize, resolve };
function filter$2(u, l) {
  if (u.filter)
    return u.filter(l);
  for (var f = [], p = 0; p < u.length; p++)
    l(u[p], p, u) && f.push(u[p]);
  return f;
}
var substr = "ab".substr(-1) === "b" ? function(u, l, f) {
  return u.substr(l, f);
} : function(u, l, f) {
  return l < 0 && (l = u.length + l), u.substr(l, f);
}, toGfmCodeBlock = function(u, l) {
  if (typeof u != "string")
    throw new TypeError("markdown-pre expects a string.");
  var f = "";
  return f += "```" + (typeof l == "string" ? l : ""), f += `
`, f += u, f += `
`, f += "```";
}, svgElements = ["circle", "ellipse", "line", "path", "polygon", "polyline", "rect", "stop", "use"], voidElements = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"], selfClosingTags = voidElements.concat(svgElements), voidElements_1 = voidElements, svgElements_1 = svgElements;
/*!
 * to-gfm-code-block <https://github.com/jonschlinkert/to-gfm-code-block>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
selfClosingTags.voidElements = voidElements_1, selfClosingTags.svgElements = svgElements_1;
var isSelfClosing = function(u) {
  if (typeof u != "string")
    throw new TypeError("expected name to be a string");
  return selfClosingTags.indexOf(u.toLowerCase()) !== -1;
}, htmlTag = function(u, l, f) {
  var p = f === !1 || l === !1;
  if (kindOf(l) !== "object" && (f = l, l = {}), f !== void 0 && f !== !1 || (f = ""), typeof f != "string")
    throw new TypeError("expected text to be a string");
  var m = "<" + u;
  for (var b in l) {
    var y = l[b];
    y === !0 && (m += " " + b), typeof y == "string" && (m += " " + b + '="' + y + '"');
  }
  return isSelfClosing(u) || p === !0 ? m + ">" + f : m + ">" + f + "</" + u + ">";
}, code = createCommonjsModule(function(u) {
  var l = u.exports;
  l.embed = function(f, p) {
    p = typeof p != "string" ? path.extname(f).slice(1) : p;
    var m = fs.readFileSync(f, "utf8");
    return p !== "markdown" && p !== "md" || (p = "markdown", m = m.split("`").join("&#x60")), toGfmCodeBlock(m, p).trim() + `
`;
  }, l.gist = function(f) {
    return htmlTag("script", { src: "https://gist.github.com/" + f + ".js" });
  }, l.jsfiddle = function(f) {
    var p = Object.assign({}, f && f.hash);
    if (p.id === void 0)
      throw new Error("jsfiddle helper expects an `id`");
    return p.id = "http://jsfiddle.net/" + p.id, p.width = p.width || "100%", p.height = p.height || "300", p.skin = p.skin || "/presentation/", p.tabs = (p.tabs || "result,js,html,css") + p.skin, p.src = p.id + "/embedded/" + p.tabs, p.allowfullscreen = p.allowfullscreen || "allowfullscreen", p.frameborder = p.frameborder || "0", delete p.tabs, delete p.skin, delete p.id, htmlTag("iframe", p);
  };
}), isNumber$2 = function(u) {
  var l = kindOf(u);
  if (l !== "number" && l !== "string")
    return !1;
  var f = +u;
  return f - f + 1 >= 0 && u !== "";
}, getObject = function(u, l) {
  if (!l)
    return u;
  if (!u)
    return {};
  for (var f = String(l).split(/[[.\]]/).filter(Boolean), p = f[f.length - 1], m = {}; l = f.shift(); )
    if (!(u = u[l]))
      return {};
  return isNumber$2(p) ? [u] : (m[p] = u, m);
}, object$1 = createCommonjsModule(function(u) {
  var l = Object.hasOwnProperty, f = u.exports;
  f.extend = function() {
    var p = [].slice.call(arguments), m = {};
    handlebarsUtils.isOptions(p[p.length - 1]) && (m = p.pop().hash, p.push(m));
    for (var b = {}, y = 0; y < p.length; y++) {
      var v = p[y];
      if (handlebarsUtils.isObject(v))
        for (var k = Object.keys(v), S = 0; S < k.length; S++) {
          var $ = k[S];
          b[$] = v[$];
        }
    }
    return b;
  }, f.forIn = function(p, m) {
    if (!handlebarsUtils.isOptions(m))
      return p.inverse(this);
    var b = createFrame(m, m.hash), y = "";
    for (var v in p)
      b.key = v, y += m.fn(p[v], { data: b });
    return y;
  }, f.forOwn = function(p, m) {
    if (!handlebarsUtils.isOptions(m))
      return p.inverse(this);
    var b = createFrame(m, m.hash), y = "";
    for (var v in p)
      p.hasOwnProperty(v) && (b.key = v, y += m.fn(p[v], { data: b }));
    return y;
  }, f.toPath = function() {
    for (var p = [], m = 0; m < arguments.length; m++)
      typeof arguments[m] != "string" && typeof arguments[m] != "number" || p.push(arguments[m]);
    return p.join(".");
  }, f.get = function(p, m, b) {
    var y = getValue$1(m, p);
    return b && b.fn ? y ? b.fn(y) : b.inverse(m) : y;
  }, f.getObject = function(p, m) {
    return getObject(m, p);
  }, f.hasOwn = function(p, m) {
    return l.call(p, m);
  }, f.isObject = function(p) {
    return typeof p == "object";
  }, f.JSONparse = function(p, m) {
    return JSON.parse(p);
  }, f.JSONstringify = function(p, m) {
    return isNaN(m) && (m = 0), JSON.stringify(p, null, m);
  }, f.merge = function(p) {
    var m = [].slice.call(arguments), b = {};
    return handlebarsUtils.isOptions(m[m.length - 1]) && (b = m.pop().hash, m.push(b)), Object.assign.apply(null, m);
  }, f.parseJSON = f.JSONparse, f.pick = function(p, m, b) {
    for (var y = array$1.arrayify(p), v = y.length, k = -1, S = {}; ++k < v; )
      S = f.extend({}, S, getObject(m, y[k]));
    return b.fn ? Object.keys(S).length ? b.fn(S) : b.inverse(m) : S;
  }, f.stringify = f.JSONstringify;
}), collection = createCommonjsModule(function(u) {
  var l = array$1.forEach, f = object$1.forOwn, p = u.exports;
  p.isEmpty = function(m, b) {
    if (!handlebarsUtils.isOptions(b))
      return b = m, handlebarsUtils.fn(!0, this, b);
    if (Array.isArray(m) && !m.length)
      return handlebarsUtils.fn(!0, this, b);
    var y = Object.keys(m), v = typeof m == "object" && !y.length;
    return handlebarsUtils.value(v, this, b);
  }, p.iterate = function(m, b) {
    return Array.isArray(m) ? l.apply(null, arguments) : handlebarsUtils.isObject(m) ? f.apply(null, arguments) : b.inverse(this);
  };
}), hasValues = function u(l) {
  switch (kindOf(l)) {
    case "boolean":
    case "date":
    case "function":
    case "null":
    case "number":
    default:
      return !0;
    case "undefined":
      return !1;
    case "regexp":
      return l.source !== "(?:)" && l.source !== "";
    case "buffer":
      return l.toString() !== "";
    case "error":
      return l.message !== "";
    case "string":
    case "arguments":
      return l.length !== 0;
    case "file":
    case "map":
    case "set":
      return l.size !== 0;
    case "array":
    case "object":
      for (const f of Object.keys(l))
        if (u(l[f]))
          return !0;
      return !1;
  }
}, hasValue = function(u, l, f) {
  return !(!isObject$4$1(u) || typeof l != "string" && !Array.isArray(l)) && hasValues(getValue$1(u, l, f));
};
/*!
 * html-tag <https://github.com/jonschlinkert/html-tag>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject$4$1(u) {
  return u != null && (typeof u == "object" || typeof u == "function" || Array.isArray(u));
}
var utils$2 = createCommonjsModule(function(u, l) {
  l.contains = function(f, p, m) {
    return f != null && p != null && !isNaN(f.length) && f.indexOf(p, m) !== -1;
  }, l.chop = function(f) {
    return typeof f != "string" ? "" : f.trim().replace(/^[-_.\W\s]+|[-_.\W\s]+$/g, "");
  }, l.changecase = function(f, p) {
    return typeof f != "string" ? "" : f.length === 1 ? f.toLowerCase() : (f = l.chop(f).toLowerCase(), typeof p != "function" && (p = handlebarsUtils.identity), f.replace(/[-_.\W\s]+(\w|$)/g, function(m, b) {
      return p(b);
    }));
  }, l.random = function(f, p) {
    return f + Math.floor(Math.random() * (p - f + 1));
  };
});
function falsey(u, l) {
  if (!u)
    return !0;
  let f = l || falsey.keywords;
  Array.isArray(f) || (f = [f]);
  const p = typeof u == "string" ? u.toLowerCase() : null;
  for (const m of f)
    if (m === u || m === p)
      return !0;
  return !1;
}
falsey.keywords = ["0", "false", "nada", "nil", "nay", "nah", "negative", "no", "none", "nope", "nul", "null", "nix", "nyet", "uh-uh", "veto", "zero"];
var falsey_1 = falsey, odd = function(u) {
  const l = Math.abs(u);
  if (isNaN(l))
    throw new TypeError("expected a number");
  if (!Number.isInteger(l))
    throw new Error("expected an integer");
  if (!Number.isSafeInteger(l))
    throw new Error("value exceeds maximum safe integer");
  return l % 2 == 1;
}, comparison$1 = createCommonjsModule(function(u) {
  var l = u.exports;
  l.and = function() {
    for (var f = arguments.length - 1, p = arguments[f], m = !0, b = 0; b < f; b++)
      if (!arguments[b]) {
        m = !1;
        break;
      }
    return handlebarsUtils.value(m, this, p);
  }, l.compare = function(f, p, m, b) {
    if (arguments.length < 4)
      throw new Error("handlebars Helper {{compare}} expects 4 arguments");
    var y;
    switch (p) {
      case "==":
        y = f == m;
        break;
      case "===":
        y = f === m;
        break;
      case "!=":
        y = f != m;
        break;
      case "!==":
        y = f !== m;
        break;
      case "<":
        y = f < m;
        break;
      case ">":
        y = f > m;
        break;
      case "<=":
        y = f <= m;
        break;
      case ">=":
        y = f >= m;
        break;
      case "typeof":
        y = typeof f === m;
        break;
      default:
        throw new Error("helper {{compare}}: invalid operator: `" + p + "`");
    }
    return handlebarsUtils.value(y, this, b);
  }, l.contains = function(f, p, m, b) {
    typeof m == "object" && (b = m, m = void 0);
    var y = utils$2.contains(f, p, m);
    return handlebarsUtils.value(y, this, b);
  }, l.default = function() {
    for (var f = 0; f < arguments.length - 1; f++)
      if (arguments[f] != null)
        return arguments[f];
    return "";
  }, l.eq = function(f, p, m) {
    return arguments.length === 2 && (p = (m = p).hash.compare), handlebarsUtils.value(f === p, this, m);
  }, l.gt = function(f, p, m) {
    return arguments.length === 2 && (p = (m = p).hash.compare), handlebarsUtils.value(f > p, this, m);
  }, l.gte = function(f, p, m) {
    return arguments.length === 2 && (p = (m = p).hash.compare), handlebarsUtils.value(f >= p, this, m);
  }, l.has = function(f, p, m) {
    return handlebarsUtils.isOptions(f) && (m = f, p = null, f = null), handlebarsUtils.isOptions(p) && (m = p, p = null), f === null ? handlebarsUtils.value(!1, this, m) : arguments.length === 2 ? handlebarsUtils.value(hasValue(this, f), this, m) : (Array.isArray(f) || handlebarsUtils.isString(f)) && handlebarsUtils.isString(p) && f.indexOf(p) > -1 || handlebarsUtils.isObject(f) && handlebarsUtils.isString(p) && p in f ? handlebarsUtils.fn(!0, this, m) : handlebarsUtils.inverse(!1, this, m);
  }, l.isFalsey = function(f, p) {
    return handlebarsUtils.value(falsey_1(f), this, p);
  }, l.isTruthy = function(f, p) {
    return handlebarsUtils.value(!falsey_1(f), this, p);
  }, l.ifEven = function(f, p) {
    return handlebarsUtils.value(!odd(f), this, p);
  }, l.ifNth = function(f, p, m) {
    var b = !isNaN(f) && !isNaN(p) && p % f === 0;
    return handlebarsUtils.value(b, this, m);
  }, l.ifOdd = function(f, p) {
    return handlebarsUtils.value(odd(f), this, p);
  }, l.is = function(f, p, m) {
    return arguments.length === 2 && (p = (m = p).hash.compare), handlebarsUtils.value(f == p, this, m);
  }, l.isnt = function(f, p, m) {
    return arguments.length === 2 && (p = (m = p).hash.compare), handlebarsUtils.value(f != p, this, m);
  }, l.lt = function(f, p, m) {
    return arguments.length === 2 && (p = (m = p).hash.compare), handlebarsUtils.value(f < p, this, m);
  }, l.lte = function(f, p, m) {
    return arguments.length === 2 && (p = (m = p).hash.compare), handlebarsUtils.value(f <= p, this, m);
  }, l.neither = function(f, p, m) {
    return handlebarsUtils.value(!f && !p, this, m);
  }, l.not = function(f, p) {
    return handlebarsUtils.value(!f, this, p);
  }, l.or = function() {
    for (var f = arguments.length - 1, p = arguments[f], m = !1, b = 0; b < f; b++)
      if (arguments[b]) {
        m = !0;
        break;
      }
    return handlebarsUtils.value(m, this, p);
  }, l.unlessEq = function(f, p, m) {
    return handlebarsUtils.isOptions(p) && (p = (m = p).hash.compare), handlebarsUtils.value(f !== p, this, m);
  }, l.unlessGt = function(f, p, m) {
    return handlebarsUtils.isOptions(p) && (p = (m = p).hash.compare), handlebarsUtils.value(f <= p, this, m);
  }, l.unlessLt = function(f, p, m) {
    return handlebarsUtils.isOptions(p) && (p = (m = p).hash.compare), handlebarsUtils.value(f >= p, this, m);
  }, l.unlessGteq = function(f, p, m) {
    return handlebarsUtils.isOptions(p) && (p = (m = p).hash.compare), handlebarsUtils.value(f < p, this, m);
  }, l.unlessLteq = function(f, p, m) {
    return handlebarsUtils.isOptions(p) && (p = (m = p).hash.compare), handlebarsUtils.value(f > p, this, m);
  };
}), striptags = createCommonjsModule(function(u) {
  (function(l) {
    if (typeof f != "function") {
      var f = function(T) {
        return T;
      };
      f.nonNative = !0;
    }
    const p = f("plaintext"), m = f("html"), b = f("comment"), y = /<(\w*)>/g, v = /<\/?([^\s\/>]+)/;
    function k(T, E, R) {
      return $(T = T || "", S(E = E || [], R = R || ""));
    }
    function S(T, E) {
      return T = function(R) {
        let O = /* @__PURE__ */ new Set();
        if (typeof R == "string") {
          let P;
          for (; P = y.exec(R); )
            O.add(P[1]);
        } else
          f.nonNative || typeof R[f.iterator] != "function" ? typeof R.forEach == "function" && R.forEach(O.add, O) : O = new Set(R);
        return O;
      }(T), { allowable_tags: T, tag_replacement: E, state: p, tag_buffer: "", depth: 0, in_quote_char: "" };
    }
    function $(T, E) {
      if (typeof T != "string")
        throw new TypeError("'html' parameter must be a string");
      let R = E.allowable_tags, O = E.tag_replacement, P = E.state, L = E.tag_buffer, M = E.depth, B = E.in_quote_char, j = "";
      for (let x = 0, N = T.length; x < N; x++) {
        let D = T[x];
        if (P === p)
          D === "<" ? (P = m, L += D) : j += D;
        else if (P === m)
          switch (D) {
            case "<":
              if (B)
                break;
              M++;
              break;
            case ">":
              if (B)
                break;
              if (M) {
                M--;
                break;
              }
              B = "", P = p, L += ">", R.has(w(L)) ? j += L : j += O, L = "";
              break;
            case '"':
            case "'":
              B = D === B ? "" : B || D, L += D;
              break;
            case "-":
              L === "<!-" && (P = b), L += D;
              break;
            case " ":
            case `
`:
              if (L === "<") {
                P = p, j += "< ", L = "";
                break;
              }
              L += D;
              break;
            default:
              L += D;
          }
        else
          P === b && (D === ">" ? (L.slice(-2) == "--" && (P = p), L = "") : L += D);
      }
      return E.state = P, E.tag_buffer = L, E.depth = M, E.in_quote_char = B, j;
    }
    function w(T) {
      let E = v.exec(T);
      return E ? E[1].toLowerCase() : null;
    }
    k.init_streaming_mode = function(T, E) {
      let R = S(T = T || [], E = E || "");
      return function(O) {
        return $(O || "", R);
      };
    }, u.exports ? u.exports = k : l.striptags = k;
  })(commonjsGlobal);
}), html_1$1 = createCommonjsModule(function(u) {
  var l = u.exports;
  l.condense = function(f) {
    return f.replace(/(\r\n|\r|\n|\u2028|\u2029) {2,}/g, `
`);
  }, l.padcomments = function(f) {
    return f.replace(/(\s*<!--)/g, `
$1`);
  }, l.parseAttributes = function(f) {
    return Object.keys(f).map(function(p) {
      return p + '="' + String(f[p]).replace(/^['"]|["']$/g, "") + '"';
    }).join(" ");
  }, l.sanitize = function(f) {
    return handlebarsUtils.isString(f) ? striptags(f).trim() : "";
  }, l.toAttributes = function(f) {
    for (var p = "", m = Object.keys(f), b = 0; b < m.length; b++) {
      var y = f[m[b]];
      p += y === !0 ? " " + m[b] : " " + m[b] + '="' + String(y) + '"';
    }
    return p;
  };
}), html_1 = createCommonjsModule(function(u) {
  var l = html_1$1.parseAttributes, f = u.exports;
  f.attr = function(p) {
    var m = l(p && p.hash || {});
    return m.trim() ? " " + m : "";
  }, f.css = function(p, m) {
    arguments.length < 2 && (m = p, p = []);
    var b = handlebarsUtils.arrayify(p), y = "";
    return this && this.options && (y = this.options.assets || ""), m.hash.href && (b = handlebarsUtils.arrayify(m.hash.href)), b.map(function(v) {
      var k = path.extname(v), S = v;
      return /(^\/\/)|(:\/\/)/.test(v) || (S = path.posix.join(y, v)), k === ".less" ? `<link type="text/css" rel="stylesheet/less" href="${S}">` : `<link type="text/css" rel="stylesheet" href="${S}">`;
    }).join(`
`);
  }, f.js = function(p) {
    if (typeof p == "object" && p.hash) {
      var m = l(p.hash);
      return `<script${m ? " " + m : ""}><\/script>`;
    }
    return typeof p == "string" ? `<script src="${p}"><\/script>` : (p = handlebarsUtils.arrayify(p)).map(function(b) {
      return path.extname(b) === ".coffee" ? htmlTag("script", { type: "text/coffeescript", src: b }) : htmlTag("script", { src: b });
    }).join(`
`);
  }, f.sanitize = function(p) {
    return html_1$1.sanitize(p);
  }, f.ul = function(p, m) {
    return "<ul " + l(m.hash) + ">" + p.map(function(b) {
      return typeof b != "string" && (b = m.fn(b)), "<li>" + b + "</li>";
    }).join(`
`) + "</ul>";
  }, f.ol = function(p, m) {
    return "<ol " + l(m.hash) + ">" + p.map(function(b) {
      return typeof b != "string" && (b = m.fn(b)), "<li>" + b + "</li>";
    }).join(`
`) + "</ol>";
  }, f.thumbnailImage = function(p) {
    var m = "", b = "", y = p.full || !1, v = { alt: p.alt, src: p.thumbnail, width: p.size.width, height: p.size.height }, k = { id: "image-" + p.id }, S = { href: y, rel: "thumbnail" };
    return p.classes && (p.classes.image && (v.class = p.classes.image.join(" ")), p.classes.figure && (k.class = p.classes.figure.join(" ")), p.classes.link && (S.class = p.classes.link.join(" "))), m += "<figure " + l(k) + `>
`, b += "<img " + l(v) + `>
`, m += y ? "<a " + l(S) + `>
` + b + `</a>
` : b, p.caption && (m += "<figcaption>" + p.caption + `</figcaption>
`), m += "</figure>";
  };
}), i18n = createCommonjsModule(function(u) {
  u.exports.i18n = function(l, f, p) {
    if (handlebarsUtils.isOptions(f) && (p = f, f = {}), !handlebarsUtils.isString(l))
      throw new Error('{{i18n}} helper expected "key" to be a string');
    var m = handlebarsUtils.options(this, f, p), b = Object.assign({}, this, m), y = b.language || b.lang;
    if (typeof y != "string")
      throw new TypeError('{{i18n}} helper expected "language" to be a string');
    var v = b[y];
    if (v === void 0)
      throw new Error('{{i18n}} helper cannot find language "' + y + '"');
    var k = getValue$1(v, l);
    if (k === void 0)
      throw new Error('{{i18n}} helper cannot find property "' + l + '" for language "' + y + '"');
    return k;
  };
}), inflection = createCommonjsModule(function(u) {
  var l = u.exports;
  l.inflect = function(f, p, m, b) {
    var y = f > 1 || f === 0 ? m : p;
    return b === !0 ? String(f) + " " + y : y;
  }, l.ordinalize = function(f) {
    var p = Math.abs(Math.round(f)), m = String(f), b = p % 100;
    if (handlebarsUtils.indexOf([11, 12, 13], b) >= 0)
      return m + "th";
    switch (p % 10) {
      case 1:
        return m + "st";
      case 2:
        return m + "nd";
      case 3:
        return m + "rd";
      default:
        return m + "th";
    }
  };
}), utils$1 = createCommonjsModule(function(u, l) {
  l.isInteger = (f) => typeof f == "number" ? Number.isInteger(f) : typeof f == "string" && f.trim() !== "" && Number.isInteger(Number(f)), l.find = (f, p) => f.nodes.find((m) => m.type === p), l.exceedsLimit = (f, p, m = 1, b) => b !== !1 && !(!l.isInteger(f) || !l.isInteger(p)) && (Number(p) - Number(f)) / Number(m) >= b, l.escapeNode = (f, p = 0, m) => {
    const b = f.nodes[p];
    b && (m && b.type === m || b.type === "open" || b.type === "close") && b.escaped !== !0 && (b.value = "\\" + b.value, b.escaped = !0);
  }, l.encloseBrace = (f) => f.type === "brace" && !(f.commas >> 0 + f.ranges | 0) && (f.invalid = !0, !0), l.isInvalidBrace = (f) => f.type === "brace" && (!(f.invalid !== !0 && !f.dollar) || (f.commas >> 0 + f.ranges | 0 ? (f.open !== !0 || f.close !== !0) && (f.invalid = !0, !0) : (f.invalid = !0, !0))), l.isOpenOrClose = (f) => f.type === "open" || f.type === "close" || f.open === !0 || f.close === !0, l.reduce = (f) => f.reduce((p, m) => (m.type === "text" && p.push(m.value), m.type === "range" && (m.type = "text"), p), []), l.flatten = (...f) => {
    const p = [], m = (b) => {
      for (let y = 0; y < b.length; y++) {
        const v = b[y];
        Array.isArray(v) ? m(v) : v !== void 0 && p.push(v);
      }
      return p;
    };
    return m(f), p;
  };
}), stringify$2 = (u, l = {}) => {
  const f = (p, m = {}) => {
    const b = l.escapeInvalid && utils$1.isInvalidBrace(m), y = p.invalid === !0 && l.escapeInvalid === !0;
    let v = "";
    if (p.value)
      return (b || y) && utils$1.isOpenOrClose(p) ? "\\" + p.value : p.value;
    if (p.value)
      return p.value;
    if (p.nodes)
      for (const k of p.nodes)
        v += f(k);
    return v;
  };
  return f(u);
}, isNumber$1 = function(u) {
  return typeof u == "number" ? u - u === 0 : typeof u == "string" && u.trim() !== "" && (Number.isFinite ? Number.isFinite(+u) : isFinite(+u));
};
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
const toRegexRange = (u, l, f) => {
  if (isNumber$1(u) === !1)
    throw new TypeError("toRegexRange: expected the first argument to be a number");
  if (l === void 0 || u === l)
    return String(u);
  if (isNumber$1(l) === !1)
    throw new TypeError("toRegexRange: expected the second argument to be a number.");
  let p = { relaxZeros: !0, ...f };
  typeof p.strictZeros == "boolean" && (p.relaxZeros = p.strictZeros === !1);
  let m = u + ":" + l + "=" + String(p.relaxZeros) + String(p.shorthand) + String(p.capture) + String(p.wrap);
  if (toRegexRange.cache.hasOwnProperty(m))
    return toRegexRange.cache[m].result;
  let b = Math.min(u, l), y = Math.max(u, l);
  if (Math.abs(b - y) === 1) {
    let w = u + "|" + l;
    return p.capture ? `(${w})` : p.wrap === !1 ? w : `(?:${w})`;
  }
  let v = hasPadding(u) || hasPadding(l), k = { min: u, max: l, a: b, b: y }, S = [], $ = [];
  return v && (k.isPadded = v, k.maxLen = String(k.max).length), b < 0 && ($ = splitToPatterns(y < 0 ? Math.abs(y) : 1, Math.abs(b), k, p), b = k.a = 0), y >= 0 && (S = splitToPatterns(b, y, k, p)), k.negatives = $, k.positives = S, k.result = collatePatterns($, S), p.capture === !0 ? k.result = `(${k.result})` : p.wrap !== !1 && S.length + $.length > 1 && (k.result = `(?:${k.result})`), toRegexRange.cache[m] = k, k.result;
};
function collatePatterns(u, l, f) {
  let p = filterPatterns(u, l, "-", !1) || [], m = filterPatterns(l, u, "", !1) || [], b = filterPatterns(u, l, "-?", !0) || [];
  return p.concat(b).concat(m).join("|");
}
function splitToRanges(u, l) {
  let f = 1, p = 1, m = countNines(u, f), b = /* @__PURE__ */ new Set([l]);
  for (; u <= m && m <= l; )
    b.add(m), f += 1, m = countNines(u, f);
  for (m = countZeros(l + 1, p) - 1; u < m && m <= l; )
    b.add(m), p += 1, m = countZeros(l + 1, p) - 1;
  return b = [...b], b.sort(compare), b;
}
function rangeToPattern(u, l, f) {
  if (u === l)
    return { pattern: u, count: [], digits: 0 };
  let p = zip(u, l), m = p.length, b = "", y = 0;
  for (let v = 0; v < m; v++) {
    let [k, S] = p[v];
    k === S ? b += k : k !== "0" || S !== "9" ? b += toCharacterClass(k, S) : y++;
  }
  return y && (b += f.shorthand === !0 ? "\\d" : "[0-9]"), { pattern: b, count: [y], digits: m };
}
function splitToPatterns(u, l, f, p) {
  let m, b = splitToRanges(u, l), y = [], v = u;
  for (let k = 0; k < b.length; k++) {
    let S = b[k], $ = rangeToPattern(String(v), String(S), p), w = "";
    f.isPadded || !m || m.pattern !== $.pattern ? (f.isPadded && (w = padZeros(S, f, p)), $.string = w + $.pattern + toQuantifier($.count), y.push($), v = S + 1, m = $) : (m.count.length > 1 && m.count.pop(), m.count.push($.count[0]), m.string = m.pattern + toQuantifier(m.count), v = S + 1);
  }
  return y;
}
function filterPatterns(u, l, f, p, m) {
  let b = [];
  for (let y of u) {
    let { string: v } = y;
    p || contains(l, "string", v) || b.push(f + v), p && contains(l, "string", v) && b.push(f + v);
  }
  return b;
}
function zip(u, l) {
  let f = [];
  for (let p = 0; p < u.length; p++)
    f.push([u[p], l[p]]);
  return f;
}
function compare(u, l) {
  return u > l ? 1 : l > u ? -1 : 0;
}
function contains(u, l, f) {
  return u.some((p) => p[l] === f);
}
function countNines(u, l) {
  return Number(String(u).slice(0, -l) + "9".repeat(l));
}
function countZeros(u, l) {
  return u - u % Math.pow(10, l);
}
function toQuantifier(u) {
  let [l = 0, f = ""] = u;
  return f || l > 1 ? `{${l + (f ? "," + f : "")}}` : "";
}
function toCharacterClass(u, l, f) {
  return `[${u}${l - u === 1 ? "" : "-"}${l}]`;
}
function hasPadding(u) {
  return /^-?(0+)\d/.test(u);
}
function padZeros(u, l, f) {
  if (!l.isPadded)
    return u;
  let p = Math.abs(l.maxLen - String(u).length), m = f.relaxZeros !== !1;
  switch (p) {
    case 0:
      return "";
    case 1:
      return m ? "0?" : "0";
    case 2:
      return m ? "0{0,2}" : "00";
    default:
      return m ? `0{0,${p}}` : `0{${p}}`;
  }
}
toRegexRange.cache = {}, toRegexRange.clearCache = () => toRegexRange.cache = {};
var toRegexRange_1 = toRegexRange;
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
const isObject$3$1 = (u) => u !== null && typeof u == "object" && !Array.isArray(u), transform = (u) => (l) => u === !0 ? Number(l) : String(l), isValidValue = (u) => typeof u == "number" || typeof u == "string" && u !== "", isNumber = (u) => Number.isInteger(+u), zeros = (u) => {
  let l = `${u}`, f = -1;
  if (l[0] === "-" && (l = l.slice(1)), l === "0")
    return !1;
  for (; l[++f] === "0"; )
    ;
  return f > 0;
}, stringify$1 = (u, l, f) => typeof u == "string" || typeof l == "string" || f.stringify === !0, pad = (u, l, f) => {
  if (l > 0) {
    let p = u[0] === "-" ? "-" : "";
    p && (u = u.slice(1)), u = p + u.padStart(p ? l - 1 : l, "0");
  }
  return f === !1 ? String(u) : u;
}, toMaxLen = (u, l) => {
  let f = u[0] === "-" ? "-" : "";
  for (f && (u = u.slice(1), l--); u.length < l; )
    u = "0" + u;
  return f ? "-" + u : u;
}, toSequence = (u, l, f) => {
  u.negatives.sort((v, k) => v < k ? -1 : v > k ? 1 : 0), u.positives.sort((v, k) => v < k ? -1 : v > k ? 1 : 0);
  let p, m = l.capture ? "" : "?:", b = "", y = "";
  return u.positives.length && (b = u.positives.map((v) => toMaxLen(String(v), f)).join("|")), u.negatives.length && (y = `-(${m}${u.negatives.map((v) => toMaxLen(String(v), f)).join("|")})`), p = b && y ? `${b}|${y}` : b || y, l.wrap ? `(${m}${p})` : p;
}, toRange = (u, l, f, p) => {
  if (f)
    return toRegexRange_1(u, l, { wrap: !1, ...p });
  let m = String.fromCharCode(u);
  return u === l ? m : `[${m}-${String.fromCharCode(l)}]`;
}, toRegex = (u, l, f) => {
  if (Array.isArray(u)) {
    let p = f.wrap === !0, m = f.capture ? "" : "?:";
    return p ? `(${m}${u.join("|")})` : u.join("|");
  }
  return toRegexRange_1(u, l, f);
}, rangeError = (...u) => new RangeError("Invalid range arguments: " + util$2.inspect(...u)), invalidRange = (u, l, f) => {
  if (f.strictRanges === !0)
    throw rangeError([u, l]);
  return [];
}, invalidStep = (u, l) => {
  if (l.strictRanges === !0)
    throw new TypeError(`Expected step "${u}" to be a number`);
  return [];
}, fillNumbers = (u, l, f = 1, p = {}) => {
  let m = Number(u), b = Number(l);
  if (!Number.isInteger(m) || !Number.isInteger(b)) {
    if (p.strictRanges === !0)
      throw rangeError([u, l]);
    return [];
  }
  m === 0 && (m = 0), b === 0 && (b = 0);
  let y = m > b, v = String(u), k = String(l), S = String(f);
  f = Math.max(Math.abs(f), 1);
  let $ = zeros(v) || zeros(k) || zeros(S), w = $ ? Math.max(v.length, k.length, S.length) : 0, T = $ === !1 && stringify$1(u, l, p) === !1, E = p.transform || transform(T);
  if (p.toRegex && f === 1)
    return toRange(toMaxLen(u, w), toMaxLen(l, w), !0, p);
  let R = { negatives: [], positives: [] }, O = (M) => R[M < 0 ? "negatives" : "positives"].push(Math.abs(M)), P = [], L = 0;
  for (; y ? m >= b : m <= b; )
    p.toRegex === !0 && f > 1 ? O(m) : P.push(pad(E(m, L), w, T)), m = y ? m - f : m + f, L++;
  return p.toRegex === !0 ? f > 1 ? toSequence(R, p, w) : toRegex(P, null, { wrap: !1, ...p }) : P;
}, fillLetters = (u, l, f = 1, p = {}) => {
  if (!isNumber(u) && u.length > 1 || !isNumber(l) && l.length > 1)
    return invalidRange(u, l, p);
  let m = p.transform || ((T) => String.fromCharCode(T)), b = `${u}`.charCodeAt(0), y = `${l}`.charCodeAt(0), v = b > y, k = Math.min(b, y), S = Math.max(b, y);
  if (p.toRegex && f === 1)
    return toRange(k, S, !1, p);
  let $ = [], w = 0;
  for (; v ? b >= y : b <= y; )
    $.push(m(b, w)), b = v ? b - f : b + f, w++;
  return p.toRegex === !0 ? toRegex($, null, { wrap: !1, options: p }) : $;
}, fill = (u, l, f, p = {}) => {
  if (l == null && isValidValue(u))
    return [u];
  if (!isValidValue(u) || !isValidValue(l))
    return invalidRange(u, l, p);
  if (typeof f == "function")
    return fill(u, l, 1, { transform: f });
  if (isObject$3$1(f))
    return fill(u, l, 0, f);
  let m = { ...p };
  return m.capture === !0 && (m.wrap = !0), f = f || m.step || 1, isNumber(f) ? isNumber(u) && isNumber(l) ? fillNumbers(u, l, f, m) : fillLetters(u, l, Math.max(Math.abs(f), 1), m) : f == null || isObject$3$1(f) ? fill(u, l, 1, f) : invalidStep(f, m);
};
var fillRange = fill;
const compile = (u, l = {}) => {
  const f = (p, m = {}) => {
    const b = utils$1.isInvalidBrace(m), y = p.invalid === !0 && l.escapeInvalid === !0, v = b === !0 || y === !0, k = l.escapeInvalid === !0 ? "\\" : "";
    let S = "";
    if (p.isOpen === !0)
      return k + p.value;
    if (p.isClose === !0)
      return console.log("node.isClose", k, p.value), k + p.value;
    if (p.type === "open")
      return v ? k + p.value : "(";
    if (p.type === "close")
      return v ? k + p.value : ")";
    if (p.type === "comma")
      return p.prev.type === "comma" ? "" : v ? p.value : "|";
    if (p.value)
      return p.value;
    if (p.nodes && p.ranges > 0) {
      const $ = utils$1.reduce(p.nodes), w = fillRange(...$, { ...l, wrap: !1, toRegex: !0, strictZeros: !0 });
      if (w.length !== 0)
        return $.length > 1 && w.length > 1 ? `(${w})` : w;
    }
    if (p.nodes)
      for (const $ of p.nodes)
        S += f($, p);
    return S;
  };
  return f(u);
};
var compile_1 = compile;
const append = (u = "", l = "", f = !1) => {
  const p = [];
  if (u = [].concat(u), !(l = [].concat(l)).length)
    return u;
  if (!u.length)
    return f ? utils$1.flatten(l).map((m) => `{${m}}`) : l;
  for (const m of u)
    if (Array.isArray(m))
      for (const b of m)
        p.push(append(b, l, f));
    else
      for (let b of l)
        f === !0 && typeof b == "string" && (b = `{${b}}`), p.push(Array.isArray(b) ? append(m, b, f) : m + b);
  return utils$1.flatten(p);
}, expand = (u, l = {}) => {
  const f = l.rangeLimit === void 0 ? 1e3 : l.rangeLimit, p = (m, b = {}) => {
    m.queue = [];
    let y = b, v = b.queue;
    for (; y.type !== "brace" && y.type !== "root" && y.parent; )
      y = y.parent, v = y.queue;
    if (m.invalid || m.dollar)
      return void v.push(append(v.pop(), stringify$2(m, l)));
    if (m.type === "brace" && m.invalid !== !0 && m.nodes.length === 2)
      return void v.push(append(v.pop(), ["{}"]));
    if (m.nodes && m.ranges > 0) {
      const w = utils$1.reduce(m.nodes);
      if (utils$1.exceedsLimit(...w, l.step, f))
        throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
      let T = fillRange(...w, l);
      return T.length === 0 && (T = stringify$2(m, l)), v.push(append(v.pop(), T)), void (m.nodes = []);
    }
    const k = utils$1.encloseBrace(m);
    let S = m.queue, $ = m;
    for (; $.type !== "brace" && $.type !== "root" && $.parent; )
      $ = $.parent, S = $.queue;
    for (let w = 0; w < m.nodes.length; w++) {
      const T = m.nodes[w];
      T.type !== "comma" || m.type !== "brace" ? T.type !== "close" ? T.value && T.type !== "open" ? S.push(append(S.pop(), T.value)) : T.nodes && p(T, m) : v.push(append(v.pop(), S, k)) : (w === 1 && S.push(""), S.push(""));
    }
    return S;
  };
  return utils$1.flatten(p(u));
};
var expand_1 = expand, constants$1 = { MAX_LENGTH: 1e4, CHAR_LEFT_PARENTHESES: "(", CHAR_RIGHT_PARENTHESES: ")", CHAR_BACKSLASH: "\\", CHAR_BACKTICK: "`", CHAR_COMMA: ",", CHAR_DOT: ".", CHAR_DOUBLE_QUOTE: '"', CHAR_LEFT_CURLY_BRACE: "{", CHAR_LEFT_SQUARE_BRACKET: "[", CHAR_NO_BREAK_SPACE: "Â ", CHAR_RIGHT_CURLY_BRACE: "}", CHAR_RIGHT_SQUARE_BRACKET: "]", CHAR_SINGLE_QUOTE: "'", CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF" };
const { MAX_LENGTH: MAX_LENGTH$1, CHAR_BACKSLASH, CHAR_BACKTICK, CHAR_COMMA: CHAR_COMMA$1, CHAR_DOT: CHAR_DOT$1, CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1, CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1, CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1, CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1, CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1, CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE } = constants$1, parse$3 = (u, l = {}) => {
  if (typeof u != "string")
    throw new TypeError("Expected a string");
  const f = l || {}, p = typeof f.maxLength == "number" ? Math.min(MAX_LENGTH$1, f.maxLength) : MAX_LENGTH$1;
  if (u.length > p)
    throw new SyntaxError(`Input length (${u.length}), exceeds max characters (${p})`);
  const m = { type: "root", input: u, nodes: [] }, b = [m];
  let y = m, v = m, k = 0;
  const S = u.length;
  let $, w = 0, T = 0;
  const E = () => u[w++], R = (O) => {
    if (O.type === "text" && v.type === "dot" && (v.type = "text"), !v || v.type !== "text" || O.type !== "text")
      return y.nodes.push(O), O.parent = y, O.prev = v, v = O, O;
    v.value += O.value;
  };
  for (R({ type: "bos" }); w < S; )
    if (y = b[b.length - 1], $ = E(), $ !== CHAR_ZERO_WIDTH_NOBREAK_SPACE && $ !== CHAR_NO_BREAK_SPACE)
      if ($ !== CHAR_BACKSLASH)
        if ($ !== CHAR_RIGHT_SQUARE_BRACKET$1) {
          if ($ === CHAR_LEFT_SQUARE_BRACKET$1) {
            let O;
            for (k++; w < S && (O = E()); )
              if ($ += O, O !== CHAR_LEFT_SQUARE_BRACKET$1)
                if (O !== CHAR_BACKSLASH) {
                  if (O === CHAR_RIGHT_SQUARE_BRACKET$1 && (k--, k === 0))
                    break;
                } else
                  $ += E();
              else
                k++;
            R({ type: "text", value: $ });
            continue;
          }
          if ($ !== CHAR_LEFT_PARENTHESES$1)
            if ($ !== CHAR_RIGHT_PARENTHESES$1) {
              if ($ === CHAR_DOUBLE_QUOTE || $ === CHAR_SINGLE_QUOTE || $ === CHAR_BACKTICK) {
                const O = $;
                let P;
                for (l.keepQuotes !== !0 && ($ = ""); w < S && (P = E()); )
                  if (P !== CHAR_BACKSLASH) {
                    if (P === O) {
                      l.keepQuotes === !0 && ($ += P);
                      break;
                    }
                    $ += P;
                  } else
                    $ += P + E();
                R({ type: "text", value: $ });
                continue;
              }
              if ($ === CHAR_LEFT_CURLY_BRACE$1) {
                T++;
                const O = v.value && v.value.slice(-1) === "$" || y.dollar === !0;
                y = R({ type: "brace", open: !0, close: !1, dollar: O, depth: T, commas: 0, ranges: 0, nodes: [] }), b.push(y), R({ type: "open", value: $ });
                continue;
              }
              if ($ === CHAR_RIGHT_CURLY_BRACE$1) {
                if (y.type !== "brace") {
                  R({ type: "text", value: $ });
                  continue;
                }
                const O = "close";
                y = b.pop(), y.close = !0, R({ type: O, value: $ }), T--, y = b[b.length - 1];
                continue;
              }
              if ($ === CHAR_COMMA$1 && T > 0) {
                if (y.ranges > 0) {
                  y.ranges = 0;
                  const O = y.nodes.shift();
                  y.nodes = [O, { type: "text", value: stringify$2(y) }];
                }
                R({ type: "comma", value: $ }), y.commas++;
              } else {
                if ($ === CHAR_DOT$1 && T > 0 && y.commas === 0) {
                  const O = y.nodes;
                  if (T === 0 || O.length === 0) {
                    R({ type: "text", value: $ });
                    continue;
                  }
                  if (v.type === "dot") {
                    if (y.range = [], v.value += $, v.type = "range", y.nodes.length !== 3 && y.nodes.length !== 5) {
                      y.invalid = !0, y.ranges = 0, v.type = "text";
                      continue;
                    }
                    y.ranges++, y.args = [];
                    continue;
                  }
                  if (v.type === "range") {
                    O.pop();
                    const P = O[O.length - 1];
                    P.value += v.value + $, v = P, y.ranges--;
                    continue;
                  }
                  R({ type: "dot", value: $ });
                  continue;
                }
                R({ type: "text", value: $ });
              }
            } else {
              if (y.type !== "paren") {
                R({ type: "text", value: $ });
                continue;
              }
              y = b.pop(), R({ type: "text", value: $ }), y = b[b.length - 1];
            }
          else
            y = R({ type: "paren", nodes: [] }), b.push(y), R({ type: "text", value: $ });
        } else
          R({ type: "text", value: "\\" + $ });
      else
        R({ type: "text", value: (l.keepEscaping ? $ : "") + E() });
  do
    if (y = b.pop(), y.type !== "root") {
      y.nodes.forEach((L) => {
        L.nodes || (L.type === "open" && (L.isOpen = !0), L.type === "close" && (L.isClose = !0), L.nodes || (L.type = "text"), L.invalid = !0);
      });
      const O = b[b.length - 1], P = O.nodes.indexOf(y);
      O.nodes.splice(P, 1, ...y.nodes);
    }
  while (b.length > 0);
  return R({ type: "eos" }), m;
};
var parse_1$2 = parse$3;
const braces = (u, l = {}) => {
  let f = [];
  if (Array.isArray(u))
    for (const p of u) {
      const m = braces.create(p, l);
      Array.isArray(m) ? f.push(...m) : f.push(m);
    }
  else
    f = [].concat(braces.create(u, l));
  return l && l.expand === !0 && l.nodupes === !0 && (f = [...new Set(f)]), f;
};
braces.parse = (u, l = {}) => parse_1$2(u, l), braces.stringify = (u, l = {}) => stringify$2(typeof u == "string" ? braces.parse(u, l) : u, l), braces.compile = (u, l = {}) => (typeof u == "string" && (u = braces.parse(u, l)), compile_1(u, l)), braces.expand = (u, l = {}) => {
  typeof u == "string" && (u = braces.parse(u, l));
  let f = expand_1(u, l);
  return l.noempty === !0 && (f = f.filter(Boolean)), l.nodupes === !0 && (f = [...new Set(f)]), f;
}, braces.create = (u, l = {}) => u === "" || u.length < 3 ? [u] : l.expand !== !0 ? braces.compile(u, l) : braces.expand(u, l);
var braces_1 = braces, browser = createCommonjsModule(function(u) {
  var l, f, p = u.exports = {};
  function m() {
    throw new Error("setTimeout has not been defined");
  }
  function b() {
    throw new Error("clearTimeout has not been defined");
  }
  function y(O) {
    if (l === setTimeout)
      return setTimeout(O, 0);
    if ((l === m || !l) && setTimeout)
      return l = setTimeout, setTimeout(O, 0);
    try {
      return l(O, 0);
    } catch {
      try {
        return l.call(null, O, 0);
      } catch {
        return l.call(this, O, 0);
      }
    }
  }
  (function() {
    try {
      l = typeof setTimeout == "function" ? setTimeout : m;
    } catch {
      l = m;
    }
    try {
      f = typeof clearTimeout == "function" ? clearTimeout : b;
    } catch {
      f = b;
    }
  })();
  var v, k = [], S = !1, $ = -1;
  function w() {
    S && v && (S = !1, v.length ? k = v.concat(k) : $ = -1, k.length && T());
  }
  function T() {
    if (!S) {
      var O = y(w);
      S = !0;
      for (var P = k.length; P; ) {
        for (v = k, k = []; ++$ < P; )
          v && v[$].run();
        $ = -1, P = k.length;
      }
      v = null, S = !1, function(L) {
        if (f === clearTimeout)
          return clearTimeout(L);
        if ((f === b || !f) && clearTimeout)
          return f = clearTimeout, clearTimeout(L);
        try {
          return f(L);
        } catch {
          try {
            return f.call(null, L);
          } catch {
            return f.call(this, L);
          }
        }
      }(O);
    }
  }
  function E(O, P) {
    this.fun = O, this.array = P;
  }
  function R() {
  }
  p.nextTick = function(O) {
    var P = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var L = 1; L < arguments.length; L++)
        P[L - 1] = arguments[L];
    k.push(new E(O, P)), k.length !== 1 || S || y(T);
  }, E.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, p.title = "browser", p.browser = !0, p.env = {}, p.argv = [], p.version = "", p.versions = {}, p.on = R, p.addListener = R, p.once = R, p.off = R, p.removeListener = R, p.removeAllListeners = R, p.emit = R, p.prependListener = R, p.prependOnceListener = R, p.listeners = function(O) {
    return [];
  }, p.binding = function(O) {
    throw new Error("process.binding is not supported");
  }, p.cwd = function() {
    return "/";
  }, p.chdir = function(O) {
    throw new Error("process.chdir is not supported");
  }, p.umask = function() {
    return 0;
  };
});
const WIN_SLASH = "\\\\/", WIN_NO_SLASH = `[^${WIN_SLASH}]`, DOT_LITERAL = "\\.", PLUS_LITERAL = "\\+", QMARK_LITERAL = "\\?", SLASH_LITERAL = "\\/", ONE_CHAR = "(?=.)", QMARK = "[^/]", END_ANCHOR = `(?:${SLASH_LITERAL}|$)`, START_ANCHOR = `(?:^|${SLASH_LITERAL})`, DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`, NO_DOT = `(?!${DOT_LITERAL})`, NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`, NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`, NO_DOTS_SLASH = `(?!${DOTS_SLASH})`, QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`, STAR = `${QMARK}*?`, POSIX_CHARS = { DOT_LITERAL, PLUS_LITERAL, QMARK_LITERAL, SLASH_LITERAL, ONE_CHAR, QMARK, END_ANCHOR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK_NO_DOT, STAR, START_ANCHOR }, WINDOWS_CHARS = { ...POSIX_CHARS, SLASH_LITERAL: `[${WIN_SLASH}]`, QMARK: WIN_NO_SLASH, STAR: `${WIN_NO_SLASH}*?`, DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`, NO_DOT: `(?!${DOT_LITERAL})`, NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`, NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`, NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`, QMARK_NO_DOT: `[^.${WIN_SLASH}]`, START_ANCHOR: `(?:^|[${WIN_SLASH}])`, END_ANCHOR: `(?:[${WIN_SLASH}]|$)` }, POSIX_REGEX_SOURCE$1 = { alnum: "a-zA-Z0-9", alpha: "a-zA-Z", ascii: "\\x00-\\x7F", blank: " \\t", cntrl: "\\x00-\\x1F\\x7F", digit: "0-9", graph: "\\x21-\\x7E", lower: "a-z", print: "\\x20-\\x7E ", punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~", space: " \\t\\r\\n\\v\\f", upper: "A-Z", word: "A-Za-z0-9_", xdigit: "A-Fa-f0-9" };
var constants = { MAX_LENGTH: 65536, POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1, REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g, REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/, REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/, REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g, REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g, REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g, REPLACEMENTS: { "***": "*", "**/**": "**", "**/**/**": "**" }, CHAR_0: 48, CHAR_9: 57, CHAR_UPPERCASE_A: 65, CHAR_LOWERCASE_A: 97, CHAR_UPPERCASE_Z: 90, CHAR_LOWERCASE_Z: 122, CHAR_LEFT_PARENTHESES: 40, CHAR_RIGHT_PARENTHESES: 41, CHAR_ASTERISK: 42, CHAR_AMPERSAND: 38, CHAR_AT: 64, CHAR_BACKWARD_SLASH: 92, CHAR_CARRIAGE_RETURN: 13, CHAR_CIRCUMFLEX_ACCENT: 94, CHAR_COLON: 58, CHAR_COMMA: 44, CHAR_DOT: 46, CHAR_DOUBLE_QUOTE: 34, CHAR_EQUAL: 61, CHAR_EXCLAMATION_MARK: 33, CHAR_FORM_FEED: 12, CHAR_FORWARD_SLASH: 47, CHAR_GRAVE_ACCENT: 96, CHAR_HASH: 35, CHAR_HYPHEN_MINUS: 45, CHAR_LEFT_ANGLE_BRACKET: 60, CHAR_LEFT_CURLY_BRACE: 123, CHAR_LEFT_SQUARE_BRACKET: 91, CHAR_LINE_FEED: 10, CHAR_NO_BREAK_SPACE: 160, CHAR_PERCENT: 37, CHAR_PLUS: 43, CHAR_QUESTION_MARK: 63, CHAR_RIGHT_ANGLE_BRACKET: 62, CHAR_RIGHT_CURLY_BRACE: 125, CHAR_RIGHT_SQUARE_BRACKET: 93, CHAR_SEMICOLON: 59, CHAR_SINGLE_QUOTE: 39, CHAR_SPACE: 32, CHAR_TAB: 9, CHAR_UNDERSCORE: 95, CHAR_VERTICAL_LINE: 124, CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, SEP: path.sep, extglobChars: (u) => ({ "!": { type: "negate", open: "(?:(?!(?:", close: `))${u.STAR})` }, "?": { type: "qmark", open: "(?:", close: ")?" }, "+": { type: "plus", open: "(?:", close: ")+" }, "*": { type: "star", open: "(?:", close: ")*" }, "@": { type: "at", open: "(?:", close: ")" } }), globChars: (u) => u === !0 ? WINDOWS_CHARS : POSIX_CHARS }, utils = createCommonjsModule(function(u, l) {
  const f = browser.platform === "win32", { REGEX_BACKSLASH: p, REGEX_REMOVE_BACKSLASH: m, REGEX_SPECIAL_CHARS: b, REGEX_SPECIAL_CHARS_GLOBAL: y } = constants;
  l.isObject = (v) => v !== null && typeof v == "object" && !Array.isArray(v), l.hasRegexChars = (v) => b.test(v), l.isRegexChar = (v) => v.length === 1 && l.hasRegexChars(v), l.escapeRegex = (v) => v.replace(y, "\\$1"), l.toPosixSlashes = (v) => v.replace(p, "/"), l.removeBackslashes = (v) => v.replace(m, (k) => k === "\\" ? "" : k), l.supportsLookbehinds = () => {
    const v = browser.version.slice(1).split(".").map(Number);
    return v.length === 3 && v[0] >= 9 || v[0] === 8 && v[1] >= 10;
  }, l.isWindows = (v) => v && typeof v.windows == "boolean" ? v.windows : f === !0 || path.sep === "\\", l.escapeLast = (v, k, S) => {
    const $ = v.lastIndexOf(k, S);
    return $ === -1 ? v : v[$ - 1] === "\\" ? l.escapeLast(v, k, $ - 1) : `${v.slice(0, $)}\\${v.slice($)}`;
  }, l.removePrefix = (v, k = {}) => {
    let S = v;
    return S.startsWith("./") && (S = S.slice(2), k.prefix = "./"), S;
  }, l.wrapOutput = (v, k = {}, S = {}) => {
    let $ = `${S.contains ? "" : "^"}(?:${v})${S.contains ? "" : "$"}`;
    return k.negated === !0 && ($ = `(?:^(?!${$}).*$)`), $;
  };
});
const { CHAR_ASTERISK, CHAR_AT, CHAR_BACKWARD_SLASH, CHAR_COMMA, CHAR_DOT, CHAR_EXCLAMATION_MARK, CHAR_FORWARD_SLASH, CHAR_LEFT_CURLY_BRACE, CHAR_LEFT_PARENTHESES, CHAR_LEFT_SQUARE_BRACKET, CHAR_PLUS, CHAR_QUESTION_MARK, CHAR_RIGHT_CURLY_BRACE, CHAR_RIGHT_PARENTHESES, CHAR_RIGHT_SQUARE_BRACKET } = constants, isPathSeparator = (u) => u === CHAR_FORWARD_SLASH || u === CHAR_BACKWARD_SLASH, depth = (u) => {
  u.isPrefix !== !0 && (u.depth = u.isGlobstar ? 1 / 0 : 1);
}, scan = (u, l) => {
  const f = l || {}, p = u.length - 1, m = f.parts === !0 || f.scanToEnd === !0, b = [], y = [], v = [];
  let k, S, $ = u, w = -1, T = 0, E = 0, R = !1, O = !1, P = !1, L = !1, M = !1, B = !1, j = !1, x = !1, N = !1, D = !1, V = 0, W = { value: "", depth: 0, isGlob: !1 };
  const F = () => w >= p, U = () => $.charCodeAt(w + 1), Y = () => (k = S, $.charCodeAt(++w));
  for (; w < p; ) {
    let X;
    if (S = Y(), S !== CHAR_BACKWARD_SLASH) {
      if (B === !0 || S === CHAR_LEFT_CURLY_BRACE) {
        for (V++; F() !== !0 && (S = Y()); )
          if (S !== CHAR_BACKWARD_SLASH)
            if (S !== CHAR_LEFT_CURLY_BRACE) {
              if (B !== !0 && S === CHAR_DOT && (S = Y()) === CHAR_DOT) {
                if (R = W.isBrace = !0, P = W.isGlob = !0, D = !0, m === !0)
                  continue;
                break;
              }
              if (B !== !0 && S === CHAR_COMMA) {
                if (R = W.isBrace = !0, P = W.isGlob = !0, D = !0, m === !0)
                  continue;
                break;
              }
              if (S === CHAR_RIGHT_CURLY_BRACE && (V--, V === 0)) {
                B = !1, R = W.isBrace = !0, D = !0;
                break;
              }
            } else
              V++;
          else
            j = W.backslashes = !0, Y();
        if (m === !0)
          continue;
        break;
      }
      if (S !== CHAR_FORWARD_SLASH) {
        if (f.noext !== !0 && (S === CHAR_PLUS || S === CHAR_AT || S === CHAR_ASTERISK || S === CHAR_QUESTION_MARK || S === CHAR_EXCLAMATION_MARK) && U() === CHAR_LEFT_PARENTHESES) {
          if (P = W.isGlob = !0, L = W.isExtglob = !0, D = !0, S === CHAR_EXCLAMATION_MARK && w === T && (N = !0), m === !0) {
            for (; F() !== !0 && (S = Y()); )
              if (S !== CHAR_BACKWARD_SLASH) {
                if (S === CHAR_RIGHT_PARENTHESES) {
                  P = W.isGlob = !0, D = !0;
                  break;
                }
              } else
                j = W.backslashes = !0, S = Y();
            continue;
          }
          break;
        }
        if (S === CHAR_ASTERISK) {
          if (k === CHAR_ASTERISK && (M = W.isGlobstar = !0), P = W.isGlob = !0, D = !0, m === !0)
            continue;
          break;
        }
        if (S === CHAR_QUESTION_MARK) {
          if (P = W.isGlob = !0, D = !0, m === !0)
            continue;
          break;
        }
        if (S === CHAR_LEFT_SQUARE_BRACKET) {
          for (; F() !== !0 && (X = Y()); )
            if (X !== CHAR_BACKWARD_SLASH) {
              if (X === CHAR_RIGHT_SQUARE_BRACKET) {
                O = W.isBracket = !0, P = W.isGlob = !0, D = !0;
                break;
              }
            } else
              j = W.backslashes = !0, Y();
          if (m === !0)
            continue;
          break;
        }
        if (f.nonegate === !0 || S !== CHAR_EXCLAMATION_MARK || w !== T) {
          if (f.noparen !== !0 && S === CHAR_LEFT_PARENTHESES) {
            if (P = W.isGlob = !0, m === !0) {
              for (; F() !== !0 && (S = Y()); )
                if (S !== CHAR_LEFT_PARENTHESES) {
                  if (S === CHAR_RIGHT_PARENTHESES) {
                    D = !0;
                    break;
                  }
                } else
                  j = W.backslashes = !0, S = Y();
              continue;
            }
            break;
          }
          if (P === !0) {
            if (D = !0, m === !0)
              continue;
            break;
          }
        } else
          x = W.negated = !0, T++;
      } else {
        if (b.push(w), y.push(W), W = { value: "", depth: 0, isGlob: !1 }, D === !0)
          continue;
        if (k === CHAR_DOT && w === T + 1) {
          T += 2;
          continue;
        }
        E = w + 1;
      }
    } else
      j = W.backslashes = !0, S = Y(), S === CHAR_LEFT_CURLY_BRACE && (B = !0);
  }
  f.noext === !0 && (L = !1, P = !1);
  let q = $, Q = "", z = "";
  T > 0 && (Q = $.slice(0, T), $ = $.slice(T), E -= T), q && P === !0 && E > 0 ? (q = $.slice(0, E), z = $.slice(E)) : P === !0 ? (q = "", z = $) : q = $, q && q !== "" && q !== "/" && q !== $ && isPathSeparator(q.charCodeAt(q.length - 1)) && (q = q.slice(0, -1)), f.unescape === !0 && (z && (z = utils.removeBackslashes(z)), q && j === !0 && (q = utils.removeBackslashes(q)));
  const H = { prefix: Q, input: u, start: T, base: q, glob: z, isBrace: R, isBracket: O, isGlob: P, isExtglob: L, isGlobstar: M, negated: x, negatedExtglob: N };
  if (f.tokens === !0 && (H.maxDepth = 0, isPathSeparator(S) || y.push(W), H.tokens = y), f.parts === !0 || f.tokens === !0) {
    let X;
    for (let Z = 0; Z < b.length; Z++) {
      const oe = X ? X + 1 : T, ee = b[Z], ie = u.slice(oe, ee);
      f.tokens && (Z === 0 && T !== 0 ? (y[Z].isPrefix = !0, y[Z].value = Q) : y[Z].value = ie, depth(y[Z]), H.maxDepth += y[Z].depth), Z === 0 && ie === "" || v.push(ie), X = ee;
    }
    if (X && X + 1 < u.length) {
      const Z = u.slice(X + 1);
      v.push(Z), f.tokens && (y[y.length - 1].value = Z, depth(y[y.length - 1]), H.maxDepth += y[y.length - 1].depth);
    }
    H.slashes = b, H.parts = v;
  }
  return H;
};
var scan_1 = scan;
const { MAX_LENGTH, POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS } = constants, expandRange = (u, l) => {
  if (typeof l.expandRange == "function")
    return l.expandRange(...u, l);
  u.sort();
  const f = `[${u.join("-")}]`;
  try {
    new RegExp(f);
  } catch {
    return u.map((m) => utils.escapeRegex(m)).join("..");
  }
  return f;
}, syntaxError = (u, l) => `Missing ${u}: "${l}" - use "\\\\${l}" to match literal characters`, parse$2 = (u, l) => {
  if (typeof u != "string")
    throw new TypeError("Expected a string");
  u = REPLACEMENTS[u] || u;
  const f = { ...l }, p = typeof f.maxLength == "number" ? Math.min(MAX_LENGTH, f.maxLength) : MAX_LENGTH;
  let m = u.length;
  if (m > p)
    throw new SyntaxError(`Input length: ${m}, exceeds maximum allowed length: ${p}`);
  const b = { type: "bos", value: "", output: f.prepend || "" }, y = [b], v = f.capture ? "" : "?:", k = utils.isWindows(l), S = constants.globChars(k), $ = constants.extglobChars(S), { DOT_LITERAL: w, PLUS_LITERAL: T, SLASH_LITERAL: E, ONE_CHAR: R, DOTS_SLASH: O, NO_DOT: P, NO_DOT_SLASH: L, NO_DOTS_SLASH: M, QMARK: B, QMARK_NO_DOT: j, STAR: x, START_ANCHOR: N } = S, D = (te) => `(${v}(?:(?!${N}${te.dot ? O : w}).)*?)`, V = f.dot ? "" : P, W = f.dot ? B : j;
  let F = f.bash === !0 ? D(f) : x;
  f.capture && (F = `(${F})`), typeof f.noext == "boolean" && (f.noextglob = f.noext);
  const U = { input: u, index: -1, start: 0, dot: f.dot === !0, consumed: "", output: "", prefix: "", backtrack: !1, negated: !1, brackets: 0, braces: 0, parens: 0, quotes: 0, globstar: !1, tokens: y };
  u = utils.removePrefix(u, U), m = u.length;
  const Y = [], q = [], Q = [];
  let z, H = b;
  const X = () => U.index === m - 1, Z = U.peek = (te = 1) => u[U.index + te], oe = U.advance = () => u[++U.index] || "", ee = () => u.slice(U.index + 1), ie = (te = "", ue = 0) => {
    U.consumed += te, U.index += ue;
  }, de = (te) => {
    U.output += te.output != null ? te.output : te.value, ie(te.value);
  }, pe = () => {
    let te = 1;
    for (; Z() === "!" && (Z(2) !== "(" || Z(3) === "?"); )
      oe(), U.start++, te++;
    return te % 2 != 0 && (U.negated = !0, U.start++, !0);
  }, le = (te) => {
    U[te]++, Q.push(te);
  }, ae = (te) => {
    U[te]--, Q.pop();
  }, ne = (te) => {
    if (H.type === "globstar") {
      const ue = U.braces > 0 && (te.type === "comma" || te.type === "brace"), J = te.extglob === !0 || Y.length && (te.type === "pipe" || te.type === "paren");
      te.type === "slash" || te.type === "paren" || ue || J || (U.output = U.output.slice(0, -H.output.length), H.type = "star", H.value = "*", H.output = F, U.output += H.output);
    }
    if (Y.length && te.type !== "paren" && (Y[Y.length - 1].inner += te.value), (te.value || te.output) && de(te), H && H.type === "text" && te.type === "text")
      return H.value += te.value, void (H.output = (H.output || "") + te.value);
    te.prev = H, y.push(te), H = te;
  }, K = (te, ue) => {
    const J = { ...$[ue], conditions: 1, inner: "" };
    J.prev = H, J.parens = U.parens, J.output = U.output;
    const fe = (f.capture ? "(" : "") + J.open;
    le("parens"), ne({ type: te, value: ue, output: U.output ? "" : R }), ne({ type: "paren", extglob: !0, value: oe(), output: fe }), Y.push(J);
  }, ce = (te) => {
    let ue, J = te.close + (f.capture ? ")" : "");
    if (te.type === "negate") {
      let fe = F;
      if (te.inner && te.inner.length > 1 && te.inner.includes("/") && (fe = D(f)), (fe !== F || X() || /^\)+$/.test(ee())) && (J = te.close = `)$))${fe}`), te.inner.includes("*") && (ue = ee()) && /^\.[^\\/.]+$/.test(ue)) {
        const _e = parse$2(ue, { ...l, fastpaths: !1 }).output;
        J = te.close = `)${_e})${fe})`;
      }
      te.prev.type === "bos" && (U.negatedExtglob = !0);
    }
    ne({ type: "paren", extglob: !0, value: z, output: J }), ae("parens");
  };
  if (f.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(u)) {
    let te = !1, ue = u.replace(REGEX_SPECIAL_CHARS_BACKREF, (J, fe, _e, ye, ke, we) => ye === "\\" ? (te = !0, J) : ye === "?" ? fe ? fe + ye + (ke ? B.repeat(ke.length) : "") : we === 0 ? W + (ke ? B.repeat(ke.length) : "") : B.repeat(_e.length) : ye === "." ? w.repeat(_e.length) : ye === "*" ? fe ? fe + ye + (ke ? F : "") : F : fe ? J : `\\${J}`);
    return te === !0 && (ue = f.unescape === !0 ? ue.replace(/\\/g, "") : ue.replace(/\\+/g, (J) => J.length % 2 == 0 ? "\\\\" : J ? "\\" : "")), ue === u && f.contains === !0 ? (U.output = u, U) : (U.output = utils.wrapOutput(ue, U, l), U);
  }
  for (; !X(); ) {
    if (z = oe(), z === "\0")
      continue;
    if (z === "\\") {
      const J = Z();
      if (J === "/" && f.bash !== !0 || J === "." || J === ";")
        continue;
      if (!J) {
        z += "\\", ne({ type: "text", value: z });
        continue;
      }
      const fe = /^\\+/.exec(ee());
      let _e = 0;
      if (fe && fe[0].length > 2 && (_e = fe[0].length, U.index += _e, _e % 2 != 0 && (z += "\\")), f.unescape === !0 ? z = oe() : z += oe(), U.brackets === 0) {
        ne({ type: "text", value: z });
        continue;
      }
    }
    if (U.brackets > 0 && (z !== "]" || H.value === "[" || H.value === "[^")) {
      if (f.posix !== !1 && z === ":") {
        const J = H.value.slice(1);
        if (J.includes("[") && (H.posix = !0, J.includes(":"))) {
          const fe = H.value.lastIndexOf("["), _e = H.value.slice(0, fe), ye = H.value.slice(fe + 2), ke = POSIX_REGEX_SOURCE[ye];
          if (ke) {
            H.value = _e + ke, U.backtrack = !0, oe(), b.output || y.indexOf(H) !== 1 || (b.output = R);
            continue;
          }
        }
      }
      (z === "[" && Z() !== ":" || z === "-" && Z() === "]") && (z = `\\${z}`), z !== "]" || H.value !== "[" && H.value !== "[^" || (z = `\\${z}`), f.posix === !0 && z === "!" && H.value === "[" && (z = "^"), H.value += z, de({ value: z });
      continue;
    }
    if (U.quotes === 1 && z !== '"') {
      z = utils.escapeRegex(z), H.value += z, de({ value: z });
      continue;
    }
    if (z === '"') {
      U.quotes = U.quotes === 1 ? 0 : 1, f.keepQuotes === !0 && ne({ type: "text", value: z });
      continue;
    }
    if (z === "(") {
      le("parens"), ne({ type: "paren", value: z });
      continue;
    }
    if (z === ")") {
      if (U.parens === 0 && f.strictBrackets === !0)
        throw new SyntaxError(syntaxError("opening", "("));
      const J = Y[Y.length - 1];
      if (J && U.parens === J.parens + 1) {
        ce(Y.pop());
        continue;
      }
      ne({ type: "paren", value: z, output: U.parens ? ")" : "\\)" }), ae("parens");
      continue;
    }
    if (z === "[") {
      if (f.nobracket !== !0 && ee().includes("]"))
        le("brackets");
      else {
        if (f.nobracket !== !0 && f.strictBrackets === !0)
          throw new SyntaxError(syntaxError("closing", "]"));
        z = `\\${z}`;
      }
      ne({ type: "bracket", value: z });
      continue;
    }
    if (z === "]") {
      if (f.nobracket === !0 || H && H.type === "bracket" && H.value.length === 1) {
        ne({ type: "text", value: z, output: `\\${z}` });
        continue;
      }
      if (U.brackets === 0) {
        if (f.strictBrackets === !0)
          throw new SyntaxError(syntaxError("opening", "["));
        ne({ type: "text", value: z, output: `\\${z}` });
        continue;
      }
      ae("brackets");
      const J = H.value.slice(1);
      if (H.posix === !0 || J[0] !== "^" || J.includes("/") || (z = `/${z}`), H.value += z, de({ value: z }), f.literalBrackets === !1 || utils.hasRegexChars(J))
        continue;
      const fe = utils.escapeRegex(H.value);
      if (U.output = U.output.slice(0, -H.value.length), f.literalBrackets === !0) {
        U.output += fe, H.value = fe;
        continue;
      }
      H.value = `(${v}${fe}|${H.value})`, U.output += H.value;
      continue;
    }
    if (z === "{" && f.nobrace !== !0) {
      le("braces");
      const J = { type: "brace", value: z, output: "(", outputIndex: U.output.length, tokensIndex: U.tokens.length };
      q.push(J), ne(J);
      continue;
    }
    if (z === "}") {
      const J = q[q.length - 1];
      if (f.nobrace === !0 || !J) {
        ne({ type: "text", value: z, output: z });
        continue;
      }
      let fe = ")";
      if (J.dots === !0) {
        const _e = y.slice(), ye = [];
        for (let ke = _e.length - 1; ke >= 0 && (y.pop(), _e[ke].type !== "brace"); ke--)
          _e[ke].type !== "dots" && ye.unshift(_e[ke].value);
        fe = expandRange(ye, f), U.backtrack = !0;
      }
      if (J.comma !== !0 && J.dots !== !0) {
        const _e = U.output.slice(0, J.outputIndex), ye = U.tokens.slice(J.tokensIndex);
        J.value = J.output = "\\{", z = fe = "\\}", U.output = _e;
        for (const ke of ye)
          U.output += ke.output || ke.value;
      }
      ne({ type: "brace", value: z, output: fe }), ae("braces"), q.pop();
      continue;
    }
    if (z === "|") {
      Y.length > 0 && Y[Y.length - 1].conditions++, ne({ type: "text", value: z });
      continue;
    }
    if (z === ",") {
      let J = z;
      const fe = q[q.length - 1];
      fe && Q[Q.length - 1] === "braces" && (fe.comma = !0, J = "|"), ne({ type: "comma", value: z, output: J });
      continue;
    }
    if (z === "/") {
      if (H.type === "dot" && U.index === U.start + 1) {
        U.start = U.index + 1, U.consumed = "", U.output = "", y.pop(), H = b;
        continue;
      }
      ne({ type: "slash", value: z, output: E });
      continue;
    }
    if (z === ".") {
      if (U.braces > 0 && H.type === "dot") {
        H.value === "." && (H.output = w);
        const J = q[q.length - 1];
        H.type = "dots", H.output += z, H.value += z, J.dots = !0;
        continue;
      }
      if (U.braces + U.parens === 0 && H.type !== "bos" && H.type !== "slash") {
        ne({ type: "text", value: z, output: w });
        continue;
      }
      ne({ type: "dot", value: z, output: w });
      continue;
    }
    if (z === "?") {
      if (!(H && H.value === "(") && f.noextglob !== !0 && Z() === "(" && Z(2) !== "?") {
        K("qmark", z);
        continue;
      }
      if (H && H.type === "paren") {
        const J = Z();
        let fe = z;
        if (J === "<" && !utils.supportsLookbehinds())
          throw new Error("Node.js v10 or higher is required for regex lookbehinds");
        (H.value === "(" && !/[!=<:]/.test(J) || J === "<" && !/<([!=]|\w+>)/.test(ee())) && (fe = `\\${z}`), ne({ type: "text", value: z, output: fe });
        continue;
      }
      if (f.dot !== !0 && (H.type === "slash" || H.type === "bos")) {
        ne({ type: "qmark", value: z, output: j });
        continue;
      }
      ne({ type: "qmark", value: z, output: B });
      continue;
    }
    if (z === "!") {
      if (f.noextglob !== !0 && Z() === "(" && (Z(2) !== "?" || !/[!=<:]/.test(Z(3)))) {
        K("negate", z);
        continue;
      }
      if (f.nonegate !== !0 && U.index === 0) {
        pe();
        continue;
      }
    }
    if (z === "+") {
      if (f.noextglob !== !0 && Z() === "(" && Z(2) !== "?") {
        K("plus", z);
        continue;
      }
      if (H && H.value === "(" || f.regex === !1) {
        ne({ type: "plus", value: z, output: T });
        continue;
      }
      if (H && (H.type === "bracket" || H.type === "paren" || H.type === "brace") || U.parens > 0) {
        ne({ type: "plus", value: z });
        continue;
      }
      ne({ type: "plus", value: T });
      continue;
    }
    if (z === "@") {
      if (f.noextglob !== !0 && Z() === "(" && Z(2) !== "?") {
        ne({ type: "at", extglob: !0, value: z, output: "" });
        continue;
      }
      ne({ type: "text", value: z });
      continue;
    }
    if (z !== "*") {
      z !== "$" && z !== "^" || (z = `\\${z}`);
      const J = REGEX_NON_SPECIAL_CHARS.exec(ee());
      J && (z += J[0], U.index += J[0].length), ne({ type: "text", value: z });
      continue;
    }
    if (H && (H.type === "globstar" || H.star === !0)) {
      H.type = "star", H.star = !0, H.value += z, H.output = F, U.backtrack = !0, U.globstar = !0, ie(z);
      continue;
    }
    let te = ee();
    if (f.noextglob !== !0 && /^\([^?]/.test(te)) {
      K("star", z);
      continue;
    }
    if (H.type === "star") {
      if (f.noglobstar === !0) {
        ie(z);
        continue;
      }
      const J = H.prev, fe = J.prev, _e = J.type === "slash" || J.type === "bos", ye = fe && (fe.type === "star" || fe.type === "globstar");
      if (f.bash === !0 && (!_e || te[0] && te[0] !== "/")) {
        ne({ type: "star", value: z, output: "" });
        continue;
      }
      const ke = U.braces > 0 && (J.type === "comma" || J.type === "brace"), we = Y.length && (J.type === "pipe" || J.type === "paren");
      if (!_e && J.type !== "paren" && !ke && !we) {
        ne({ type: "star", value: z, output: "" });
        continue;
      }
      for (; te.slice(0, 3) === "/**"; ) {
        const se = u[U.index + 4];
        if (se && se !== "/")
          break;
        te = te.slice(3), ie("/**", 3);
      }
      if (J.type === "bos" && X()) {
        H.type = "globstar", H.value += z, H.output = D(f), U.output = H.output, U.globstar = !0, ie(z);
        continue;
      }
      if (J.type === "slash" && J.prev.type !== "bos" && !ye && X()) {
        U.output = U.output.slice(0, -(J.output + H.output).length), J.output = `(?:${J.output}`, H.type = "globstar", H.output = D(f) + (f.strictSlashes ? ")" : "|$)"), H.value += z, U.globstar = !0, U.output += J.output + H.output, ie(z);
        continue;
      }
      if (J.type === "slash" && J.prev.type !== "bos" && te[0] === "/") {
        const se = te[1] !== void 0 ? "|$" : "";
        U.output = U.output.slice(0, -(J.output + H.output).length), J.output = `(?:${J.output}`, H.type = "globstar", H.output = `${D(f)}${E}|${E}${se})`, H.value += z, U.output += J.output + H.output, U.globstar = !0, ie(z + oe()), ne({ type: "slash", value: "/", output: "" });
        continue;
      }
      if (J.type === "bos" && te[0] === "/") {
        H.type = "globstar", H.value += z, H.output = `(?:^|${E}|${D(f)}${E})`, U.output = H.output, U.globstar = !0, ie(z + oe()), ne({ type: "slash", value: "/", output: "" });
        continue;
      }
      U.output = U.output.slice(0, -H.output.length), H.type = "globstar", H.output = D(f), H.value += z, U.output += H.output, U.globstar = !0, ie(z);
      continue;
    }
    const ue = { type: "star", value: z, output: F };
    f.bash !== !0 ? !H || H.type !== "bracket" && H.type !== "paren" || f.regex !== !0 ? (U.index !== U.start && H.type !== "slash" && H.type !== "dot" || (H.type === "dot" ? (U.output += L, H.output += L) : f.dot === !0 ? (U.output += M, H.output += M) : (U.output += V, H.output += V), Z() !== "*" && (U.output += R, H.output += R)), ne(ue)) : (ue.output = z, ne(ue)) : (ue.output = ".*?", H.type !== "bos" && H.type !== "slash" || (ue.output = V + ue.output), ne(ue));
  }
  for (; U.brackets > 0; ) {
    if (f.strictBrackets === !0)
      throw new SyntaxError(syntaxError("closing", "]"));
    U.output = utils.escapeLast(U.output, "["), ae("brackets");
  }
  for (; U.parens > 0; ) {
    if (f.strictBrackets === !0)
      throw new SyntaxError(syntaxError("closing", ")"));
    U.output = utils.escapeLast(U.output, "("), ae("parens");
  }
  for (; U.braces > 0; ) {
    if (f.strictBrackets === !0)
      throw new SyntaxError(syntaxError("closing", "}"));
    U.output = utils.escapeLast(U.output, "{"), ae("braces");
  }
  if (f.strictSlashes === !0 || H.type !== "star" && H.type !== "bracket" || ne({ type: "maybe_slash", value: "", output: `${E}?` }), U.backtrack === !0) {
    U.output = "";
    for (const te of U.tokens)
      U.output += te.output != null ? te.output : te.value, te.suffix && (U.output += te.suffix);
  }
  return U;
};
parse$2.fastpaths = (u, l) => {
  const f = { ...l }, p = typeof f.maxLength == "number" ? Math.min(MAX_LENGTH, f.maxLength) : MAX_LENGTH, m = u.length;
  if (m > p)
    throw new SyntaxError(`Input length: ${m}, exceeds maximum allowed length: ${p}`);
  u = REPLACEMENTS[u] || u;
  const b = utils.isWindows(l), { DOT_LITERAL: y, SLASH_LITERAL: v, ONE_CHAR: k, DOTS_SLASH: S, NO_DOT: $, NO_DOTS: w, NO_DOTS_SLASH: T, STAR: E, START_ANCHOR: R } = constants.globChars(b), O = f.dot ? w : $, P = f.dot ? T : $, L = f.capture ? "" : "?:";
  let M = f.bash === !0 ? ".*?" : E;
  f.capture && (M = `(${M})`);
  const B = (D) => D.noglobstar === !0 ? M : `(${L}(?:(?!${R}${D.dot ? S : y}).)*?)`, j = (D) => {
    switch (D) {
      case "*":
        return `${O}${k}${M}`;
      case ".*":
        return `${y}${k}${M}`;
      case "*.*":
        return `${O}${M}${y}${k}${M}`;
      case "*/*":
        return `${O}${M}${v}${k}${P}${M}`;
      case "**":
        return O + B(f);
      case "**/*":
        return `(?:${O}${B(f)}${v})?${P}${k}${M}`;
      case "**/*.*":
        return `(?:${O}${B(f)}${v})?${P}${M}${y}${k}${M}`;
      case "**/.*":
        return `(?:${O}${B(f)}${v})?${y}${k}${M}`;
      default: {
        const V = /^(.*?)\.(\w+)$/.exec(D);
        if (!V)
          return;
        const W = j(V[1]);
        return W ? W + y + V[2] : void 0;
      }
    }
  }, x = utils.removePrefix(u, { negated: !1, prefix: "" });
  let N = j(x);
  return N && f.strictSlashes !== !0 && (N += `${v}?`), N;
};
var parse_1$1 = parse$2;
const isObject$2$1 = (u) => u && typeof u == "object" && !Array.isArray(u), picomatch$1 = (u, l, f = !1) => {
  if (Array.isArray(u)) {
    const $ = u.map((T) => picomatch$1(T, l, f));
    return (T) => {
      for (const E of $) {
        const R = E(T);
        if (R)
          return R;
      }
      return !1;
    };
  }
  const p = isObject$2$1(u) && u.tokens && u.input;
  if (u === "" || typeof u != "string" && !p)
    throw new TypeError("Expected pattern to be a non-empty string");
  const m = l || {}, b = utils.isWindows(l), y = p ? picomatch$1.compileRe(u, l) : picomatch$1.makeRe(u, l, !1, !0), v = y.state;
  delete y.state;
  let k = () => !1;
  if (m.ignore) {
    const $ = { ...l, ignore: null, onMatch: null, onResult: null };
    k = picomatch$1(m.ignore, $, f);
  }
  const S = ($, w = !1) => {
    const { isMatch: T, match: E, output: R } = picomatch$1.test($, y, l, { glob: u, posix: b }), O = { glob: u, state: v, regex: y, posix: b, input: $, output: R, match: E, isMatch: T };
    return typeof m.onResult == "function" && m.onResult(O), T === !1 ? (O.isMatch = !1, !!w && O) : k($) ? (typeof m.onIgnore == "function" && m.onIgnore(O), O.isMatch = !1, !!w && O) : (typeof m.onMatch == "function" && m.onMatch(O), !w || O);
  };
  return f && (S.state = v), S;
};
picomatch$1.test = (u, l, f, { glob: p, posix: m } = {}) => {
  if (typeof u != "string")
    throw new TypeError("Expected input to be a string");
  if (u === "")
    return { isMatch: !1, output: "" };
  const b = f || {}, y = b.format || (m ? utils.toPosixSlashes : null);
  let v = u === p, k = v && y ? y(u) : u;
  return v === !1 && (k = y ? y(u) : u, v = k === p), v !== !1 && b.capture !== !0 || (v = b.matchBase === !0 || b.basename === !0 ? picomatch$1.matchBase(u, l, f, m) : l.exec(k)), { isMatch: !!v, match: v, output: k };
}, picomatch$1.matchBase = (u, l, f, p = utils.isWindows(f)) => (l instanceof RegExp ? l : picomatch$1.makeRe(l, f)).test(path.basename(u)), picomatch$1.isMatch = (u, l, f) => picomatch$1(l, f)(u), picomatch$1.parse = (u, l) => Array.isArray(u) ? u.map((f) => picomatch$1.parse(f, l)) : parse_1$1(u, { ...l, fastpaths: !1 }), picomatch$1.scan = (u, l) => scan_1(u, l), picomatch$1.compileRe = (u, l, f = !1, p = !1) => {
  if (f === !0)
    return u.output;
  const m = l || {}, b = m.contains ? "" : "^", y = m.contains ? "" : "$";
  let v = `${b}(?:${u.output})${y}`;
  u && u.negated === !0 && (v = `^(?!${v}).*$`);
  const k = picomatch$1.toRegex(v, l);
  return p === !0 && (k.state = u), k;
}, picomatch$1.makeRe = (u, l = {}, f = !1, p = !1) => {
  if (!u || typeof u != "string")
    throw new TypeError("Expected a non-empty string");
  let m = { negated: !1, fastpaths: !0 };
  return l.fastpaths === !1 || u[0] !== "." && u[0] !== "*" || (m.output = parse_1$1.fastpaths(u, l)), m.output || (m = parse_1$1(u, l)), picomatch$1.compileRe(m, l, f, p);
}, picomatch$1.toRegex = (u, l) => {
  try {
    const f = l || {};
    return new RegExp(u, f.flags || (f.nocase ? "i" : ""));
  } catch (f) {
    if (l && l.debug === !0)
      throw f;
    return /$^/;
  }
}, picomatch$1.constants = constants;
var picomatch_1 = picomatch$1, picomatch = picomatch_1;
const isEmptyString = (u) => u === "" || u === "./", hasBraces = (u) => {
  const l = u.indexOf("{");
  return l > -1 && u.indexOf("}", l) > -1;
}, micromatch = (u, l, f) => {
  l = [].concat(l), u = [].concat(u);
  let p = /* @__PURE__ */ new Set(), m = /* @__PURE__ */ new Set(), b = /* @__PURE__ */ new Set(), y = 0, v = (S) => {
    b.add(S.output), f && f.onResult && f.onResult(S);
  };
  for (let S = 0; S < l.length; S++) {
    let $ = picomatch(String(l[S]), { ...f, onResult: v }, !0), w = $.state.negated || $.state.negatedExtglob;
    w && y++;
    for (let T of u) {
      let E = $(T, !0);
      (w ? !E.isMatch : E.isMatch) && (w ? p.add(E.output) : (p.delete(E.output), m.add(E.output)));
    }
  }
  let k = (y === l.length ? [...b] : [...m]).filter((S) => !p.has(S));
  if (f && k.length === 0) {
    if (f.failglob === !0)
      throw new Error(`No matches found for "${l.join(", ")}"`);
    if (f.nonull === !0 || f.nullglob === !0)
      return f.unescape ? l.map((S) => S.replace(/\\/g, "")) : l;
  }
  return k;
};
micromatch.match = micromatch, micromatch.matcher = (u, l) => picomatch(u, l), micromatch.isMatch = (u, l, f) => picomatch(l, f)(u), micromatch.any = micromatch.isMatch, micromatch.not = (u, l, f = {}) => {
  l = [].concat(l).map(String);
  let p = /* @__PURE__ */ new Set(), m = [], b = new Set(micromatch(u, l, { ...f, onResult: (y) => {
    f.onResult && f.onResult(y), m.push(y.output);
  } }));
  for (let y of m)
    b.has(y) || p.add(y);
  return [...p];
}, micromatch.contains = (u, l, f) => {
  if (typeof u != "string")
    throw new TypeError(`Expected a string: "${util$2.inspect(u)}"`);
  if (Array.isArray(l))
    return l.some((p) => micromatch.contains(u, p, f));
  if (typeof l == "string") {
    if (isEmptyString(u) || isEmptyString(l))
      return !1;
    if (u.includes(l) || u.startsWith("./") && u.slice(2).includes(l))
      return !0;
  }
  return micromatch.isMatch(u, l, { ...f, contains: !0 });
}, micromatch.matchKeys = (u, l, f) => {
  if (!utils.isObject(u))
    throw new TypeError("Expected the first argument to be an object");
  let p = micromatch(Object.keys(u), l, f), m = {};
  for (let b of p)
    m[b] = u[b];
  return m;
}, micromatch.some = (u, l, f) => {
  let p = [].concat(u);
  for (let m of [].concat(l)) {
    let b = picomatch(String(m), f);
    if (p.some((y) => b(y)))
      return !0;
  }
  return !1;
}, micromatch.every = (u, l, f) => {
  let p = [].concat(u);
  for (let m of [].concat(l)) {
    let b = picomatch(String(m), f);
    if (!p.every((y) => b(y)))
      return !1;
  }
  return !0;
}, micromatch.all = (u, l, f) => {
  if (typeof u != "string")
    throw new TypeError(`Expected a string: "${util$2.inspect(u)}"`);
  return [].concat(l).every((p) => picomatch(p, f)(u));
}, micromatch.capture = (u, l, f) => {
  let p = utils.isWindows(f), m = picomatch.makeRe(String(u), { ...f, capture: !0 }).exec(p ? utils.toPosixSlashes(l) : l);
  if (m)
    return m.slice(1).map((b) => b === void 0 ? "" : b);
}, micromatch.makeRe = (...u) => picomatch.makeRe(...u), micromatch.scan = (...u) => picomatch.scan(...u), micromatch.parse = (u, l) => {
  let f = [];
  for (let p of [].concat(u || []))
    for (let m of braces_1(String(p), l))
      f.push(picomatch.parse(m, l));
  return f;
}, micromatch.braces = (u, l) => {
  if (typeof u != "string")
    throw new TypeError("Expected a string");
  return l && l.nobrace === !0 || !hasBraces(u) ? [u] : braces_1(u, l);
}, micromatch.braceExpand = (u, l) => {
  if (typeof u != "string")
    throw new TypeError("Expected a string");
  return micromatch.braces(u, { ...l, expand: !0 });
}, micromatch.hasBraces = hasBraces;
var micromatch_1 = micromatch, match = createCommonjsModule(function(u) {
  var l = u.exports;
  l.match = function(f, p, m, b) {
    var y = handlebarsUtils.options(this, m, b);
    return typeof p == "string" && (p = p.split(/, */)), micromatch_1(f, p, y);
  }, l.isMatch = function(f, p, m, b) {
    var y = handlebarsUtils.options(this, m, b);
    return micromatch_1.isMatch(f, p, y);
  }, l.mm = function() {
    return console.log("the {{mm}} helper is depcrecated and will be removed"), console.log("in handlebars-helpers v1.0.0, please use the {{match}}"), console.log("helper instead."), l.match.apply(this, arguments);
  };
}), math$1 = createCommonjsModule(function(u) {
  var l = u.exports;
  l.abs = function(f) {
    if (isNaN(f))
      throw new TypeError("expected a number");
    return Math.abs(f);
  }, l.add = function(f, p) {
    return isNaN(f) || isNaN(p) ? typeof f == "string" && typeof p == "string" ? f + p : "" : Number(f) + Number(p);
  }, l.avg = function() {
    const f = [].concat.apply([], arguments);
    return f.pop(), l.sum(f) / f.length;
  }, l.ceil = function(f) {
    if (isNaN(f))
      throw new TypeError("expected a number");
    return Math.ceil(f);
  }, l.divide = function(f, p) {
    if (isNaN(f))
      throw new TypeError("expected the first argument to be a number");
    if (isNaN(p))
      throw new TypeError("expected the second argument to be a number");
    return Number(f) / Number(p);
  }, l.floor = function(f) {
    if (isNaN(f))
      throw new TypeError("expected a number");
    return Math.floor(f);
  }, l.minus = function(f, p) {
    if (isNaN(f))
      throw new TypeError("expected the first argument to be a number");
    if (isNaN(p))
      throw new TypeError("expected the second argument to be a number");
    return Number(f) - Number(p);
  }, l.modulo = function(f, p) {
    if (isNaN(f))
      throw new TypeError("expected the first argument to be a number");
    if (isNaN(p))
      throw new TypeError("expected the second argument to be a number");
    return Number(f) % Number(p);
  }, l.multiply = function(f, p) {
    if (isNaN(f))
      throw new TypeError("expected the first argument to be a number");
    if (isNaN(p))
      throw new TypeError("expected the second argument to be a number");
    return Number(f) * Number(p);
  }, l.plus = function(f, p) {
    if (isNaN(f))
      throw new TypeError("expected the first argument to be a number");
    if (isNaN(p))
      throw new TypeError("expected the second argument to be a number");
    return Number(f) + Number(p);
  }, l.random = function(f, p) {
    if (isNaN(f))
      throw new TypeError("expected minimum to be a number");
    if (isNaN(p))
      throw new TypeError("expected maximum to be a number");
    return utils$2.random(f, p);
  }, l.remainder = function(f, p) {
    return f % p;
  }, l.round = function(f) {
    if (isNaN(f))
      throw new TypeError("expected a number");
    return Math.round(f);
  }, l.subtract = function(f, p) {
    if (isNaN(f))
      throw new TypeError("expected the first argument to be a number");
    if (isNaN(p))
      throw new TypeError("expected the second argument to be a number");
    return Number(f) - Number(p);
  }, l.sum = function() {
    for (var f = [].concat.apply([], arguments), p = f.length, m = 0; p--; )
      isNaN(f[p]) || (m += Number(f[p]));
    return m;
  };
}), misc = createCommonjsModule(function(u) {
  var l = u.exports;
  l.frame = function(f, p) {
    typeof f == "object" && f.hash && (f = (p = f).data);
    var m = createFrame(f);
    return typeof p != "object" && (p = {}), m.extend(p.hash), p.fn(this, { data: m });
  }, l.option = function(f, p, m) {
    return getValue$1(handlebarsUtils.options(this, p, m), f);
  }, l.noop = function(f) {
    return f.fn(this);
  }, l.typeOf = function(f) {
    return typeof f;
  }, l.withHash = function(f) {
    return f.hash && Object.keys(f.hash).length ? f.fn(f.hash) : f.inverse(this);
  };
}), number$1 = createCommonjsModule(function(u) {
  var l = u.exports;
  l.bytes = function(f, p, m) {
    if (f == null || isNaN(f) && !(f = f.length))
      return "0 B";
    isNaN(p) && (p = 2);
    var b = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
    p = Math.pow(10, p), f = Number(f);
    for (var y = b.length - 1; y-- >= 0; ) {
      var v = Math.pow(10, 3 * y);
      if (v <= f + 1) {
        f = Math.round(f * p / v) / p, f += " " + b[y];
        break;
      }
    }
    return f;
  }, l.addCommas = function(f) {
    return f.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
  }, l.phoneNumber = function(f) {
    return "(" + (f = f.toString()).substr(0, 3) + ") " + f.substr(3, 3) + "-" + f.substr(6, 4);
  }, l.toAbbr = function(f, p) {
    isNaN(f) && (f = 0), handlebarsUtils.isUndefined(p) && (p = 2), f = Number(f), p = Math.pow(10, p);
    for (var m = ["k", "m", "b", "t", "q"], b = m.length - 1; b >= 0; ) {
      var y = Math.pow(10, 3 * (b + 1));
      if (y <= f + 1) {
        f = Math.round(f * p / y) / p, f += m[b];
        break;
      }
      b--;
    }
    return f;
  }, l.toExponential = function(f, p) {
    return isNaN(f) && (f = 0), handlebarsUtils.isUndefined(p) && (p = 0), Number(f).toExponential(p);
  }, l.toFixed = function(f, p) {
    return isNaN(f) && (f = 0), isNaN(p) && (p = 0), Number(f).toFixed(p);
  }, l.toFloat = function(f) {
    return parseFloat(f);
  }, l.toInt = function(f) {
    return parseInt(f, 10);
  }, l.toPrecision = function(f, p) {
    return isNaN(f) && (f = 0), isNaN(p) && (p = 1), Number(f).toPrecision(p);
  };
}), toString$1$1 = {}.toString, isarray = Array.isArray || function(u) {
  return toString$1$1.call(u) == "[object Array]";
}, isobject = function(u) {
  return u != null && typeof u == "object" && isarray(u) === !1;
}, relative_1 = relative;
function relative(u, l, f) {
  if (typeof u != "string")
    throw new TypeError("relative expects a string.");
  if (u == "" && !l)
    return u;
  var p = arguments.length;
  p === 1 && (l = u, u = browser.cwd(), f = null), p === 2 && typeof l == "boolean" && (l = u, u = browser.cwd(), f = !0), p === 2 && typeof l == "object" && (f = l, l = u, u = browser.cwd());
  var m = l, b = endsWith(u, "/"), y = endsWith(l, "/");
  u = unixify(u), l = unixify(l), b && (u += "/"), isFile(u, f) && (u = path.dirname(u));
  var v = path.relative(u, l);
  if (v === "")
    return ".";
  var k = trimEnd(m, "/");
  return y && (v === k || endsWith(v, k)) && (v += "/"), v;
}
function unixify(u) {
  return u.replace(/[\\\/]+/g, "/");
}
function trimEnd(u, l) {
  return u.slice(0, u.length - l.length);
}
function endsWith(u, l) {
  return u.slice(-l.length)[0] === l;
}
function tryStats(u) {
  try {
    return fs.statSync(u);
  } catch {
  }
  return null;
}
function isDir(u, l) {
  if (endsWith(u, "/"))
    return !0;
  if (l === null && (l = tryStats(u)), isobject(l) && typeof l.isDirectory == "function")
    return l.isDirectory();
  var f = u.split("/"), p = f[f.length - 1];
  return !p || p.indexOf(".") === -1;
}
function isFile(u, l) {
  return l === !0 && (l = tryStats(u)), !isDir(u, l);
}
relative.toBase = function(u, l) {
  u = unixify(u);
  var f = (l = unixify(l)).slice(u.length);
  return f.charAt(0) === "/" && (f = f.slice(1)), f;
};
var path_1 = createCommonjsModule(function(u) {
  var l = u.exports;
  l.absolute = function(f, p) {
    p = p || { data: {} };
    var m = handlebarsUtils.options(this, p), b = Object.assign({}, p.data.root, m).cwd || browser.cwd();
    return path.resolve(b, f);
  }, l.dirname = function(f, p) {
    if (typeof f != "string")
      throw new TypeError(handlebarsUtils.expectedType("filepath", "string", f));
    return path.dirname(f);
  }, l.relative = function(f, p) {
    if (typeof f != "string")
      throw new TypeError(handlebarsUtils.expectedType("first path", "string", f));
    if (typeof p != "string")
      throw new TypeError(handlebarsUtils.expectedType("second path", "string", p));
    return relative_1(f, p);
  }, l.basename = function(f) {
    if (typeof f != "string")
      throw new TypeError(handlebarsUtils.expectedType("filepath", "string", f));
    return path.basename(f);
  }, l.stem = function(f) {
    if (typeof f != "string")
      throw new TypeError(handlebarsUtils.expectedType("filepath", "string", f));
    return path.basename(f, path.extname(f));
  }, l.extname = function(f) {
    if (typeof f != "string")
      throw new TypeError(handlebarsUtils.expectedType("filepath", "string", f));
    return path.extname(f);
  }, l.resolve = function(f) {
    var p = [].slice.call(arguments), m = handlebarsUtils.options(this, p.pop()), b = path.resolve(m.cwd || browser.cwd());
    return p.unshift(b), path.resolve.apply(path, p);
  }, l.segments = function(f, p, m) {
    if (typeof f != "string")
      throw new TypeError(handlebarsUtils.expectedType("filepath", "string", f));
    return f.split(/[\\\/]+/).slice(p, m).join("/");
  };
}), regex$2 = createCommonjsModule(function(u) {
  var l = u.exports;
  l.toRegex = function(f, p, m) {
    var b = handlebarsUtils.options({}, p, m);
    return new RegExp(f, b.flags);
  }, l.test = function(f, p) {
    if (typeof f != "string")
      return !1;
    if (kindOf(p) !== "regexp")
      throw new TypeError("expected a regular expression");
    return p.test(f);
  };
});
const lorem = `Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus imperdiet, nulla et dictum interdum, nisi lorem egestas odio, vitae scelerisque enim ligula venenatis dolor. Maecenas nisl est, ultrices nec congue eget, auctor vitae massa. Fusce luctus vestibulum augue ut aliquet. Mauris ante ligula, facilisis sed ornare eu, lobortis in odio. Praesent convallis urna a lacus interdum ut hendrerit risus congue. Nunc sagittis dictum nisi, sed ullamcorper ipsum dignissim ac. In at libero sed nunc venenatis imperdiet sed ornare turpis. Donec vitae dui eget tellus gravida venenatis. Integer fringilla congue eros non fermentum. Sed dapibus pulvinar nibh tempor porta. 

 Crase tempor malesuada magna a vehicula. Nam sollicitudin vel turpis id fermentum. Ut sit amet nisl ac nulla vulputate ultrices vitae vitae urna. Quisque eget odio ac lectus vestibulum faucibus eget in metus. In pellentesque faucibus vestibulum. Nulla at nulla justo, eget luctus tortor. Nulla facilisi. Donec vulputate interdum sollicitudin. Nunc lacinia auctor quam sed pellentesque. Aliquam dui mauris, mattis quis lacus id, pellentesque lobortis odio. 

 Nullam malesuada erat ut turpis. Suspendisse urna nibh, viverra non, semper suscipit, posuere a, pede. Donec nec justo eget felis facilisis fermentum. Aliquam porttitor mauris sit amet orci. Aenean dignissim pellentesque felis. Phasellus ultrices nulla quis nibh. Quisque a lectus. Donec consectetuer ligula vulputate sem tristique cursus. Nam nulla quam, gravida non, commodo a, sodales sit amet, nisi. Praesent id justo in neque elementum ultrices. Sed malesuada augue eu sapien sodales congue. Nam ut dui. Quisque a lectus. Donec consectetuer ligula vulputate sem tristique cursus. Nam nulla quam, gravida non, commodo a, sodales sit amet, nisi. Proin vel ante a orci tempus eleifend ut et magna. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus luctus urna sed urna ultricies ac tempor dui sagittis. In condimentum facilisis porta. Sed nec diam eu diam mattis viverra. Nulla fringilla, orci ac euismod semper, magna diam porttitor mauris, quis sollicitudin sapien justo in libero. Vestibulum mollis mauris enim. Morbi euismod magna ac lorem rutrum elementum. Donec viverra auctor lobortis. Pellentesque eu est a nulla placerat dignissim. Morbi a enim in magna semper bibendum. Etiam scelerisque, nunc ac egestas consequat, odio nibh euismod nulla, eget auctor orci nibh vel nisi. Aliquam erat volutpat. Sed quis velit. Nulla facilisi. Nulla libero. Vivamus fermentum nibh in augue. Praesent a lacus at urna congue rutrum. Nulla enim eros, porttitor eu, tempus id, varius non, nibh. Vestibulum imperdiet nibh vel magna lacinia ultrices. Sed id ligula quis est convallis tempor. 

 Aliquam erat volutpat. Integer aliquam ultrices nunc. Ut lectus dui, tincidunt ac, scelerisque ac, ultrices vitae, risus. Donec vehicula augue eu neque. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Mauris ut leo. Cras viverra metus rhoncus sem. Nulla et lectus vestibulum urna fringilla ultrices. Phasellus eu tellus sit amet tortor gravida placerat. Integer sapien est, iaculis in, pretium quis, viverra ac, nunc. Praesent eget sem vel leo ultrices bibendum. Aenean faucibus. Morbi dolor nulla, malesuada eu, pulvinar at, mollis ac, nulla. Curabitur vehicula nisi a magna. Sed nec libero. Phasellus nonummy magna. Sed et libero nec ligula blandit fringilla. Ut pretium tempus gravida. Proin lacinia justo vel ipsum varius eget auctor est iaculis. 

 Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Fusce luctus vestibulum augue ut aliquet. Nunc sagittis dictum nisi, sed ullamcorper ipsum dignissim ac. In at libero sed nunc venenatis imperdiet sed ornare turpis. Donec vitae dui eget tellus gravida venenatis. Integer fringilla congue eros non fermentum. Sed dapibus pulvinar nibh tempor porta. 

 Nam dui erat, auctor a, dignissim quis. Aenean dignissim pellentesque felis. Sed gravida ante at nunc dictum placerat. Donec placerat nisl magna, et faucibus arcu condimentum sed. Curabitur et eros ac orci vehicula vestibulum sit amet at nunc. Maecenas non diam cursus, tincidunt nisi vitae, hendrerit enim. Donec vulputate felis id felis dapibus fermentum. 

 Nullam malesuada erat ut turpis. Suspendisse urna nibh, viverra non, semper suscipit, posuere a, pede. Donec nec justo eget felis facilisis fermentum. Aliquam porttitor mauris sit amet orci. Aenean dignissim pellentesque felis. Phasellus ultrices nulla quis nibh. Quisque a lectus. Donec consectetuer ligula vulputate sem tristique cursus. Nam nulla quam, gravida non, commodo a, sodales sit amet, nisi. Praesent id justo in neque elementum ultrices. Sed malesuada augue eu sapien sodales congue. Nam ut dui. Quisque a lectus. Donec consectetuer ligula vulputate sem tristique cursus. Nam nulla quam, gravida non, commodo a, sodales sit amet, nisi. 

 Pellentesque sit amet mauris eget lectus commodo viverra. Donec vulputate interdum sollicitudin. Nunc lacinia auctor quam sed pellentesque. Aliquam dui mauris, mattis quis lacus id, pellentesque lobortis odio. Cras ultricies ligula sed magna dictum porta. Curabitur aliquet quam id dui posuere blandit. Nulla porttitor accumsan tincidunt. Donec sollicitudin molestie malesuada. Curabitur arcu erat, accumsan id imperdiet et, porttitor at sem. Sed porttitor lectus nibh. Pellentesque in ipsum id orci porta dapibus. Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui. 

 Cras ultricies ligula sed magna dictum porta. Donec rutrum congue leo eget malesuada. Nulla quis lorem ut libero malesuada feugiat. Proin eget tortor risus. Nulla quis lorem ut libero malesuada feugiat. Proin eget tortor risus. Curabitur aliquet quam id dui posuere blandit. Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui. Pellentesque in ipsum id orci porta dapibus. Curabitur non nulla sit amet nisl tempus convallis quis ac lectus. Donec rutrum congue leo eget malesuada. Vivamus suscipit tortor eget felis porttitor volutpat. Nulla porttitor accumsan tincidunt. 

 Donec sollicitudin molestie malesuada. Pellentesque in ipsum id orci porta dapibus. Curabitur non nulla sit amet nisl tempus convallis quis ac lectus. Nulla quis lorem ut libero malesuada feugiat. Proin eget tortor risus. Cras ultricies ligula sed magna dictum porta. Donec sollicitudin molestie malesuada. Pellentesque in ipsum id orci porta dapibus. Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui. Curabitur non nulla sit amet nisl tempus convallis quis ac lectus. Nulla quis lorem ut libero malesuada feugiat. Proin eget tortor risus. Curabitur aliquet quam id dui posuere blandit. 

 Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui. Curabitur non nulla sit amet nisl tempus convallis quis ac lectus. Nulla quis lorem ut libero malesuada feugiat. Proin eget tortor risus. Cras ultricies ligula sed magna dictum porta. Donec sollicitudin molestie malesuada. Pellentesque in ipsum id orci porta dapibus. Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui. Curabitur non nulla sit amet nisl tempus convallis quis ac lectus. Nulla quis lorem ut libero malesuada feugiat. Proin eget tortor risus. 

 Curabitur aliquet quam id dui posuere blandit. Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui. Pellentesque in ipsum id orci porta dapibus. Curabitur non nulla sit amet nisl tempus convallis quis ac lectus. Nulla quis lorem ut libero malesuada feugiat. Proin eget tortor risus. Cras ultricies ligula sed magna dictum porta. Donec sollicitudin molestie malesuada. Pellentesque in ipsum id orci porta dapibus. Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui. Curabitur non nulla sit amet nisl tempus convallis quis ac lectus. Nulla quis lorem ut libero malesuada feugiat. Proin eget tortor risus. Curabitur aliquet quam id dui posuere blandit. Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui.`;
var lorem_1 = lorem, string$1 = createCommonjsModule(function(u, l) {
  var f = u.exports;
  f.append = function(p, m) {
    return typeof p == "string" && typeof m == "string" ? p + m : p;
  }, f.camelcase = function(p) {
    return typeof p != "string" ? "" : utils$2.changecase(p, function(m) {
      return m.toUpperCase();
    });
  }, f.capitalize = function(p) {
    return typeof p != "string" ? "" : p.charAt(0).toUpperCase() + p.slice(1);
  }, f.capitalizeAll = function(p) {
    return typeof p != "string" ? "" : handlebarsUtils.isString(p) ? p.replace(/\w\S*/g, function(m) {
      return f.capitalize(m);
    }) : void 0;
  }, f.center = function(p, m) {
    if (typeof p != "string")
      return "";
    for (var b = "", y = 0; y < m; )
      b += "&nbsp;", y++;
    return b + p + b;
  }, f.chop = function(p) {
    return typeof p != "string" ? "" : utils$2.chop(p);
  }, f.dashcase = function(p) {
    return typeof p != "string" ? "" : utils$2.changecase(p, function(m) {
      return "-" + m;
    });
  }, f.dotcase = function(p) {
    return typeof p != "string" ? "" : utils$2.changecase(p, function(m) {
      return "." + m;
    });
  }, f.downcase = function() {
    return f.lowercase.apply(this, arguments);
  }, f.ellipsis = function(p, m) {
    if (handlebarsUtils.isString(p))
      return p.length <= m ? p : f.truncate(p, m) + "â€¦";
  }, f.hyphenate = function(p) {
    return typeof p != "string" ? "" : p.split(" ").join("-");
  }, f.isString = function(p) {
    return typeof p == "string";
  }, f.lowercase = function(p) {
    return handlebarsUtils.isObject(p) && p.fn ? p.fn(this).toLowerCase() : typeof p != "string" ? "" : p.toLowerCase();
  }, f.occurrences = function(p, m) {
    if (typeof p != "string")
      return "";
    for (var b = m.length, y = 0, v = 0; (y = p.indexOf(m, y)) > -1; )
      v++, y += b;
    return v;
  }, f.pascalcase = function(p) {
    return typeof p != "string" ? "" : (p = utils$2.changecase(p, function(m) {
      return m.toUpperCase();
    })).charAt(0).toUpperCase() + p.slice(1);
  }, f.pathcase = function(p) {
    return typeof p != "string" ? "" : utils$2.changecase(p, function(m) {
      return "/" + m;
    });
  }, f.plusify = function(p, m) {
    return typeof p != "string" ? "" : (handlebarsUtils.isString(m) || (m = " "), p.split(m).join("+"));
  }, f.prepend = function(p, m) {
    return typeof p == "string" && typeof m == "string" ? m + p : p;
  }, f.raw = function(p) {
    var m = p.fn();
    if (handlebarsUtils.options(this, p).escape !== !1)
      for (var b = 0; (b = m.indexOf("{{", b)) !== -1; )
        m[b - 1] !== "\\" && (m = m.slice(0, b) + "\\" + m.slice(b)), b += 3;
    return m;
  }, f.remove = function(p, m) {
    return typeof p != "string" ? "" : handlebarsUtils.isString(m) ? p.split(m).join("") : p;
  }, f.removeFirst = function(p, m) {
    return typeof p != "string" ? "" : handlebarsUtils.isString(m) ? p.replace(m, "") : p;
  }, f.replace = function(p, m, b) {
    return typeof p != "string" ? "" : handlebarsUtils.isString(m) ? (handlebarsUtils.isString(b) || (b = ""), p.split(m).join(b)) : p;
  }, f.replaceFirst = function(p, m, b) {
    return typeof p != "string" ? "" : handlebarsUtils.isString(m) ? (handlebarsUtils.isString(b) || (b = ""), p.replace(m, b)) : p;
  }, f.reverse = array$1.reverse, f.sentence = function(p) {
    return typeof p != "string" ? "" : p.replace(/((?:\S[^\.\?\!]*)[\.\?\!]*)/g, function(m) {
      return m.charAt(0).toUpperCase() + m.substr(1).toLowerCase();
    });
  }, f.snakecase = function(p) {
    return typeof p != "string" ? "" : utils$2.changecase(p, function(m) {
      return "_" + m;
    });
  }, f.split = function(p, m) {
    return typeof p != "string" ? "" : (handlebarsUtils.isString(m) || (m = ","), p.split(m));
  }, f.startsWith = function(p, m, b) {
    return b = [].slice.call(arguments).pop(), handlebarsUtils.isString(m) && m.indexOf(p) === 0 ? b.fn(this) : typeof b.inverse == "function" ? b.inverse(this) : "";
  }, f.titleize = function(p) {
    if (typeof p != "string")
      return "";
    for (var m = p.replace(/[- _]+/g, " ").split(" "), b = m.length, y = [], v = 0; b--; ) {
      var k = m[v++];
      y.push(l.capitalize(k));
    }
    return y.join(" ");
  }, f.trim = function(p) {
    return typeof p == "string" ? p.trim() : "";
  }, f.trimLeft = function(p) {
    if (handlebarsUtils.isString(p))
      return p.replace(/^\s+/, "");
  }, f.trimRight = function(p) {
    if (handlebarsUtils.isString(p))
      return p.replace(/\s+$/, "");
  }, f.truncate = function(p, m, b) {
    if (handlebarsUtils.isString(p))
      return typeof b != "string" && (b = ""), p.length > m ? p.slice(0, m - b.length) + b : p;
  }, f.truncateWords = function(p, m, b) {
    if (handlebarsUtils.isString(p) && !isNaN(m)) {
      typeof b != "string" && (b = "â€¦");
      var y = Number(m), v = p.split(/[ \t]/);
      return y >= v.length ? p : (v = v.slice(0, y)).join(" ").trim() + b;
    }
  }, f.upcase = function() {
    return f.uppercase.apply(this, arguments);
  }, f.uppercase = function(p) {
    return handlebarsUtils.isObject(p) && p.fn ? p.fn(this).toUpperCase() : typeof p != "string" ? "" : p.toUpperCase();
  }, f.lorem = function(p) {
    return (isNaN(p) || p < 1 || !p) && (p = 11), lorem_1.substring(0, p);
  };
}), maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode;
function error(u) {
  throw new RangeError(errors[u]);
}
function map$1(u, l) {
  for (var f = u.length, p = []; f--; )
    p[f] = l(u[f]);
  return p;
}
function mapDomain(u, l) {
  var f = u.split("@"), p = "";
  return f.length > 1 && (p = f[0] + "@", u = f[1]), p + map$1((u = u.replace(regexSeparators, ".")).split("."), l).join(".");
}
function ucs2decode(u) {
  for (var l, f, p = [], m = 0, b = u.length; m < b; )
    (l = u.charCodeAt(m++)) >= 55296 && l <= 56319 && m < b ? (64512 & (f = u.charCodeAt(m++))) == 56320 ? p.push(((1023 & l) << 10) + (1023 & f) + 65536) : (p.push(l), m--) : p.push(l);
  return p;
}
function digitToBasic(u, l) {
  return u + 22 + 75 * (u < 26) - ((l != 0) << 5);
}
function adapt(u, l, f) {
  var p = 0;
  for (u = f ? floor(u / damp) : u >> 1, u += floor(u / l); u > baseMinusTMin * tMax >> 1; p += base)
    u = floor(u / baseMinusTMin);
  return floor(p + (baseMinusTMin + 1) * u / (u + skew));
}
function encode$3(u) {
  var l, f, p, m, b, y, v, k, S, $, w, T, E, R, O, P = [];
  for (T = (u = ucs2decode(u)).length, l = initialN, f = 0, b = initialBias, y = 0; y < T; ++y)
    (w = u[y]) < 128 && P.push(stringFromCharCode(w));
  for (p = m = P.length, m && P.push(delimiter); p < T; ) {
    for (v = maxInt, y = 0; y < T; ++y)
      (w = u[y]) >= l && w < v && (v = w);
    for (v - l > floor((maxInt - f) / (E = p + 1)) && error("overflow"), f += (v - l) * E, l = v, y = 0; y < T; ++y)
      if ((w = u[y]) < l && ++f > maxInt && error("overflow"), w == l) {
        for (k = f, S = base; !(k < ($ = S <= b ? tMin : S >= b + tMax ? tMax : S - b)); S += base)
          O = k - $, R = base - $, P.push(stringFromCharCode(digitToBasic($ + O % R, 0))), k = floor(O / R);
        P.push(stringFromCharCode(digitToBasic(k, 0))), b = adapt(f, E, p == m), f = 0, ++p;
      }
    ++f, ++l;
  }
  return P.join("");
}
function toASCII(u) {
  return mapDomain(u, function(l) {
    return regexNonASCII.test(l) ? "xn--" + encode$3(l) : l;
  });
}
function hasOwnProperty$f(u, l) {
  return Object.prototype.hasOwnProperty.call(u, l);
}
var isArray$1$1 = Array.isArray || function(u) {
  return Object.prototype.toString.call(u) === "[object Array]";
};
function stringifyPrimitive(u) {
  switch (typeof u) {
    case "string":
      return u;
    case "boolean":
      return u ? "true" : "false";
    case "number":
      return isFinite(u) ? u : "";
    default:
      return "";
  }
}
function stringify(u, l, f, p) {
  return l = l || "&", f = f || "=", u === null && (u = void 0), typeof u == "object" ? map(objectKeys(u), function(m) {
    var b = encodeURIComponent(stringifyPrimitive(m)) + f;
    return isArray$1$1(u[m]) ? map(u[m], function(y) {
      return b + encodeURIComponent(stringifyPrimitive(y));
    }).join(l) : b + encodeURIComponent(stringifyPrimitive(u[m]));
  }).join(l) : p ? encodeURIComponent(stringifyPrimitive(p)) + f + encodeURIComponent(stringifyPrimitive(u)) : "";
}
function map(u, l) {
  if (u.map)
    return u.map(l);
  for (var f = [], p = 0; p < u.length; p++)
    f.push(l(u[p], p));
  return f;
}
var objectKeys = Object.keys || function(u) {
  var l = [];
  for (var f in u)
    Object.prototype.hasOwnProperty.call(u, f) && l.push(f);
  return l;
};
function parse$1$1(u, l, f, p) {
  l = l || "&", f = f || "=";
  var m = {};
  if (typeof u != "string" || u.length === 0)
    return m;
  var b = /\+/g;
  u = u.split(l);
  var y = 1e3;
  p && typeof p.maxKeys == "number" && (y = p.maxKeys);
  var v = u.length;
  y > 0 && v > y && (v = y);
  for (var k = 0; k < v; ++k) {
    var S, $, w, T, E = u[k].replace(b, "%20"), R = E.indexOf(f);
    R >= 0 ? (S = E.substr(0, R), $ = E.substr(R + 1)) : (S = E, $ = ""), w = decodeURIComponent(S), T = decodeURIComponent($), hasOwnProperty$f(m, w) ? isArray$1$1(m[w]) ? m[w].push(T) : m[w] = [m[w], T] : m[w] = T;
  }
  return m;
}
var querystring$1 = { encode: stringify, stringify, decode: parse$1$1, parse: parse$1$1 };
const URL$1 = global$1.URL, URLSearchParams$1 = global$1.URLSearchParams;
var url$1 = { parse: urlParse, resolve: urlResolve, resolveObject: urlResolveObject, fileURLToPath: urlFileURLToPath, format: urlFormat, Url, URL: URL$1, URLSearchParams: URLSearchParams$1 };
function Url() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", `
`, "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = { javascript: !0, "javascript:": !0 }, hostlessProtocol = { javascript: !0, "javascript:": !0 }, slashedProtocol = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, "http:": !0, "https:": !0, "ftp:": !0, "gopher:": !0, "file:": !0 };
function urlParse(u, l, f) {
  if (u && isObject$5(u) && u instanceof Url)
    return u;
  var p = new Url();
  return p.parse(u, l, f), p;
}
function parse$5(u, l, f, p) {
  if (!isString(l))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof l);
  var m = l.indexOf("?"), b = m !== -1 && m < l.indexOf("#") ? "?" : "#", y = l.split(b);
  y[0] = y[0].replace(/\\/g, "/");
  var v = l = y.join(b);
  if (v = v.trim(), !p && l.split("#").length === 1) {
    var k = simplePathPattern.exec(v);
    if (k)
      return u.path = v, u.href = v, u.pathname = k[1], k[2] ? (u.search = k[2], u.query = f ? parse$1$1(u.search.substr(1)) : u.search.substr(1)) : f && (u.search = "", u.query = {}), u;
  }
  var S, $, w, T, E = protocolPattern.exec(v);
  if (E) {
    var R = (E = E[0]).toLowerCase();
    u.protocol = R, v = v.substr(E.length);
  }
  if (p || E || v.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var O = v.substr(0, 2) === "//";
    !O || E && hostlessProtocol[E] || (v = v.substr(2), u.slashes = !0);
  }
  if (!hostlessProtocol[E] && (O || E && !slashedProtocol[E])) {
    var P, L, M = -1;
    for (S = 0; S < hostEndingChars.length; S++)
      ($ = v.indexOf(hostEndingChars[S])) !== -1 && (M === -1 || $ < M) && (M = $);
    for ((L = M === -1 ? v.lastIndexOf("@") : v.lastIndexOf("@", M)) !== -1 && (P = v.slice(0, L), v = v.slice(L + 1), u.auth = decodeURIComponent(P)), M = -1, S = 0; S < nonHostChars.length; S++)
      ($ = v.indexOf(nonHostChars[S])) !== -1 && (M === -1 || $ < M) && (M = $);
    M === -1 && (M = v.length), u.host = v.slice(0, M), v = v.slice(M), parseHost(u), u.hostname = u.hostname || "";
    var B = u.hostname[0] === "[" && u.hostname[u.hostname.length - 1] === "]";
    if (!B) {
      var j = u.hostname.split(/\./);
      for (S = 0, w = j.length; S < w; S++) {
        var x = j[S];
        if (x && !x.match(hostnamePartPattern)) {
          for (var N = "", D = 0, V = x.length; D < V; D++)
            x.charCodeAt(D) > 127 ? N += "x" : N += x[D];
          if (!N.match(hostnamePartPattern)) {
            var W = j.slice(0, S), F = j.slice(S + 1), U = x.match(hostnamePartStart);
            U && (W.push(U[1]), F.unshift(U[2])), F.length && (v = "/" + F.join(".") + v), u.hostname = W.join(".");
            break;
          }
        }
      }
    }
    u.hostname.length > hostnameMaxLen ? u.hostname = "" : u.hostname = u.hostname.toLowerCase(), B || (u.hostname = toASCII(u.hostname)), T = u.port ? ":" + u.port : "";
    var Y = u.hostname || "";
    u.host = Y + T, u.href += u.host, B && (u.hostname = u.hostname.substr(1, u.hostname.length - 2), v[0] !== "/" && (v = "/" + v));
  }
  if (!unsafeProtocol[R])
    for (S = 0, w = autoEscape.length; S < w; S++) {
      var q = autoEscape[S];
      if (v.indexOf(q) !== -1) {
        var Q = encodeURIComponent(q);
        Q === q && (Q = escape(q)), v = v.split(q).join(Q);
      }
    }
  var z = v.indexOf("#");
  z !== -1 && (u.hash = v.substr(z), v = v.slice(0, z));
  var H = v.indexOf("?");
  if (H !== -1 ? (u.search = v.substr(H), u.query = v.substr(H + 1), f && (u.query = parse$1$1(u.query)), v = v.slice(0, H)) : f && (u.search = "", u.query = {}), v && (u.pathname = v), slashedProtocol[R] && u.hostname && !u.pathname && (u.pathname = "/"), u.pathname || u.search) {
    T = u.pathname || "";
    var X = u.search || "";
    u.path = T + X;
  }
  return u.href = format(u), u;
}
function urlFileURLToPath(u) {
  if (typeof u == "string")
    u = new Url().parse(u);
  else if (!(u instanceof Url))
    throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof u + String(u));
  if (u.protocol !== "file:")
    throw new TypeError("The URL must be of scheme file");
  return getPathFromURLPosix(u);
}
function getPathFromURLPosix(u) {
  const l = u.pathname;
  for (let f = 0; f < l.length; f++)
    if (l[f] === "%") {
      const p = 32 | l.codePointAt(f + 2);
      if (l[f + 1] === "2" && p === 102)
        throw new TypeError("must not include encoded / characters");
    }
  return decodeURIComponent(l);
}
function urlFormat(u) {
  return isString(u) && (u = parse$5({}, u)), format(u);
}
function format(u) {
  var l = u.auth || "";
  l && (l = (l = encodeURIComponent(l)).replace(/%3A/i, ":"), l += "@");
  var f = u.protocol || "", p = u.pathname || "", m = u.hash || "", b = !1, y = "";
  u.host ? b = l + u.host : u.hostname && (b = l + (u.hostname.indexOf(":") === -1 ? u.hostname : "[" + this.hostname + "]"), u.port && (b += ":" + u.port)), u.query && isObject$5(u.query) && Object.keys(u.query).length && (y = stringify(u.query));
  var v = u.search || y && "?" + y || "";
  return f && f.substr(-1) !== ":" && (f += ":"), u.slashes || (!f || slashedProtocol[f]) && b !== !1 ? (b = "//" + (b || ""), p && p.charAt(0) !== "/" && (p = "/" + p)) : b || (b = ""), m && m.charAt(0) !== "#" && (m = "#" + m), v && v.charAt(0) !== "?" && (v = "?" + v), p = p.replace(/[?#]/g, function(k) {
    return encodeURIComponent(k);
  }), f + b + p + (v = v.replace("#", "%23")) + m;
}
function urlResolve(u, l) {
  return urlParse(u, !1, !0).resolve(l);
}
function urlResolveObject(u, l) {
  return u ? urlParse(u, !1, !0).resolveObject(l) : l;
}
function parseHost(u) {
  var l = u.host, f = portPattern.exec(l);
  f && ((f = f[0]) !== ":" && (u.port = f.substr(1)), l = l.substr(0, l.length - f.length)), l && (u.hostname = l);
}
Url.prototype.parse = function(u, l, f) {
  return parse$5(this, u, l, f);
}, Url.prototype.format = function() {
  return format(this);
}, Url.prototype.resolve = function(u) {
  return this.resolveObject(urlParse(u, !1, !0)).format();
}, Url.prototype.resolveObject = function(u) {
  if (isString(u)) {
    var l = new Url();
    l.parse(u, !1, !0), u = l;
  }
  for (var f, p = new Url(), m = Object.keys(this), b = 0; b < m.length; b++) {
    var y = m[b];
    p[y] = this[y];
  }
  if (p.hash = u.hash, u.href === "")
    return p.href = p.format(), p;
  if (u.slashes && !u.protocol) {
    for (var v = Object.keys(u), k = 0; k < v.length; k++) {
      var S = v[k];
      S !== "protocol" && (p[S] = u[S]);
    }
    return slashedProtocol[p.protocol] && p.hostname && !p.pathname && (p.path = p.pathname = "/"), p.href = p.format(), p;
  }
  if (u.protocol && u.protocol !== p.protocol) {
    if (!slashedProtocol[u.protocol]) {
      for (var $ = Object.keys(u), w = 0; w < $.length; w++) {
        var T = $[w];
        p[T] = u[T];
      }
      return p.href = p.format(), p;
    }
    if (p.protocol = u.protocol, u.host || hostlessProtocol[u.protocol])
      p.pathname = u.pathname;
    else {
      for (f = (u.pathname || "").split("/"); f.length && !(u.host = f.shift()); )
        ;
      u.host || (u.host = ""), u.hostname || (u.hostname = ""), f[0] !== "" && f.unshift(""), f.length < 2 && f.unshift(""), p.pathname = f.join("/");
    }
    if (p.search = u.search, p.query = u.query, p.host = u.host || "", p.auth = u.auth, p.hostname = u.hostname || u.host, p.port = u.port, p.pathname || p.search) {
      var E = p.pathname || "", R = p.search || "";
      p.path = E + R;
    }
    return p.slashes = p.slashes || u.slashes, p.href = p.format(), p;
  }
  var O, P = p.pathname && p.pathname.charAt(0) === "/", L = u.host || u.pathname && u.pathname.charAt(0) === "/", M = L || P || p.host && u.pathname, B = M, j = p.pathname && p.pathname.split("/") || [], x = p.protocol && !slashedProtocol[p.protocol];
  if (f = u.pathname && u.pathname.split("/") || [], x && (p.hostname = "", p.port = null, p.host && (j[0] === "" ? j[0] = p.host : j.unshift(p.host)), p.host = "", u.protocol && (u.hostname = null, u.port = null, u.host && (f[0] === "" ? f[0] = u.host : f.unshift(u.host)), u.host = null), M = M && (f[0] === "" || j[0] === "")), L)
    p.host = u.host || u.host === "" ? u.host : p.host, p.hostname = u.hostname || u.hostname === "" ? u.hostname : p.hostname, p.search = u.search, p.query = u.query, j = f;
  else if (f.length)
    j || (j = []), j.pop(), j = j.concat(f), p.search = u.search, p.query = u.query;
  else if (!isNullOrUndefined(u.search))
    return x && (p.hostname = p.host = j.shift(), (O = !!(p.host && p.host.indexOf("@") > 0) && p.host.split("@")) && (p.auth = O.shift(), p.host = p.hostname = O.shift())), p.search = u.search, p.query = u.query, isNull(p.pathname) && isNull(p.search) || (p.path = (p.pathname ? p.pathname : "") + (p.search ? p.search : "")), p.href = p.format(), p;
  if (!j.length)
    return p.pathname = null, p.search ? p.path = "/" + p.search : p.path = null, p.href = p.format(), p;
  for (var N = j.slice(-1)[0], D = (p.host || u.host || j.length > 1) && (N === "." || N === "..") || N === "", V = 0, W = j.length; W >= 0; W--)
    (N = j[W]) === "." ? j.splice(W, 1) : N === ".." ? (j.splice(W, 1), V++) : V && (j.splice(W, 1), V--);
  if (!M && !B)
    for (; V--; V)
      j.unshift("..");
  !M || j[0] === "" || j[0] && j[0].charAt(0) === "/" || j.unshift(""), D && j.join("/").substr(-1) !== "/" && j.push("");
  var F = j[0] === "" || j[0] && j[0].charAt(0) === "/";
  return x && (p.hostname = p.host = F ? "" : j.length ? j.shift() : "", (O = !!(p.host && p.host.indexOf("@") > 0) && p.host.split("@")) && (p.auth = O.shift(), p.host = p.hostname = O.shift())), (M = M || p.host && j.length) && !F && j.unshift(""), j.length ? p.pathname = j.join("/") : (p.pathname = null, p.path = null), isNull(p.pathname) && isNull(p.search) || (p.path = (p.pathname ? p.pathname : "") + (p.search ? p.search : "")), p.auth = u.auth || p.auth, p.slashes = p.slashes || u.slashes, p.href = p.format(), p;
}, Url.prototype.parseHost = function() {
  return parseHost(this);
};
var url_1 = createCommonjsModule(function(u) {
  var l = u.exports;
  l.encodeURI = function(f) {
    if (handlebarsUtils.isString(f))
      return encodeURIComponent(f);
  }, l.escape = function(f) {
    if (handlebarsUtils.isString(f))
      return querystring$1.escape(f);
  }, l.decodeURI = function(f) {
    if (handlebarsUtils.isString(f))
      return decodeURIComponent(f);
  }, l.urlResolve = function(f, p) {
    return url$1.resolve(f, p);
  }, l.urlParse = function(f) {
    return url$1.parse(f);
  }, l.stripQuerystring = function(f) {
    if (handlebarsUtils.isString(f))
      return f.split("?")[0];
  }, l.stripProtocol = function(f) {
    if (handlebarsUtils.isString(f)) {
      var p = url$1.parse(f);
      return p.protocol = "", p.format();
    }
  };
}), _default = rng;
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
var rng_1 = Object.defineProperty({ default: _default }, "__esModule", { value: !0 }), regex$1 = createCommonjsModule(function(u, l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.default = void 0, l.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
}), validate_1 = createCommonjsModule(function(u, l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.default = void 0;
  var f, p = (f = regex$1) && f.__esModule ? f : { default: f }, m = function(b) {
    return typeof b == "string" && p.default.test(b);
  };
  l.default = m;
}), stringify_1 = createCommonjsModule(function(u, l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.default = void 0, l.unsafeStringify = b;
  var f, p = (f = validate_1) && f.__esModule ? f : { default: f };
  const m = [];
  for (let v = 0; v < 256; ++v)
    m.push((v + 256).toString(16).slice(1));
  function b(v, k = 0) {
    return m[v[k + 0]] + m[v[k + 1]] + m[v[k + 2]] + m[v[k + 3]] + "-" + m[v[k + 4]] + m[v[k + 5]] + "-" + m[v[k + 6]] + m[v[k + 7]] + "-" + m[v[k + 8]] + m[v[k + 9]] + "-" + m[v[k + 10]] + m[v[k + 11]] + m[v[k + 12]] + m[v[k + 13]] + m[v[k + 14]] + m[v[k + 15]];
  }
  var y = function(v, k = 0) {
    const S = b(v, k);
    if (!(0, p.default)(S))
      throw TypeError("Stringified UUID is invalid");
    return S;
  };
  l.default = y;
}), v1_1 = createCommonjsModule(function(u, l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.default = void 0;
  var f, p = (f = rng_1) && f.__esModule ? f : { default: f };
  let m, b, y = 0, v = 0;
  var k = function(S, $, w) {
    let T = $ && w || 0;
    const E = $ || new Array(16);
    let R = (S = S || {}).node || m, O = S.clockseq !== void 0 ? S.clockseq : b;
    if (R == null || O == null) {
      const x = S.random || (S.rng || p.default)();
      R == null && (R = m = [1 | x[0], x[1], x[2], x[3], x[4], x[5]]), O == null && (O = b = 16383 & (x[6] << 8 | x[7]));
    }
    let P = S.msecs !== void 0 ? S.msecs : Date.now(), L = S.nsecs !== void 0 ? S.nsecs : v + 1;
    const M = P - y + (L - v) / 1e4;
    if (M < 0 && S.clockseq === void 0 && (O = O + 1 & 16383), (M < 0 || P > y) && S.nsecs === void 0 && (L = 0), L >= 1e4)
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    y = P, v = L, b = O, P += 122192928e5;
    const B = (1e4 * (268435455 & P) + L) % 4294967296;
    E[T++] = B >>> 24 & 255, E[T++] = B >>> 16 & 255, E[T++] = B >>> 8 & 255, E[T++] = 255 & B;
    const j = P / 4294967296 * 1e4 & 268435455;
    E[T++] = j >>> 8 & 255, E[T++] = 255 & j, E[T++] = j >>> 24 & 15 | 16, E[T++] = j >>> 16 & 255, E[T++] = O >>> 8 | 128, E[T++] = 255 & O;
    for (let x = 0; x < 6; ++x)
      E[T + x] = R[x];
    return $ || (0, stringify_1.unsafeStringify)(E);
  };
  l.default = k;
}), parse_1 = createCommonjsModule(function(u, l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.default = void 0;
  var f, p = (f = validate_1) && f.__esModule ? f : { default: f }, m = function(b) {
    if (!(0, p.default)(b))
      throw TypeError("Invalid UUID");
    let y;
    const v = new Uint8Array(16);
    return v[0] = (y = parseInt(b.slice(0, 8), 16)) >>> 24, v[1] = y >>> 16 & 255, v[2] = y >>> 8 & 255, v[3] = 255 & y, v[4] = (y = parseInt(b.slice(9, 13), 16)) >>> 8, v[5] = 255 & y, v[6] = (y = parseInt(b.slice(14, 18), 16)) >>> 8, v[7] = 255 & y, v[8] = (y = parseInt(b.slice(19, 23), 16)) >>> 8, v[9] = 255 & y, v[10] = (y = parseInt(b.slice(24, 36), 16)) / 1099511627776 & 255, v[11] = y / 4294967296 & 255, v[12] = y >>> 24 & 255, v[13] = y >>> 16 & 255, v[14] = y >>> 8 & 255, v[15] = 255 & y, v;
  };
  l.default = m;
}), v35_1 = createCommonjsModule(function(u, l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.URL = l.DNS = void 0, l.default = function(y, v, k) {
    function S($, w, T, E) {
      var R;
      if (typeof $ == "string" && ($ = function(P) {
        P = unescape(encodeURIComponent(P));
        const L = [];
        for (let M = 0; M < P.length; ++M)
          L.push(P.charCodeAt(M));
        return L;
      }($)), typeof w == "string" && (w = (0, p.default)(w)), ((R = w) === null || R === void 0 ? void 0 : R.length) !== 16)
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      let O = new Uint8Array(16 + $.length);
      if (O.set(w), O.set($, w.length), O = k(O), O[6] = 15 & O[6] | v, O[8] = 63 & O[8] | 128, T) {
        E = E || 0;
        for (let P = 0; P < 16; ++P)
          T[E + P] = O[P];
        return T;
      }
      return (0, stringify_1.unsafeStringify)(O);
    }
    try {
      S.name = y;
    } catch {
    }
    return S.DNS = m, S.URL = b, S;
  };
  var f, p = (f = parse_1) && f.__esModule ? f : { default: f };
  const m = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  l.DNS = m;
  const b = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  l.URL = b;
}), md5_1 = createCommonjsModule(function(u, l) {
  function f($) {
    return 14 + ($ + 64 >>> 9 << 4) + 1;
  }
  function p($, w) {
    const T = (65535 & $) + (65535 & w);
    return ($ >> 16) + (w >> 16) + (T >> 16) << 16 | 65535 & T;
  }
  function m($, w, T, E, R, O) {
    return p((P = p(p(w, $), p(E, O))) << (L = R) | P >>> 32 - L, T);
    var P, L;
  }
  function b($, w, T, E, R, O, P) {
    return m(w & T | ~w & E, $, w, R, O, P);
  }
  function y($, w, T, E, R, O, P) {
    return m(w & E | T & ~E, $, w, R, O, P);
  }
  function v($, w, T, E, R, O, P) {
    return m(w ^ T ^ E, $, w, R, O, P);
  }
  function k($, w, T, E, R, O, P) {
    return m(T ^ (w | ~E), $, w, R, O, P);
  }
  Object.defineProperty(l, "__esModule", { value: !0 }), l.default = void 0;
  var S = function($) {
    if (typeof $ == "string") {
      const w = unescape(encodeURIComponent($));
      $ = new Uint8Array(w.length);
      for (let T = 0; T < w.length; ++T)
        $[T] = w.charCodeAt(T);
    }
    return function(w) {
      const T = [], E = 32 * w.length, R = "0123456789abcdef";
      for (let O = 0; O < E; O += 8) {
        const P = w[O >> 5] >>> O % 32 & 255, L = parseInt(R.charAt(P >>> 4 & 15) + R.charAt(15 & P), 16);
        T.push(L);
      }
      return T;
    }(function(w, T) {
      w[T >> 5] |= 128 << T % 32, w[f(T) - 1] = T;
      let E = 1732584193, R = -271733879, O = -1732584194, P = 271733878;
      for (let L = 0; L < w.length; L += 16) {
        const M = E, B = R, j = O, x = P;
        E = b(E, R, O, P, w[L], 7, -680876936), P = b(P, E, R, O, w[L + 1], 12, -389564586), O = b(O, P, E, R, w[L + 2], 17, 606105819), R = b(R, O, P, E, w[L + 3], 22, -1044525330), E = b(E, R, O, P, w[L + 4], 7, -176418897), P = b(P, E, R, O, w[L + 5], 12, 1200080426), O = b(O, P, E, R, w[L + 6], 17, -1473231341), R = b(R, O, P, E, w[L + 7], 22, -45705983), E = b(E, R, O, P, w[L + 8], 7, 1770035416), P = b(P, E, R, O, w[L + 9], 12, -1958414417), O = b(O, P, E, R, w[L + 10], 17, -42063), R = b(R, O, P, E, w[L + 11], 22, -1990404162), E = b(E, R, O, P, w[L + 12], 7, 1804603682), P = b(P, E, R, O, w[L + 13], 12, -40341101), O = b(O, P, E, R, w[L + 14], 17, -1502002290), R = b(R, O, P, E, w[L + 15], 22, 1236535329), E = y(E, R, O, P, w[L + 1], 5, -165796510), P = y(P, E, R, O, w[L + 6], 9, -1069501632), O = y(O, P, E, R, w[L + 11], 14, 643717713), R = y(R, O, P, E, w[L], 20, -373897302), E = y(E, R, O, P, w[L + 5], 5, -701558691), P = y(P, E, R, O, w[L + 10], 9, 38016083), O = y(O, P, E, R, w[L + 15], 14, -660478335), R = y(R, O, P, E, w[L + 4], 20, -405537848), E = y(E, R, O, P, w[L + 9], 5, 568446438), P = y(P, E, R, O, w[L + 14], 9, -1019803690), O = y(O, P, E, R, w[L + 3], 14, -187363961), R = y(R, O, P, E, w[L + 8], 20, 1163531501), E = y(E, R, O, P, w[L + 13], 5, -1444681467), P = y(P, E, R, O, w[L + 2], 9, -51403784), O = y(O, P, E, R, w[L + 7], 14, 1735328473), R = y(R, O, P, E, w[L + 12], 20, -1926607734), E = v(E, R, O, P, w[L + 5], 4, -378558), P = v(P, E, R, O, w[L + 8], 11, -2022574463), O = v(O, P, E, R, w[L + 11], 16, 1839030562), R = v(R, O, P, E, w[L + 14], 23, -35309556), E = v(E, R, O, P, w[L + 1], 4, -1530992060), P = v(P, E, R, O, w[L + 4], 11, 1272893353), O = v(O, P, E, R, w[L + 7], 16, -155497632), R = v(R, O, P, E, w[L + 10], 23, -1094730640), E = v(E, R, O, P, w[L + 13], 4, 681279174), P = v(P, E, R, O, w[L], 11, -358537222), O = v(O, P, E, R, w[L + 3], 16, -722521979), R = v(R, O, P, E, w[L + 6], 23, 76029189), E = v(E, R, O, P, w[L + 9], 4, -640364487), P = v(P, E, R, O, w[L + 12], 11, -421815835), O = v(O, P, E, R, w[L + 15], 16, 530742520), R = v(R, O, P, E, w[L + 2], 23, -995338651), E = k(E, R, O, P, w[L], 6, -198630844), P = k(P, E, R, O, w[L + 7], 10, 1126891415), O = k(O, P, E, R, w[L + 14], 15, -1416354905), R = k(R, O, P, E, w[L + 5], 21, -57434055), E = k(E, R, O, P, w[L + 12], 6, 1700485571), P = k(P, E, R, O, w[L + 3], 10, -1894986606), O = k(O, P, E, R, w[L + 10], 15, -1051523), R = k(R, O, P, E, w[L + 1], 21, -2054922799), E = k(E, R, O, P, w[L + 8], 6, 1873313359), P = k(P, E, R, O, w[L + 15], 10, -30611744), O = k(O, P, E, R, w[L + 6], 15, -1560198380), R = k(R, O, P, E, w[L + 13], 21, 1309151649), E = k(E, R, O, P, w[L + 4], 6, -145523070), P = k(P, E, R, O, w[L + 11], 10, -1120210379), O = k(O, P, E, R, w[L + 2], 15, 718787259), R = k(R, O, P, E, w[L + 9], 21, -343485551), E = p(E, M), R = p(R, B), O = p(O, j), P = p(P, x);
      }
      return [E, R, O, P];
    }(function(w) {
      if (w.length === 0)
        return [];
      const T = 8 * w.length, E = new Uint32Array(f(T));
      for (let R = 0; R < T; R += 8)
        E[R >> 5] |= (255 & w[R / 8]) << R % 32;
      return E;
    }($), 8 * $.length));
  };
  l.default = S;
}), v3_1 = createCommonjsModule(function(u, l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.default = void 0;
  var f = m(v35_1), p = m(md5_1);
  function m(y) {
    return y && y.__esModule ? y : { default: y };
  }
  var b = (0, f.default)("v3", 48, p.default);
  l.default = b;
}), native = createCommonjsModule(function(u, l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.default = void 0;
  var f = { randomUUID: typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto) };
  l.default = f;
}), v4_1 = createCommonjsModule(function(u, l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.default = void 0;
  var f = m(native), p = m(rng_1);
  function m(y) {
    return y && y.__esModule ? y : { default: y };
  }
  var b = function(y, v, k) {
    if (f.default.randomUUID && !v && !y)
      return f.default.randomUUID();
    const S = (y = y || {}).random || (y.rng || p.default)();
    if (S[6] = 15 & S[6] | 64, S[8] = 63 & S[8] | 128, v) {
      k = k || 0;
      for (let $ = 0; $ < 16; ++$)
        v[k + $] = S[$];
      return v;
    }
    return (0, stringify_1.unsafeStringify)(S);
  };
  l.default = b;
}), sha1_1 = createCommonjsModule(function(u, l) {
  function f(b, y, v, k) {
    switch (b) {
      case 0:
        return y & v ^ ~y & k;
      case 1:
      case 3:
        return y ^ v ^ k;
      case 2:
        return y & v ^ y & k ^ v & k;
    }
  }
  function p(b, y) {
    return b << y | b >>> 32 - y;
  }
  Object.defineProperty(l, "__esModule", { value: !0 }), l.default = void 0;
  var m = function(b) {
    const y = [1518500249, 1859775393, 2400959708, 3395469782], v = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof b == "string") {
      const w = unescape(encodeURIComponent(b));
      b = [];
      for (let T = 0; T < w.length; ++T)
        b.push(w.charCodeAt(T));
    } else
      Array.isArray(b) || (b = Array.prototype.slice.call(b));
    b.push(128);
    const k = b.length / 4 + 2, S = Math.ceil(k / 16), $ = new Array(S);
    for (let w = 0; w < S; ++w) {
      const T = new Uint32Array(16);
      for (let E = 0; E < 16; ++E)
        T[E] = b[64 * w + 4 * E] << 24 | b[64 * w + 4 * E + 1] << 16 | b[64 * w + 4 * E + 2] << 8 | b[64 * w + 4 * E + 3];
      $[w] = T;
    }
    $[S - 1][14] = 8 * (b.length - 1) / Math.pow(2, 32), $[S - 1][14] = Math.floor($[S - 1][14]), $[S - 1][15] = 8 * (b.length - 1) & 4294967295;
    for (let w = 0; w < S; ++w) {
      const T = new Uint32Array(80);
      for (let M = 0; M < 16; ++M)
        T[M] = $[w][M];
      for (let M = 16; M < 80; ++M)
        T[M] = p(T[M - 3] ^ T[M - 8] ^ T[M - 14] ^ T[M - 16], 1);
      let E = v[0], R = v[1], O = v[2], P = v[3], L = v[4];
      for (let M = 0; M < 80; ++M) {
        const B = Math.floor(M / 20), j = p(E, 5) + f(B, R, O, P) + L + y[B] + T[M] >>> 0;
        L = P, P = O, O = p(R, 30) >>> 0, R = E, E = j;
      }
      v[0] = v[0] + E >>> 0, v[1] = v[1] + R >>> 0, v[2] = v[2] + O >>> 0, v[3] = v[3] + P >>> 0, v[4] = v[4] + L >>> 0;
    }
    return [v[0] >> 24 & 255, v[0] >> 16 & 255, v[0] >> 8 & 255, 255 & v[0], v[1] >> 24 & 255, v[1] >> 16 & 255, v[1] >> 8 & 255, 255 & v[1], v[2] >> 24 & 255, v[2] >> 16 & 255, v[2] >> 8 & 255, 255 & v[2], v[3] >> 24 & 255, v[3] >> 16 & 255, v[3] >> 8 & 255, 255 & v[3], v[4] >> 24 & 255, v[4] >> 16 & 255, v[4] >> 8 & 255, 255 & v[4]];
  };
  l.default = m;
}), v5_1 = createCommonjsModule(function(u, l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.default = void 0;
  var f = m(v35_1), p = m(sha1_1);
  function m(y) {
    return y && y.__esModule ? y : { default: y };
  }
  var b = (0, f.default)("v5", 80, p.default);
  l.default = b;
}), nil = createCommonjsModule(function(u, l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.default = void 0, l.default = "00000000-0000-0000-0000-000000000000";
}), version_1 = createCommonjsModule(function(u, l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), l.default = void 0;
  var f, p = (f = validate_1) && f.__esModule ? f : { default: f }, m = function(b) {
    if (!(0, p.default)(b))
      throw TypeError("Invalid UUID");
    return parseInt(b.slice(14, 15), 16);
  };
  l.default = m;
}), commonjsBrowser = createCommonjsModule(function(u, l) {
  Object.defineProperty(l, "__esModule", { value: !0 }), Object.defineProperty(l, "NIL", { enumerable: !0, get: function() {
    return y.default;
  } }), Object.defineProperty(l, "parse", { enumerable: !0, get: function() {
    return $.default;
  } }), Object.defineProperty(l, "stringify", { enumerable: !0, get: function() {
    return S.default;
  } }), Object.defineProperty(l, "v1", { enumerable: !0, get: function() {
    return f.default;
  } }), Object.defineProperty(l, "v3", { enumerable: !0, get: function() {
    return p.default;
  } }), Object.defineProperty(l, "v4", { enumerable: !0, get: function() {
    return m.default;
  } }), Object.defineProperty(l, "v5", { enumerable: !0, get: function() {
    return b.default;
  } }), Object.defineProperty(l, "validate", { enumerable: !0, get: function() {
    return k.default;
  } }), Object.defineProperty(l, "version", { enumerable: !0, get: function() {
    return v.default;
  } });
  var f = w(v1_1), p = w(v3_1), m = w(v4_1), b = w(v5_1), y = w(nil), v = w(version_1), k = w(validate_1), S = w(stringify_1), $ = w(parse_1);
  function w(T) {
    return T && T.__esModule ? T : { default: T };
  }
}), uuid_1 = createCommonjsModule(function(u) {
  u.exports.uuid = function() {
    return commonjsBrowser.v4();
  };
}), lib$1 = { array: array$1, code, collection, comparison: comparison$1, html: html_1, i18n, inflection, match, math: math$1, misc, number: number$1, object: object$1, path: path_1, regex: regex$2, string: string$1, url: url_1, uuid: uuid_1 }, handlebarsHelpers = createCommonjsModule(function(u) {
  u.exports = function(l, f) {
    typeof l == "string" ? l = [l] : Array.isArray(l) || (f = l, l = null);
    var p = (f = f || {}).handlebars || f.hbs || handlebars;
    if (u.exports.handlebars = p, l)
      l.forEach(function(m) {
        p.registerHelper(lib$1[m]);
      });
    else
      for (const m in lib$1) {
        const b = lib$1[m];
        p.registerHelper(b);
      }
    return p.helpers;
  };
  for (const l in lib$1) {
    const f = lib$1[l];
    u.exports[l] = function(p) {
      var m = (p = p || {}).handlebars || p.hbs || handlebars;
      return u.exports.handlebars = m, m.registerHelper(f), f;
    };
  }
  u.exports.utils = utils$2;
}), dayjs_min = createCommonjsModule(function(u, l) {
  u.exports = function() {
    var f = 1e3, p = 6e4, m = 36e5, b = "millisecond", y = "second", v = "minute", k = "hour", S = "day", $ = "week", w = "month", T = "quarter", E = "year", R = "date", O = "Invalid Date", P = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, L = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(Q) {
      var z = ["th", "st", "nd", "rd"], H = Q % 100;
      return "[" + Q + (z[(H - 20) % 10] || z[H] || z[0]) + "]";
    } }, B = function(Q, z, H) {
      var X = String(Q);
      return !X || X.length >= z ? Q : "" + Array(z + 1 - X.length).join(H) + Q;
    }, j = { s: B, z: function(Q) {
      var z = -Q.utcOffset(), H = Math.abs(z), X = Math.floor(H / 60), Z = H % 60;
      return (z <= 0 ? "+" : "-") + B(X, 2, "0") + ":" + B(Z, 2, "0");
    }, m: function Q(z, H) {
      if (z.date() < H.date())
        return -Q(H, z);
      var X = 12 * (H.year() - z.year()) + (H.month() - z.month()), Z = z.clone().add(X, w), oe = H - Z < 0, ee = z.clone().add(X + (oe ? -1 : 1), w);
      return +(-(X + (H - Z) / (oe ? Z - ee : ee - Z)) || 0);
    }, a: function(Q) {
      return Q < 0 ? Math.ceil(Q) || 0 : Math.floor(Q);
    }, p: function(Q) {
      return { M: w, y: E, w: $, d: S, D: R, h: k, m: v, s: y, ms: b, Q: T }[Q] || String(Q || "").toLowerCase().replace(/s$/, "");
    }, u: function(Q) {
      return Q === void 0;
    } }, x = "en", N = {};
    N[x] = M;
    var D = "$isDayjsObject", V = function(Q) {
      return Q instanceof Y || !(!Q || !Q[D]);
    }, W = function Q(z, H, X) {
      var Z;
      if (!z)
        return x;
      if (typeof z == "string") {
        var oe = z.toLowerCase();
        N[oe] && (Z = oe), H && (N[oe] = H, Z = oe);
        var ee = z.split("-");
        if (!Z && ee.length > 1)
          return Q(ee[0]);
      } else {
        var ie = z.name;
        N[ie] = z, Z = ie;
      }
      return !X && Z && (x = Z), Z || !X && x;
    }, F = function(Q, z) {
      if (V(Q))
        return Q.clone();
      var H = typeof z == "object" ? z : {};
      return H.date = Q, H.args = arguments, new Y(H);
    }, U = j;
    U.l = W, U.i = V, U.w = function(Q, z) {
      return F(Q, { locale: z.$L, utc: z.$u, x: z.$x, $offset: z.$offset });
    };
    var Y = function() {
      function Q(H) {
        this.$L = W(H.locale, null, !0), this.parse(H), this.$x = this.$x || H.x || {}, this[D] = !0;
      }
      var z = Q.prototype;
      return z.parse = function(H) {
        this.$d = function(X) {
          var Z = X.date, oe = X.utc;
          if (Z === null)
            return /* @__PURE__ */ new Date(NaN);
          if (U.u(Z))
            return /* @__PURE__ */ new Date();
          if (Z instanceof Date)
            return new Date(Z);
          if (typeof Z == "string" && !/Z$/i.test(Z)) {
            var ee = Z.match(P);
            if (ee) {
              var ie = ee[2] - 1 || 0, de = (ee[7] || "0").substring(0, 3);
              return oe ? new Date(Date.UTC(ee[1], ie, ee[3] || 1, ee[4] || 0, ee[5] || 0, ee[6] || 0, de)) : new Date(ee[1], ie, ee[3] || 1, ee[4] || 0, ee[5] || 0, ee[6] || 0, de);
            }
          }
          return new Date(Z);
        }(H), this.init();
      }, z.init = function() {
        var H = this.$d;
        this.$y = H.getFullYear(), this.$M = H.getMonth(), this.$D = H.getDate(), this.$W = H.getDay(), this.$H = H.getHours(), this.$m = H.getMinutes(), this.$s = H.getSeconds(), this.$ms = H.getMilliseconds();
      }, z.$utils = function() {
        return U;
      }, z.isValid = function() {
        return this.$d.toString() !== O;
      }, z.isSame = function(H, X) {
        var Z = F(H);
        return this.startOf(X) <= Z && Z <= this.endOf(X);
      }, z.isAfter = function(H, X) {
        return F(H) < this.startOf(X);
      }, z.isBefore = function(H, X) {
        return this.endOf(X) < F(H);
      }, z.$g = function(H, X, Z) {
        return U.u(H) ? this[X] : this.set(Z, H);
      }, z.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, z.valueOf = function() {
        return this.$d.getTime();
      }, z.startOf = function(H, X) {
        var Z = this, oe = !!U.u(X) || X, ee = U.p(H), ie = function(te, ue) {
          var J = U.w(Z.$u ? Date.UTC(Z.$y, ue, te) : new Date(Z.$y, ue, te), Z);
          return oe ? J : J.endOf(S);
        }, de = function(te, ue) {
          return U.w(Z.toDate()[te].apply(Z.toDate("s"), (oe ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ue)), Z);
        }, pe = this.$W, le = this.$M, ae = this.$D, ne = "set" + (this.$u ? "UTC" : "");
        switch (ee) {
          case E:
            return oe ? ie(1, 0) : ie(31, 11);
          case w:
            return oe ? ie(1, le) : ie(0, le + 1);
          case $:
            var K = this.$locale().weekStart || 0, ce = (pe < K ? pe + 7 : pe) - K;
            return ie(oe ? ae - ce : ae + (6 - ce), le);
          case S:
          case R:
            return de(ne + "Hours", 0);
          case k:
            return de(ne + "Minutes", 1);
          case v:
            return de(ne + "Seconds", 2);
          case y:
            return de(ne + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, z.endOf = function(H) {
        return this.startOf(H, !1);
      }, z.$set = function(H, X) {
        var Z, oe = U.p(H), ee = "set" + (this.$u ? "UTC" : ""), ie = (Z = {}, Z[S] = ee + "Date", Z[R] = ee + "Date", Z[w] = ee + "Month", Z[E] = ee + "FullYear", Z[k] = ee + "Hours", Z[v] = ee + "Minutes", Z[y] = ee + "Seconds", Z[b] = ee + "Milliseconds", Z)[oe], de = oe === S ? this.$D + (X - this.$W) : X;
        if (oe === w || oe === E) {
          var pe = this.clone().set(R, 1);
          pe.$d[ie](de), pe.init(), this.$d = pe.set(R, Math.min(this.$D, pe.daysInMonth())).$d;
        } else
          ie && this.$d[ie](de);
        return this.init(), this;
      }, z.set = function(H, X) {
        return this.clone().$set(H, X);
      }, z.get = function(H) {
        return this[U.p(H)]();
      }, z.add = function(H, X) {
        var Z, oe = this;
        H = Number(H);
        var ee = U.p(X), ie = function(le) {
          var ae = F(oe);
          return U.w(ae.date(ae.date() + Math.round(le * H)), oe);
        };
        if (ee === w)
          return this.set(w, this.$M + H);
        if (ee === E)
          return this.set(E, this.$y + H);
        if (ee === S)
          return ie(1);
        if (ee === $)
          return ie(7);
        var de = (Z = {}, Z[v] = p, Z[k] = m, Z[y] = f, Z)[ee] || 1, pe = this.$d.getTime() + H * de;
        return U.w(pe, this);
      }, z.subtract = function(H, X) {
        return this.add(-1 * H, X);
      }, z.format = function(H) {
        var X = this, Z = this.$locale();
        if (!this.isValid())
          return Z.invalidDate || O;
        var oe = H || "YYYY-MM-DDTHH:mm:ssZ", ee = U.z(this), ie = this.$H, de = this.$m, pe = this.$M, le = Z.weekdays, ae = Z.months, ne = Z.meridiem, K = function(ue, J, fe, _e) {
          return ue && (ue[J] || ue(X, oe)) || fe[J].slice(0, _e);
        }, ce = function(ue) {
          return U.s(ie % 12 || 12, ue, "0");
        }, te = ne || function(ue, J, fe) {
          var _e = ue < 12 ? "AM" : "PM";
          return fe ? _e.toLowerCase() : _e;
        };
        return oe.replace(L, function(ue, J) {
          return J || function(fe) {
            switch (fe) {
              case "YY":
                return String(X.$y).slice(-2);
              case "YYYY":
                return U.s(X.$y, 4, "0");
              case "M":
                return pe + 1;
              case "MM":
                return U.s(pe + 1, 2, "0");
              case "MMM":
                return K(Z.monthsShort, pe, ae, 3);
              case "MMMM":
                return K(ae, pe);
              case "D":
                return X.$D;
              case "DD":
                return U.s(X.$D, 2, "0");
              case "d":
                return String(X.$W);
              case "dd":
                return K(Z.weekdaysMin, X.$W, le, 2);
              case "ddd":
                return K(Z.weekdaysShort, X.$W, le, 3);
              case "dddd":
                return le[X.$W];
              case "H":
                return String(ie);
              case "HH":
                return U.s(ie, 2, "0");
              case "h":
                return ce(1);
              case "hh":
                return ce(2);
              case "a":
                return te(ie, de, !0);
              case "A":
                return te(ie, de, !1);
              case "m":
                return String(de);
              case "mm":
                return U.s(de, 2, "0");
              case "s":
                return String(X.$s);
              case "ss":
                return U.s(X.$s, 2, "0");
              case "SSS":
                return U.s(X.$ms, 3, "0");
              case "Z":
                return ee;
            }
            return null;
          }(ue) || ee.replace(":", "");
        });
      }, z.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, z.diff = function(H, X, Z) {
        var oe, ee = this, ie = U.p(X), de = F(H), pe = (de.utcOffset() - this.utcOffset()) * p, le = this - de, ae = function() {
          return U.m(ee, de);
        };
        switch (ie) {
          case E:
            oe = ae() / 12;
            break;
          case w:
            oe = ae();
            break;
          case T:
            oe = ae() / 3;
            break;
          case $:
            oe = (le - pe) / 6048e5;
            break;
          case S:
            oe = (le - pe) / 864e5;
            break;
          case k:
            oe = le / m;
            break;
          case v:
            oe = le / p;
            break;
          case y:
            oe = le / f;
            break;
          default:
            oe = le;
        }
        return Z ? oe : U.a(oe);
      }, z.daysInMonth = function() {
        return this.endOf(w).$D;
      }, z.$locale = function() {
        return N[this.$L];
      }, z.locale = function(H, X) {
        if (!H)
          return this.$L;
        var Z = this.clone(), oe = W(H, X, !0);
        return oe && (Z.$L = oe), Z;
      }, z.clone = function() {
        return U.w(this.$d, this);
      }, z.toDate = function() {
        return new Date(this.valueOf());
      }, z.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, z.toISOString = function() {
        return this.$d.toISOString();
      }, z.toString = function() {
        return this.$d.toUTCString();
      }, Q;
    }(), q = Y.prototype;
    return F.prototype = q, [["$ms", b], ["$s", y], ["$m", v], ["$H", k], ["$W", S], ["$M", w], ["$y", E], ["$D", R]].forEach(function(Q) {
      q[Q[1]] = function(z) {
        return this.$g(z, Q[0], Q[1]);
      };
    }), F.extend = function(Q, z) {
      return Q.$i || (Q(z, Y, F), Q.$i = !0), F;
    }, F.locale = W, F.isDayjs = V, F.unix = function(Q) {
      return F(1e3 * Q);
    }, F.en = N[x], F.Ls = N, F.p = {}, F;
  }();
}), duration$1 = createCommonjsModule(function(u, l) {
  var f, p, m, b, y, v, k, S, $, w, T, E, R, O, P, L, M, B, j, x;
  u.exports = (k = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, w = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, T = { years: S = 31536e6, months: $ = 2628e6, days: v = 864e5, hours: y = 36e5, minutes: b = 6e4, seconds: m = 1e3, milliseconds: 1, weeks: 6048e5 }, E = function(N) {
    return N instanceof j;
  }, R = function(N, D, V) {
    return new j(N, V, D.$l);
  }, O = function(N) {
    return p.p(N) + "s";
  }, P = function(N) {
    return N < 0;
  }, L = function(N) {
    return P(N) ? Math.ceil(N) : Math.floor(N);
  }, M = function(N) {
    return Math.abs(N);
  }, B = function(N, D) {
    return N ? P(N) ? { negative: !0, format: "" + M(N) + D } : { negative: !1, format: "" + N + D } : { negative: !1, format: "" };
  }, j = function() {
    function N(V, W, F) {
      var U = this;
      if (this.$d = {}, this.$l = F, V === void 0 && (this.$ms = 0, this.parseFromMilliseconds()), W)
        return R(V * T[O(W)], this);
      if (typeof V == "number")
        return this.$ms = V, this.parseFromMilliseconds(), this;
      if (typeof V == "object")
        return Object.keys(V).forEach(function(Q) {
          U.$d[O(Q)] = V[Q];
        }), this.calMilliseconds(), this;
      if (typeof V == "string") {
        var Y = V.match(w);
        if (Y) {
          var q = Y.slice(2).map(function(Q) {
            return Q != null ? Number(Q) : 0;
          });
          return this.$d.years = q[0], this.$d.months = q[1], this.$d.weeks = q[2], this.$d.days = q[3], this.$d.hours = q[4], this.$d.minutes = q[5], this.$d.seconds = q[6], this.calMilliseconds(), this;
        }
      }
      return this;
    }
    var D = N.prototype;
    return D.calMilliseconds = function() {
      var V = this;
      this.$ms = Object.keys(this.$d).reduce(function(W, F) {
        return W + (V.$d[F] || 0) * T[F];
      }, 0);
    }, D.parseFromMilliseconds = function() {
      var V = this.$ms;
      this.$d.years = L(V / S), V %= S, this.$d.months = L(V / $), V %= $, this.$d.days = L(V / v), V %= v, this.$d.hours = L(V / y), V %= y, this.$d.minutes = L(V / b), V %= b, this.$d.seconds = L(V / m), V %= m, this.$d.milliseconds = V;
    }, D.toISOString = function() {
      var V = B(this.$d.years, "Y"), W = B(this.$d.months, "M"), F = +this.$d.days || 0;
      this.$d.weeks && (F += 7 * this.$d.weeks);
      var U = B(F, "D"), Y = B(this.$d.hours, "H"), q = B(this.$d.minutes, "M"), Q = this.$d.seconds || 0;
      this.$d.milliseconds && (Q += this.$d.milliseconds / 1e3, Q = Math.round(1e3 * Q) / 1e3);
      var z = B(Q, "S"), H = V.negative || W.negative || U.negative || Y.negative || q.negative || z.negative, X = Y.format || q.format || z.format ? "T" : "", Z = (H ? "-" : "") + "P" + V.format + W.format + U.format + X + Y.format + q.format + z.format;
      return Z === "P" || Z === "-P" ? "P0D" : Z;
    }, D.toJSON = function() {
      return this.toISOString();
    }, D.format = function(V) {
      var W = V || "YYYY-MM-DDTHH:mm:ss", F = { Y: this.$d.years, YY: p.s(this.$d.years, 2, "0"), YYYY: p.s(this.$d.years, 4, "0"), M: this.$d.months, MM: p.s(this.$d.months, 2, "0"), D: this.$d.days, DD: p.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: p.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: p.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: p.s(this.$d.seconds, 2, "0"), SSS: p.s(this.$d.milliseconds, 3, "0") };
      return W.replace(k, function(U, Y) {
        return Y || String(F[U]);
      });
    }, D.as = function(V) {
      return this.$ms / T[O(V)];
    }, D.get = function(V) {
      var W = this.$ms, F = O(V);
      return F === "milliseconds" ? W %= 1e3 : W = F === "weeks" ? L(W / T[F]) : this.$d[F], W || 0;
    }, D.add = function(V, W, F) {
      var U;
      return U = W ? V * T[O(W)] : E(V) ? V.$ms : R(V, this).$ms, R(this.$ms + U * (F ? -1 : 1), this);
    }, D.subtract = function(V, W) {
      return this.add(V, W, !0);
    }, D.locale = function(V) {
      var W = this.clone();
      return W.$l = V, W;
    }, D.clone = function() {
      return R(this.$ms, this);
    }, D.humanize = function(V) {
      return f().add(this.$ms, "ms").locale(this.$l).fromNow(!V);
    }, D.valueOf = function() {
      return this.asMilliseconds();
    }, D.milliseconds = function() {
      return this.get("milliseconds");
    }, D.asMilliseconds = function() {
      return this.as("milliseconds");
    }, D.seconds = function() {
      return this.get("seconds");
    }, D.asSeconds = function() {
      return this.as("seconds");
    }, D.minutes = function() {
      return this.get("minutes");
    }, D.asMinutes = function() {
      return this.as("minutes");
    }, D.hours = function() {
      return this.get("hours");
    }, D.asHours = function() {
      return this.as("hours");
    }, D.days = function() {
      return this.get("days");
    }, D.asDays = function() {
      return this.as("days");
    }, D.weeks = function() {
      return this.get("weeks");
    }, D.asWeeks = function() {
      return this.as("weeks");
    }, D.months = function() {
      return this.get("months");
    }, D.asMonths = function() {
      return this.as("months");
    }, D.years = function() {
      return this.get("years");
    }, D.asYears = function() {
      return this.as("years");
    }, N;
  }(), x = function(N, D, V) {
    return N.add(D.years() * V, "y").add(D.months() * V, "M").add(D.days() * V, "d").add(D.hours() * V, "h").add(D.minutes() * V, "m").add(D.seconds() * V, "s").add(D.milliseconds() * V, "ms");
  }, function(N, D, V) {
    f = V, p = V().$utils(), V.duration = function(U, Y) {
      var q = V.locale();
      return R(U, { $l: q }, Y);
    }, V.isDuration = E;
    var W = D.prototype.add, F = D.prototype.subtract;
    D.prototype.add = function(U, Y) {
      return E(U) ? x(this, U, 1) : W.bind(this)(U, Y);
    }, D.prototype.subtract = function(U, Y) {
      return E(U) ? x(this, U, -1) : F.bind(this)(U, Y);
    };
  });
}), advancedFormat = createCommonjsModule(function(u, l) {
  u.exports = function(f, p) {
    var m = p.prototype, b = m.format;
    m.format = function(y) {
      var v = this, k = this.$locale();
      if (!this.isValid())
        return b.bind(this)(y);
      var S = this.$utils(), $ = (y || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(w) {
        switch (w) {
          case "Q":
            return Math.ceil((v.$M + 1) / 3);
          case "Do":
            return k.ordinal(v.$D);
          case "gggg":
            return v.weekYear();
          case "GGGG":
            return v.isoWeekYear();
          case "wo":
            return k.ordinal(v.week(), "W");
          case "w":
          case "ww":
            return S.s(v.week(), w === "w" ? 1 : 2, "0");
          case "W":
          case "WW":
            return S.s(v.isoWeek(), w === "W" ? 1 : 2, "0");
          case "k":
          case "kk":
            return S.s(String(v.$H === 0 ? 24 : v.$H), w === "k" ? 1 : 2, "0");
          case "X":
            return Math.floor(v.$d.getTime() / 1e3);
          case "x":
            return v.$d.getTime();
          case "z":
            return "[" + v.offsetName() + "]";
          case "zzz":
            return "[" + v.offsetName("long") + "]";
          default:
            return w;
        }
      });
      return b.bind(this)($);
    };
  };
}), isoWeek = createCommonjsModule(function(u, l) {
  var f;
  u.exports = (f = "day", function(p, m, b) {
    var y = function(S) {
      return S.add(4 - S.isoWeekday(), f);
    }, v = m.prototype;
    v.isoWeekYear = function() {
      return y(this).year();
    }, v.isoWeek = function(S) {
      if (!this.$utils().u(S))
        return this.add(7 * (S - this.isoWeek()), f);
      var $, w, T, E = y(this), R = ($ = this.isoWeekYear(), T = 4 - (w = (this.$u ? b.utc : b)().year($).startOf("year")).isoWeekday(), w.isoWeekday() > 4 && (T += 7), w.add(T, f));
      return E.diff(R, "week") + 1;
    }, v.isoWeekday = function(S) {
      return this.$utils().u(S) ? this.day() || 7 : this.day(this.day() % 7 ? S : S - 7);
    };
    var k = v.startOf;
    v.startOf = function(S, $) {
      var w = this.$utils(), T = !!w.u($) || $;
      return w.p(S) === "isoweek" ? T ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : k.bind(this)(S, $);
    };
  });
}), weekYear = createCommonjsModule(function(u, l) {
  u.exports = function(f, p) {
    p.prototype.weekYear = function() {
      var m = this.month(), b = this.week(), y = this.year();
      return b === 1 && m === 11 ? y + 1 : m === 0 && b >= 52 ? y - 1 : y;
    };
  };
}), weekOfYear = createCommonjsModule(function(u, l) {
  var f, p;
  u.exports = (f = "week", p = "year", function(m, b, y) {
    var v = b.prototype;
    v.week = function(k) {
      if (k === void 0 && (k = null), k !== null)
        return this.add(7 * (k - this.week()), "day");
      var S = this.$locale().yearStart || 1;
      if (this.month() === 11 && this.date() > 25) {
        var $ = y(this).startOf(p).add(1, p).date(S), w = y(this).endOf(f);
        if ($.isBefore(w))
          return 1;
      }
      var T = y(this).startOf(p).date(S).startOf(f).subtract(1, "millisecond"), E = this.diff(T, f, !0);
      return E < 0 ? y(this).startOf("week").week() : Math.ceil(E);
    }, v.weeks = function(k) {
      return k === void 0 && (k = null), this.week(k);
    };
  });
}), relativeTime = createCommonjsModule(function(u, l) {
  u.exports = function(f, p, m) {
    f = f || {};
    var b = p.prototype, y = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
    function v(S, $, w, T) {
      return b.fromToBase(S, $, w, T);
    }
    m.en.relativeTime = y, b.fromToBase = function(S, $, w, T, E) {
      for (var R, O, P, L = w.$locale().relativeTime || y, M = f.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], B = M.length, j = 0; j < B; j += 1) {
        var x = M[j];
        x.d && (R = T ? m(S).diff(w, x.d, !0) : w.diff(S, x.d, !0));
        var N = (f.rounding || Math.round)(Math.abs(R));
        if (P = R > 0, N <= x.r || !x.r) {
          N <= 1 && j > 0 && (x = M[j - 1]);
          var D = L[x.l];
          E && (N = E("" + N)), O = typeof D == "string" ? D.replace("%d", N) : D(N, $, x.l, P);
          break;
        }
      }
      if ($)
        return O;
      var V = P ? L.future : L.past;
      return typeof V == "function" ? V(O) : V.replace("%s", O);
    }, b.to = function(S, $) {
      return v(S, $, this, !0);
    }, b.from = function(S, $) {
      return v(S, $, this);
    };
    var k = function(S) {
      return S.$u ? m.utc() : m();
    };
    b.toNow = function(S) {
      return this.to(k(this), S);
    }, b.fromNow = function(S) {
      return this.from(k(this), S);
    };
  };
}), utc = createCommonjsModule(function(u, l) {
  var f, p, m;
  u.exports = (f = "minute", p = /[+-]\d\d(?::?\d\d)?/g, m = /([+-]|\d\d)/g, function(b, y, v) {
    var k = y.prototype;
    v.utc = function(O) {
      return new y({ date: O, utc: !0, args: arguments });
    }, k.utc = function(O) {
      var P = v(this.toDate(), { locale: this.$L, utc: !0 });
      return O ? P.add(this.utcOffset(), f) : P;
    }, k.local = function() {
      return v(this.toDate(), { locale: this.$L, utc: !1 });
    };
    var S = k.parse;
    k.parse = function(O) {
      O.utc && (this.$u = !0), this.$utils().u(O.$offset) || (this.$offset = O.$offset), S.call(this, O);
    };
    var $ = k.init;
    k.init = function() {
      if (this.$u) {
        var O = this.$d;
        this.$y = O.getUTCFullYear(), this.$M = O.getUTCMonth(), this.$D = O.getUTCDate(), this.$W = O.getUTCDay(), this.$H = O.getUTCHours(), this.$m = O.getUTCMinutes(), this.$s = O.getUTCSeconds(), this.$ms = O.getUTCMilliseconds();
      } else
        $.call(this);
    };
    var w = k.utcOffset;
    k.utcOffset = function(O, P) {
      var L = this.$utils().u;
      if (L(O))
        return this.$u ? 0 : L(this.$offset) ? w.call(this) : this.$offset;
      if (typeof O == "string" && (O = function(x) {
        x === void 0 && (x = "");
        var N = x.match(p);
        if (!N)
          return null;
        var D = ("" + N[0]).match(m) || ["-", 0, 0], V = D[0], W = 60 * +D[1] + +D[2];
        return W === 0 ? 0 : V === "+" ? W : -W;
      }(O), O === null))
        return this;
      var M = Math.abs(O) <= 16 ? 60 * O : O;
      if (M === 0)
        return this.utc(P);
      var B = this.clone();
      if (P)
        return B.$offset = M, B.$u = !1, B;
      var j = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
      return (B = this.local().add(M + j, f)).$offset = M, B.$x.$localOffset = j, B;
    };
    var T = k.format;
    k.format = function(O) {
      var P = O || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
      return T.call(this, P);
    }, k.valueOf = function() {
      var O = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
      return this.$d.valueOf() - 6e4 * O;
    }, k.isUTC = function() {
      return !!this.$u;
    }, k.toISOString = function() {
      return this.toDate().toISOString();
    }, k.toString = function() {
      return this.toDate().toUTCString();
    };
    var E = k.toDate;
    k.toDate = function(O) {
      return O === "s" && this.$offset ? v(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : E.call(this);
    };
    var R = k.diff;
    k.diff = function(O, P, L) {
      if (O && this.$u === O.$u)
        return R.call(this, O, P, L);
      var M = this.local(), B = v(O).local();
      return R.call(M, B, P, L);
    };
  });
}), timezone = createCommonjsModule(function(u, l) {
  var f, p;
  u.exports = (f = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, p = {}, function(m, b, y) {
    var v, k = function(T, E, R) {
      R === void 0 && (R = {});
      var O = new Date(T), P = function(L, M) {
        M === void 0 && (M = {});
        var B = M.timeZoneName || "short", j = L + "|" + B, x = p[j];
        return x || (x = new Intl.DateTimeFormat("en-US", { hour12: !1, timeZone: L, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: B }), p[j] = x), x;
      }(E, R);
      return P.formatToParts(O);
    }, S = function(T, E) {
      for (var R = k(T, E), O = [], P = 0; P < R.length; P += 1) {
        var L = R[P], M = L.type, B = L.value, j = f[M];
        j >= 0 && (O[j] = parseInt(B, 10));
      }
      var x = O[3], N = x === 24 ? 0 : x, D = O[0] + "-" + O[1] + "-" + O[2] + " " + N + ":" + O[4] + ":" + O[5] + ":000", V = +T;
      return (y.utc(D).valueOf() - (V -= V % 1e3)) / 6e4;
    }, $ = b.prototype;
    $.tz = function(T, E) {
      T === void 0 && (T = v);
      var R, O = this.utcOffset(), P = this.toDate(), L = P.toLocaleString("en-US", { timeZone: T }), M = Math.round((P - new Date(L)) / 1e3 / 60), B = 15 * -Math.round(P.getTimezoneOffset() / 15) - M;
      if (Number(B)) {
        if (R = y(L, { locale: this.$L }).$set("millisecond", this.$ms).utcOffset(B, !0), E) {
          var j = R.utcOffset();
          R = R.add(O - j, "minute");
        }
      } else
        R = this.utcOffset(0, E);
      return R.$x.$timezone = T, R;
    }, $.offsetName = function(T) {
      var E = this.$x.$timezone || y.tz.guess(), R = k(this.valueOf(), E, { timeZoneName: T }).find(function(O) {
        return O.type.toLowerCase() === "timezonename";
      });
      return R && R.value;
    };
    var w = $.startOf;
    $.startOf = function(T, E) {
      if (!this.$x || !this.$x.$timezone)
        return w.call(this, T, E);
      var R = y(this.format("YYYY-MM-DD HH:mm:ss:SSS"), { locale: this.$L });
      return w.call(R, T, E).tz(this.$x.$timezone, !0);
    }, y.tz = function(T, E, R) {
      var O = R && E, P = R || E || v, L = S(+y(), P);
      if (typeof T != "string")
        return y(T).tz(P);
      var M = function(N, D, V) {
        var W = N - 60 * D * 1e3, F = S(W, V);
        if (D === F)
          return [W, D];
        var U = S(W -= 60 * (F - D) * 1e3, V);
        return F === U ? [W, F] : [N - 60 * Math.min(F, U) * 1e3, Math.max(F, U)];
      }(y.utc(T, O).valueOf(), L, P), B = M[0], j = M[1], x = y(B).utcOffset(j);
      return x.$x.$timezone = P, x;
    }, y.tz.guess = function() {
      return Intl.DateTimeFormat().resolvedOptions().timeZone;
    }, y.tz.setDefault = function(T) {
      v = T;
    };
  });
});
function isOptions(u) {
  return typeof u == "object" && typeof u.hash == "object";
}
function isApp(u) {
  return typeof u == "object" && typeof u.options == "object" && typeof u.app == "object";
}
function getContext(u, l, f) {
  if (isOptions(u))
    return getContext({}, l, u);
  if (isOptions(l))
    return getContext(u, f, l);
  const p = isApp(u) ? u.context : {};
  isOptions(f = f || {}) || (l = Object.assign({}, l, f)), isOptions(f) && f.hash.root === !0 && (l = Object.assign({}, f.data.root, l));
  let m = Object.assign({}, p, l, f.hash);
  return isApp(u) || (m = Object.assign({}, u, m)), isApp(u) && u.view && u.view.data && (m = Object.assign({}, m, u.view.data)), m;
}
function initialConfig(u, l, f) {
  return isOptions(l) && (f = l, l = DEFAULT_FORMAT), isOptions(u) && (f = u, l = null, u = null), { str: u, pattern: l, options: f };
}
function setLocale(u, l, f) {
  const p = initialConfig(u, l, f), m = getContext(this, { lang: "en", date: new Date(p.str) }, {});
  dayjs_min.locale(m.lang || m.language);
}
dayjs_min.extend(duration$1), dayjs_min.extend(advancedFormat), dayjs_min.extend(isoWeek), dayjs_min.extend(weekYear), dayjs_min.extend(weekOfYear), dayjs_min.extend(relativeTime), dayjs_min.extend(utc), dayjs_min.extend(timezone);
const DEFAULT_FORMAT = "MMMM DD, YYYY", date$1 = (u, l, f) => {
  const p = initialConfig(u, l, f);
  if (p.str == null && p.pattern == null)
    return dayjs_min.locale("en"), dayjs_min().format(DEFAULT_FORMAT);
  setLocale(p.str, p.pattern, p.options);
  let m = dayjs_min(new Date(p.str));
  return m = typeof p.options == "string" ? p.options.toLowerCase() === "utc" ? m.utc() : m.tz(p.options) : m.tz(dayjs_min.tz.guess()), p.pattern === "" ? m.toISOString() : m.format(p.pattern);
}, duration = (u, l, f) => {
  const p = initialConfig(u, l);
  setLocale(p.str, p.pattern);
  const m = dayjs_min.duration(p.str, p.pattern);
  return f && !isOptions(f) ? m.format(f) : m.humanize();
}, difference = (u, l, f) => dayjs_min(new Date(u)).diff(dayjs_min(new Date(l)), f), durationFromNow = (u) => {
  const l = difference(u, (/* @__PURE__ */ new Date()).toISOString(), "ms");
  return duration(l, "ms");
}, HelperFunctionBuiltin = ["#if", "#unless", "#each", "#with", "lookup", "log", "blockHelperMissing", "each", "helperMissing", "if", "unless", "log", "lookup", "with"], EXTERNAL_FUNCTION_COLLECTIONS = ["math", "array", "number", "url", "string", "comparison", "object", "regex", "uuid"], HelperFunctionNames = { OBJECT: "object", ALL: "all", LITERAL: "literal", JS: "js", DECODE_ID: "decodeId" }, LITERAL_MARKER = "%LITERAL%", ADDED_HELPERS = { date: date$1, duration, difference, durationFromNow };
function registerAll$1(u) {
  for (let [f, p] of Object.entries(ADDED_HELPERS))
    u.registerHelper(f, p);
  let l = [];
  for (let f of EXTERNAL_FUNCTION_COLLECTIONS) {
    let p = handlebarsHelpers[f]();
    for (let m of Object.entries(p)) {
      const b = m[0];
      HelperFunctionBuiltin.indexOf(b) === -1 && l.indexOf(b) === -1 && l.push(b);
    }
    handlebarsHelpers[f]({ handlebars: u });
  }
  externalHelperNames = l.concat(Object.keys(ADDED_HELPERS));
}
let externalHelperNames = [];
function isJest() {
  return browser.env.NODE_ENV === "jest" || browser.env.JEST_WORKER_ID != null && browser.env.JEST_WORKER_ID !== "null";
}
function isTest() {
  return isJest();
}
const isTestingBackendJS = () => browser && browser.env.BACKEND_JS, ALPHA_NUMERIC_REGEX = /^[A-Za-z0-9]+$/g, FIND_HBS_REGEX = /{{([^{].*?)}}/g, FIND_ANY_HBS_REGEX = /{?{{([^{].*?)}}}?/g, FIND_TRIPLE_HBS_REGEX = /{{{([^{].*?)}}}/g, isBackendService = () => !(!isTest() || !isTestingBackendJS()) || !isTest() && typeof window > "u", isJSAllowed = () => browser && !browser.env.NO_JS, findDoubleHbsInstances = (u) => {
  let l = u;
  const f = new RegExp(FIND_HBS_REGEX), p = new RegExp(FIND_TRIPLE_HBS_REGEX), m = l.match(p);
  return m && m.forEach((y) => {
    l = l.replace(y, "");
  }), l.match(f) || [];
}, isAlphaNumeric = (u) => u.match(ALPHA_NUMERIC_REGEX), swapStrings = (u, l, f, p) => u.slice(0, l) + p + u.slice(l + f), atob$1 = (u) => Buffer.from(u, "base64").toString("utf-8"), prefixStrings = (u, l, f) => {
  const p = l.map((b) => b.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")), m = new RegExp(`\\b(${p.join("|")})\\b`, "g");
  return u.replace(m, `${f}$1`);
};
function frontendWrapJS(u) {
  return `
        result = {
          result: null,
          error: null,
        };

        try {
          result.result = ${u};
        } catch (e) {
          result.error = e;
        }

        result;
      `;
}
const externalCollections = { math: math$1, array: array$1, number: number$1, url: url_1, string: string$1, comparison: comparison$1, object: object$1, regex: regex$2, uuid: uuid_1 }, helpersToRemoveForJs = ["sortBy"], addedHelpers = { date: date$1, duration };
let helpers;
function getJsHelperList() {
  if (helpers)
    return helpers;
  helpers = {};
  for (let u of Object.values(externalCollections))
    for (let [l, f] of Object.entries(u))
      helpers[l] = (...p) => f(...p, {});
  helpers = Object.assign(Object.assign({}, helpers), addedHelpers);
  for (const u of helpersToRemoveForJs)
    delete helpers[u];
  return Object.freeze(helpers), helpers;
}
const iifeWrapper = (u) => `(function(){
${u}
})();`;
class JsTimeoutError extends Error {
  constructor() {
    super(JsTimeoutError.message), this.code = JsTimeoutError.code;
  }
}
JsTimeoutError.message = "Timed out while executing JS", JsTimeoutError.code = "JS_TIMEOUT_ERROR";
class UserScriptError extends Error {
  constructor(l) {
    super(`error while running user-supplied JavaScript: ${l.toString()}`), this.userScriptError = l, this.code = UserScriptError.code;
  }
}
UserScriptError.code = "USER_SCRIPT_ERROR";
var _mapping$1 = createCommonjsModule(function(u, l) {
  l.aliasToReal = { each: "forEach", eachRight: "forEachRight", entries: "toPairs", entriesIn: "toPairsIn", extend: "assignIn", extendAll: "assignInAll", extendAllWith: "assignInAllWith", extendWith: "assignInWith", first: "head", conforms: "conformsTo", matches: "isMatch", property: "get", __: "placeholder", F: "stubFalse", T: "stubTrue", all: "every", allPass: "overEvery", always: "constant", any: "some", anyPass: "overSome", apply: "spread", assoc: "set", assocPath: "set", complement: "negate", compose: "flowRight", contains: "includes", dissoc: "unset", dissocPath: "unset", dropLast: "dropRight", dropLastWhile: "dropRightWhile", equals: "isEqual", identical: "eq", indexBy: "keyBy", init: "initial", invertObj: "invert", juxt: "over", omitAll: "omit", nAry: "ary", path: "get", pathEq: "matchesProperty", pathOr: "getOr", paths: "at", pickAll: "pick", pipe: "flow", pluck: "map", prop: "get", propEq: "matchesProperty", propOr: "getOr", props: "at", symmetricDifference: "xor", symmetricDifferenceBy: "xorBy", symmetricDifferenceWith: "xorWith", takeLast: "takeRight", takeLastWhile: "takeRightWhile", unapply: "rest", unnest: "flatten", useWith: "overArgs", where: "conformsTo", whereEq: "isMatch", zipObj: "zipObject" }, l.aryMethod = { 1: ["assignAll", "assignInAll", "attempt", "castArray", "ceil", "create", "curry", "curryRight", "defaultsAll", "defaultsDeepAll", "floor", "flow", "flowRight", "fromPairs", "invert", "iteratee", "memoize", "method", "mergeAll", "methodOf", "mixin", "nthArg", "over", "overEvery", "overSome", "rest", "reverse", "round", "runInContext", "spread", "template", "trim", "trimEnd", "trimStart", "uniqueId", "words", "zipAll"], 2: ["add", "after", "ary", "assign", "assignAllWith", "assignIn", "assignInAllWith", "at", "before", "bind", "bindAll", "bindKey", "chunk", "cloneDeepWith", "cloneWith", "concat", "conformsTo", "countBy", "curryN", "curryRightN", "debounce", "defaults", "defaultsDeep", "defaultTo", "delay", "difference", "divide", "drop", "dropRight", "dropRightWhile", "dropWhile", "endsWith", "eq", "every", "filter", "find", "findIndex", "findKey", "findLast", "findLastIndex", "findLastKey", "flatMap", "flatMapDeep", "flattenDepth", "forEach", "forEachRight", "forIn", "forInRight", "forOwn", "forOwnRight", "get", "groupBy", "gt", "gte", "has", "hasIn", "includes", "indexOf", "intersection", "invertBy", "invoke", "invokeMap", "isEqual", "isMatch", "join", "keyBy", "lastIndexOf", "lt", "lte", "map", "mapKeys", "mapValues", "matchesProperty", "maxBy", "meanBy", "merge", "mergeAllWith", "minBy", "multiply", "nth", "omit", "omitBy", "overArgs", "pad", "padEnd", "padStart", "parseInt", "partial", "partialRight", "partition", "pick", "pickBy", "propertyOf", "pull", "pullAll", "pullAt", "random", "range", "rangeRight", "rearg", "reject", "remove", "repeat", "restFrom", "result", "sampleSize", "some", "sortBy", "sortedIndex", "sortedIndexOf", "sortedLastIndex", "sortedLastIndexOf", "sortedUniqBy", "split", "spreadFrom", "startsWith", "subtract", "sumBy", "take", "takeRight", "takeRightWhile", "takeWhile", "tap", "throttle", "thru", "times", "trimChars", "trimCharsEnd", "trimCharsStart", "truncate", "union", "uniqBy", "uniqWith", "unset", "unzipWith", "without", "wrap", "xor", "zip", "zipObject", "zipObjectDeep"], 3: ["assignInWith", "assignWith", "clamp", "differenceBy", "differenceWith", "findFrom", "findIndexFrom", "findLastFrom", "findLastIndexFrom", "getOr", "includesFrom", "indexOfFrom", "inRange", "intersectionBy", "intersectionWith", "invokeArgs", "invokeArgsMap", "isEqualWith", "isMatchWith", "flatMapDepth", "lastIndexOfFrom", "mergeWith", "orderBy", "padChars", "padCharsEnd", "padCharsStart", "pullAllBy", "pullAllWith", "rangeStep", "rangeStepRight", "reduce", "reduceRight", "replace", "set", "slice", "sortedIndexBy", "sortedLastIndexBy", "transform", "unionBy", "unionWith", "update", "xorBy", "xorWith", "zipWith"], 4: ["fill", "setWith", "updateWith"] }, l.aryRearg = { 2: [1, 0], 3: [2, 0, 1], 4: [3, 2, 0, 1] }, l.iterateeAry = { dropRightWhile: 1, dropWhile: 1, every: 1, filter: 1, find: 1, findFrom: 1, findIndex: 1, findIndexFrom: 1, findKey: 1, findLast: 1, findLastFrom: 1, findLastIndex: 1, findLastIndexFrom: 1, findLastKey: 1, flatMap: 1, flatMapDeep: 1, flatMapDepth: 1, forEach: 1, forEachRight: 1, forIn: 1, forInRight: 1, forOwn: 1, forOwnRight: 1, map: 1, mapKeys: 1, mapValues: 1, partition: 1, reduce: 2, reduceRight: 2, reject: 1, remove: 1, some: 1, takeRightWhile: 1, takeWhile: 1, times: 1, transform: 2 }, l.iterateeRearg = { mapKeys: [1], reduceRight: [1, 0] }, l.methodRearg = { assignInAllWith: [1, 0], assignInWith: [1, 2, 0], assignAllWith: [1, 0], assignWith: [1, 2, 0], differenceBy: [1, 2, 0], differenceWith: [1, 2, 0], getOr: [2, 1, 0], intersectionBy: [1, 2, 0], intersectionWith: [1, 2, 0], isEqualWith: [1, 2, 0], isMatchWith: [2, 1, 0], mergeAllWith: [1, 0], mergeWith: [1, 2, 0], padChars: [2, 1, 0], padCharsEnd: [2, 1, 0], padCharsStart: [2, 1, 0], pullAllBy: [2, 1, 0], pullAllWith: [2, 1, 0], rangeStep: [1, 2, 0], rangeStepRight: [1, 2, 0], setWith: [3, 1, 2, 0], sortedIndexBy: [2, 1, 0], sortedLastIndexBy: [2, 1, 0], unionBy: [1, 2, 0], unionWith: [1, 2, 0], updateWith: [3, 1, 2, 0], xorBy: [1, 2, 0], xorWith: [1, 2, 0], zipWith: [1, 2, 0] }, l.methodSpread = { assignAll: { start: 0 }, assignAllWith: { start: 0 }, assignInAll: { start: 0 }, assignInAllWith: { start: 0 }, defaultsAll: { start: 0 }, defaultsDeepAll: { start: 0 }, invokeArgs: { start: 2 }, invokeArgsMap: { start: 2 }, mergeAll: { start: 0 }, mergeAllWith: { start: 0 }, partial: { start: 1 }, partialRight: { start: 1 }, without: { start: 1 }, zipAll: { start: 0 } }, l.mutate = { array: { fill: !0, pull: !0, pullAll: !0, pullAllBy: !0, pullAllWith: !0, pullAt: !0, remove: !0, reverse: !0 }, object: { assign: !0, assignAll: !0, assignAllWith: !0, assignIn: !0, assignInAll: !0, assignInAllWith: !0, assignInWith: !0, assignWith: !0, defaults: !0, defaultsAll: !0, defaultsDeep: !0, defaultsDeepAll: !0, merge: !0, mergeAll: !0, mergeAllWith: !0, mergeWith: !0 }, set: { set: !0, setWith: !0, unset: !0, update: !0, updateWith: !0 } }, l.realToAlias = function() {
    var f = Object.prototype.hasOwnProperty, p = l.aliasToReal, m = {};
    for (var b in p) {
      var y = p[b];
      f.call(m, y) ? m[y].push(b) : m[y] = [b];
    }
    return m;
  }(), l.remap = { assignAll: "assign", assignAllWith: "assignWith", assignInAll: "assignIn", assignInAllWith: "assignInWith", curryN: "curry", curryRightN: "curryRight", defaultsAll: "defaults", defaultsDeepAll: "defaultsDeep", findFrom: "find", findIndexFrom: "findIndex", findLastFrom: "findLast", findLastIndexFrom: "findLastIndex", getOr: "get", includesFrom: "includes", indexOfFrom: "indexOf", invokeArgs: "invoke", invokeArgsMap: "invokeMap", lastIndexOfFrom: "lastIndexOf", mergeAll: "merge", mergeAllWith: "mergeWith", padChars: "pad", padCharsEnd: "padEnd", padCharsStart: "padStart", propertyOf: "get", rangeStep: "range", rangeStepRight: "rangeRight", restFrom: "rest", spreadFrom: "spread", trimChars: "trim", trimCharsEnd: "trimEnd", trimCharsStart: "trimStart", zipAll: "zip" }, l.skipFixed = { castArray: !0, flow: !0, flowRight: !0, iteratee: !0, mixin: !0, rearg: !0, runInContext: !0 }, l.skipRearg = { add: !0, assign: !0, assignIn: !0, bind: !0, bindKey: !0, concat: !0, difference: !0, divide: !0, eq: !0, gt: !0, gte: !0, isEqual: !0, lt: !0, lte: !0, matchesProperty: !0, merge: !0, multiply: !0, overArgs: !0, partial: !0, partialRight: !0, propertyOf: !0, random: !0, range: !0, rangeRight: !0, subtract: !0, zip: !0, zipObject: !0, zipObjectDeep: !0 };
}), placeholder$1 = {}, push$2 = Array.prototype.push;
function baseArity$1(u, l) {
  return l == 2 ? function(f, p) {
    return u.apply(void 0, arguments);
  } : function(f) {
    return u.apply(void 0, arguments);
  };
}
function baseAry$1(u, l) {
  return l == 2 ? function(f, p) {
    return u(f, p);
  } : function(f) {
    return u(f);
  };
}
function cloneArray$1(u) {
  for (var l = u ? u.length : 0, f = Array(l); l--; )
    f[l] = u[l];
  return f;
}
function createCloner$1(u) {
  return function(l) {
    return u({}, l);
  };
}
function flatSpread$1(u, l) {
  return function() {
    for (var f = arguments.length, p = f - 1, m = Array(f); f--; )
      m[f] = arguments[f];
    var b = m[l], y = m.slice(0, l);
    return b && push$2.apply(y, b), l != p && push$2.apply(y, m.slice(l + 1)), u.apply(this, y);
  };
}
function wrapImmutable$1(u, l) {
  return function() {
    var f = arguments.length;
    if (f) {
      for (var p = Array(f); f--; )
        p[f] = arguments[f];
      var m = p[0] = l.apply(void 0, p);
      return u.apply(void 0, p), m;
    }
  };
}
function baseConvert$2(u, l, f, p) {
  var m = typeof l == "function", b = l === Object(l);
  if (b && (p = f, f = l, l = void 0), f == null)
    throw new TypeError();
  p || (p = {});
  var y = !("cap" in p) || p.cap, v = !("curry" in p) || p.curry, k = !("fixed" in p) || p.fixed, S = !("immutable" in p) || p.immutable, $ = !("rearg" in p) || p.rearg, w = m ? f : placeholder$1, T = "curry" in p && p.curry, E = "fixed" in p && p.fixed, R = "rearg" in p && p.rearg, O = m ? f.runInContext() : void 0, P = m ? f : { ary: u.ary, assign: u.assign, clone: u.clone, curry: u.curry, forEach: u.forEach, isArray: u.isArray, isError: u.isError, isFunction: u.isFunction, isWeakMap: u.isWeakMap, iteratee: u.iteratee, keys: u.keys, rearg: u.rearg, toInteger: u.toInteger, toPath: u.toPath }, L = P.ary, M = P.assign, B = P.clone, j = P.curry, x = P.forEach, N = P.isArray, D = P.isError, V = P.isFunction, W = P.isWeakMap, F = P.keys, U = P.rearg, Y = P.toInteger, q = P.toPath, Q = F(_mapping$1.aryMethod), z = { castArray: function(ae) {
    return function() {
      var ne = arguments[0];
      return N(ne) ? ae(cloneArray$1(ne)) : ae.apply(void 0, arguments);
    };
  }, iteratee: function(ae) {
    return function() {
      var ne = arguments[1], K = ae(arguments[0], ne), ce = K.length;
      return y && typeof ne == "number" ? (ne = ne > 2 ? ne - 2 : 1, ce && ce <= ne ? K : baseAry$1(K, ne)) : K;
    };
  }, mixin: function(ae) {
    return function(ne) {
      var K = this;
      if (!V(K))
        return ae(K, Object(ne));
      var ce = [];
      return x(F(ne), function(te) {
        V(ne[te]) && ce.push([te, K.prototype[te]]);
      }), ae(K, Object(ne)), x(ce, function(te) {
        var ue = te[1];
        V(ue) ? K.prototype[te[0]] = ue : delete K.prototype[te[0]];
      }), K;
    };
  }, nthArg: function(ae) {
    return function(ne) {
      var K = ne < 0 ? 1 : Y(ne) + 1;
      return j(ae(ne), K);
    };
  }, rearg: function(ae) {
    return function(ne, K) {
      var ce = K ? K.length : 0;
      return j(ae(ne, K), ce);
    };
  }, runInContext: function(ae) {
    return function(ne) {
      return baseConvert$2(u, ae(ne), p);
    };
  } };
  function H(ae, ne) {
    if (y) {
      var K = _mapping$1.iterateeRearg[ae];
      if (K)
        return function(te, ue) {
          return ie(te, function(J) {
            var fe = ue.length;
            return baseArity$1(U(baseAry$1(J, fe), ue), fe);
          });
        }(ne, K);
      var ce = !m && _mapping$1.iterateeAry[ae];
      if (ce)
        return function(te, ue) {
          return ie(te, function(J) {
            return typeof J == "function" ? baseAry$1(J, ue) : J;
          });
        }(ne, ce);
    }
    return ne;
  }
  function X(ae, ne, K) {
    if (k && (E || !_mapping$1.skipFixed[ae])) {
      var ce = _mapping$1.methodSpread[ae], te = ce && ce.start;
      return te === void 0 ? L(ne, K) : flatSpread$1(ne, te);
    }
    return ne;
  }
  function Z(ae, ne, K) {
    return $ && K > 1 && (R || !_mapping$1.skipRearg[ae]) ? U(ne, _mapping$1.methodRearg[ae] || _mapping$1.aryRearg[K]) : ne;
  }
  function oe(ae, ne) {
    for (var K = -1, ce = (ne = q(ne)).length, te = ce - 1, ue = B(Object(ae)), J = ue; J != null && ++K < ce; ) {
      var fe = ne[K], _e = J[fe];
      _e == null || V(_e) || D(_e) || W(_e) || (J[fe] = B(K == te ? _e : Object(_e))), J = J[fe];
    }
    return ue;
  }
  function ee(ae, ne) {
    var K = _mapping$1.aliasToReal[ae] || ae, ce = _mapping$1.remap[K] || K, te = p;
    return function(ue) {
      var J = m ? O : P, fe = m ? O[ce] : ne, _e = M(M({}, te), ue);
      return baseConvert$2(J, K, fe, _e);
    };
  }
  function ie(ae, ne) {
    return function() {
      var K = arguments.length;
      if (!K)
        return ae();
      for (var ce = Array(K); K--; )
        ce[K] = arguments[K];
      var te = $ ? 0 : K - 1;
      return ce[te] = ne(ce[te]), ae.apply(void 0, ce);
    };
  }
  function de(ae, ne, K) {
    var ce, te = _mapping$1.aliasToReal[ae] || ae, ue = ne, J = z[te];
    return J ? ue = J(ne) : S && (_mapping$1.mutate.array[te] ? ue = wrapImmutable$1(ne, cloneArray$1) : _mapping$1.mutate.object[te] ? ue = wrapImmutable$1(ne, createCloner$1(ne)) : _mapping$1.mutate.set[te] && (ue = wrapImmutable$1(ne, oe))), x(Q, function(fe) {
      return x(_mapping$1.aryMethod[fe], function(_e) {
        if (te == _e) {
          var ye = _mapping$1.methodSpread[te], ke = ye && ye.afterRearg;
          return ce = ke ? X(te, Z(te, ue, fe), fe) : Z(te, X(te, ue, fe), fe), ce = function(we, se, $e) {
            return T || v && $e > 1 ? j(se, $e) : se;
          }(0, ce = H(te, ce), fe), !1;
        }
      }), !ce;
    }), ce || (ce = ue), ce == ne && (ce = T ? j(ce, 1) : function() {
      return ne.apply(this, arguments);
    }), ce.convert = ee(te, ne), ce.placeholder = ne.placeholder = K, ce;
  }
  if (!b)
    return de(l, f, w);
  var pe = f, le = [];
  return x(Q, function(ae) {
    x(_mapping$1.aryMethod[ae], function(ne) {
      var K = pe[_mapping$1.remap[ne] || ne];
      K && le.push([ne, de(ne, K, pe)]);
    });
  }), x(F(pe), function(ae) {
    var ne = pe[ae];
    if (typeof ne == "function") {
      for (var K = le.length; K--; )
        if (le[K][0] == ae)
          return;
      ne.convert = ee(ae, ne), le.push([ae, ne]);
    }
  }), x(le, function(ae) {
    pe[ae[0]] = ae[1];
  }), pe.convert = function(ae) {
    return pe.runInContext.convert(ae)(void 0);
  }, pe.placeholder = pe, x(F(pe), function(ae) {
    x(_mapping$1.realToAlias[ae] || [], function(ne) {
      pe[ne] = pe[ae];
    });
  }), pe;
}
var _baseConvert$1 = baseConvert$2;
function identity$1(u) {
  return u;
}
var identity_1 = identity$1, freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, _freeGlobal = freeGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root$4 = _freeGlobal || freeSelf || Function("return this")(), _root = root$4, Symbol$1$1 = _root.Symbol, _Symbol = Symbol$1$1, objectProto$h = Object.prototype, hasOwnProperty$e = objectProto$h.hasOwnProperty, nativeObjectToString$1 = objectProto$h.toString, symToStringTag$1 = _Symbol ? _Symbol.toStringTag : void 0;
function getRawTag(u) {
  var l = hasOwnProperty$e.call(u, symToStringTag$1), f = u[symToStringTag$1];
  try {
    u[symToStringTag$1] = void 0;
    var p = !0;
  } catch {
  }
  var m = nativeObjectToString$1.call(u);
  return p && (l ? u[symToStringTag$1] = f : delete u[symToStringTag$1]), m;
}
var _getRawTag = getRawTag, objectProto$g = Object.prototype, nativeObjectToString = objectProto$g.toString;
function objectToString(u) {
  return nativeObjectToString.call(u);
}
var _objectToString = objectToString, nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
function baseGetTag$1(u) {
  return u == null ? u === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(u) ? _getRawTag(u) : _objectToString(u);
}
var _baseGetTag = baseGetTag$1;
function isObject$1$1(u) {
  var l = typeof u;
  return u != null && (l == "object" || l == "function");
}
var isObject_1 = isObject$1$1, asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(u) {
  if (!isObject_1(u))
    return !1;
  var l = _baseGetTag(u);
  return l == funcTag$2 || l == genTag$1 || l == asyncTag || l == proxyTag;
}
var isFunction_1 = isFunction, coreJsData = _root["__core-js_shared__"], _coreJsData = coreJsData, maskSrcKey = (uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || ""), uid ? "Symbol(src)_1." + uid : ""), uid;
function isMasked(u) {
  return !!maskSrcKey && maskSrcKey in u;
}
var _isMasked = isMasked, funcProto$2 = Function.prototype, funcToString$2 = funcProto$2.toString;
function toSource(u) {
  if (u != null) {
    try {
      return funcToString$2.call(u);
    } catch {
    }
    try {
      return u + "";
    } catch {
    }
  }
  return "";
}
var _toSource = toSource, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto$1 = Function.prototype, objectProto$f = Object.prototype, funcToString$1 = funcProto$1.toString, hasOwnProperty$d = objectProto$f.hasOwnProperty, reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$d).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(u) {
  return !(!isObject_1(u) || _isMasked(u)) && (isFunction_1(u) ? reIsNative : reIsHostCtor).test(_toSource(u));
}
var _baseIsNative = baseIsNative;
function getValue(u, l) {
  return u == null ? void 0 : u[l];
}
var _getValue = getValue;
function getNative(u, l) {
  var f = _getValue(u, l);
  return _baseIsNative(f) ? f : void 0;
}
var _getNative = getNative, WeakMap$2 = _getNative(_root, "WeakMap"), _WeakMap = WeakMap$2, metaMap$3 = _WeakMap && new _WeakMap(), _metaMap$1 = metaMap$3, baseSetData$3 = _metaMap$1 ? function(u, l) {
  return _metaMap$1.set(u, l), u;
} : identity_1, _baseSetData$1 = baseSetData$3, objectCreate$1 = Object.create, baseCreate$5 = function() {
  function u() {
  }
  return function(l) {
    if (!isObject_1(l))
      return {};
    if (objectCreate$1)
      return objectCreate$1(l);
    u.prototype = l;
    var f = new u();
    return u.prototype = void 0, f;
  };
}(), _baseCreate$1 = baseCreate$5;
function createCtor$5(u) {
  return function() {
    var l = arguments;
    switch (l.length) {
      case 0:
        return new u();
      case 1:
        return new u(l[0]);
      case 2:
        return new u(l[0], l[1]);
      case 3:
        return new u(l[0], l[1], l[2]);
      case 4:
        return new u(l[0], l[1], l[2], l[3]);
      case 5:
        return new u(l[0], l[1], l[2], l[3], l[4]);
      case 6:
        return new u(l[0], l[1], l[2], l[3], l[4], l[5]);
      case 7:
        return new u(l[0], l[1], l[2], l[3], l[4], l[5], l[6]);
    }
    var f = _baseCreate$1(u.prototype), p = u.apply(f, l);
    return isObject_1(p) ? p : f;
  };
}
var _createCtor$1 = createCtor$5, WRAP_BIND_FLAG$5$1 = 1;
function createBind$2(u, l, f) {
  var p = l & WRAP_BIND_FLAG$5$1, m = _createCtor$1(u);
  return function b() {
    return (this && this !== _root && this instanceof b ? m : u).apply(p ? f : this, arguments);
  };
}
var _createBind$1 = createBind$2;
function apply$2(u, l, f) {
  switch (f.length) {
    case 0:
      return u.call(l);
    case 1:
      return u.call(l, f[0]);
    case 2:
      return u.call(l, f[0], f[1]);
    case 3:
      return u.call(l, f[0], f[1], f[2]);
  }
  return u.apply(l, f);
}
var _apply = apply$2, nativeMax$3 = Math.max;
function composeArgs$3(u, l, f, p) {
  for (var m = -1, b = u.length, y = f.length, v = -1, k = l.length, S = nativeMax$3(b - y, 0), $ = Array(k + S), w = !p; ++v < k; )
    $[v] = l[v];
  for (; ++m < y; )
    (w || m < b) && ($[f[m]] = u[m]);
  for (; S--; )
    $[v++] = u[m++];
  return $;
}
var _composeArgs$1 = composeArgs$3, nativeMax$2$1 = Math.max;
function composeArgsRight$3(u, l, f, p) {
  for (var m = -1, b = u.length, y = -1, v = f.length, k = -1, S = l.length, $ = nativeMax$2$1(b - v, 0), w = Array($ + S), T = !p; ++m < $; )
    w[m] = u[m];
  for (var E = m; ++k < S; )
    w[E + k] = l[k];
  for (; ++y < v; )
    (T || m < b) && (w[E + f[y]] = u[m++]);
  return w;
}
var _composeArgsRight$1 = composeArgsRight$3;
function countHolders$2(u, l) {
  for (var f = u.length, p = 0; f--; )
    u[f] === l && ++p;
  return p;
}
var _countHolders$1 = countHolders$2;
function baseLodash$4() {
}
var _baseLodash$1 = baseLodash$4, MAX_ARRAY_LENGTH$1 = 4294967295;
function LazyWrapper$4(u) {
  this.__wrapped__ = u, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = MAX_ARRAY_LENGTH$1, this.__views__ = [];
}
LazyWrapper$4.prototype = _baseCreate$1(_baseLodash$1.prototype), LazyWrapper$4.prototype.constructor = LazyWrapper$4;
var _LazyWrapper$1 = LazyWrapper$4;
function noop$3() {
}
var noop_1$2 = noop$3, getData$3 = _metaMap$1 ? function(u) {
  return _metaMap$1.get(u);
} : noop_1$2, _getData$1 = getData$3, realNames$2 = {}, _realNames$1 = realNames$2, objectProto$e = Object.prototype, hasOwnProperty$c = objectProto$e.hasOwnProperty;
function getFuncName$2(u) {
  for (var l = u.name + "", f = _realNames$1[l], p = hasOwnProperty$c.call(_realNames$1, l) ? f.length : 0; p--; ) {
    var m = f[p], b = m.func;
    if (b == null || b == u)
      return m.name;
  }
  return l;
}
var _getFuncName$1 = getFuncName$2;
function LodashWrapper$3(u, l) {
  this.__wrapped__ = u, this.__actions__ = [], this.__chain__ = !!l, this.__index__ = 0, this.__values__ = void 0;
}
LodashWrapper$3.prototype = _baseCreate$1(_baseLodash$1.prototype), LodashWrapper$3.prototype.constructor = LodashWrapper$3;
var _LodashWrapper$1 = LodashWrapper$3, isArray$5 = Array.isArray, isArray_1 = isArray$5;
function isObjectLike$5(u) {
  return u != null && typeof u == "object";
}
var isObjectLike_1 = isObjectLike$5;
function copyArray$5(u, l) {
  var f = -1, p = u.length;
  for (l || (l = Array(p)); ++f < p; )
    l[f] = u[f];
  return l;
}
var _copyArray$1 = copyArray$5;
function wrapperClone$2(u) {
  if (u instanceof _LazyWrapper$1)
    return u.clone();
  var l = new _LodashWrapper$1(u.__wrapped__, u.__chain__);
  return l.__actions__ = _copyArray$1(u.__actions__), l.__index__ = u.__index__, l.__values__ = u.__values__, l;
}
var _wrapperClone$1 = wrapperClone$2, objectProto$d = Object.prototype, hasOwnProperty$b = objectProto$d.hasOwnProperty;
function lodash$2(u) {
  if (isObjectLike_1(u) && !isArray_1(u) && !(u instanceof _LazyWrapper$1)) {
    if (u instanceof _LodashWrapper$1)
      return u;
    if (hasOwnProperty$b.call(u, "__wrapped__"))
      return _wrapperClone$1(u);
  }
  return new _LodashWrapper$1(u);
}
lodash$2.prototype = _baseLodash$1.prototype, lodash$2.prototype.constructor = lodash$2;
var wrapperLodash$1 = lodash$2;
function isLaziable$2(u) {
  var l = _getFuncName$1(u), f = wrapperLodash$1[l];
  if (typeof f != "function" || !(l in _LazyWrapper$1.prototype))
    return !1;
  if (u === f)
    return !0;
  var p = _getData$1(f);
  return !!p && u === p[0];
}
var _isLaziable$1 = isLaziable$2, HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
function shortOut$1(u) {
  var l = 0, f = 0;
  return function() {
    var p = nativeNow(), m = HOT_SPAN - (p - f);
    if (f = p, m > 0) {
      if (++l >= HOT_COUNT)
        return arguments[0];
    } else
      l = 0;
    return u.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1, setData$3 = _shortOut(_baseSetData$1), _setData$1 = setData$3, reWrapDetails$1 = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails$1 = /,? & /;
function getWrapDetails$2(u) {
  var l = u.match(reWrapDetails$1);
  return l ? l[1].split(reSplitDetails$1) : [];
}
var _getWrapDetails$1 = getWrapDetails$2, reWrapComment$1 = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails$2(u, l) {
  var f = l.length;
  if (!f)
    return u;
  var p = f - 1;
  return l[p] = (f > 1 ? "& " : "") + l[p], l = l.join(f > 2 ? ", " : " "), u.replace(reWrapComment$1, `{
/* [wrapped with ` + l + `] */
`);
}
var _insertWrapDetails$1 = insertWrapDetails$2;
function constant(u) {
  return function() {
    return u;
  };
}
var constant_1 = constant, defineProperty = function() {
  try {
    var u = _getNative(Object, "defineProperty");
    return u({}, "", {}), u;
  } catch {
  }
}(), _defineProperty = defineProperty, baseSetToString = _defineProperty ? function(u, l) {
  return _defineProperty(u, "toString", { configurable: !0, enumerable: !1, value: constant_1(l), writable: !0 });
} : identity_1, _baseSetToString = baseSetToString, setToString$1 = _shortOut(_baseSetToString), _setToString = setToString$1;
function arrayEach$3(u, l) {
  for (var f = -1, p = u == null ? 0 : u.length; ++f < p && l(u[f], f, u) !== !1; )
    ;
  return u;
}
var _arrayEach$1 = arrayEach$3;
function baseFindIndex$2(u, l, f, p) {
  for (var m = u.length, b = f + (p ? 1 : -1); p ? b-- : ++b < m; )
    if (l(u[b], b, u))
      return b;
  return -1;
}
var _baseFindIndex$1 = baseFindIndex$2;
function baseIsNaN$2(u) {
  return u != u;
}
var _baseIsNaN$1 = baseIsNaN$2;
function strictIndexOf$2(u, l, f) {
  for (var p = f - 1, m = u.length; ++p < m; )
    if (u[p] === l)
      return p;
  return -1;
}
var _strictIndexOf$1 = strictIndexOf$2;
function baseIndexOf$2(u, l, f) {
  return l == l ? _strictIndexOf$1(u, l, f) : _baseFindIndex$1(u, _baseIsNaN$1, f);
}
var _baseIndexOf$1 = baseIndexOf$2;
function arrayIncludes$2(u, l) {
  return !!(u != null && u.length) && _baseIndexOf$1(u, l, 0) > -1;
}
var _arrayIncludes$1 = arrayIncludes$2, WRAP_BIND_FLAG$4$1 = 1, WRAP_BIND_KEY_FLAG$3$1 = 2, WRAP_CURRY_FLAG$5$1 = 8, WRAP_CURRY_RIGHT_FLAG$2$1 = 16, WRAP_PARTIAL_FLAG$2$1 = 32, WRAP_PARTIAL_RIGHT_FLAG$2$1 = 64, WRAP_ARY_FLAG$3$1 = 128, WRAP_REARG_FLAG$2$1 = 256, WRAP_FLIP_FLAG$1$1 = 512, wrapFlags$1 = [["ary", WRAP_ARY_FLAG$3$1], ["bind", WRAP_BIND_FLAG$4$1], ["bindKey", WRAP_BIND_KEY_FLAG$3$1], ["curry", WRAP_CURRY_FLAG$5$1], ["curryRight", WRAP_CURRY_RIGHT_FLAG$2$1], ["flip", WRAP_FLIP_FLAG$1$1], ["partial", WRAP_PARTIAL_FLAG$2$1], ["partialRight", WRAP_PARTIAL_RIGHT_FLAG$2$1], ["rearg", WRAP_REARG_FLAG$2$1]];
function updateWrapDetails$2(u, l) {
  return _arrayEach$1(wrapFlags$1, function(f) {
    var p = "_." + f[0];
    l & f[1] && !_arrayIncludes$1(u, p) && u.push(p);
  }), u.sort();
}
var _updateWrapDetails$1 = updateWrapDetails$2;
function setWrapToString$3(u, l, f) {
  var p = l + "";
  return _setToString(u, _insertWrapDetails$1(p, _updateWrapDetails$1(_getWrapDetails$1(p), f)));
}
var _setWrapToString$1 = setWrapToString$3, WRAP_CURRY_BOUND_FLAG$1$1 = 4, WRAP_CURRY_FLAG$4$1 = 8, WRAP_PARTIAL_FLAG$1$1 = 32, WRAP_PARTIAL_RIGHT_FLAG$1$1 = 64;
function createRecurry$3(u, l, f, p, m, b, y, v, k, S) {
  var $ = l & WRAP_CURRY_FLAG$4$1;
  l |= $ ? WRAP_PARTIAL_FLAG$1$1 : WRAP_PARTIAL_RIGHT_FLAG$1$1, (l &= ~($ ? WRAP_PARTIAL_RIGHT_FLAG$1$1 : WRAP_PARTIAL_FLAG$1$1)) & WRAP_CURRY_BOUND_FLAG$1$1 || (l &= -4);
  var w = [u, l, m, $ ? b : void 0, $ ? y : void 0, $ ? void 0 : b, $ ? void 0 : y, v, k, S], T = f.apply(void 0, w);
  return _isLaziable$1(u) && _setData$1(T, w), T.placeholder = p, _setWrapToString$1(T, u, l);
}
var _createRecurry$1 = createRecurry$3;
function getHolder$3(u) {
  return u.placeholder;
}
var _getHolder$1 = getHolder$3, MAX_SAFE_INTEGER$1 = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(u, l) {
  var f = typeof u;
  return !!(l = l ?? MAX_SAFE_INTEGER$1) && (f == "number" || f != "symbol" && reIsUint.test(u)) && u > -1 && u % 1 == 0 && u < l;
}
var _isIndex = isIndex$1, nativeMin$1$1 = Math.min;
function reorder$2(u, l) {
  for (var f = u.length, p = nativeMin$1$1(l.length, f), m = _copyArray$1(u); p--; ) {
    var b = l[p];
    u[p] = _isIndex(b, f) ? m[b] : void 0;
  }
  return u;
}
var _reorder$1 = reorder$2, PLACEHOLDER$1$1 = "__lodash_placeholder__";
function replaceHolders$4(u, l) {
  for (var f = -1, p = u.length, m = 0, b = []; ++f < p; ) {
    var y = u[f];
    y !== l && y !== PLACEHOLDER$1$1 || (u[f] = PLACEHOLDER$1$1, b[m++] = f);
  }
  return b;
}
var _replaceHolders$1 = replaceHolders$4, WRAP_BIND_FLAG$3$1 = 1, WRAP_BIND_KEY_FLAG$2$1 = 2, WRAP_CURRY_FLAG$3$1 = 8, WRAP_CURRY_RIGHT_FLAG$1$1 = 16, WRAP_ARY_FLAG$2$1 = 128, WRAP_FLIP_FLAG$2 = 512;
function createHybrid$3(u, l, f, p, m, b, y, v, k, S) {
  var $ = l & WRAP_ARY_FLAG$2$1, w = l & WRAP_BIND_FLAG$3$1, T = l & WRAP_BIND_KEY_FLAG$2$1, E = l & (WRAP_CURRY_FLAG$3$1 | WRAP_CURRY_RIGHT_FLAG$1$1), R = l & WRAP_FLIP_FLAG$2, O = T ? void 0 : _createCtor$1(u);
  return function P() {
    for (var L = arguments.length, M = Array(L), B = L; B--; )
      M[B] = arguments[B];
    if (E)
      var j = _getHolder$1(P), x = _countHolders$1(M, j);
    if (p && (M = _composeArgs$1(M, p, m, E)), b && (M = _composeArgsRight$1(M, b, y, E)), L -= x, E && L < S) {
      var N = _replaceHolders$1(M, j);
      return _createRecurry$1(u, l, createHybrid$3, P.placeholder, f, M, N, v, k, S - L);
    }
    var D = w ? f : this, V = T ? D[u] : u;
    return L = M.length, v ? M = _reorder$1(M, v) : R && L > 1 && M.reverse(), $ && k < L && (M.length = k), this && this !== _root && this instanceof P && (V = O || _createCtor$1(V)), V.apply(D, M);
  };
}
var _createHybrid$1 = createHybrid$3;
function createCurry$2(u, l, f) {
  var p = _createCtor$1(u);
  return function m() {
    for (var b = arguments.length, y = Array(b), v = b, k = _getHolder$1(m); v--; )
      y[v] = arguments[v];
    var S = b < 3 && y[0] !== k && y[b - 1] !== k ? [] : _replaceHolders$1(y, k);
    return (b -= S.length) < f ? _createRecurry$1(u, l, _createHybrid$1, m.placeholder, void 0, y, S, void 0, void 0, f - b) : _apply(this && this !== _root && this instanceof m ? p : u, this, y);
  };
}
var _createCurry$1 = createCurry$2, WRAP_BIND_FLAG$2$1 = 1;
function createPartial$2(u, l, f, p) {
  var m = l & WRAP_BIND_FLAG$2$1, b = _createCtor$1(u);
  return function y() {
    for (var v = -1, k = arguments.length, S = -1, $ = p.length, w = Array($ + k), T = this && this !== _root && this instanceof y ? b : u; ++S < $; )
      w[S] = p[S];
    for (; k--; )
      w[S++] = arguments[++v];
    return _apply(T, m ? f : this, w);
  };
}
var _createPartial$1 = createPartial$2, PLACEHOLDER$2 = "__lodash_placeholder__", WRAP_BIND_FLAG$1$1 = 1, WRAP_BIND_KEY_FLAG$1$1 = 2, WRAP_CURRY_BOUND_FLAG$2 = 4, WRAP_CURRY_FLAG$2$1 = 8, WRAP_ARY_FLAG$1$1 = 128, WRAP_REARG_FLAG$1$1 = 256, nativeMin$2 = Math.min;
function mergeData$2(u, l) {
  var f = u[1], p = l[1], m = f | p, b = m < (WRAP_BIND_FLAG$1$1 | WRAP_BIND_KEY_FLAG$1$1 | WRAP_ARY_FLAG$1$1), y = p == WRAP_ARY_FLAG$1$1 && f == WRAP_CURRY_FLAG$2$1 || p == WRAP_ARY_FLAG$1$1 && f == WRAP_REARG_FLAG$1$1 && u[7].length <= l[8] || p == (WRAP_ARY_FLAG$1$1 | WRAP_REARG_FLAG$1$1) && l[7].length <= l[8] && f == WRAP_CURRY_FLAG$2$1;
  if (!b && !y)
    return u;
  p & WRAP_BIND_FLAG$1$1 && (u[2] = l[2], m |= f & WRAP_BIND_FLAG$1$1 ? 0 : WRAP_CURRY_BOUND_FLAG$2);
  var v = l[3];
  if (v) {
    var k = u[3];
    u[3] = k ? _composeArgs$1(k, v, l[4]) : v, u[4] = k ? _replaceHolders$1(u[3], PLACEHOLDER$2) : l[4];
  }
  return (v = l[5]) && (k = u[5], u[5] = k ? _composeArgsRight$1(k, v, l[6]) : v, u[6] = k ? _replaceHolders$1(u[5], PLACEHOLDER$2) : l[6]), (v = l[7]) && (u[7] = v), p & WRAP_ARY_FLAG$1$1 && (u[8] = u[8] == null ? l[8] : nativeMin$2(u[8], l[8])), u[9] == null && (u[9] = l[9]), u[0] = l[0], u[1] = m, u;
}
var _mergeData$1 = mergeData$2, reWhitespace$1 = /\s/;
function trimmedEndIndex$2(u) {
  for (var l = u.length; l-- && reWhitespace$1.test(u.charAt(l)); )
    ;
  return l;
}
var _trimmedEndIndex$1 = trimmedEndIndex$2, reTrimStart$1 = /^\s+/;
function baseTrim$2(u) {
  return u && u.slice(0, _trimmedEndIndex$1(u) + 1).replace(reTrimStart$1, "");
}
var _baseTrim$1 = baseTrim$2, symbolTag$3 = "[object Symbol]";
function isSymbol$2(u) {
  return typeof u == "symbol" || isObjectLike_1(u) && _baseGetTag(u) == symbolTag$3;
}
var isSymbol_1 = isSymbol$2, NAN$1 = NaN, reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$1 = /^0b[01]+$/i, reIsOctal$1 = /^0o[0-7]+$/i, freeParseInt$1 = parseInt;
function toNumber$2(u) {
  if (typeof u == "number")
    return u;
  if (isSymbol_1(u))
    return NAN$1;
  if (isObject_1(u)) {
    var l = typeof u.valueOf == "function" ? u.valueOf() : u;
    u = isObject_1(l) ? l + "" : l;
  }
  if (typeof u != "string")
    return u === 0 ? u : +u;
  u = _baseTrim$1(u);
  var f = reIsBinary$1.test(u);
  return f || reIsOctal$1.test(u) ? freeParseInt$1(u.slice(2), f ? 2 : 8) : reIsBadHex$1.test(u) ? NAN$1 : +u;
}
var toNumber_1$1 = toNumber$2, INFINITY$1 = 1 / 0, MAX_INTEGER$1 = 17976931348623157e292;
function toFinite$2(u) {
  return u ? (u = toNumber_1$1(u)) === INFINITY$1 || u === -INFINITY$1 ? (u < 0 ? -1 : 1) * MAX_INTEGER$1 : u == u ? u : 0 : u === 0 ? u : 0;
}
var toFinite_1$1 = toFinite$2;
function toInteger$2(u) {
  var l = toFinite_1$1(u), f = l % 1;
  return l == l ? f ? l - f : l : 0;
}
var toInteger_1$1 = toInteger$2, FUNC_ERROR_TEXT$1 = "Expected a function", WRAP_BIND_FLAG$7 = 1, WRAP_BIND_KEY_FLAG$5 = 2, WRAP_CURRY_FLAG$1$1 = 8, WRAP_CURRY_RIGHT_FLAG$3 = 16, WRAP_PARTIAL_FLAG$3 = 32, WRAP_PARTIAL_RIGHT_FLAG$3 = 64, nativeMax$1$1 = Math.max;
function createWrap$4(u, l, f, p, m, b, y, v) {
  var k = l & WRAP_BIND_KEY_FLAG$5;
  if (!k && typeof u != "function")
    throw new TypeError(FUNC_ERROR_TEXT$1);
  var S = p ? p.length : 0;
  if (S || (l &= -97, p = m = void 0), y = y === void 0 ? y : nativeMax$1$1(toInteger_1$1(y), 0), v = v === void 0 ? v : toInteger_1$1(v), S -= m ? m.length : 0, l & WRAP_PARTIAL_RIGHT_FLAG$3) {
    var $ = p, w = m;
    p = m = void 0;
  }
  var T = k ? void 0 : _getData$1(u), E = [u, l, f, p, m, $, w, b, y, v];
  if (T && _mergeData$1(E, T), u = E[0], l = E[1], f = E[2], p = E[3], m = E[4], !(v = E[9] = E[9] === void 0 ? k ? 0 : u.length : nativeMax$1$1(E[9] - S, 0)) && l & (WRAP_CURRY_FLAG$1$1 | WRAP_CURRY_RIGHT_FLAG$3) && (l &= -25), l && l != WRAP_BIND_FLAG$7)
    R = l == WRAP_CURRY_FLAG$1$1 || l == WRAP_CURRY_RIGHT_FLAG$3 ? _createCurry$1(u, l, v) : l != WRAP_PARTIAL_FLAG$3 && l != (WRAP_BIND_FLAG$7 | WRAP_PARTIAL_FLAG$3) || m.length ? _createHybrid$1.apply(void 0, E) : _createPartial$1(u, l, f, p);
  else
    var R = _createBind$1(u, l, f);
  return _setWrapToString$1((T ? _baseSetData$1 : _setData$1)(R, E), u, l);
}
var _createWrap$1 = createWrap$4, WRAP_ARY_FLAG$4 = 128;
function ary$1(u, l, f) {
  return l = f ? void 0 : l, l = u && l == null ? u.length : l, _createWrap$1(u, WRAP_ARY_FLAG$4, void 0, void 0, void 0, void 0, l);
}
var ary_1$1 = ary$1;
function baseAssignValue$1(u, l, f) {
  l == "__proto__" && _defineProperty ? _defineProperty(u, l, { configurable: !0, enumerable: !0, value: f, writable: !0 }) : u[l] = f;
}
var _baseAssignValue = baseAssignValue$1;
function eq(u, l) {
  return u === l || u != u && l != l;
}
var eq_1 = eq, objectProto$c = Object.prototype, hasOwnProperty$a = objectProto$c.hasOwnProperty;
function assignValue$2(u, l, f) {
  var p = u[l];
  hasOwnProperty$a.call(u, l) && eq_1(p, f) && (f !== void 0 || l in u) || _baseAssignValue(u, l, f);
}
var _assignValue = assignValue$2;
function copyObject$5(u, l, f, p) {
  var m = !f;
  f || (f = {});
  for (var b = -1, y = l.length; ++b < y; ) {
    var v = l[b], k = p ? p(f[v], u[v], v, f, u) : void 0;
    k === void 0 && (k = u[v]), m ? _baseAssignValue(f, v, k) : _assignValue(f, v, k);
  }
  return f;
}
var _copyObject$1 = copyObject$5;
function baseTimes(u, l) {
  for (var f = -1, p = Array(u); ++f < u; )
    p[f] = l(f);
  return p;
}
var _baseTimes = baseTimes, argsTag$3 = "[object Arguments]";
function baseIsArguments(u) {
  return isObjectLike_1(u) && _baseGetTag(u) == argsTag$3;
}
var _baseIsArguments = baseIsArguments, objectProto$b = Object.prototype, hasOwnProperty$9 = objectProto$b.hasOwnProperty, propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable, isArguments = _baseIsArguments(function() {
  return arguments;
}()) ? _baseIsArguments : function(u) {
  return isObjectLike_1(u) && hasOwnProperty$9.call(u, "callee") && !propertyIsEnumerable$1.call(u, "callee");
}, isArguments_1 = isArguments;
function stubFalse() {
  return !1;
}
var stubFalse_1 = stubFalse, isBuffer_1 = createCommonjsModule(function(u, l) {
  var f = l && !l.nodeType && l, p = f && u && !u.nodeType && u, m = p && p.exports === f ? _root.Buffer : void 0, b = (m ? m.isBuffer : void 0) || stubFalse_1;
  u.exports = b;
}), MAX_SAFE_INTEGER = 9007199254740991;
function isLength(u) {
  return typeof u == "number" && u > -1 && u % 1 == 0 && u <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength, argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$3 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$3 = "[object WeakMap]", arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]", typedArrayTags = {};
function baseIsTypedArray(u) {
  return isObjectLike_1(u) && isLength_1(u.length) && !!typedArrayTags[_baseGetTag(u)];
}
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0, typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$3] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$3] = !1;
var _baseIsTypedArray = baseIsTypedArray;
function baseUnary$2(u) {
  return function(l) {
    return u(l);
  };
}
var _baseUnary = baseUnary$2, _nodeUtil = createCommonjsModule(function(u, l) {
  var f = l && !l.nodeType && l, p = f && u && !u.nodeType && u, m = p && p.exports === f && _freeGlobal.process, b = function() {
    try {
      var y = p && p.require && p.require("util").types;
      return y || m && m.binding && m.binding("util");
    } catch {
    }
  }();
  u.exports = b;
}), nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray, isTypedArray_1 = isTypedArray, objectProto$a = Object.prototype, hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function arrayLikeKeys(u, l) {
  var f = isArray_1(u), p = !f && isArguments_1(u), m = !f && !p && isBuffer_1(u), b = !f && !p && !m && isTypedArray_1(u), y = f || p || m || b, v = y ? _baseTimes(u.length, String) : [], k = v.length;
  for (var S in u)
    !l && !hasOwnProperty$8.call(u, S) || y && (S == "length" || m && (S == "offset" || S == "parent") || b && (S == "buffer" || S == "byteLength" || S == "byteOffset") || _isIndex(S, k)) || v.push(S);
  return v;
}
var _arrayLikeKeys = arrayLikeKeys, objectProto$9 = Object.prototype;
function isPrototype$1(u) {
  var l = u && u.constructor;
  return u === (typeof l == "function" && l.prototype || objectProto$9);
}
var _isPrototype = isPrototype$1;
function overArg(u, l) {
  return function(f) {
    return u(l(f));
  };
}
var _overArg = overArg, nativeKeys = _overArg(Object.keys, Object), _nativeKeys = nativeKeys, objectProto$8 = Object.prototype, hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function baseKeys(u) {
  if (!_isPrototype(u))
    return _nativeKeys(u);
  var l = [];
  for (var f in Object(u))
    hasOwnProperty$7.call(u, f) && f != "constructor" && l.push(f);
  return l;
}
var _baseKeys = baseKeys;
function isArrayLike(u) {
  return u != null && isLength_1(u.length) && !isFunction_1(u);
}
var isArrayLike_1 = isArrayLike;
function keys$2(u) {
  return isArrayLike_1(u) ? _arrayLikeKeys(u) : _baseKeys(u);
}
var keys_1 = keys$2;
function baseAssign$2(u, l) {
  return u && _copyObject$1(l, keys_1(l), u);
}
var _baseAssign$1 = baseAssign$2;
function listCacheClear() {
  this.__data__ = [], this.size = 0;
}
var _listCacheClear = listCacheClear;
function assocIndexOf(u, l) {
  for (var f = u.length; f--; )
    if (eq_1(u[f][0], l))
      return f;
  return -1;
}
var _assocIndexOf = assocIndexOf, arrayProto = Array.prototype, splice = arrayProto.splice;
function listCacheDelete(u) {
  var l = this.__data__, f = _assocIndexOf(l, u);
  return !(f < 0) && (f == l.length - 1 ? l.pop() : splice.call(l, f, 1), --this.size, !0);
}
var _listCacheDelete = listCacheDelete;
function listCacheGet(u) {
  var l = this.__data__, f = _assocIndexOf(l, u);
  return f < 0 ? void 0 : l[f][1];
}
var _listCacheGet = listCacheGet;
function listCacheHas(u) {
  return _assocIndexOf(this.__data__, u) > -1;
}
var _listCacheHas = listCacheHas;
function listCacheSet(u, l) {
  var f = this.__data__, p = _assocIndexOf(f, u);
  return p < 0 ? (++this.size, f.push([u, l])) : f[p][1] = l, this;
}
var _listCacheSet = listCacheSet;
function ListCache(u) {
  var l = -1, f = u == null ? 0 : u.length;
  for (this.clear(); ++l < f; ) {
    var p = u[l];
    this.set(p[0], p[1]);
  }
}
ListCache.prototype.clear = _listCacheClear, ListCache.prototype.delete = _listCacheDelete, ListCache.prototype.get = _listCacheGet, ListCache.prototype.has = _listCacheHas, ListCache.prototype.set = _listCacheSet;
var _ListCache = ListCache;
function stackClear() {
  this.__data__ = new _ListCache(), this.size = 0;
}
var _stackClear = stackClear;
function stackDelete(u) {
  var l = this.__data__, f = l.delete(u);
  return this.size = l.size, f;
}
var _stackDelete = stackDelete;
function stackGet(u) {
  return this.__data__.get(u);
}
var _stackGet = stackGet;
function stackHas(u) {
  return this.__data__.has(u);
}
var _stackHas = stackHas, Map$1 = _getNative(_root, "Map"), _Map = Map$1, nativeCreate = _getNative(Object, "create"), _nativeCreate = nativeCreate;
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {}, this.size = 0;
}
var _hashClear = hashClear;
function hashDelete(u) {
  var l = this.has(u) && delete this.__data__[u];
  return this.size -= l ? 1 : 0, l;
}
var _hashDelete = hashDelete, HASH_UNDEFINED$2 = "__lodash_hash_undefined__", objectProto$7 = Object.prototype, hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function hashGet(u) {
  var l = this.__data__;
  if (_nativeCreate) {
    var f = l[u];
    return f === HASH_UNDEFINED$2 ? void 0 : f;
  }
  return hasOwnProperty$6.call(l, u) ? l[u] : void 0;
}
var _hashGet = hashGet, objectProto$6 = Object.prototype, hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function hashHas(u) {
  var l = this.__data__;
  return _nativeCreate ? l[u] !== void 0 : hasOwnProperty$5.call(l, u);
}
var _hashHas = hashHas, HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(u, l) {
  var f = this.__data__;
  return this.size += this.has(u) ? 0 : 1, f[u] = _nativeCreate && l === void 0 ? HASH_UNDEFINED$1 : l, this;
}
var _hashSet = hashSet;
function Hash(u) {
  var l = -1, f = u == null ? 0 : u.length;
  for (this.clear(); ++l < f; ) {
    var p = u[l];
    this.set(p[0], p[1]);
  }
}
Hash.prototype.clear = _hashClear, Hash.prototype.delete = _hashDelete, Hash.prototype.get = _hashGet, Hash.prototype.has = _hashHas, Hash.prototype.set = _hashSet;
var _Hash = Hash;
function mapCacheClear() {
  this.size = 0, this.__data__ = { hash: new _Hash(), map: new (_Map || _ListCache)(), string: new _Hash() };
}
var _mapCacheClear = mapCacheClear;
function isKeyable(u) {
  var l = typeof u;
  return l == "string" || l == "number" || l == "symbol" || l == "boolean" ? u !== "__proto__" : u === null;
}
var _isKeyable = isKeyable;
function getMapData(u, l) {
  var f = u.__data__;
  return _isKeyable(l) ? f[typeof l == "string" ? "string" : "hash"] : f.map;
}
var _getMapData = getMapData;
function mapCacheDelete(u) {
  var l = _getMapData(this, u).delete(u);
  return this.size -= l ? 1 : 0, l;
}
var _mapCacheDelete = mapCacheDelete;
function mapCacheGet(u) {
  return _getMapData(this, u).get(u);
}
var _mapCacheGet = mapCacheGet;
function mapCacheHas(u) {
  return _getMapData(this, u).has(u);
}
var _mapCacheHas = mapCacheHas;
function mapCacheSet(u, l) {
  var f = _getMapData(this, u), p = f.size;
  return f.set(u, l), this.size += f.size == p ? 0 : 1, this;
}
var _mapCacheSet = mapCacheSet;
function MapCache(u) {
  var l = -1, f = u == null ? 0 : u.length;
  for (this.clear(); ++l < f; ) {
    var p = u[l];
    this.set(p[0], p[1]);
  }
}
MapCache.prototype.clear = _mapCacheClear, MapCache.prototype.delete = _mapCacheDelete, MapCache.prototype.get = _mapCacheGet, MapCache.prototype.has = _mapCacheHas, MapCache.prototype.set = _mapCacheSet;
var _MapCache = MapCache, LARGE_ARRAY_SIZE = 200;
function stackSet(u, l) {
  var f = this.__data__;
  if (f instanceof _ListCache) {
    var p = f.__data__;
    if (!_Map || p.length < LARGE_ARRAY_SIZE - 1)
      return p.push([u, l]), this.size = ++f.size, this;
    f = this.__data__ = new _MapCache(p);
  }
  return f.set(u, l), this.size = f.size, this;
}
var _stackSet = stackSet;
function Stack$1(u) {
  var l = this.__data__ = new _ListCache(u);
  this.size = l.size;
}
Stack$1.prototype.clear = _stackClear, Stack$1.prototype.delete = _stackDelete, Stack$1.prototype.get = _stackGet, Stack$1.prototype.has = _stackHas, Stack$1.prototype.set = _stackSet;
var _Stack = Stack$1;
function nativeKeysIn(u) {
  var l = [];
  if (u != null)
    for (var f in Object(u))
      l.push(f);
  return l;
}
var _nativeKeysIn = nativeKeysIn, objectProto$5 = Object.prototype, hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function baseKeysIn(u) {
  if (!isObject_1(u))
    return _nativeKeysIn(u);
  var l = _isPrototype(u), f = [];
  for (var p in u)
    (p != "constructor" || !l && hasOwnProperty$4.call(u, p)) && f.push(p);
  return f;
}
var _baseKeysIn = baseKeysIn;
function keysIn$2(u) {
  return isArrayLike_1(u) ? _arrayLikeKeys(u, !0) : _baseKeysIn(u);
}
var keysIn_1 = keysIn$2;
function baseAssignIn$2(u, l) {
  return u && _copyObject$1(l, keysIn_1(l), u);
}
var _baseAssignIn$1 = baseAssignIn$2, _cloneBuffer$1 = createCommonjsModule(function(u, l) {
  var f = l && !l.nodeType && l, p = f && u && !u.nodeType && u, m = p && p.exports === f ? _root.Buffer : void 0, b = m ? m.allocUnsafe : void 0;
  u.exports = function(y, v) {
    if (v)
      return y.slice();
    var k = y.length, S = b ? b(k) : new y.constructor(k);
    return y.copy(S), S;
  };
});
function arrayFilter(u, l) {
  for (var f = -1, p = u == null ? 0 : u.length, m = 0, b = []; ++f < p; ) {
    var y = u[f];
    l(y, f, u) && (b[m++] = y);
  }
  return b;
}
var _arrayFilter = arrayFilter;
function stubArray() {
  return [];
}
var stubArray_1 = stubArray, objectProto$4 = Object.prototype, propertyIsEnumerable = objectProto$4.propertyIsEnumerable, nativeGetSymbols$1 = Object.getOwnPropertySymbols, getSymbols$1 = nativeGetSymbols$1 ? function(u) {
  return u == null ? [] : (u = Object(u), _arrayFilter(nativeGetSymbols$1(u), function(l) {
    return propertyIsEnumerable.call(u, l);
  }));
} : stubArray_1, _getSymbols = getSymbols$1;
function copySymbols$2(u, l) {
  return _copyObject$1(u, _getSymbols(u), l);
}
var _copySymbols$1 = copySymbols$2;
function arrayPush(u, l) {
  for (var f = -1, p = l.length, m = u.length; ++f < p; )
    u[m + f] = l[f];
  return u;
}
var _arrayPush = arrayPush, getPrototype$1 = _overArg(Object.getPrototypeOf, Object), _getPrototype = getPrototype$1, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbolsIn$1 = nativeGetSymbols ? function(u) {
  for (var l = []; u; )
    _arrayPush(l, _getSymbols(u)), u = _getPrototype(u);
  return l;
} : stubArray_1, _getSymbolsIn = getSymbolsIn$1;
function copySymbolsIn$2(u, l) {
  return _copyObject$1(u, _getSymbolsIn(u), l);
}
var _copySymbolsIn$1 = copySymbolsIn$2;
function baseGetAllKeys(u, l, f) {
  var p = l(u);
  return isArray_1(u) ? p : _arrayPush(p, f(u));
}
var _baseGetAllKeys = baseGetAllKeys;
function getAllKeys$1(u) {
  return _baseGetAllKeys(u, keys_1, _getSymbols);
}
var _getAllKeys = getAllKeys$1;
function getAllKeysIn$1(u) {
  return _baseGetAllKeys(u, keysIn_1, _getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1, DataView$1 = _getNative(_root, "DataView"), _DataView = DataView$1, Promise$1 = _getNative(_root, "Promise"), _Promise = Promise$1, Set$1 = _getNative(_root, "Set"), _Set = Set$1, mapTag$4 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$2 = "[object WeakMap]", dataViewTag$3 = "[object DataView]", dataViewCtorString = _toSource(_DataView), mapCtorString = _toSource(_Map), promiseCtorString = _toSource(_Promise), setCtorString = _toSource(_Set), weakMapCtorString = _toSource(_WeakMap), getTag$4 = _baseGetTag;
(_DataView && getTag$4(new _DataView(new ArrayBuffer(1))) != dataViewTag$3 || _Map && getTag$4(new _Map()) != mapTag$4 || _Promise && getTag$4(_Promise.resolve()) != promiseTag || _Set && getTag$4(new _Set()) != setTag$4 || _WeakMap && getTag$4(new _WeakMap()) != weakMapTag$2) && (getTag$4 = function(u) {
  var l = _baseGetTag(u), f = l == objectTag$3 ? u.constructor : void 0, p = f ? _toSource(f) : "";
  if (p)
    switch (p) {
      case dataViewCtorString:
        return dataViewTag$3;
      case mapCtorString:
        return mapTag$4;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag$4;
      case weakMapCtorString:
        return weakMapTag$2;
    }
  return l;
});
var _getTag = getTag$4, objectProto$3 = Object.prototype, hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function initCloneArray$2(u) {
  var l = u.length, f = new u.constructor(l);
  return l && typeof u[0] == "string" && hasOwnProperty$3.call(u, "index") && (f.index = u.index, f.input = u.input), f;
}
var _initCloneArray$1 = initCloneArray$2, Uint8Array$1$1 = _root.Uint8Array, _Uint8Array = Uint8Array$1$1;
function cloneArrayBuffer$4(u) {
  var l = new u.constructor(u.byteLength);
  return new _Uint8Array(l).set(new _Uint8Array(u)), l;
}
var _cloneArrayBuffer$1 = cloneArrayBuffer$4;
function cloneDataView$2(u, l) {
  var f = l ? _cloneArrayBuffer$1(u.buffer) : u.buffer;
  return new u.constructor(f, u.byteOffset, u.byteLength);
}
var _cloneDataView$1 = cloneDataView$2, reFlags$1 = /\w*$/;
function cloneRegExp$2(u) {
  var l = new u.constructor(u.source, reFlags$1.exec(u));
  return l.lastIndex = u.lastIndex, l;
}
var _cloneRegExp$1 = cloneRegExp$2, symbolProto$2 = _Symbol ? _Symbol.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function cloneSymbol$2(u) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(u)) : {};
}
var _cloneSymbol$1 = cloneSymbol$2;
function cloneTypedArray$2(u, l) {
  var f = l ? _cloneArrayBuffer$1(u.buffer) : u.buffer;
  return new u.constructor(f, u.byteOffset, u.length);
}
var _cloneTypedArray$1 = cloneTypedArray$2, boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]", arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1$1 = "[object Float32Array]", float64Tag$1$1 = "[object Float64Array]", int8Tag$1$1 = "[object Int8Array]", int16Tag$1$1 = "[object Int16Array]", int32Tag$1$1 = "[object Int32Array]", uint8Tag$1$1 = "[object Uint8Array]", uint8ClampedTag$1$1 = "[object Uint8ClampedArray]", uint16Tag$1$1 = "[object Uint16Array]", uint32Tag$1$1 = "[object Uint32Array]";
function initCloneByTag$2(u, l, f) {
  var p = u.constructor;
  switch (l) {
    case arrayBufferTag$2:
      return _cloneArrayBuffer$1(u);
    case boolTag$2:
    case dateTag$2:
      return new p(+u);
    case dataViewTag$2:
      return _cloneDataView$1(u, f);
    case float32Tag$1$1:
    case float64Tag$1$1:
    case int8Tag$1$1:
    case int16Tag$1$1:
    case int32Tag$1$1:
    case uint8Tag$1$1:
    case uint8ClampedTag$1$1:
    case uint16Tag$1$1:
    case uint32Tag$1$1:
      return _cloneTypedArray$1(u, f);
    case mapTag$3:
      return new p();
    case numberTag$2:
    case stringTag$2:
      return new p(u);
    case regexpTag$2:
      return _cloneRegExp$1(u);
    case setTag$3:
      return new p();
    case symbolTag$2:
      return _cloneSymbol$1(u);
  }
}
var _initCloneByTag$1 = initCloneByTag$2;
function initCloneObject$2(u) {
  return typeof u.constructor != "function" || _isPrototype(u) ? {} : _baseCreate$1(_getPrototype(u));
}
var _initCloneObject$1 = initCloneObject$2, mapTag$2$1 = "[object Map]";
function baseIsMap$2(u) {
  return isObjectLike_1(u) && _getTag(u) == mapTag$2$1;
}
var _baseIsMap$1 = baseIsMap$2, nodeIsMap$1 = _nodeUtil && _nodeUtil.isMap, isMap$2 = nodeIsMap$1 ? _baseUnary(nodeIsMap$1) : _baseIsMap$1, isMap_1$1 = isMap$2, setTag$2$1 = "[object Set]";
function baseIsSet$2(u) {
  return isObjectLike_1(u) && _getTag(u) == setTag$2$1;
}
var _baseIsSet$1 = baseIsSet$2, nodeIsSet$1 = _nodeUtil && _nodeUtil.isSet, isSet$2 = nodeIsSet$1 ? _baseUnary(nodeIsSet$1) : _baseIsSet$1, isSet_1$1 = isSet$2, CLONE_DEEP_FLAG$2$1 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2$1 = 4, argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1$1 = "[object Boolean]", dateTag$1$1 = "[object Date]", errorTag$2 = "[object Error]", funcTag$3 = "[object Function]", genTag$2 = "[object GeneratorFunction]", mapTag$1$1 = "[object Map]", numberTag$1$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1$1 = "[object RegExp]", setTag$1$1 = "[object Set]", stringTag$1$1 = "[object String]", symbolTag$1$1 = "[object Symbol]", weakMapTag$1$1 = "[object WeakMap]", arrayBufferTag$1$1 = "[object ArrayBuffer]", dataViewTag$1$1 = "[object DataView]", float32Tag$3 = "[object Float32Array]", float64Tag$3 = "[object Float64Array]", int8Tag$3 = "[object Int8Array]", int16Tag$3 = "[object Int16Array]", int32Tag$3 = "[object Int32Array]", uint8Tag$3 = "[object Uint8Array]", uint8ClampedTag$3 = "[object Uint8ClampedArray]", uint16Tag$3 = "[object Uint16Array]", uint32Tag$3 = "[object Uint32Array]", cloneableTags$1 = {};
function baseClone$4(u, l, f, p, m, b) {
  var y, v = l & CLONE_DEEP_FLAG$2$1, k = l & CLONE_FLAT_FLAG$1, S = l & CLONE_SYMBOLS_FLAG$2$1;
  if (f && (y = m ? f(u, p, m, b) : f(u)), y !== void 0)
    return y;
  if (!isObject_1(u))
    return u;
  var $ = isArray_1(u);
  if ($) {
    if (y = _initCloneArray$1(u), !v)
      return _copyArray$1(u, y);
  } else {
    var w = _getTag(u), T = w == funcTag$3 || w == genTag$2;
    if (isBuffer_1(u))
      return _cloneBuffer$1(u, v);
    if (w == objectTag$2 || w == argsTag$1 || T && !m) {
      if (y = k || T ? {} : _initCloneObject$1(u), !v)
        return k ? _copySymbolsIn$1(u, _baseAssignIn$1(y, u)) : _copySymbols$1(u, _baseAssign$1(y, u));
    } else {
      if (!cloneableTags$1[w])
        return m ? u : {};
      y = _initCloneByTag$1(u, w, v);
    }
  }
  b || (b = new _Stack());
  var E = b.get(u);
  if (E)
    return E;
  b.set(u, y), isSet_1$1(u) ? u.forEach(function(O) {
    y.add(baseClone$4(O, l, f, O, u, b));
  }) : isMap_1$1(u) && u.forEach(function(O, P) {
    y.set(P, baseClone$4(O, l, f, P, u, b));
  });
  var R = $ ? void 0 : (S ? k ? _getAllKeysIn : _getAllKeys : k ? keysIn_1 : keys_1)(u);
  return _arrayEach$1(R || u, function(O, P) {
    R && (O = u[P = O]), _assignValue(y, P, baseClone$4(O, l, f, P, u, b));
  }), y;
}
cloneableTags$1[argsTag$1] = cloneableTags$1[arrayTag$1] = cloneableTags$1[arrayBufferTag$1$1] = cloneableTags$1[dataViewTag$1$1] = cloneableTags$1[boolTag$1$1] = cloneableTags$1[dateTag$1$1] = cloneableTags$1[float32Tag$3] = cloneableTags$1[float64Tag$3] = cloneableTags$1[int8Tag$3] = cloneableTags$1[int16Tag$3] = cloneableTags$1[int32Tag$3] = cloneableTags$1[mapTag$1$1] = cloneableTags$1[numberTag$1$1] = cloneableTags$1[objectTag$2] = cloneableTags$1[regexpTag$1$1] = cloneableTags$1[setTag$1$1] = cloneableTags$1[stringTag$1$1] = cloneableTags$1[symbolTag$1$1] = cloneableTags$1[uint8Tag$3] = cloneableTags$1[uint8ClampedTag$3] = cloneableTags$1[uint16Tag$3] = cloneableTags$1[uint32Tag$3] = !0, cloneableTags$1[errorTag$2] = cloneableTags$1[funcTag$3] = cloneableTags$1[weakMapTag$1$1] = !1;
var _baseClone$1 = baseClone$4, CLONE_SYMBOLS_FLAG$1$1 = 4;
function clone$1(u) {
  return _baseClone$1(u, CLONE_SYMBOLS_FLAG$1$1);
}
var clone_1$1 = clone$1, WRAP_CURRY_FLAG$6 = 8;
function curry$1(u, l, f) {
  var p = _createWrap$1(u, WRAP_CURRY_FLAG$6, void 0, void 0, void 0, void 0, void 0, l = f ? void 0 : l);
  return p.placeholder = curry$1.placeholder, p;
}
curry$1.placeholder = {};
var curry_1$1 = curry$1, objectTag$1 = "[object Object]", funcProto = Function.prototype, objectProto$2$1 = Object.prototype, funcToString = funcProto.toString, hasOwnProperty$2$1 = objectProto$2$1.hasOwnProperty, objectCtorString = funcToString.call(Object);
function isPlainObject$1(u) {
  if (!isObjectLike_1(u) || _baseGetTag(u) != objectTag$1)
    return !1;
  var l = _getPrototype(u);
  if (l === null)
    return !0;
  var f = hasOwnProperty$2$1.call(l, "constructor") && l.constructor;
  return typeof f == "function" && f instanceof f && funcToString.call(f) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$1, domExcTag$1 = "[object DOMException]", errorTag$1$1 = "[object Error]";
function isError$3(u) {
  if (!isObjectLike_1(u))
    return !1;
  var l = _baseGetTag(u);
  return l == errorTag$1$1 || l == domExcTag$1 || typeof u.message == "string" && typeof u.name == "string" && !isPlainObject_1(u);
}
var isError_1$1 = isError$3, weakMapTag$4 = "[object WeakMap]";
function isWeakMap$1(u) {
  return isObjectLike_1(u) && _getTag(u) == weakMapTag$4;
}
var isWeakMap_1$1 = isWeakMap$1, HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(u) {
  return this.__data__.set(u, HASH_UNDEFINED), this;
}
var _setCacheAdd = setCacheAdd;
function setCacheHas(u) {
  return this.__data__.has(u);
}
var _setCacheHas = setCacheHas;
function SetCache(u) {
  var l = -1, f = u == null ? 0 : u.length;
  for (this.__data__ = new _MapCache(); ++l < f; )
    this.add(u[l]);
}
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd, SetCache.prototype.has = _setCacheHas;
var _SetCache = SetCache;
function arraySome(u, l) {
  for (var f = -1, p = u == null ? 0 : u.length; ++f < p; )
    if (l(u[f], f, u))
      return !0;
  return !1;
}
var _arraySome = arraySome;
function cacheHas(u, l) {
  return u.has(l);
}
var _cacheHas = cacheHas, COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(u, l, f, p, m, b) {
  var y = f & COMPARE_PARTIAL_FLAG$5, v = u.length, k = l.length;
  if (v != k && !(y && k > v))
    return !1;
  var S = b.get(u), $ = b.get(l);
  if (S && $)
    return S == l && $ == u;
  var w = -1, T = !0, E = f & COMPARE_UNORDERED_FLAG$3 ? new _SetCache() : void 0;
  for (b.set(u, l), b.set(l, u); ++w < v; ) {
    var R = u[w], O = l[w];
    if (p)
      var P = y ? p(O, R, w, l, u, b) : p(R, O, w, u, l, b);
    if (P !== void 0) {
      if (P)
        continue;
      T = !1;
      break;
    }
    if (E) {
      if (!_arraySome(l, function(L, M) {
        if (!_cacheHas(E, M) && (R === L || m(R, L, f, p, b)))
          return E.push(M);
      })) {
        T = !1;
        break;
      }
    } else if (R !== O && !m(R, O, f, p, b)) {
      T = !1;
      break;
    }
  }
  return b.delete(u), b.delete(l), T;
}
var _equalArrays = equalArrays;
function mapToArray(u) {
  var l = -1, f = Array(u.size);
  return u.forEach(function(p, m) {
    f[++l] = [m, p];
  }), f;
}
var _mapToArray = mapToArray;
function setToArray(u) {
  var l = -1, f = Array(u.size);
  return u.forEach(function(p) {
    f[++l] = p;
  }), f;
}
var _setToArray = setToArray, COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2, boolTag$4 = "[object Boolean]", dateTag$4 = "[object Date]", errorTag$4 = "[object Error]", mapTag$6 = "[object Map]", numberTag$4 = "[object Number]", regexpTag$4 = "[object RegExp]", setTag$6 = "[object Set]", stringTag$4 = "[object String]", symbolTag$4 = "[object Symbol]", arrayBufferTag$4 = "[object ArrayBuffer]", dataViewTag$5 = "[object DataView]", symbolProto$1 = _Symbol ? _Symbol.prototype : void 0, symbolValueOf$2 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag(u, l, f, p, m, b, y) {
  switch (f) {
    case dataViewTag$5:
      if (u.byteLength != l.byteLength || u.byteOffset != l.byteOffset)
        return !1;
      u = u.buffer, l = l.buffer;
    case arrayBufferTag$4:
      return !(u.byteLength != l.byteLength || !b(new _Uint8Array(u), new _Uint8Array(l)));
    case boolTag$4:
    case dateTag$4:
    case numberTag$4:
      return eq_1(+u, +l);
    case errorTag$4:
      return u.name == l.name && u.message == l.message;
    case regexpTag$4:
    case stringTag$4:
      return u == l + "";
    case mapTag$6:
      var v = _mapToArray;
    case setTag$6:
      var k = p & COMPARE_PARTIAL_FLAG$4;
      if (v || (v = _setToArray), u.size != l.size && !k)
        return !1;
      var S = y.get(u);
      if (S)
        return S == l;
      p |= COMPARE_UNORDERED_FLAG$2, y.set(u, l);
      var $ = _equalArrays(v(u), v(l), p, m, b, y);
      return y.delete(u), $;
    case symbolTag$4:
      if (symbolValueOf$2)
        return symbolValueOf$2.call(u) == symbolValueOf$2.call(l);
  }
  return !1;
}
var _equalByTag = equalByTag, COMPARE_PARTIAL_FLAG$3 = 1, objectProto$1$1 = Object.prototype, hasOwnProperty$1$1 = objectProto$1$1.hasOwnProperty;
function equalObjects(u, l, f, p, m, b) {
  var y = f & COMPARE_PARTIAL_FLAG$3, v = _getAllKeys(u), k = v.length;
  if (k != _getAllKeys(l).length && !y)
    return !1;
  for (var S = k; S--; ) {
    var $ = v[S];
    if (!(y ? $ in l : hasOwnProperty$1$1.call(l, $)))
      return !1;
  }
  var w = b.get(u), T = b.get(l);
  if (w && T)
    return w == l && T == u;
  var E = !0;
  b.set(u, l), b.set(l, u);
  for (var R = y; ++S < k; ) {
    var O = u[$ = v[S]], P = l[$];
    if (p)
      var L = y ? p(P, O, $, l, u, b) : p(O, P, $, u, l, b);
    if (!(L === void 0 ? O === P || m(O, P, f, p, b) : L)) {
      E = !1;
      break;
    }
    R || (R = $ == "constructor");
  }
  if (E && !R) {
    var M = u.constructor, B = l.constructor;
    M == B || !("constructor" in u) || !("constructor" in l) || typeof M == "function" && M instanceof M && typeof B == "function" && B instanceof B || (E = !1);
  }
  return b.delete(u), b.delete(l), E;
}
var _equalObjects = equalObjects, COMPARE_PARTIAL_FLAG$2 = 1, argsTag$4 = "[object Arguments]", arrayTag$3 = "[object Array]", objectTag$5 = "[object Object]", objectProto$i = Object.prototype, hasOwnProperty$h = objectProto$i.hasOwnProperty;
function baseIsEqualDeep(u, l, f, p, m, b) {
  var y = isArray_1(u), v = isArray_1(l), k = y ? arrayTag$3 : _getTag(u), S = v ? arrayTag$3 : _getTag(l), $ = (k = k == argsTag$4 ? objectTag$5 : k) == objectTag$5, w = (S = S == argsTag$4 ? objectTag$5 : S) == objectTag$5, T = k == S;
  if (T && isBuffer_1(u)) {
    if (!isBuffer_1(l))
      return !1;
    y = !0, $ = !1;
  }
  if (T && !$)
    return b || (b = new _Stack()), y || isTypedArray_1(u) ? _equalArrays(u, l, f, p, m, b) : _equalByTag(u, l, k, f, p, m, b);
  if (!(f & COMPARE_PARTIAL_FLAG$2)) {
    var E = $ && hasOwnProperty$h.call(u, "__wrapped__"), R = w && hasOwnProperty$h.call(l, "__wrapped__");
    if (E || R) {
      var O = E ? u.value() : u, P = R ? l.value() : l;
      return b || (b = new _Stack()), m(O, P, f, p, b);
    }
  }
  return !!T && (b || (b = new _Stack()), _equalObjects(u, l, f, p, m, b));
}
var _baseIsEqualDeep = baseIsEqualDeep;
function baseIsEqual(u, l, f, p, m) {
  return u === l || (u == null || l == null || !isObjectLike_1(u) && !isObjectLike_1(l) ? u != u && l != l : _baseIsEqualDeep(u, l, f, p, baseIsEqual, m));
}
var _baseIsEqual = baseIsEqual, COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(u, l, f, p) {
  var m = f.length, b = m, y = !p;
  if (u == null)
    return !b;
  for (u = Object(u); m--; ) {
    var v = f[m];
    if (y && v[2] ? v[1] !== u[v[0]] : !(v[0] in u))
      return !1;
  }
  for (; ++m < b; ) {
    var k = (v = f[m])[0], S = u[k], $ = v[1];
    if (y && v[2]) {
      if (S === void 0 && !(k in u))
        return !1;
    } else {
      var w = new _Stack();
      if (p)
        var T = p(S, $, k, u, l, w);
      if (!(T === void 0 ? _baseIsEqual($, S, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, p, w) : T))
        return !1;
    }
  }
  return !0;
}
var _baseIsMatch = baseIsMatch;
function isStrictComparable(u) {
  return u == u && !isObject_1(u);
}
var _isStrictComparable = isStrictComparable;
function getMatchData(u) {
  for (var l = keys_1(u), f = l.length; f--; ) {
    var p = l[f], m = u[p];
    l[f] = [p, m, _isStrictComparable(m)];
  }
  return l;
}
var _getMatchData = getMatchData;
function matchesStrictComparable(u, l) {
  return function(f) {
    return f != null && f[u] === l && (l !== void 0 || u in Object(f));
  };
}
var _matchesStrictComparable = matchesStrictComparable;
function baseMatches(u) {
  var l = _getMatchData(u);
  return l.length == 1 && l[0][2] ? _matchesStrictComparable(l[0][0], l[0][1]) : function(f) {
    return f === u || _baseIsMatch(f, u, l);
  };
}
var _baseMatches = baseMatches, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(u, l) {
  if (isArray_1(u))
    return !1;
  var f = typeof u;
  return !(f != "number" && f != "symbol" && f != "boolean" && u != null && !isSymbol_1(u)) || reIsPlainProp.test(u) || !reIsDeepProp.test(u) || l != null && u in Object(l);
}
var _isKey = isKey, FUNC_ERROR_TEXT$2 = "Expected a function";
function memoize(u, l) {
  if (typeof u != "function" || l != null && typeof l != "function")
    throw new TypeError(FUNC_ERROR_TEXT$2);
  var f = function() {
    var p = arguments, m = l ? l.apply(this, p) : p[0], b = f.cache;
    if (b.has(m))
      return b.get(m);
    var y = u.apply(this, p);
    return f.cache = b.set(m, y) || b, y;
  };
  return f.cache = new (memoize.Cache || _MapCache)(), f;
}
memoize.Cache = _MapCache;
var memoize_1 = memoize, MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(u) {
  var l = memoize_1(u, function(p) {
    return f.size === MAX_MEMOIZE_SIZE && f.clear(), p;
  }), f = l.cache;
  return l;
}
var _memoizeCapped = memoizeCapped, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar = /\\(\\)?/g, stringToPath$1 = _memoizeCapped(function(u) {
  var l = [];
  return u.charCodeAt(0) === 46 && l.push(""), u.replace(rePropName, function(f, p, m, b) {
    l.push(m ? b.replace(reEscapeChar, "$1") : p || f);
  }), l;
}), _stringToPath = stringToPath$1;
function arrayMap$1(u, l) {
  for (var f = -1, p = u == null ? 0 : u.length, m = Array(p); ++f < p; )
    m[f] = l(u[f], f, u);
  return m;
}
var _arrayMap = arrayMap$1, symbolProto$3 = _Symbol ? _Symbol.prototype : void 0, symbolToString = symbolProto$3 ? symbolProto$3.toString : void 0;
function baseToString(u) {
  if (typeof u == "string")
    return u;
  if (isArray_1(u))
    return _arrayMap(u, baseToString) + "";
  if (isSymbol_1(u))
    return symbolToString ? symbolToString.call(u) : "";
  var l = u + "";
  return l == "0" && 1 / u == -1 / 0 ? "-0" : l;
}
var _baseToString = baseToString;
function toString$4(u) {
  return u == null ? "" : _baseToString(u);
}
var toString_1 = toString$4;
function castPath(u, l) {
  return isArray_1(u) ? u : _isKey(u, l) ? [u] : _stringToPath(toString_1(u));
}
var _castPath = castPath;
function toKey$1(u) {
  if (typeof u == "string" || isSymbol_1(u))
    return u;
  var l = u + "";
  return l == "0" && 1 / u == -1 / 0 ? "-0" : l;
}
var _toKey = toKey$1;
function baseGet(u, l) {
  for (var f = 0, p = (l = _castPath(l, u)).length; u != null && f < p; )
    u = u[_toKey(l[f++])];
  return f && f == p ? u : void 0;
}
var _baseGet = baseGet;
function get$1(u, l, f) {
  var p = u == null ? void 0 : _baseGet(u, l);
  return p === void 0 ? f : p;
}
var get_1 = get$1;
function baseHasIn(u, l) {
  return u != null && l in Object(u);
}
var _baseHasIn = baseHasIn;
function hasPath(u, l, f) {
  for (var p = -1, m = (l = _castPath(l, u)).length, b = !1; ++p < m; ) {
    var y = _toKey(l[p]);
    if (!(b = u != null && f(u, y)))
      break;
    u = u[y];
  }
  return b || ++p != m ? b : !!(m = u == null ? 0 : u.length) && isLength_1(m) && _isIndex(y, m) && (isArray_1(u) || isArguments_1(u));
}
var _hasPath = hasPath;
function hasIn(u, l) {
  return u != null && _hasPath(u, l, _baseHasIn);
}
var hasIn_1 = hasIn, COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(u, l) {
  return _isKey(u) && _isStrictComparable(l) ? _matchesStrictComparable(_toKey(u), l) : function(f) {
    var p = get_1(f, u);
    return p === void 0 && p === l ? hasIn_1(f, u) : _baseIsEqual(l, p, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty;
function baseProperty(u) {
  return function(l) {
    return l == null ? void 0 : l[u];
  };
}
var _baseProperty = baseProperty;
function basePropertyDeep(u) {
  return function(l) {
    return _baseGet(l, u);
  };
}
var _basePropertyDeep = basePropertyDeep;
function property(u) {
  return _isKey(u) ? _baseProperty(_toKey(u)) : _basePropertyDeep(u);
}
var property_1 = property;
function baseIteratee$1(u) {
  return typeof u == "function" ? u : u == null ? identity_1 : typeof u == "object" ? isArray_1(u) ? _baseMatchesProperty(u[0], u[1]) : _baseMatches(u) : property_1(u);
}
var _baseIteratee = baseIteratee$1, CLONE_DEEP_FLAG$1$1 = 1;
function iteratee$1(u) {
  return _baseIteratee(typeof u == "function" ? u : _baseClone$1(u, CLONE_DEEP_FLAG$1$1));
}
var iteratee_1$1 = iteratee$1, spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : void 0;
function isFlattenable(u) {
  return isArray_1(u) || isArguments_1(u) || !!(spreadableSymbol && u && u[spreadableSymbol]);
}
var _isFlattenable = isFlattenable;
function baseFlatten(u, l, f, p, m) {
  var b = -1, y = u.length;
  for (f || (f = _isFlattenable), m || (m = []); ++b < y; ) {
    var v = u[b];
    l > 0 && f(v) ? l > 1 ? baseFlatten(v, l - 1, f, p, m) : _arrayPush(m, v) : p || (m[m.length] = v);
  }
  return m;
}
var _baseFlatten = baseFlatten;
function flatten(u) {
  return u != null && u.length ? _baseFlatten(u, 1) : [];
}
var flatten_1 = flatten, nativeMax$4 = Math.max;
function overRest(u, l, f) {
  return l = nativeMax$4(l === void 0 ? u.length - 1 : l, 0), function() {
    for (var p = arguments, m = -1, b = nativeMax$4(p.length - l, 0), y = Array(b); ++m < b; )
      y[m] = p[l + m];
    m = -1;
    for (var v = Array(l + 1); ++m < l; )
      v[m] = p[m];
    return v[l] = f(y), _apply(u, this, v);
  };
}
var _overRest = overRest;
function flatRest$1(u) {
  return _setToString(_overRest(u, void 0, flatten_1), u + "");
}
var _flatRest = flatRest$1, WRAP_REARG_FLAG$3 = 256, rearg$1 = _flatRest(function(u, l) {
  return _createWrap$1(u, WRAP_REARG_FLAG$3, void 0, void 0, void 0, l);
}), rearg_1$1 = rearg$1;
function toPath$1(u) {
  return isArray_1(u) ? _arrayMap(u, _toKey) : isSymbol_1(u) ? [u] : _copyArray$1(_stringToPath(toString_1(u)));
}
var toPath_1$1 = toPath$1, _util$1 = { ary: ary_1$1, assign: _baseAssign$1, clone: clone_1$1, curry: curry_1$1, forEach: _arrayEach$1, isArray: isArray_1, isError: isError_1$1, isFunction: isFunction_1, isWeakMap: isWeakMap_1$1, iteratee: iteratee_1$1, keys: _baseKeys, rearg: rearg_1$1, toInteger: toInteger_1$1, toPath: toPath_1$1 };
function convert$2(u, l, f) {
  return _baseConvert$1(_util$1, u, l, f);
}
var convert_1$1 = convert$2, CLONE_DEEP_FLAG$3 = 1, CLONE_SYMBOLS_FLAG$3 = 4;
function cloneDeep$1$1(u) {
  return _baseClone$1(u, CLONE_DEEP_FLAG$3 | CLONE_SYMBOLS_FLAG$3);
}
var cloneDeep_1$1 = cloneDeep$1$1, _falseOptions$1 = { cap: !1, curry: !1, fixed: !1, immutable: !1, rearg: !1 }, func$1 = convert_1$1("cloneDeep", cloneDeep_1$1, _falseOptions$1);
func$1.placeholder = placeholder$1;
var cloneDeep$4 = func$1;
let runJS;
const setJSRunner = (u) => runJS = u, removeJSRunner = () => {
  runJS = void 0;
}, removeSquareBrackets = (u) => {
  if (!u || typeof u != "string")
    return u;
  const l = u.match(/\[+(.+)]+/);
  return l && l[1] ? l[1] : u;
}, isReservedKey = (u) => u === "snippets" || u === "helpers" || u.startsWith("snippets.") || u.startsWith("helpers."), getContextValue = (u, l) => {
  if (isReservedKey(u))
    return;
  let f = l;
  return /^(["'`]).*\1$/.test(u) ? u.substring(1, u.length - 1) : (u.split(".").forEach((p) => {
    if (f == null || typeof f != "object")
      return null;
    f = f[removeSquareBrackets(p)];
  }), f);
};
function processJS(handlebars, context) {
  if (!isJSAllowed() || !runJS)
    throw new Error("JS disabled in environment.");
  try {
    const js = iifeWrapper(atob$1(handlebars));
    let snippetMap = {}, snippetCache = {}, clonedContext;
    for (let u of context.snippets || [])
      snippetMap[u.name] = u.code;
    clonedContext = isBackendService() ? context : cloneDeep$4(context);
    const sandboxContext = { $: (u) => getContextValue(u, clonedContext), helpers: getJsHelperList(), snippets: new Proxy({}, { get: function(_, name) {
      return name in snippetCache || (snippetCache[name] = eval(iifeWrapper(snippetMap[name]))), snippetCache[name];
    } }) }, logs = [];
    if (!isBackendService()) {
      const u = frontendWrapJS(js).split(js)[0].split(`
`).length, l = (f) => (...p) => {
        var m, b;
        isTest() || console[f](...p), p.forEach((v, k) => {
          typeof v == "object" && (p[k] = JSON.stringify(v));
        });
        const y = (b = (m = new Error().stack) === null || m === void 0 ? void 0 : m.match(/<anonymous>:(\d+):\d+/)) === null || b === void 0 ? void 0 : b[1];
        logs.push({ log: p, line: y ? parseInt(y) - u : void 0, type: f });
      };
      sandboxContext.console = { log: l("log"), info: l("info"), debug: l("debug"), warn: l("warn"), error: l("error"), table: l("table") };
    }
    const res = { data: runJS(js, sandboxContext), logs };
    return `{{${LITERAL_MARKER} js_result-${JSON.stringify(res)}}}`;
  } catch (u) {
    const { noThrow: l = !0 } = context.__opts || {};
    if (u.code === "ERR_SCRIPT_EXECUTION_TIMEOUT")
      return "Timed out while executing JS";
    if (u.code === "JS_REQUEST_TIMEOUT_ERROR")
      return u.message;
    if (u.code === JsTimeoutError.code)
      return JsTimeoutError.message;
    if (u.code === UserScriptError.code) {
      if (l)
        return u.userScriptError.toString();
      throw u;
    }
    if (u.name === "SyntaxError") {
      if (l)
        return u.toString();
      throw u;
    }
    return "Error while executing JS";
  }
}
const HTML_SWAPS = { "<": "&lt;", ">": "&gt;" };
function isObject$6(u) {
  return u != null && typeof u == "object" && (u.toString() === "[object Object]" || u.length > 0 && typeof u[0] == "object");
}
const HELPERS = [new Helper(HelperFunctionNames.OBJECT, (u) => new Handlebars.SafeString(JSON.stringify(u))), new Helper(HelperFunctionNames.JS, processJS, !1), new Helper(HelperFunctionNames.DECODE_ID, (u) => {
  if (!u)
    return [];
  const l = typeof u == "string" ? u : u._id, f = decodeURIComponent(l).replace(/'/g, '"');
  try {
    const p = JSON.parse(f);
    return Array.isArray(p) ? p : [p];
  } catch {
    return [u];
  }
}), new Helper(HelperFunctionNames.ALL, (u, l) => {
  const { __opts: f } = l;
  if (isObject$6(u))
    return new Handlebars.SafeString(JSON.stringify(u));
  if (f && f.onlyFound && u == null)
    return f.input;
  if (u == null || typeof u != "string")
    return u ?? "";
  u && u.string && (u = u.string);
  let p = u;
  return f && f.escapeNewlines && (p = u.replace(/\n/g, "\\n")), p = new Handlebars.SafeString(p.replace(/&amp;/g, "&")), p == null || typeof p != "string" ? p : p.replace(/[<>]/g, (m) => HTML_SWAPS[m] || m);
}), new Helper(HelperFunctionNames.LITERAL, (u) => {
  if (u === void 0)
    return "";
  const l = typeof u, f = l === "object" ? JSON.stringify(u) : u;
  return `{{${LITERAL_MARKER} ${l}-${f}}}`;
})];
function HelperNames() {
  return Object.values(HelperFunctionNames).concat(HelperFunctionBuiltin, externalHelperNames);
}
function registerMinimum(u) {
  for (let l of HELPERS)
    l.register(u);
}
function registerAll(u) {
  registerMinimum(u), registerAll$1(u);
}
const FUNCTION_CASES = ["#", "else", "/"];
var PreprocessorNames;
(function(u) {
  u.SWAP_TO_DOT = "swap-to-dot-notation", u.FIX_FUNCTIONS = "fix-functions", u.FINALISE = "finalise", u.NORMALIZE_SPACES = "normalize-spaces";
})(PreprocessorNames || (PreprocessorNames = {}));
class Preprocessor {
  constructor(l, f) {
    this.name = l, this.fn = f;
  }
  process(l, f, p) {
    const m = this.fn(f, p), b = l.indexOf(f);
    return swapStrings(l, b, f.length, m);
  }
}
const processors$1 = [new Preprocessor(PreprocessorNames.SWAP_TO_DOT, (u) => {
  let l = u.indexOf("["), f = 0;
  for (; l !== -1; ) {
    isAlphaNumeric(u.charAt(l - 1)) && (u = swapStrings(u, l + f, 1, ".[")), f = l + 1;
    const p = u.substring(f + 1).indexOf("[");
    l = p > 0 ? f + 1 + p : -1;
  }
  return u;
}), new Preprocessor(PreprocessorNames.FIX_FUNCTIONS, (u) => {
  for (let l of FUNCTION_CASES) {
    const f = `{ ${l}`, p = `{${l}`;
    u = u.replace(new RegExp(f, "g"), p);
  }
  return u;
}), new Preprocessor(PreprocessorNames.NORMALIZE_SPACES, (u) => u.replace(/{{(\s{2,})/g, "{{ ")), new Preprocessor(PreprocessorNames.FINALISE, (u, l) => {
  var f;
  const p = !(l != null && l.noHelpers);
  let m = u.slice(2, u.length - 2);
  m.charAt(0) === " " && (m = m.slice(1)), m.charAt(m.length - 1) === " " && (m = m.slice(0, m.length - 1));
  const b = m.split(" ")[0];
  for (let v of FUNCTION_CASES)
    if (b.includes(v))
      return u;
  const y = b.trim().toLowerCase();
  return p && !(!((f = l == null ? void 0 : l.disabledHelpers) === null || f === void 0) && f.includes(y)) && HelperNames().some((v) => y === v.toLowerCase()) && (m = `(${m})`), `{{ all ${m} }}`;
})];
var PostProcessorNames;
(function(u) {
  u.CONVERT_LITERALS = "convert-literals";
})(PostProcessorNames || (PostProcessorNames = {}));
class Postprocessor {
  constructor(l, f) {
    this.name = l, this.fn = f;
  }
  process(l) {
    return this.fn(l);
  }
}
const processors = [new Postprocessor(PostProcessorNames.CONVERT_LITERALS, (u) => {
  if (typeof u != "string" || !u.includes(LITERAL_MARKER))
    return { result: u };
  const l = u.indexOf("-"), f = u.substring(12, l), p = u.substring(l + 1, u.length - 2);
  switch (f) {
    case "string":
      return { result: p };
    case "number":
      return { result: parseFloat(p) };
    case "boolean":
      return { result: p === "true" };
    case "object":
      return { result: JSON.parse(p) };
    case "js_result": {
      const m = JSON.parse(p);
      return { result: m.data, logs: m.logs };
    }
  }
  return { result: p };
})];
function process(u, l, f) {
  let p = [];
  for (let m of l) {
    if (typeof u != "string")
      break;
    let b = new RegExp(FIND_HBS_REGEX), y = u.match(b);
    if (y != null)
      for (let v of y) {
        const k = m.process(u, v, f || {});
        typeof k == "object" ? ("logs" in k && k.logs && (p = p.concat(k.logs)), u = k.result) : u = k;
      }
  }
  return { result: u, logs: p };
}
function preprocess(u, l) {
  let f = processors$1;
  return l.noFinalise && (f = f.filter((p) => p.name !== PreprocessorNames.FINALISE)), process(u, f, l).result;
}
function postprocess(u) {
  return process(u, processors).result;
}
function postprocessWithLogs(u) {
  return process(u, processors);
}
const hbsInstance = handlebars.create();
registerAll(hbsInstance);
const helperNames = Object.keys(hbsInstance.helpers), hbsInstanceNoHelpers = handlebars.create();
registerMinimum(hbsInstanceNoHelpers);
const defaultOpts = { noHelpers: !1, cacheTemplates: !1, noEscaping: !1, escapeNewlines: !1, noFinalise: !1 };
function testObject(u) {
  try {
    JSON.stringify(u);
  } catch {
    throw "Unable to process inputs to JSON, cannot recurse";
  }
}
function findOverlappingHelpers(u) {
  return u ? Object.keys(u).filter((l) => helperNames.includes(l)) : [];
}
const templateCache = {};
function createTemplate(u, l, f) {
  const p = !((l = Object.assign(Object.assign({}, defaultOpts), l)) != null && l.noHelpers), m = `${u}-${JSON.stringify(l)}`;
  if (l.cacheTemplates && templateCache[m])
    return templateCache[m];
  const b = p ? findOverlappingHelpers(f) : [];
  if (u = preprocess(u, Object.assign(Object.assign({}, l), { disabledHelpers: b })), f && p && b.length > 0)
    for (const v of findHBSBlocks(u))
      u = u.replace(v, prefixStrings(v, b, "./"));
  l.noEscaping && (u = disableEscaping(u));
  const y = (l.noHelpers ? hbsInstanceNoHelpers : hbsInstance).compile(u, { strict: !1 });
  return templateCache[m] = y, y;
}
function processObjectSync(u, l, f) {
  testObject(u);
  for (let p of Object.keys(u || {})) {
    let m = u[p];
    typeof m == "string" ? u[p] = processStringSync(u[p], l, f) : typeof m == "object" && (u[p] = processObjectSync(u[p], l, f));
  }
  return u;
}
function processStringSyncInternal(u, l, f) {
  const p = u;
  if (typeof u != "string")
    throw new Error("Cannot process non-string types.");
  function m(b) {
    const y = createTemplate(b, f, l), v = 1e3 * Math.floor(Date.now() / 1e3), k = y(Object.assign({ now: new Date(v).toISOString(), __opts: Object.assign(Object.assign({}, f), { input: b }) }, l));
    return f != null && f.logging ? postprocessWithLogs(k) : postprocess(k);
  }
  try {
    if (f && f.onlyFound) {
      let b = [];
      const y = findHBSBlocks(u);
      for (let v of y) {
        const k = m(v);
        typeof k == "object" && "result" in k ? (b = b.concat(k.logs || []), u = u.replace(v, k.result)) : u = u.replace(v, k);
      }
      return f != null && f.logging ? { result: u, logs: b } : u;
    }
    return m(u);
  } catch (b) {
    const { noThrow: y = !0 } = f || {};
    if (y)
      return p;
    throw b;
  }
}
function processStringSync(u, l, f) {
  return processStringSyncInternal(u, l, Object.assign(Object.assign({}, f), { logging: !1 }));
}
function disableEscaping(u) {
  const l = findDoubleHbsInstances(u);
  if (l == null)
    return u;
  const f = [...new Set(l)];
  for (let p of f) {
    const m = new RegExp(`${p}(?!})`, "g");
    u = u.replace(m, `{${p}}`);
  }
  return u;
}
function makePropSafe(u) {
  return `[${u}]`.replace("[[", "[").replace("]]", "]");
}
function isJSBinding(u) {
  return decodeJSBinding(u) != null;
}
function decodeJSBinding(u) {
  if (!u || typeof u != "string" || !u.trim().startsWith("{{ js "))
    return null;
  const l = new RegExp(/{{ js "(.*)" }}/), f = u.match(l);
  return !f || f.length < 2 ? null : atob$1(f[1]);
}
function findHBSBlocks(u) {
  if (!u || typeof u != "string")
    return [];
  let l = new RegExp(FIND_ANY_HBS_REGEX), f = u.match(l);
  return f ?? [];
}
function browserJSSetup() {
  const u = isTest() ? vm : vmBrowserify;
  setJSRunner((l, f) => {
    u.createContext(f);
    const p = frontendWrapJS(l), m = u.runInNewContext(p, f);
    if (m.error)
      throw new UserScriptError(m.error);
    return m.result;
  });
}
function defaultJSSetup() {
  isBackendService() ? removeJSRunner() : browserJSSetup();
}
defaultJSSetup();
const CellRenderer_svelte_svelte_type_style_lang = "", SelectEditRenderer_svelte_svelte_type_style_lang = "", Table_svelte_svelte_type_style_lang = "", Tab_svelte_svelte_type_style_lang = "";
function create_else_block$b(u) {
  let l, f, p, m, b, y, v, k = (
    /*icon*/
    u[1] && create_if_block_3$6(u)
  );
  return {
    c() {
      l = element("div"), k && k.c(), f = space(), p = element("span"), m = text$2(
        /*title*/
        u[0]
      ), attr(p, "class", "spectrum-Tabs-itemLabel"), attr(
        l,
        "id",
        /*id*/
        u[2]
      ), attr(l, "class", "spectrum-Tabs-item svelte-msdyh4"), attr(l, "tabindex", "0"), toggle_class(
        l,
        "is-selected",
        /*isSelected*/
        u[6]
      ), toggle_class(
        l,
        "emphasized",
        /*isSelected*/
        u[6] && /*$selected*/
        u[7].emphasized
      );
    },
    m(S, $) {
      insert(S, l, $), k && k.m(l, null), append$1(l, f), append$1(l, p), append$1(p, m), u[14](l), b = !0, y || (v = [
        listen(
          l,
          "click",
          /*onClick*/
          u[10]
        ),
        listen(
          l,
          "click",
          /*click_handler*/
          u[12]
        )
      ], y = !0);
    },
    p(S, $) {
      /*icon*/
      S[1] ? k ? (k.p(S, $), $ & /*icon*/
      2 && transition_in(k, 1)) : (k = create_if_block_3$6(S), k.c(), transition_in(tH¹Såú9ØS·½¦³g×q·C›0ÒžœŸWðTBÆÉ8k, 1), k.m(l, f)) : k && (group_outros(), transition_out(k, 1, 1, () => {
        k = null;
      }), check_outros()), (!b || $ & /*title*/
      1) && set_data(
        m,
        /*title*/
        S[0]
      ), (!b || $ & /*id*/
      4) && attr(
        l,
        "id",
        /*id*/
        S[2]
      ), (!b || $ & /*isSelected*/
      64) && toggle_class(
        l,
        "is-selected",
        /*isSelected*/
        S[6]
      ), (!b || $ & /*isSelected, $selected*/
      192) && toggle_class(
        l,
        "emphasized",
        /*isSelected*/
        S[6] && /*$selected*/
        S[7].emphasized
      );
    },
    i(S) {
      b || (transition_in(k), b = !0);
    },
    o(S) {
      transition_out(k), b = !1;
    },
    d(S) {
      S && detach(l), k && k.d(), u[14](null), y = !1, run_all(v);
    }
  };
}
function create_if_block_1$g(u) {
  let l, f, p, m, b, y, v, k = (
    /*icon*/
    u[1] && create_if_block_2$b(u)
  );
  return {
    c() {
      l = element("a"), k && k.c(), f = space(), p = element("span"), m = text$2(
        /*title*/
        u[0]
      ), attr(p, "class", "spectrum-Tabs-itemLabel"), attr(
        l,
        "href",
        /*href*/
        u[3]
      ), attr(
        l,
        "id",
        /*id*/
        u[2]
      ), attr(l, "class", "spectrum-Tabs-item link svelte-msdyh4"), attr(l, "tabindex", "0"), toggle_class(
        l,
        "is-selected",
        /*isSelected*/
        u[6]
      ), toggle_class(
        l,
        "emphasized",
        /*isSelected*/
        u[6] && /*$selected*/
        u[7].emphasized
      );
    },
    m(S, $) {
      insert(S, l, $), k && k.m(l, null), append$1(l, f), append$1(l, p), append$1(p, m), u[13](l), b = !0, y || (v = listen(
        l,
        "click",
        /*onAnchorClick*/
        u[9]
      ), y = !0);
    },
    p(S, $) {
      /*icon*/
      S[1] ? k ? (k.p(S, $), $ & /*icon*/
      2 && transition_in(k, 1)) : (k = create_if_block_2$b(S), k.c(), transition_in(k, 1), k.m(l, f)) : k && (group_outros(), transition_out(k, 1, 1, () => {
        k = null;
      }), check_outros()), (!b || $ & /*title*/
      1) && set_data(
        m,
        /*title*/
        S[0]
      ), (!b || $ & /*href*/
      8) && attr(
        l,
        "href",
        /*href*/
        S[3]
      ), (!b || $ & /*id*/
      4) && attr(
        l,
        "id",
        /*id*/
        S[2]
      ), (!b || $ & /*isSelected*/
      64) && toggle_class(
        l,
        "is-selected",
        /*isSelected*/
        S[6]
      ), (!b || $ & /*isSelected, $selected*/
      192) && toggle_class(
        l,
        "emphasized",
        /*isSelected*/
        S[6] && /*$selected*/
        S[7].emphasized
      );
    },
    i(S) {
      b || (transition_in(k), b = !0);
    },
    o(S) {
      transition_out(k), b = !1;
    },
    d(S) {
      S && detach(l), k && k.d(), u[13](null), y = !1, v();
    }
  };
}
function create_if_block_3$6(u) {
  let l, f;
  return l = new Icon({
    props: { name: (
      /*icon*/
      u[1]
    ), size: "M" }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*icon*/
      2 && (b.name = /*icon*/
      p[1]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_2$b(u) {
  let l, f;
  return l = new Icon({
    props: { name: (
      /*icon*/
      u[1]
    ), size: "M" }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*icon*/
      2 && (b.name = /*icon*/
      p[1]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block$y(u) {
  let l, f;
  return l = new Portal({
    props: {
      target: ".spectrum-Tabs-content-" + /*$selected*/
      u[7].id,
      $$slots: { default: [create_default_slot$x] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$selected*/
      128 && (b.target = ".spectrum-Tabs-content-" + /*$selected*/
      p[7].id), m & /*$$scope*/
      32768 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot$x(u) {
  let l;
  const f = (
    /*#slots*/
    u[11].default
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[15],
    null
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, b) {
      p && p.p && (!l || b & /*$$scope*/
      32768) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[15],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[15],
          b,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[15]
        ),
        null
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function create_fragment$15(u) {
  let l, f, p, m, b;
  const y = [create_if_block_1$g, create_else_block$b], v = [];
  function k($, w) {
    return (
      /*link*/
      $[4] ? 0 : 1
    );
  }
  l = k(u), f = v[l] = y[l](u);
  let S = (
    /*isSelected*/
    u[6] && create_if_block$y(u)
  );
  return {
    c() {
      f.c(), p = space(), S && S.c(), m = empty$1();
    },
    m($, w) {
      v[l].m($, w), insert($, p, w), S && S.m($, w), insert($, m, w), b = !0;
    },
    p($, [w]) {
      let T = l;
      l = k($), l === T ? v[l].p($, w) : (group_outros(), transition_out(v[T], 1, 1, () => {
        v[T] = null;
      }), check_outros(), f = v[l], f ? f.p($, w) : (f = v[l] = y[l]($), f.c()), transition_in(f, 1), f.m(p.parentNode, p)), /*isSelected*/
      $[6] ? S ? (S.p($, w), w & /*isSelected*/
      64 && transition_in(S, 1)) : (S = create_if_block$y($), S.c(), transition_in(S, 1), S.m(m.parentNode, m)) : S && (group_outros(), transition_out(S, 1, 1, () => {
        S = null;
      }), check_outros());
    },
    i($) {
      b || (transition_in(f), transition_in(S), b = !0);
    },
    o($) {
      transition_out(f), transition_out(S), b = !1;
    },
    d($) {
      $ && (detach(p), detach(m)), v[l].d($), S && S.d($);
    }
  };
}
function instance$13(u, l, f) {
  let p, m, { $$slots: b = {}, $$scope: y } = l, { title: v } = l, { icon: k = "" } = l, { id: S = void 0 } = l, { href: $ = "#" } = l, { link: w = !1 } = l;
  const T = createEventDispatcher();
  let E = getContext$1("tab");
  component_subscribe(u, E, (V) => f(7, m = V));
  let R, O;
  const P = () => {
    const V = O == null ? void 0 : O.getBoundingClientRect();
    V && set_store_value(E, m.info = V, m);
  }, L = (V) => {
    V.metaKey || V.shiftKey || V.altKey || V.ctrlKey || (V.preventDefault(), set_store_value(
      E,
      m = {
        ...m,
        title: v,
        info: O.getBoundingClientRect()
      },
      m
    ), T("click"));
  }, M = () => {
    set_store_value(
      E,
      m = {
        ...m,
        title: v,
        info: O.getBoundingClientRect()
      },
      m
    );
  }, B = () => {
    R || (R = new ResizeObserver(P), R.observe(O));
  }, j = () => {
    R && (R.unobserve(O), R = null);
  };
  onDestroy(j);
  function x(V) {
    bubble.call(this, u, V);
  }
  function N(V) {
    binding_callbacks[V ? "unshift" : "push"](() => {
      O = V, f(5, O);
    });
  }
  function D(V) {
    binding_callbacks[V ? "unshift" : "push"](() => {
      O = V, f(5, O);
    });
  }
  return u.$$set = (V) => {
    "title" in V && f(0, v = V.title), "icon" in V && f(1, k = V.icon), "id" in V && f(2, S = V.id), "href" in V && f(3, $ = V.href), "link" in V && f(4, w = V.link), "$$scope" in V && f(15, y = V.$$scope);
  }, u.$$.update = () => {
    u.$$.dirty & /*$selected, title*/
    129 && f(6, p = m.title === v), u.$$.dirty & /*isSelected, ref*/
    96 && (p && O ? B() : j());
  }, [
    v,
    k,
    S,
    $,
    w,
    O,
    p,
    m,
    E,
    L,
    M,
    b,
    x,
    N,
    D,
    y
  ];
}
class Tab extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$13, create_fragment$15, safe_not_equal, {
      title: 0,
      icon: 1,
      id: 2,
      href: 3,
      link: 4
    });
  }
}
const indexVars$2 = "", Tabs_svelte_svelte_type_style_lang = "";
function create_if_block$x(u) {
  let l;
  return {
    c() {
      l = element("div"), attr(l, "class", "spectrum-Tabs-selectionIndicator svelte-1chmmw5"), set_style(
        l,
        "width",
        /*width*/
        u[11]
      ), set_style(
        l,
        "height",
        /*height*/
        u[12]
      ), set_style(
        l,
        "left",
        /*left*/
        u[10]
      ), set_style(
        l,
        "top",
        /*top*/
        u[9]
      ), toggle_class(
        l,
        "emphasized",
        /*emphasized*/
        u[4]
      );
    },
    m(f, p) {
      insert(f, l, p);
    },
    p(f, p) {
      p & /*width*/
      2048 && set_style(
        l,
        "width",
        /*width*/
        f[11]
      ), p & /*height*/
      4096 && set_style(
        l,
        "height",
        /*height*/
        f[12]
      ), p & /*left*/
      1024 && set_style(
        l,
        "left",
        /*left*/
        f[10]
      ), p & /*top*/
      512 && set_style(
        l,
        "top",
        /*top*/
        f[9]
      ), p & /*emphasized*/
      16 && toggle_class(
        l,
        "emphasized",
        /*emphasized*/
        f[4]
      );
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_fragment$14(u) {
  let l, f, p, m, b, y;
  const v = (
    /*#slots*/
    u[19].default
  ), k = create_slot(
    v,
    u,
    /*$$scope*/
    u[18],
    null
  );
  let S = (
    /*$tab*/
    u[7].info && create_if_block$x(u)
  );
  return {
    c() {
      l = element("div"), k && k.c(), f = space(), S && S.c(), m = space(), b = element("div"), attr(l, "class", p = "spectrum-Tabs spectrum-Tabs--size" + /*size*/
      u[6] + " svelte-1chmmw5"), toggle_class(
        l,
        "spectrum-Tabs--quiet",
        /*quiet*/
        u[3]
      ), toggle_class(
        l,
        "noHorizPadding",
        /*noHorizPadding*/
        u[2]
      ), toggle_class(
        l,
        "onTop",
        /*onTop*/
        u[5]
      ), toggle_class(
        l,
        "spectrum-Tabs--vertical",
        /*vertical*/
        u[0]
      ), toggle_class(l, "spectrum-Tabs--horizontal", !/*vertical*/
      u[0]), attr(b, "class", "spectrum-Tabs-content spectrum-Tabs-content-" + /*_id*/
      u[13] + " svelte-1chmmw5"), toggle_class(
        b,
        "noPadding",
        /*noPadding*/
        u[1]
      );
    },
    m($, w) {
      insert($, l, w), k && k.m(l, null), append$1(l, f), S && S.m(l, null), u[20](l), insert($, m, w), insert($, b, w), y = !0;
    },
    p($, [w]) {
      k && k.p && (!y || w & /*$$scope*/
      262144) && update_slot_base(
        k,
        v,
        $,
        /*$$scope*/
        $[18],
        y ? get_slot_changes(
          v,
          /*$$scope*/
          $[18],
          w,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          $[18]
        ),
        null
      ), /*$tab*/
      $[7].info ? S ? S.p($, w) : (S = create_if_block$x($), S.c(), S.m(l, null)) : S && (S.d(1), S = null), (!y || w & /*size*/
      64 && p !== (p = "spectrum-Tabs spectrum-Tabs--size" + /*size*/
      $[6] + " svelte-1chmmw5")) && attr(l, "class", p), (!y || w & /*size, quiet*/
      72) && toggle_class(
        l,
        "spectrum-Tabs--quiet",
        /*quiet*/
        $[3]
      ), (!y || w & /*size, noHorizPadding*/
      68) && toggle_class(
        l,
        "noHorizPadding",
        /*noHorizPadding*/
        $[2]
      ), (!y || w & /*size, onTop*/
      96) && toggle_class(
        l,
        "onTop",
        /*onTop*/
        $[5]
      ), (!y || w & /*size, vertical*/
      65) && toggle_class(
        l,
        "spectrum-Tabs--vertical",
        /*vertical*/
        $[0]
      ), (!y || w & /*size, vertical*/
      65) && toggle_class(l, "spectrum-Tabs--horizontal", !/*vertical*/
      $[0]), (!y || w & /*noPadding*/
      2) && toggle_class(
        b,
        "noPadding",
        /*noPadding*/
        $[1]
      );
    },
    i($) {
      y || (transition_in(k, $), y = !0);
    },
    o($) {
      transition_out(k, $), y = !1;
    },
    d($) {
      $ && (detach(l), detach(m), detach(b)), k && k.d($), S && S.d(), u[20](null);
    }
  };
}
function id() {
  return "_" + Math.random().toString(36).slice(2, 9);
}
function instance$12(u, l, f) {
  let p, { $$slots: m = {}, $$scope: b } = l, { selected: y } = l, { vertical: v = !1 } = l, { noPadding: k = !1 } = l, { noHorizPadding: S = !1 } = l, { quiet: $ = !1 } = l, { emphasized: w = !1 } = l, { onTop: T = !1 } = l, { size: E = "M" } = l, { beforeSwitch: R = null } = l, O, P, L = id();
  const M = writable({ title: y, id: L, emphasized: w });
  component_subscribe(u, M, (U) => f(7, p = U)), setContext("tab", M);
  let B, j, x, N;
  const D = createEventDispatcher();
  function V() {
    var U, Y;
    v ? f(12, N = (((Y = p.info) == null ? void 0 : Y.height) ?? 0) + 4 + "px") : f(11, x = (((U = p.info) == null ? void 0 : U.width) ?? 0) + "px");
  }
  function W() {
    var U, Y;
    v ? f(9, B = (((Y = p.info) == null ? void 0 : Y.top) ?? 0) - ((P == null ? void 0 : P.getBoundingClientRect().top) ?? 0) + "px") : f(10, j = (((U = p.info) == null ? void 0 : U.left) ?? 0) - ((P == null ? void 0 : P.getBoundingClientRect().left) ?? 0) + "px");
  }
  onMount(() => {
    V(), W();
  });
  function F(U) {
    binding_callbacks[U ? "unshift" : "push"](() => {
      P = U, f(8, P);
    });
  }
  return u.$$set = (U) => {
    "selected" in U && f(15, y = U.selected), "vertical" in U && f(0, v = U.vertical), "noPadding" in U && f(1, k = U.noPadding), "noHorizPadding" in U && f(2, S = U.noHorizPadding), "quiet" in U && f(3, $ = U.quiet), "emphasized" in U && f(4, w = U.emphasized), "onTop" in U && f(5, T = U.onTop), "size" in U && f(6, E = U.size), "beforeSwitch" in U && f(16, R = U.beforeSwitch), "$$scope" in U && f(18, b = U.$$scope);
  }, u.$$.update = () => {
    u.$$.dirty & /*thisSelected, selected, $tab, beforeSwitch*/
    229504 && (O !== y ? (f(17, O = y), D("select", O)) : p.title !== O && (typeof R == "function" ? R(p.title) && (f(17, O = p.title), f(15, y = p.title), D("select", O)) : (f(17, O = p.title), f(15, y = p.title), D("select", O))), p.title !== O && M.update((U) => (U.title = O, U))), u.$$.dirty & /*$tab*/
    128 && p && V(), u.$$.dirty & /*$tab*/
    128 && p && W();
  }, [
    v,
    k,
    S,
    $,
    w,
    T,
    E,
    p,
    P,
    B,
    j,
    x,
    N,
    L,
    M,
    y,
    R,
    O,
    b,
    m,
    F
  ];
}
class Tabs extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$12, create_fragment$14, safe_not_equal, {
      selected: 15,
      vertical: 0,
      noPadding: 1,
      noHorizPadding: 2,
      quiet: 3,
      emphasized: 4,
      onTop: 5,
      size: 6,
      beforeSwitch: 16
    });
  }
}
const Context_svelte_svelte_type_style_lang = "", indexVars$1 = "", BoldRenderer_svelte_svelte_type_style_lang = "", CodeRenderer_svelte_svelte_type_style_lang = "", Body_svelte_svelte_type_style_lang = "";
function create_fragment$13(u) {
  let l, f, p, m;
  const b = (
    /*#slots*/
    u[6].default
  ), y = create_slot(
    b,
    u,
    /*$$scope*/
    u[5],
    null
  );
  return {
    c() {
      l = element("p"), y && y.c(), attr(l, "data-testid", "typography-body"), attr(l, "style", f = `
    ${/*weight*/
      u[2] ? `font-weight:${/*weight*/
      u[2]};` : ""}
    ${/*textAlign*/
      u[3] ? `text-align:${/*textAlign*/
      u[3]};` : ""}
    ${/*color*/
      u[4] ? `color:${/*color*/
      u[4]};` : ""}
  `), attr(l, "class", p = "spectrum-Body spectrum-Body--size" + /*size*/
      u[0] + " svelte-1asmvv2"), toggle_class(
        l,
        "spectrum-Body--serif",
        /*serif*/
        u[1]
      );
    },
    m(v, k) {
      insert(v, l, k), y && y.m(l, null), m = !0;
    },
    p(v, [k]) {
      y && y.p && (!m || k & /*$$scope*/
      32) && update_slot_base(
        y,
        b,
        v,
        /*$$scope*/
        v[5],
        m ? get_slot_changes(
          b,
          /*$$scope*/
          v[5],
          k,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          v[5]
        ),
        null
      ), (!m || k & /*weight, textAlign, color*/
      28 && f !== (f = `
    ${/*weight*/
      v[2] ? `font-weight:${/*weight*/
      v[2]};` : ""}
    ${/*textAlign*/
      v[3] ? `text-align:${/*textAlign*/
      v[3]};` : ""}
    ${/*color*/
      v[4] ? `color:${/*color*/
      v[4]};` : ""}
  `)) && attr(l, "style", f), (!m || k & /*size*/
      1 && p !== (p = "spectrum-Body spectrum-Body--size" + /*size*/
      v[0] + " svelte-1asmvv2")) && attr(l, "class", p), (!m || k & /*size, serif*/
      3) && toggle_class(
        l,
        "spectrum-Body--serif",
        /*serif*/
        v[1]
      );
    },
    i(v) {
      m || (transition_in(y, v), m = !0);
    },
    o(v) {
      transition_out(y, v), m = !1;
    },
    d(v) {
      v && detach(l), y && y.d(v);
    }
  };
}
function instance$11(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l, { size: b = "M" } = l, { serif: y = !1 } = l, { weight: v = null } = l, { textAlign: k = null } = l, { color: S = null } = l;
  return u.$$set = ($) => {
    "size" in $ && f(0, b = $.size), "serif" in $ && f(1, y = $.serif), "weight" in $ && f(2, v = $.weight), "textAlign" in $ && f(3, k = $.textAlign), "color" in $ && f(4, S = $.color), "$$scope" in $ && f(5, m = $.$$scope);
  }, [b, y, v, k, S, m, p];
}
class Body extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$11, create_fragment$13, safe_not_equal, {
      size: 0,
      serif: 1,
      weight: 2,
      textAlign: 3,
      color: 4
    });
  }
}
const Heading_svelte_svelte_type_style_lang = "";
function create_fragment$12(u) {
  let l, f, p, m;
  const b = (
    /*#slots*/
    u[6].default
  ), y = create_slot(
    b,
    u,
    /*$$scope*/
    u[5],
    null
  );
  return {
    c() {
      l = element("h1"), y && y.c(), attr(l, "data-testid", "typography-heading"), attr(l, "style", f = [
        /*textAlign*/
        u[1] ? `text-align: ${/*textAlign*/
        u[1]}` : "",
        /*color*/
        u[4] ? `color: ${/*color*/
        u[4]}` : ""
      ].filter(Boolean).join("; ")), attr(l, "class", p = "spectrum-Heading spectrum-Heading--size" + /*size*/
      u[0] + " spectrum-Heading--" + /*weight*/
      u[3] + " svelte-1m70x3z"), toggle_class(
        l,
        "noPadding",
        /*noPadding*/
        u[2]
      );
    },
    m(v, k) {
      insert(v, l, k), y && y.m(l, null), m = !0;
    },
    p(v, [k]) {
      y && y.p && (!m || k & /*$$scope*/
      32) && update_slot_base(
        y,
        b,
        v,
        /*$$scope*/
        v[5],
        m ? get_slot_changes(
          b,
          /*$$scope*/
          v[5],
          k,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          v[5]
        ),
        null
      ), (!m || k & /*textAlign, color*/
      18 && f !== (f = [
        /*textAlign*/
        v[1] ? `text-align: ${/*textAlign*/
        v[1]}` : "",
        /*color*/
        v[4] ? `color: ${/*color*/
        v[4]}` : ""
      ].filter(Boolean).join("; "))) && attr(l, "style", f), (!m || k & /*size, weight*/
      9 && p !== (p = "spectrum-Heading spectrum-Heading--size" + /*size*/
      v[0] + " spectrum-Heading--" + /*weight*/
      v[3] + " svelte-1m70x3z")) && attr(l, "class", p), (!m || k & /*size, weight, noPadding*/
      13) && toggle_class(
        l,
        "noPadding",
        /*noPadding*/
        v[2]
      );
    },
    i(v) {
      m || (transition_in(y, v), m = !0);
    },
    o(v) {
      transition_out(y, v), m = !1;
    },
    d(v) {
      v && detach(l), y && y.d(v);
    }
  };
}
function instance$10(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l, { size: b = "M" } = l, { textAlign: y = void 0 } = l, { noPadding: v = !1 } = l, { weight: k = "default" } = l, { color: S = void 0 } = l;
  return u.$$set = ($) => {
    "size" in $ && f(0, b = $.size), "textAlign" in $ && f(1, y = $.textAlign), "noPadding" in $ && f(2, v = $.noPadding), "weight" in $ && f(3, k = $.weight), "color" in $ && f(4, S = $.color), "$$scope" in $ && f(5, m = $.$$scope);
  }, [b, y, v, k, S, m, p];
}
class Heading extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$10, create_fragment$12, safe_not_equal, {
      size: 0,
      textAlign: 1,
      noPadding: 2,
      weight: 3,
      color: 4
    });
  }
}
const ErrorSVG = `<?xml version="1.0"?>
<svg xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 48 48" height="48px" viewBox="0 0 48 48" width="48px" xml:space="preserve">
  <g>
    <g>
      <path d="M9,42H3c-0.552,0-1-0.449-1-1v-3.5C2,37.224,2.224,37,2.5,37S3,37.224,3,37.5V41h6    c0.276,0,0.5,0.224,0.5,0.5S9.276,42,9,42z"/>
        <path d="M45,42h-6c-0.276,0-0.5-0.224-0.5-0.5S38.724,41,39,41h6V13H3v27c0,0.276-0.224,0.5-0.5,0.5S2,40.276,2,40    V12h44v29C46,41.551,45.552,42,45,42z"/>
        <g>
        <path d="M45.5,13h-43C2.224,13,2,12.776,2,12.5v-5C2,6.673,2.673,6,3.5,6h41C45.327,6,46,6.673,46,7.5v5     C46,12.776,45.776,13,45.5,13z M3,12h42V7.5C45,7.224,44.775,7,44.5,7h-41C3.225,7,3,7.224,3,7.5V12z"/>
      </g>
        <g>
        <g>
          <path d="M16.5,11c-0.827,0-1.5-0.673-1.5-1.5S15.673,8,16.5,8S18,8.673,18,9.5S17.327,11,16.5,11z M16.5,9      C16.225,9,16,9.224,16,9.5s0.225,0.5,0.5,0.5S17,9.776,17,9.5S16.775,9,16.5,9z"/>
        </g>
            <g>
          <path d="M11.5,11c-0.827,0-1.5-0.673-1.5-1.5S10.673,8,11.5,8S13,8.673,13,9.5S12.327,11,11.5,11z M11.5,9      C11.225,9,11,9.224,11,9.5s0.225,0.5,0.5,0.5S12,9.776,12,9.5S11.775,9,11.5,9z"/>
        </g>
            <g>
          <path d="M6.5,11C5.673,11,5,10.327,5,9.5S5.673,8,6.5,8S8,8.673,8,9.5S7.327,11,6.5,11z M6.5,9      C6.225,9,6,9.224,6,9.5S6.225,10,6.5,10S7,9.776,7,9.5S6.775,9,6.5,9z"/>
        </g>
      </g>
    </g>
      <g>
      <g>
        <path d="M35.696,44H12.304c-0.728,0-1.313-0.284-1.605-0.779c-0.289-0.489-0.259-1.126,0.084-1.749L22.58,19.996     c0.709-1.285,2.132-1.285,2.839,0l11.799,21.477v0c0.343,0.623,0.373,1.26,0.084,1.749C37.01,43.716,36.424,44,35.696,44z M24,20     c-0.176,0-0.379,0.179-0.544,0.478L11.659,41.954c-0.168,0.306-0.205,0.582-0.101,0.758C11.667,42.895,11.938,43,12.304,43     h23.393c0.365,0,0.637-0.105,0.745-0.288c0.104-0.177,0.067-0.453-0.101-0.758v0L24.543,20.478C24.379,20.179,24.176,20,24,20z"/>
      </g>
          <g>
        <path d="M24,36L24,36c-0.225,0-0.421-0.15-0.481-0.366C23.456,35.412,22,30.169,22,28c0-1.103,0.897-2,2-2     s2,0.897,2,2c0,2.232-1.457,7.417-1.519,7.636C24.42,35.851,24.224,36,24,36z M24,27c-0.552,0-1,0.449-1,1     c0,1.266,0.569,3.793,1.002,5.531C24.435,31.806,25,29.301,25,28C25,27.449,24.552,27,24,27z"/>
      </g>
          <g>
        <path d="M24,41c-1.103,0-2-0.897-2-2s0.897-2,2-2s2,0.897,2,2S25.103,41,24,41z M24,38c-0.552,0-1,0.449-1,1     s0.448,1,1,1s1-0.449,1-1S24.552,38,24,38z"/>
      </g>
    </g>
  </g>
</svg>
`;
var HTTPMethod = /* @__PURE__ */ ((u) => (u.POST = "POST", u.PATCH = "PATCH", u.GET = "GET", u.PUT = "PUT", u.DELETE = "DELETE", u))(HTTPMethod || {});
const BannedSearchTypes = [
  FieldType.LINK,
  FieldType.ATTACHMENT_SINGLE,
  FieldType.ATTACHMENTS,
  FieldType.FORMULA,
  FieldType.JSON,
  FieldType.ATTACHMENT_SINGLE,
  FieldType.SIGNATURE_SINGLE,
  "jsonarray",
  "queryarray"
], Cookies = {
  Auth: "budibase:auth",
  CurrentApp: "budibase:currentapp",
  ReturnUrl: "budibase:returnurl",
  AccountReturnUrl: "budibase:account:returnurl",
  OnboardingProcessCorrelationKey: BpmCorrelationKey.ONBOARDING
};
var TableNames = /* @__PURE__ */ ((u) => (u.USERS = "ta_users", u))(TableNames || {});
const BudibaseRoles = {
  AppUser: "appUser",
  Developer: "developer",
  Creator: "creator",
  Admin: "admin",
  Owner: "owner"
}, BudibaseRoleOptionsOld = [
  {
    label: "Developer",
    value: BudibaseRoles.Developer,
    sortOrder: 2
  }
], BudibaseRoleOptions = [
  {
    label: "Tenant admin",
    value: BudibaseRoles.Admin,
    subtitle: "Has full access to all workspaces in your tenant",
    sortOrder: 1
  },
  {
    label: "Creator",
    value: BudibaseRoles.Creator,
    subtitle: "Can create and edit apps they have access to",
    sortOrder: 2
  },
  {
    label: "App user",
    value: BudibaseRoles.AppUser,
    subtitle: "Can only use published apps they have access to",
    sortOrder: 3
  }
], ExtendedBudibaseRoleOptions = [
  {
    label: "Account holder",
    value: BudibaseRoles.Owner,
    sortOrder: 0
  },
  ...BudibaseRoleOptions,
  ...BudibaseRoleOptionsOld
], PlanType = {
  FREE: "free",
  TEAM: "team",
  PRO: "pro",
  BUSINESS: "business",
  PREMIUM: "premium",
  PREMIUM_PLUS: "premium_plus",
  ENTERPRISE: "enterprise",
  ENTERPRISE_BASIC_TRIAL: "enterprise_basic_trial"
}, ApiVersion = "1", Roles = {
  ADMIN: "ADMIN",
  POWER: "POWER",
  BASIC: "BASIC",
  PUBLIC: "PUBLIC",
  BUILDER: "BUILDER",
  CREATOR: "CREATOR",
  GROUP: "GROUP"
}, EventPublishType = {
  ENV_VAR_UPGRADE_PANEL_OPENED: "environment_variable_upgrade_panel_opened"
}, TypeIconMap = {
  [FieldType.STRING]: "text-align-left",
  [FieldType.OPTIONS]: "caret-circle-down",
  [FieldType.DATETIME]: "calendar",
  [FieldType.BARCODEQR]: "barcode",
  [FieldType.SIGNATURE_SINGLE]: "pen-nib",
  [FieldType.LONGFORM]: "text-align-left",
  [FieldType.ARRAY]: "list-checks",
  [FieldType.NUMBER]: "hash",
  [FieldType.BOOLEAN]: "toggle-right",
  [FieldType.ATTACHMENTS]: "files",
  [FieldType.ATTACHMENT_SINGLE]: "file",
  [FieldType.LINK]: "arrow-circle-up-right",
  [FieldType.FORMULA]: "calculator",
  [FieldType.AI]: "sparkle",
  [FieldType.JSON]: "brackets-angle",
  [FieldType.BIGINT]: "text-bolder",
  [FieldType.AUTO]: "shapes",
  [FieldType.BB_REFERENCE]: {
    [BBReferenceFieldSubType.USER]: "users-three",
    [BBReferenceFieldSubType.USERS]: "users-three"
  },
  [FieldType.BB_REFERENCE_SINGLE]: {
    [BBReferenceFieldSubType.USER]: "user"
  }
}, OptionColours = [...new Array(12).keys()].map((u) => `hsla(${(u + 1) * 222 % 360}, 90%, 75%, 0.3)`), FilterOperator = {
  ANY: "any",
  ALL: "all"
}, OnEmptyFilter = {
  RETURN_ALL: "all",
  RETURN_NONE: "none"
}, FilterValueType = {
  BINDING: "Binding",
  VALUE: "Value"
}, FieldPermissions = {
  WRITABLE: "writable",
  READONLY: "readonly",
  HIDDEN: "hidden"
}, APP_NAME_REGEX = /^[\w\s]+$/, APP_URL_REGEX = /^[0-9a-zA-Z-_]+$/, Constants$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  APP_NAME_REGEX,
  APP_URL_REGEX,
  ApiVersion,
  BannedSearchTypes,
  BudibaseRoleOptions,
  BudibaseRoleOptionsOld,
  BudibaseRoles,
  ContextScopes: ComponentContextScopes,
  Cookies,
  DEFAULT_BB_DATASOURCE_ID,
  EventPublishType,
  ExtendedBudibaseRoleOptions,
  Features: Feature,
  FieldPermissions,
  FilterOperator,
  FilterValueType,
  OnEmptyFilter,
  OperatorOptions,
  OptionColours,
  PlanType,
  Roles,
  SqlNumberTypeRangeMap,
  TableNames,
  TypeIconMap
}, Symbol.toStringTag, { value: "Module" })), buildAnalyticsEndpoints = (u) => ({
  /**
   * Gets the current status of analytics for this environment
   */
  getAnalyticsStatus: async () => await u.get({
    url: "/api/bbtel"
  }),
  /**
   * Notifies analytics of a certain environment
   */
  analyticsPing: async (l) => await u.post({
    url: "/api/bbtel/ping",
    body: {
      ...l,
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
    }
  })
}), buildAIEndpoints = (u) => ({
  /**
   * Generates a cron expression from a prompt
   */
  generateCronExpression: async (l) => await u.post({
    url: "/api/ai/cron",
    body: { prompt: l }
  }),
  generateJs: async (l) => await u.post({
    url: "/api/ai/js",
    body: l
  }),
  generateTables: async (l) => await u.post({
    url: "/api/ai/tables",
    body: l
  })
}), buildAppEndpoints = (u) => ({
  /**
   * Fetches screen definition for an app.
   * @param appId the ID of the app to fetch from
   */
  fetchAppPackage: async (l) => await u.get({
    url: `/api/applications/${l}/appPackage`
  }),
  /**
   * Saves and patches metadata about an app.
   * @param appId the ID of the app to update
   * @param metadata the app metadata to save
   */
  saveAppMetadata: async (l, f) => await u.put({
    url: `/api/applications/${l}`,
    body: f
  }),
  /**
   * Publishes the current app.
   */
  publishAppChanges: async (l, f) => await u.post({
    url: `/api/applications/${l}/publish`,
    body: f
  }),
  /**
   * Reverts an app to a previous version.
   * @param appId the app ID to revert
   */
  revertAppChanges: async (l) => await u.post({
    url: `/api/dev/${l}/revert`
  }),
  /**
   * Updates an app's version of the client library.
   * @param appId the app ID to update
   */
  updateAppClientVersion: async (l) => await u.post({
    url: `/api/applications/${l}/client/update`
  }),
  /**
   * Reverts an app's version of the client library to the previous version.
   * @param appId the app ID to revert
   */
  revertAppClientVersion: async (l) => await u.post({
    url: `/api/applications/${l}/client/revert`
  }),
  /**
   * Gets a list of app deployments.
   */
  getAppDeployments: async () => await u.get({
    url: "/api/deployments"
  }),
  /**
   * Creates an app.
   * @param app the app to create
   */
  createApp: async (l) => l instanceof FormData ? await u.post({
    url: "/api/applications",
    body: l,
    json: !1
  }) : await u.post({
    url: "/api/applications",
    body: l
  }),
  /**
   * Duplicate an existing app
   * @param app the app to dupe
   */
  duplicateApp: async (l, f) => await u.post({
    url: `/api/applications/${l}/duplicate`,
    body: f
  }),
  /**
   * Update an application using an export - the body
   * should be of type FormData, with a "file" and a "password" if encrypted.
   * @param appId The ID of the app to update - this will always be
   * converted to development ID.
   * @param body a FormData body with a file and password.
   */
  updateAppFromExport: async (l, f, p) => {
    const m = getDevAppID(l), b = new FormData();
    b.append("appExport", p);
    for (const [y, v] of Object.entries(f))
      b.append(y, v);
    return await u.post({
      url: `/api/applications/${m}/import`,
      body: b,
      json: !1
    });
  },
  /**
   * Imports an export of all apps.
   * @param apps the FormData containing the apps to import
   */
  importApps: async (l) => await u.post({
    url: "/api/cloud/import",
    body: l,
    json: !1
  }),
  /**
   * Unpublishes a published app.
   * @param appId the production ID of the app to unpublish
   */
  unpublishApp: async (l) => await u.post({
    url: `/api/applications/${l}/unpublish`
  }),
  /**
   * Deletes a dev app.
   * @param appId the dev app ID to delete
   */
  deleteApp: async (l) => await u.delete({
    url: `/api/applications/${l}`
  }),
  /**
   * Releases the lock on a dev app.
   * @param appId the dev app ID to unlock
   */
  releaseAppLock: async (l) => await u.delete({
    url: `/api/dev/${l}/lock`
  }),
  /**
   * Gets budibase platform debug information.
   */
  fetchSystemDebugInfo: async () => await u.get({
    url: "/api/debug/diagnostics"
  }),
  /**
   * Gets a list of apps.
   */
  getApps: async () => await u.get({
    url: "/api/applications?status=all"
  }),
  /**
   * Fetches the definitions for component library components. This includes
   * their props and other metadata from components.json.
   * @param appId ID of the currently running app
   */
  fetchComponentLibDefinitions: async (l) => await u.get({
    url: `/api/${l}/components/definitions`
  }),
  /**
   * Adds sample data to an app
   * @param appId the app ID
   */
  addSampleData: async (l) => await u.post({
    url: `/api/applications/${l}/sample`
  }),
  getPublishedApps: async () => (await u.get({
    url: "/api/client/applications"
  })).apps
}), buildAttachmentEndpoints = (u) => {
  const l = {
    /**
     * Generates a signed URL to upload a file to an external datasource.
     * @param datasourceId the ID of the datasource to upload to
     * @param bucket the name of the bucket to upload to
     * @param key the name of the file to upload to
     */
    getSignedDatasourceURL: async (f, p, m) => await u.post({
      url: `/api/attachments/${f}/url`,
      body: { bucket: p, key: m }
    })
  };
  return {
    ...l,
    /**
     * Uploads an attachment to the server.
     * @param data the attachment to upload
     * @param tableId the table ID to upload to
     */
    uploadAttachment: async (f, p) => await u.post({
      url: `/api/attachments/${f}/upload`,
      body: p,
      json: !1
    }),
    /**
     * Uploads an attachment to the server as a builder user from the builder.
     * @param data the data to upload
     */
    uploadBuilderAttachment: async (f) => await u.post({
      url: "/api/attachments/process",
      body: f,
      json: !1
    }),
    uploadPWAZip: async (f) => await u.post({
      url: "/api/pwa/process-zip",
      body: f,
      json: !1
    }),
    /**
     * Uploads a file to an external datasource.
     * @param datasourceId the ID of the datasource to upload to
     * @param bucket the name of the bucket to upload to
     * @param key the name of the file to upload to
     * @param data the file to upload
     */
    externalUpload: async (f, p, m, b) => {
      const { signedUrl: y, publicUrl: v } = await l.getSignedDatasourceURL(
        f,
        p,
        m
      );
      return y ? (await u.put({
        url: y,
        body: b,
        json: !1,
        external: !0,
        parseResponse: (k) => k
      }), { publicUrl: v }) : { publicUrl: void 0 };
    },
    /**
     * Download an attachment from a row given its column name.
     * @param datasourceId the ID of the datasource to download from
     * @param rowId the ID of the row to download from
     * @param columnName the column name to download
     */
    downloadAttachment: async (f, p, m) => await u.get({
      url: `/api/${f}/rows/${p}/attachment/${m}`,
      parseResponse: (b) => b,
      suppressErrors: !0
    })
  };
}, buildAuthEndpoints = (u) => ({
  /**
   * Performs a login request.
   * @param tenantId the ID of the tenant to log in to
   * @param username the username (email)
   * @param password the password
   */
  logIn: async (l, f, p) => await u.post({
    url: `/api/global/auth/${l}/login`,
    body: {
      username: f,
      password: p
    },
    parseResponse: async (m) => {
      const b = await m.json(), y = m.headers.get(
        "X-Session-Invalidated-Count"
      );
      return {
        ...b,
        invalidatedSessionCount: y ? parseInt(y) : 0
      };
    }
  }),
  /**
   * Logs the user out and invalidates their session.
   */
  logOut: async () => await u.post({
    url: "/api/global/auth/logout"
  }),
  /**
   * Sets initialisation info.
   * @param info the info to set
   */
  setInitInfo: async (l) => await u.post({
    url: "/api/global/auth/init",
    body: l
  }),
  /**
   * Gets the initialisation info.
   */
  getInitInfo: async () => await u.get({
    url: "/api/global/auth/init"
  }),
  /**
   * Sends a password reset email.
   * @param tenantId the ID of the tenant the user is in
   * @param email the email address of the user
   */
  requestForgotPassword: async (l, f) => await u.post({
    url: `/api/global/auth/${l}/reset`,
    body: {
      email: f
    }
  }),
  /**
   * Resets a user's password.
   * @param tenantId the ID of the tenant the user is in
   * @param password the new password to set
   * @param resetCode the reset code to authenticate the request
   */
  resetPassword: async (l, f, p) => await u.post({
    url: `/api/global/auth/${l}/reset/update`,
    body: {
      password: f,
      resetCode: p
    }
  })
}), buildAutomationEndpoints = (u) => ({
  /**
   * Executes an automation. Must have "App Action" trigger.
   * @param automationId the ID of the automation to trigger
   * @param fields the fields to trigger the automation with
   * @param timeout a timeout override
   */
  triggerAutomation: async (l, f, p) => await u.post({
    url: `/api/automations/${l}/trigger`,
    body: { fields: f, timeout: p }
  }),
  /**
   * Tests an automation with data.
   * @param automationId the ID of the automation to test
   * @param data the test data to run against the automation
   */
  testAutomation: async (l, f) => await u.post({
    url: `/api/automations/${l}/test`,
    body: f
  }),
  /**
   * Gets a list of all automations.
   */
  getAutomations: async () => await u.get({
    url: "/api/automations"
  }),
  /**
   * Gets a list of all the definitions for blocks in automations.
   */
  getAutomationDefinitions: async () => await u.get({
    url: "/api/automations/definitions/list"
  }),
  /**
   * Creates an automation.
   * @param automation the automation to create
   */
  createAutomation: async (l) => await u.post({
    url: "/api/automations",
    body: l
  }),
  /**
   * Updates an automation.
   * @param automation the automation to update
   */
  updateAutomation: async (l) => await u.put({
    url: "/api/automations",
    body: l
  }),
  /**
   * Deletes an automation
   * @param automationId the ID of the automation to delete
   * @param automationRev the rev of the automation to delete
   */
  deleteAutomation: async (l, f) => await u.delete({
    url: `/api/automations/${l}/${f}`
  }),
  /**
   * Get the logs for the app, or by automation ID.
   */
  getAutomationLogs: async (l) => await u.post({
    url: "/api/automations/logs/search",
    body: l
  }),
  /**
   * Clears automation log errors (which are creating notification) for
   * automation or the app.
   * @param automationId optional - the ID of the automation to clear errors for.
   * @param appId The app ID to clear errors for.
   */
  clearAutomationLogErrors: async (l, f) => await u.delete({
    url: "/api/automations/logs",
    body: {
      appId: f,
      automationId: l
    }
  })
}), buildConfigEndpoints = (u) => ({
  /**
   * Saves a global config.
   * @param config the config to save
   */
  saveConfig: async (l) => await u.post({
    url: "/api/global/configs",
    body: l
  }),
  /**
   * Gets a global config of a certain type.
   * @param type the type to fetch
   */
  getConfig: async (l) => await u.get({
    url: `/api/global/configs/${l}`
  }),
  /**
   * Deletes a global config
   * @param id the id of the config to delete
   * @param rev the revision of the config to delete
   */
  deleteConfig: async (l, f) => await u.delete({
    url: `/api/global/configs/${l}/${f}`
  }),
  /**
   * Gets the config for a certain tenant.
   * @param tenantId the tenant ID to get the config for
   */
  getTenantConfig: async (l) => await u.get({
    url: `/api/global/configs/public?tenantId=${l}`
  }),
  /**
   * Gets the OIDC config for a certain tenant.
   * @param tenantId the tenant ID to get the config for
   */
  getOIDCConfigs: async (l) => await u.get({
    url: `/api/global/configs/public/oidc?tenantId=${l}`
  }),
  /**
   * Gets the checklist for a specific tenant.
   * @param tenantId the tenant ID to get the checklist for
   */
  getChecklist: async (l) => await u.get({
    url: `/api/global/configs/checklist?tenantId=${l}`
  }),
  /**
   * Updates the company logo for the environment.
   * @param data the logo form data
   */
  uploadLogo: async (l) => await u.post({
    url: "/api/global/configs/upload/settings/logoUrl",
    body: l,
    json: !1
  }),
  /**
   * Updates the company favicon for the environment.
   * @param data the favicon form data
   */
  uploadFavicon: async (l) => await u.post({
    url: "/api/global/configs/upload/settings/faviconUrl",
    body: l,
    json: !1
  }),
  /**
   * Uploads a logo for an OIDC provider.
   * @param name the name of the OIDC provider
   * @param data the logo form data to upload
   */
  uploadOIDCLogo: async (l, f) => await u.post({
    url: `/api/global/configs/upload/logos_oidc/${l}`,
    body: f,
    json: !1
  }),
  /**
   * Gets the list of OIDC logos.
   */
  getOIDCLogos: async () => await u.get({
    url: "/api/global/configs/logos_oidc"
  })
}), buildDatasourceEndpoints = (u) => ({
  /**
   * Gets a list of datasources.
   */
  getDatasources: async () => await u.get({
    url: "/api/datasources"
  }),
  /**
   * Prompts the server to build the schema for a datasource.
   */
  buildDatasourceSchema: async (l, f) => await u.post({
    url: `/api/datasources/${l}/schema`,
    body: {
      tablesFilter: f
    }
  }),
  /**
   * Creates a datasource
   */
  createDatasource: async (l) => await u.post({
    url: "/api/datasources",
    body: l
  }),
  /**
   * Updates a datasource
   */
  updateDatasource: async (l) => await u.put({
    url: `/api/datasources/${l._id}`,
    body: l
  }),
  /**
   * Deletes a datasource.
   */
  deleteDatasource: async (l, f) => await u.delete({
    url: `/api/datasources/${l}/${f}`
  }),
  /**
   * Validate a datasource configuration
   */
  validateDatasource: async (l) => await u.post({
    url: "/api/datasources/verify",
    body: { datasource: l }
  }),
  /**
   * Fetch table names available within the datasource, for filtering out undesired tables
   */
  fetchInfoForDatasource: async (l) => await u.post({
    url: "/api/datasources/info",
    body: { datasource: l }
  }),
  /**
   * Fetch view names and definitions available within the datasource
   */
  fetchViewInfoForDatasource: async (l) => await u.post({
    url: "/api/datasources/views",
    body: { datasource: l }
  }),
  /**
   * Fetches the external schema of a datasource
   */
  fetchExternalSchema: async (l) => await u.get({
    url: `/api/datasources/${l}/schema/external`
  })
}), buildFlagEndpoints = (u) => ({
  /**
   * Gets the current user flags object.
   */
  getFlags: async () => await u.get({
    url: "/api/users/flags"
  }),
  /**
   * Updates a flag for the current user.
   * @param flag the flag to update
   * @param value the value to set the flag to
   */
  updateFlag: async (l, f) => await u.post({
    url: "/api/users/flags",
    body: {
      flag: l,
      value: f
    }
  })
}), buildLayoutEndpoints = (u) => ({
  /**
   * Saves a layout.
   * @param layout the layout to save
   */
  saveLayout: async (l) => await u.post({
    url: "/api/layouts",
    body: l
  }),
  /**
   * Deletes a layout.
   * @param layoutId the ID of the layout to delete
   * @param layoutRev the rev of the layout to delete
   */
  deleteLayout: async (l, f) => await u.delete({
    url: `/api/layouts/${l}/${f}`
  })
}), buildOtherEndpoints = (u) => ({
  /**
   * Gets the current environment details.
   */
  getEnvironment: async () => await u.get({
    url: "/api/system/environment"
  }),
  /**
   * Gets the current system status.
   */
  getSystemStatus: async () => await u.get({
    url: "/api/system/status"
  }),
  /**
   * Gets the list of available integrations.
   */
  getIntegrations: async () => await u.get({
    url: "/api/integrations"
  }),
  /**
   * Gets the version of the installed Budibase environment.
   */
  getBudibaseVersion: async () => (await u.get({
    url: "/api/dev/version"
  })).version,
  /**
   * Gets the base permissions for roles.
   */
  getBasePermissions: async () => await u.get({
    url: "/api/permission/builtin"
  })
}), buildPermissionsEndpoints = (u) => ({
  /**
   * Gets the permission required to access a specific resource
   * @param resourceId the resource ID to check
   */
  getPermissionForResource: async (l) => await u.get({
    url: `/api/permission/${l}`
  }),
  /**
   * Updates the permissions for a certain resource
   * @param resourceId the ID of the resource to update
   * @param roleId the ID of the role to update the permissions of
   * @param level the level to assign the role for this resource
   */
  updatePermissionForResource: async (l, f, p) => await u.post({
    url: `/api/permission/${f}/${l}/${p}`
  }),
  /**
   * Remove the the permissions for a certain resource
   * @param resourceId the ID of the resource to update
   * @param roleId the ID of the role to update the permissions of
   * @param level the level to remove the role for this resource
   */
  removePermissionFromResource: async (l, f, p) => await u.delete({
    url: `/api/permission/${f}/${l}/${p}`
  }),
  /**
   * Gets info about the resources that depend on this resource permissions
   * @param resourceId the resource ID to check
   */
  getDependants: async (l) => await u.get({
    url: `/api/permission/${l}/dependants`
  })
}), buildQueryEndpoints = (u) => ({
  /**
   * Executes a query against an external data connector.
   * @param queryId the ID of the query to execute
   * @param pagination pagination info for the query
   * @param parameters parameters for the query
   */
  executeQuery: async (l, { pagination: f, parameters: p } = {}) => await u.post({
    url: `/api/v2/queries/${l}`,
    body: {
      parameters: p,
      pagination: f
    }
  }),
  /**
   * Fetches the definition of an external query.
   * @param queryId the ID of thr query to fetch the definition of
   */
  fetchQueryDefinition: async (l) => await u.get({
    url: `/api/queries/${l}`,
    cache: !0
  }),
  /**
   * Gets a list of queries
   */
  getQueries: async () => await u.get({
    url: "/api/queries"
  }),
  /**
   * Saves a query.
   * @param query the query to save
   */
  saveQuery: async (l) => await u.post({
    url: "/api/queries",
    body: l
  }),
  /**
   * Deletes a query
   * @param id the ID of the query to delete
   * @param rev the rev of the query to delete
   */
  deleteQuery: async (l, f) => await u.delete({
    url: `/api/queries/${l}/${f}`
  }),
  /**
   * Imports a set of queries into a certain datasource
   */
  importQueries: async (l) => await u.post({
    url: "/api/queries/import",
    body: l
  }),
  /**
   * Runs a query with test parameters to see the result.
   * @param query the query to run
   */
  previewQuery: async (l) => await u.post({
    url: "/api/queries/preview",
    body: l
  })
}), buildRelationshipEndpoints = (u) => ({
  /**
   * Fetches related rows for a certain field of a certain row.
   * @param sourceId the ID of the table to fetch from
   * @param rowId the ID of the row to fetch related rows for
   * @param fieldName the name of the relationship field
   */
  fetchRelationshipData: async (l, f, p) => {
    const m = await u.get({
      url: `/api/${l}/${f}/enrich?field=${p}`
    });
    return p ? m[p] || [] : [m];
  }
}), buildRoleEndpoints = (u) => ({
  /**
   * Deletes a role.
   * @param id the ID of the role to delete
   * @param rev the rev of the role to delete
   */
  deleteRole: async (l, f) => await u.delete({
    url: `/api/roles/${l}/${f}`
  }),
  /**
   * Saves a role.
   * @param role the role to save
   */
  saveRole: async (l) => await u.post({
    url: "/api/roles",
    body: l
  }),
  /**
   * Gets a list of roles.
   */
  getRoles: async () => await u.get({
    url: "/api/roles"
  }),
  /**
   * Gets a list of roles within a specified app.
   */
  getRolesForApp: async (l) => await u.get({
    url: `/api/global/roles/${l}`
  }),
  /**
   * For the logged in user and current app - retrieves accessible roles.
   */
  getAccessibleRoles: async () => await u.get({
    url: "/api/roles/accessible"
  })
}), buildRouteEndpoints = (u) => ({
  /**
   * Fetches available routes for the client app.
   */
  fetchClientAppRoutes: async () => await u.get({
    url: "/api/routing/client"
  }),
  /**
   * Fetches all routes for the current app.
   */
  fetchAppRoutes: async () => await u.get({
    url: "/api/routing"
  })
}), buildRowEndpoints = (u) => ({
  /**
   * Fetches data about a certain row in a data source.
   * @param sourceId the ID of the table or view to fetch from
   * @param rowId the ID of the row to fetch
   */
  fetchRow: async (l, f) => await u.get({
    url: `/api/${l}/rows/${f}`
  }),
  /**
   * Creates or updates a row in a table.
   * @param row the row to save
   * @param suppressErrors whether or not to suppress error notifications
   */
  saveRow: async (l, f = !1) => {
    const p = l._viewId || l.tableId;
    return await u.post({
      url: `/api/${p}/rows`,
      body: l,
      suppressErrors: f
    });
  },
  /**
   * Patches a row in a table.
   * @param row the row to patch
   * @param suppressErrors whether or not to suppress error notifications
   */
  patchRow: async (l, f = !1) => {
    const p = l._viewId || l.tableId;
    return await u.patch({
      url: `/api/${p}/rows`,
      body: l,
      suppressErrors: f
    });
  },
  /**
   * Deletes a row from a table.
   * @param sourceId the ID of the table or view to delete from
   * @param rowId the ID of the row to delete
   */
  deleteRow: async (l, f) => await u.delete({
    url: `/api/${l}/rows`,
    body: {
      _id: f
    }
  }),
  /**
   * Deletes multiple rows from a table.
   * @param sourceId the table or view ID to delete the rows from
   * @param rows the array of rows to delete
   */
  deleteRows: async (l, f) => (f.forEach((p) => {
    typeof p == "object" && (p == null || delete p._viewId);
  }), await u.delete({
    url: `/api/${l}/rows`,
    body: {
      rows: f
    }
  })),
  /**
   * Exports rows.
   * @param tableId the table ID to export the rows from
   * @param format the format to export (csv or json)
   * @param data the export options
   */
  exportRows: async (l, f, p) => await u.post({
    url: `/api/${l}/rows/exportRows?format=${f}`,
    body: p,
    parseResponse: async (m) => await m.text()
  })
}), buildScreenEndpoints = (u) => ({
  /**
   * Saves a screen definition
   * @param screen the screen to save
   */
  saveScreen: async (l) => await u.post({
    url: "/api/screens",
    body: l
  }),
  /**
   * Deletes a screen.
   * @param id the ID of the screen to delete
   * @param rev the rev of the screen to delete
   */
  deleteScreen: async (l, f) => await u.delete({
    url: `/api/screens/${l}/${f}`
  }),
  usageInScreens: async (l) => await u.post({
    url: `/api/screens/usage/${l}`
  })
}), buildTableEndpoints = (u) => ({
  /**
   * Fetches a table definition.
   * Since definitions cannot change at runtime, the result is cached.
   * @param tableId the ID of the table to fetch
   */
  fetchTableDefinition: async (l) => await u.get({
    url: `/api/tables/${l}`,
    cache: !0
  }),
  /**
   * Fetches all rows from a table.
   * @param sourceId the ID of the table to fetch
   */
  fetchTableData: async (l) => await u.get({ url: `/api/${l}/rows` }),
  /**
   * Searches a table using Lucene.
   * @param sourceId the ID of the table to search
   * @param opts the search opts
   */
  searchTable: async (l, f) => await u.post({
    url: `/api/${l}/search`,
    body: f
  }),
  /**
   * Imports data into an existing table
   * @param tableId the table ID to import to
   * @param rows the data import object
   * @param identifierFields column names to be used as keys for overwriting existing rows
   */
  importTableData: async (l, f, p) => await u.post({
    url: `/api/tables/${l}/import`,
    body: {
      rows: f,
      identifierFields: p
    }
  }),
  /**
   * Converts a CSV string to JSON
   * @param csvString the CSV string
   */
  csvToJson: async (l) => await u.post({
    url: "/api/convert/csvToJson",
    body: {
      csvString: l
    }
  }),
  /**
   * Gets a list of tables.
   */
  getTables: async () => await u.get({
    url: "/api/tables"
  }),
  /**
   * Get a single table based on table ID.
   * Dupe of fetchTableDefinition but not cached?
   */
  getTable: async (l) => await u.get({
    url: `/api/tables/${l}`
  }),
  /**
   * Saves a table.
   * @param table the table to save
   */
  saveTable: async (l) => await u.post({
    url: "/api/tables",
    body: l
  }),
  /**
   * Deletes a table.
   * @param id the ID of the table to delete
   * @param rev the rev of the table to delete
   */
  deleteTable: async (l, f) => await u.delete({
    url: `/api/tables/${l}/${f}`
  }),
  validateNewTableImport: async (l, f) => await u.post({
    url: "/api/tables/validateNewTableImport",
    body: {
      rows: l,
      schema: f
    }
  }),
  validateExistingTableImport: async (l, f) => await u.post({
    url: "/api/tables/validateExistingTableImport",
    body: {
      rows: l,
      tableId: f
    }
  }),
  migrateColumn: async (l, f, p) => await u.post({
    url: `/api/tables/${l}/migrate`,
    body: {
      oldColumn: f,
      newColumn: p
    }
  }),
  /**
   * Duplicates a table without its data.
   * @param tableId the ID of the table to duplicate
   */
  duplicateTable: async (l) => await u.post({
    url: `/api/tables/${l}/duplicate`
  })
}), buildTemplateEndpoints = (u) => ({
  /**
   * Gets the list of email template definitions.
   */
  getEmailTemplateDefinitions: async () => await u.get({ url: "/api/global/template/definitions" }),
  /**
   * Gets the list of email templates.
   */
  getEmailTemplates: async () => await u.get({
    url: "/api/global/template/email"
  }),
  /**
   * Saves an email template.
   * @param template the template to save
   */
  saveEmailTemplate: async (l) => await u.post({
    url: "/api/global/template",
    body: l
  }),
  /**
   * Gets a list of app templates.
   */
  getAppTemplates: async () => await u.get({
    url: "/api/templates"
  })
}), buildUserEndpoints = (u) => ({
  /**
   * Gets a list of users in the current tenant.
   */
  getUsers: async () => await u.get({
    url: "/api/global/users"
  }),
  /**
   * Searches a list of users in the current tenant.
   */
  searchUsers: async (l) => await u.post({
    url: "/api/global/users/search",
    body: l
  }),
  /**
   * Get a single user by ID.
   */
  getUser: async (l) => await u.get({
    url: `/api/global/users/${l}`
  }),
  /**
   * Updates the current user metadata.
   * @param metadata the metadata to save
   */
  updateOwnMetadata: async (l) => await u.post({
    url: "/api/users/metadata/self",
    body: l
  }),
  /**
   * Creates an admin user.
   * @param user the admin user to create
   */
  createAdminUser: async (l) => await u.post({
    url: "/api/global/users/init",
    body: l
  }),
  /**
   * Creates or updates a user in the current tenant.
   * @param user the new user to create
   */
  saveUser: async (l) => await u.post({
    url: "/api/global/users",
    body: l
  }),
  /**
   * Creates multiple users.
   * @param users the array of user objects to create
   * @param groups the array of group ids to add all users to
   */
  createUsers: async (l, f) => (await u.post({
    url: "/api/global/users/bulk",
    body: {
      create: {
        users: l,
        groups: f
      }
    }
  })).created,
  /**
   * Deletes a user from the curernt tenant.
   * @param userId the ID of the user to delete
   */
  deleteUser: async (l) => await u.delete({
    url: `/api/global/users/${l}`
  }),
  /**
   * Deletes multiple users
   * @param users the ID/email pair of the user to delete
   */
  deleteUsers: async (l) => (await u.post({
    url: "/api/global/users/bulk",
    body: {
      delete: {
        users: l
      }
    }
  })).deleted,
  /**
   * Onboards multiple users
   */
  onboardUsers: async (l) => await u.post({
    url: "/api/global/users/onboard",
    body: l
  }),
  addWorkspaceIdToInvite: async (l, f) => await u.post({
    url: `/api/global/users/invite/${l}/${f}`
  }),
  removeWorkspaceIdFromInvite: async (l) => await u.delete({
    url: `/api/global/users/invite/${l}`
  }),
  addUserToWorkspace: async (l, f, p) => await u.post({
    url: `/api/global/users/${l}/permission/${f}`,
    body: {
      _rev: p
    }
  }),
  removeUserFromWorkspace: async (l, f) => await u.delete({
    url: `/api/global/users/${l}/permission`,
    body: {
      _rev: f
    }
  }),
  /**
   * Retrieves the invitation associated with a provided code.
   * @param code The unique code for the target invite
   */
  getUserInvite: async (l) => await u.get({
    url: `/api/global/users/invite/${l}`
  }),
  /**
   * Retrieves all user invitations for the current tenant.
   */
  getUserInvites: async () => await u.get({
    url: "/api/global/users/invites"
  }),
  /**
   * Invites multiple users to the current tenant.
   * @param users An array of users to invite
   */
  inviteUsers: async (l) => await u.post({
    url: "/api/global/users/multi/invite",
    body: l
  }),
  /**
   * Removes multiple user invites from Redis cache
   */
  removeUserInvites: async (l) => await u.post({
    url: "/api/global/users/multi/invite/delete",
    body: l
  }),
  /**
   * Accepts an invite to join the platform and creates a user.
   */
  acceptInvite: async (l) => await u.post({
    url: "/api/global/users/invite/accept",
    body: l
  }),
  /**
   * Counts the number of users in an app
   */
  getUserCountByApp: async (l) => (await u.get({
    url: `/api/global/users/count/${l}`
  })).userCount,
  /**
   * Gets the account holder of the current tenant
   */
  getAccountHolder: async () => await u.get({
    url: "/api/global/users/accountholder"
  })
}), buildSelfEndpoints = (u) => ({
  /**
   * Using the logged in user, this will generate a new API key,
   * assuming the user is a builder.
   */
  generateAPIKey: async () => {
    const l = await u.post({
      url: "/api/global/self/api_key"
    });
    return l == null ? void 0 : l.apiKey;
  },
  /**
   * retrieves the API key for the logged in user.
   */
  fetchDeveloperInfo: async () => u.get({
    url: "/api/global/self/api_key"
  }),
  /**
   * Fetches the currently logged-in user object.
   * Used in client apps.
   */
  fetchSelf: async () => await u.get({
    url: "/api/self"
  }),
  /**
   * Fetches the currently logged-in user object.
   * Used in the builder.
   */
  fetchBuilderSelf: async () => await u.get({
    url: "/api/global/self"
  }),
  /**
   * Updates the current logged-in user.
   * @param user the new user object to save
   */
  updateSelf: async (l) => await u.post({
    url: "/api/global/self",
    body: l
  })
}), buildViewEndpoints = (u) => ({
  /**
   * Fetches all rows in a view
   * @param name the name of the view
   * @param field the field to perform the calculation on
   * @param groupBy the field to group by
   * @param calculation the calculation to perform
   */
  fetchViewData: async (l, { field: f, groupBy: p, calculation: m }) => {
    const b = new URLSearchParams();
    m && (f && b.set("field", f), b.set("calculation", m)), p && b.set("group", p);
    const y = f ? `/api/views/${encodeURIComponent(l)}?${b}` : `/api/views/${encodeURIComponent(l)}`;
    return await u.get({ url: y });
  },
  /**
   * Exports a view for download
   * @param name the view to export
   * @param format the format to download
   */
  exportView: async (l, f) => {
    const p = encodeURIComponent(l);
    return await u.get({
      url: `/api/views/export?view=${p}&format=${f}`,
      parseResponse: async (m) => await m.text()
    });
  },
  /**
   * Saves a view.
   * @param view the view to save
   */
  saveView: async (l) => await u.post({
    url: "/api/views",
    body: l
  }),
  /**
   * Deletes a view.
   * @param viewName the name of the view to delete
   */
  deleteView: async (l) => await u.delete({
    url: `/api/views/${encodeURIComponent(l)}`
  })
}), buildViewV2Endpoints = (u) => ({
  /**
   * Fetches the definition of a view
   * @param viewId the ID of the view to fetch
   */
  fetchDefinition: async (l) => await u.get({
    url: `/api/v2/views/${encodeURIComponent(l)}`,
    cache: !0
  }),
  /**
   * Create a new view
   * @param view the view object
   */
  create: async (l) => await u.post({
    url: "/api/v2/views",
    body: l
  }),
  /**
   * Updates a view
   * @param view the view object
   */
  update: async (l) => await u.put({
    url: `/api/v2/views/${encodeURIComponent(l.id)}`,
    body: l
  }),
  /**
   * Fetches all rows in a view
   * @param viewId the id of the view
   * @param opts the search options
   */
  fetch: async (l, f) => await u.post({
    url: `/api/v2/views/${encodeURIComponent(l)}/search`,
    body: f
  }),
  /**
   * Delete a view
   * @param viewId the id of the view
   */
  delete: async (l) => await u.delete({
    url: `/api/v2/views/${encodeURIComponent(l)}`
  })
}), buildLicensingEndpoints = (u) => ({
  // LICENSE KEY
  activateLicenseKey: async (l) => u.post({
    url: "/api/global/license/key",
    body: { licenseKey: l }
  }),
  deleteLicenseKey: async () => u.delete({
    url: "/api/global/license/key"
  }),
  getLicenseKey: async () => {
    try {
      return await u.get({
        url: "/api/global/license/key"
      });
    } catch (l) {
      if (l.status !== 404)
        throw l;
    }
  },
  // INSTALL ID
  getInstallInfo: async () => {
    try {
      return await u.get({
        url: "/api/global/install"
      });
    } catch (l) {
      if (l.status !== 404)
        throw l;
    }
  },
  // OFFLINE LICENSE
  activateOfflineLicense: async (l) => u.post({
    url: "/api/global/license/offline",
    body: {
      offlineLicenseToken: l
    }
  }),
  deleteOfflineLicense: async () => u.delete({
    url: "/api/global/license/offline"
  }),
  getOfflineLicense: async () => {
    try {
      return await u.get({
        url: "/api/global/license/offline"
      });
    } catch (l) {
      if (l.status !== 404)
        throw l;
    }
  },
  getOfflineLicenseIdentifier: async () => await u.get({
    url: "/api/global/license/offline/identifier"
  }),
  /**
   * Refreshes the license cache
   */
  refreshLicense: async () => u.post({
    url: "/api/global/license/refresh"
  }),
  /**
   * Retrieve the usage information for the tenant
   */
  getQuotaUsage: async () => u.get({
    url: "/api/global/license/usage"
  })
}), buildGroupsEndpoints = (u) => {
  async function l(f, p, m, b) {
    return await u.post({
      url: `/api/global/groups/${f}/${p}`,
      body: {
        [m]: b
      }
    });
  }
  return {
    /**
     * Creates a user group.
     * @param group the new group to create
     */
    saveGroup: async (f) => await u.post({
      url: "/api/global/groups",
      body: f
    }),
    /**
     * Gets all the user groups
     */
    getGroups: async () => (await u.get({
      url: "/api/global/groups"
    })).data,
    /**
     * Gets a group by ID
     */
    getGroup: async (f) => await u.get({
      url: `/api/global/groups/${f}`
    }),
    /**
     * Deletes a user group
     * @param id the id of the config to delete
     * @param rev the revision of the config to delete
     */
    deleteGroup: async (f, p) => await u.delete({
      url: `/api/global/groups/${f}/${p}`
    }),
    /**
     * Gets a group users by the group id
     */
    getGroupUsers: async ({ id: f, bookmark: p, emailSearch: m }) => {
      let b = `/api/global/groups/${f}/users?`;
      return p && (b += `bookmark=${p}&`), m && (b += `emailSearch=${m}`), await u.get({
        url: b
      });
    },
    /**
     * Adds users to a group
     * @param groupId The group to update
     * @param userIds The user IDs to be added
     */
    addUsersToGroup: async (f, p) => l(
      f,
      "users",
      "add",
      p
    ),
    /**
     * Removes users from a group
     * @param groupId The group to update
     * @param userIds The user IDs to be removed
     */
    removeUsersFromGroup: async (f, p) => l(
      f,
      "users",
      "remove",
      p
    ),
    /**
     * Adds apps to a group
     * @param groupId The group to update
     * @param appArray Array of objects, containing the appId and roleId to be added
     */
    addAppsToGroup: async (f, p) => l(
      f,
      "apps",
      "add",
      p
    ),
    /**
     * Removes apps from a group
     * @param groupId The group to update
     * @param appArray Array of objects, containing the appId to be removed
     */
    removeAppsFromGroup: async (f, p) => l(
      f,
      "apps",
      "remove",
      p
    ),
    /**
     * Bulk add users to group from CSV content
     * @param groupId The group to update
     * @param csvContent The CSV content with email addresses
     */
    bulkAddUsersFromCsv: async (f, p) => await u.post({
      url: `/api/global/groups/${f}/users/bulk`,
      body: { csvContent: p }
    })
  };
}, buildPluginEndpoints = (u) => ({
  /**
   * Uploads a plugin tarball bundle
   * @param data the plugin tarball bundle to upload
   */
  uploadPlugin: async (l) => await u.post({
    url: "/api/plugin/upload",
    body: l,
    json: !1
  }),
  /**
   * Creates a plugin from URL, Github or NPM
   */
  createPlugin: async (l) => await u.post({
    url: "/api/plugin",
    body: l
  }),
  /**
   * Gets a list of all plugins
   */
  getPlugins: async () => await u.get({
    url: "/api/plugin"
  }),
  /**
   * Deletes a plugin.
   * @param pluginId the ID of the plugin to delete
   *
   * * @param pluginId the revision of the plugin to delete
   */
  deletePlugin: async (l) => await u.delete({
    url: `/api/plugin/${encodeURIComponent(l)}`
  })
}), buildBackupEndpoints = (u) => ({
  createManualBackup: async (l) => await u.post({
    url: `/api/apps/${l}/backups`
  }),
  searchBackups: async (l, f) => await u.post({
    url: `/api/apps/${l}/backups/search`,
    body: f
  }),
  deleteBackup: async (l, f) => await u.delete({
    url: `/api/apps/${l}/backups/${f}`
  }),
  deleteBackups: async (l, f) => await u.delete({
    url: `/api/apps/${l}/backups`,
    body: { backupIds: f }
  }),
  restoreBackup: async (l, f, p) => await u.post({
    url: `/api/apps/${l}/backups/${f}/import`,
    // Name is a legacy thing, but unsure if it is needed for restoring.
    // Leaving this in just in case, but not type casting the body here
    // as we won't normally have it, but it's required in the type.
    body: { name: p }
  }),
  clearBackupErrors: async (l, f) => await u.delete({
    url: "/api/backups/logs",
    body: { appId: l, backupId: f }
  })
}), buildEnvironmentVariableEndpoints = (u) => ({
  checkEnvironmentVariableStatus: async () => await u.get({
    url: "/api/env/variables/status"
  }),
  fetchEnvironmentVariables: async () => await u.get({
    url: "/api/env/variables",
    json: !1
  }),
  createEnvironmentVariable: async (l) => await u.post({
    url: "/api/env/variables",
    body: l
  }),
  deleteEnvironmentVariable: async (l) => await u.delete({
    url: `/api/env/variables/${l}`
  }),
  updateEnvironmentVariable: async (l, f) => await u.patch({
    url: `/api/env/variables/${l}`,
    body: f
  })
}), buildEventEndpoints = (u) => ({
  publishEvent: async (l) => await u.post({
    url: "/api/global/event/publish",
    body: {
      type: l
    }
  })
}), buildAuditLogEndpoints = (u) => ({
  searchAuditLogs: async (l) => await u.post({
    url: "/api/global/auditlogs/search",
    body: l
  }),
  getEventDefinitions: async () => await u.get({
    url: "/api/global/auditlogs/definitions"
  }),
  getDownloadUrl: (l) => `/api/global/auditlogs/download?query=${encodeURIComponent(JSON.stringify(l))}`
}), buildLogsEndpoints = (u) => ({
  /**
   * Gets a stream for the system logs.
   */
  getSystemLogs: async () => await u.get({
    url: "/api/system/logs",
    json: !1,
    parseResponse: async (l) => l
  })
}), buildMigrationEndpoints = (u) => ({
  /**
   * Gets the info about the current app migration
   */
  getMigrationStatus: async () => await u.get({
    url: "/api/migrations/status"
  })
}), buildRowActionEndpoints = (u) => ({
  /**
   * Gets the available row actions for a table.
   * @param tableId the ID of the table
   */
  fetch: async (l) => (await u.get({
    url: `/api/tables/${l}/actions`
  })).actions,
  /**
   * Creates a row action.
   * @param name the name of the row action
   * @param tableId the ID of the table
   */
  create: async (l, f) => await u.post({
    url: `/api/tables/${l}/actions`,
    body: {
      name: f
    }
  }),
  /**
   * Deletes a row action.
   * @param tableId the ID of the table
   * @param rowActionId the ID of the row action to delete
   */
  delete: async (l, f) => await u.delete({
    url: `/api/tables/${l}/actions/${f}`
  }),
  /**
   * Enables a row action for a certain view
   * @param tableId the ID of the parent table
   * @param rowActionId the ID of the row action
   * @param viewId the ID of the view
   */
  enableView: async (l, f, p) => await u.post({
    url: `/api/tables/${l}/actions/${f}/permissions/${p}`
  }),
  /**
   * Disables a row action for a certain view
   * @param tableId the ID of the parent table
   * @param rowActionId the ID of the row action
   * @param viewId the ID of the view
   */
  disableView: async (l, f, p) => await u.delete({
    url: `/api/tables/${l}/actions/${f}/permissions/${p}`
  }),
  /**
   * Triggers a row action.
   * @param tableId the ID of the table
   * @param rowActionId the ID of the row action to trigger
   */
  trigger: async (l, f, p) => await u.post({
    url: `/api/tables/${l}/actions/${f}/trigger`,
    body: {
      rowId: p
    }
  })
}), buildOAuth2Endpoints = (u) => ({
  /**
   * Gets all OAuth2 configurations for the app.
   */
  fetch: async () => (await u.get({
    url: "/api/oauth2"
  })).configs,
  /**
   * Creates a OAuth2 configuration.
   */
  create: async (l) => await u.post({
    url: "/api/oauth2",
    body: {
      ...l
    }
  }),
  /**
   * Updates an existing OAuth2 configuration.
   */
  update: async (l) => await u.put(
    {
      url: `/api/oauth2/${l._id}`,
      body: {
        ...l
      }
    }
  ),
  /**
   * Deletes an OAuth2 configuration by its id.
   * @param id the ID of the OAuth2 config
   * @param rev the rev of the OAuth2 config
   */
  delete: async (l, f) => await u.delete({
    url: `/api/oauth2/${l}/${f}`
  }),
  validate: async function(l) {
    return await u.post({
      url: "/api/oauth2/validate",
      body: {
        ...l
      }
    });
  }
}), buildAgentEndpoints = (u) => ({
  agentChat: async (l) => {
    const f = l;
    return await u.post({
      url: "/api/agent/chat",
      body: f
    });
  },
  agentChatStream: async (l, f, p, m) => {
    var y;
    const b = l;
    try {
      const v = await fetch("/api/agent/chat/stream", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          [Header.APP_ID]: f
        },
        body: JSON.stringify(b),
        credentials: "same-origin"
      });
      if (!v.ok)
        throw new Error(`HTTP error! status: ${v.status}`);
      const k = (y = v.body) == null ? void 0 : y.getReader();
      if (!k)
        throw new Error("Failed to get response reader");
      const S = new TextDecoder();
      let $ = "";
      for (; ; ) {
        const { done: w, value: T } = await k.read();
        if (w)
          break;
        $ += S.decode(T, { stream: !0 });
        const E = $.split(`
`);
        $ = E.pop() || "";
        for (const R of E)
          if (R.startsWith("data: "))
            try {
              const O = R.slice(6);
              if (O.trim()) {
                const P = JSON.parse(O);
                p(P);
              }
            } catch (O) {
              console.error("Failed to parse SSE data:", O);
            }
      }
    } catch (v) {
      if (m)
        m(v);
      else
        throw v;
    }
  },
  removeChat: async (l) => await u.delete({
    url: `/api/agent/history/${l}`
  }),
  fetchChats: async () => await u.get({
    url: "/api/agent/history"
  }),
  fetchToolSources: async () => await u.get({
    url: "/api/agent/toolsource"
  }),
  createToolSource: async (l) => await u.post({
    url: "/api/agent/toolsource",
    body: l
  }),
  updateToolSource: async (l) => await u.put({
    url: "/api/agent/toolsource",
    body: l
  }),
  deleteToolSource: async (l) => await u.delete({
    url: `/api/agent/toolsource/${l}`
  })
}), buildFeatureFlagEndpoints = (u) => ({
  overrideFeatureFlags: async (l) => {
    const f = { flags: l };
    return await u.patch({
      url: "/api/features",
      body: f,
      parseResponse: () => {
      }
    });
  }
}), buildNavigationEndpoints = (u) => ({
  updateNavigation: async (l, f) => await u.put({
    url: `/api/navigation/${l}`,
    body: f
  })
}), buildWorkspaceAppEndpoints = (u) => ({
  find: async (l) => await u.get({
    url: `/api/workspaceApp/${l}`
  }),
  fetch: async () => await u.get({
    url: "/api/workspaceApp"
  }),
  create: async (l) => await u.post({
    url: "/api/workspaceApp",
    body: l
  }),
  duplicate: async (l) => await u.post({
    url: `/api/workspaceApp/${l}/duplicate`
  }),
  update: async (l) => await u.put({
    url: `/api/workspaceApp/${l._id}`,
    body: l
  }),
  delete: async (l, f) => await u.delete({
    url: `/api/workspaceApp/${l}/${f}`
  })
}), buildResourceEndpoints = (u) => ({
  getResourcesInfo: async () => await u.get({
    url: "/api/resources"
  }),
  duplicateResourceToWorkspace: async (l) => await u.post({
    url: "/api/resources/duplicate",
    body: l
  })
}), buildDeploymentEndpoints = (u) => ({
  getPublishStatus: async () => await u.get({
    url: "/api/deploy/status"
  })
}), buildWorkspaceFavouriteEndpoints = (u) => ({
  fetch: async () => await u.get({
    url: "/api/workspace/favourites"
  }),
  create: async (l) => await u.post({
    url: "/api/workspace/favourites",
    body: l
  }),
  delete: async (l, f) => await u.delete({
    url: `/api/workspace/favourites/${l}/${f}`
  })
}), buildRecaptchaEndpoints = (u) => ({
  verify: async (l) => await u.post({
    url: "/api/recaptcha/verify",
    body: {
      token: l
    }
  }),
  check: async () => await u.get({
    url: "/api/recaptcha/check"
  })
}), APISessionID = uuid(), createAPIClient = (u = {}) => {
  let l = {};
  const f = async (S, $, w = !1) => {
    let T = S.statusText, E = null;
    try {
      E = await S.json(), E != null && E.message ? T = E.message : E != null && E.error && (T = JSON.stringify(E.error));
    } catch {
    }
    return {
      message: T,
      json: E,
      status: S.status,
      url: S.url,
      method: $,
      handled: !0,
      suppressErrors: w
    };
  }, p = (S, $, w) => ({
    message: S,
    json: null,
    status: 400,
    url: $,
    method: w,
    handled: !0,
    suppressErrors: !1
  }), m = async (S) => {
    let { json: $, method: w, external: T, body: E, url: R, parseResponse: O, suppressErrors: P } = S;
    $ = $ && w !== HTTPMethod.GET;
    let L = { Accept: "application/json" };
    L[Header.SESSION_ID] = APISessionID, T || (L[Header.API_VER] = ApiVersion), $ && (L["Content-Type"] = "application/json"), u != null && u.attachHeaders && u.attachHeaders(L);
    let M = E;
    if ($)
      try {
        M = JSON.stringify(E);
      } catch {
        throw p("Invalid JSON body", R, w);
      }
    let B;
    try {
      B = await fetch(R, {
        method: w,
        headers: L,
        body: M,
        credentials: "same-origin"
      });
    } catch {
      throw delete l[R], p("Failed to send request", R, w);
    }
    if (B.status >= 200 && B.status < 400) {
      b(B);
      try {
        return B.status === 204 ? void 0 : O ? await O(B) : await B.json();
      } catch (j) {
        throw delete l[R], `Failed to parse response: ${j}`;
      }
    } else
      throw delete l[R], await f(B, w, P);
  }, b = (S) => {
    if (!u.onMigrationDetected)
      return;
    const $ = S.headers.get(Header.MIGRATING_APP);
    $ && u.onMigrationDetected($);
  }, y = async (S) => {
    const $ = S.url;
    return l[$] || (l[$] = m(S), l[$] = await l[$]), await l[$];
  }, v = (S) => async ($) => {
    try {
      let w = {
        json: !0,
        external: !1,
        suppressErrors: !1,
        cache: !1,
        method: S,
        ...$
      }, { url: T, cache: E, external: R } = w;
      return R || (w.url = `/${T}`.replace("//", "/")), await (E && (u == null ? void 0 : u.enableCaching) ? y : m)(w);
    } catch (w) {
      throw u != null && u.onError && u.onError(w), w;
    }
  };
  let k = {
    post: v(HTTPMethod.POST),
    get: v(HTTPMethod.GET),
    patch: v(HTTPMethod.PATCH),
    delete: v(HTTPMethod.DELETE),
    put: v(HTTPMethod.PUT),
    invalidateCache: () => {
      l = {};
    },
    // Generic utility to extract the current app ID. Assumes that any client
    // that exists in an app context will be attaching our app ID header.
    getAppID: () => {
      var $;
      let S = {};
      return ($ = u == null ? void 0 : u.attachHeaders) == null || $.call(u, S), S == null ? void 0 : S[Header.APP_ID];
    }
  };
  return {
    ...k,
    ...buildAIEndpoints(k),
    ...buildAnalyticsEndpoints(k),
    ...buildAppEndpoints(k),
    ...buildAttachmentEndpoints(k),
    ...buildAuthEndpoints(k),
    ...buildAutomationEndpoints(k),
    ...buildConfigEndpoints(k),
    ...buildDatasourceEndpoints(k),
    ...buildFlagEndpoints(k),
    ...buildLayoutEndpoints(k),
    ...buildOtherEndpoints(k),
    ...buildPermissionsEndpoints(k),
    ...buildQueryEndpoints(k),
    ...buildRelationshipEndpoints(k),
    ...buildRoleEndpoints(k),
    ...buildRouteEndpoints(k),
    ...buildRowEndpoints(k),
    ...buildScreenEndpoints(k),
    ...buildTableEndpoints(k),
    ...buildTemplateEndpoints(k),
    ...buildUserEndpoints(k),
    ...buildViewEndpoints(k),
    ...buildSelfEndpoints(k),
    ...buildLicensingEndpoints(k),
    ...buildGroupsEndpoints(k),
    ...buildPluginEndpoints(k),
    ...buildBackupEndpoints(k),
    ...buildEnvironmentVariableEndpoints(k),
    ...buildEventEndpoints(k),
    ...buildAuditLogEndpoints(k),
    ...buildLogsEndpoints(k),
    ...buildMigrationEndpoints(k),
    ...buildAgentEndpoints(k),
    ...buildFeatureFlagEndpoints(k),
    deployment: buildDeploymentEndpoints(k),
    viewV2: buildViewV2Endpoints(k),
    rowActions: buildRowActionEndpoints(k),
    oauth2: buildOAuth2Endpoints(k),
    navigation: buildNavigationEndpoints(k),
    workspaceApp: buildWorkspaceAppEndpoints(k),
    workspace: buildWorkspaceFavouriteEndpoints(k),
    resource: buildResourceEndpoints(k),
    recaptcha: buildRecaptchaEndpoints(k)
  };
};
var _mapping = {};
(function(u) {
  u.aliasToReal = {
    // Lodash aliases.
    each: "forEach",
    eachRight: "forEachRight",
    entries: "toPairs",
    entriesIn: "toPairsIn",
    extend: "assignIn",
    extendAll: "assignInAll",
    extendAllWith: "assignInAllWith",
    extendWith: "assignInWith",
    first: "head",
    // Methods that are curried variants of others.
    conforms: "conformsTo",
    matches: "isMatch",
    property: "get",
    // Ramda aliases.
    __: "placeholder",
    F: "stubFalse",
    T: "stubTrue",
    all: "every",
    allPass: "overEvery",
    always: "constant",
    any: "some",
    anyPass: "overSome",
    apply: "spread",
    assoc: "set",
    assocPath: "set",
    complement: "negate",
    compose: "flowRight",
    contains: "includes",
    dissoc: "unset",
    dissocPath: "unset",
    dropLast: "dropRight",
    dropLastWhile: "dropRightWhile",
    equals: "isEqual",
    identical: "eq",
    indexBy: "keyBy",
    init: "initial",
    invertObj: "invert",
    juxt: "over",
    omitAll: "omit",
    nAry: "ary",
    path: "get",
    pathEq: "matchesProperty",
    pathOr: "getOr",
    paths: "at",
    pickAll: "pick",
    pipe: "flow",
    pluck: "map",
    prop: "get",
    propEq: "matchesProperty",
    propOr: "getOr",
    props: "at",
    symmetricDifference: "xor",
    symmetricDifferenceBy: "xorBy",
    symmetricDifferenceWith: "xorWith",
    takeLast: "takeRight",
    takeLastWhile: "takeRightWhile",
    unapply: "rest",
    unnest: "flatten",
    useWith: "overArgs",
    where: "conformsTo",
    whereEq: "isMatch",
    zipObj: "zipObject"
  }, u.aryMethod = {
    1: [
      "assignAll",
      "assignInAll",
      "attempt",
      "castArray",
      "ceil",
      "create",
      "curry",
      "curryRight",
      "defaultsAll",
      "defaultsDeepAll",
      "floor",
      "flow",
      "flowRight",
      "fromPairs",
      "invert",
      "iteratee",
      "memoize",
      "method",
      "mergeAll",
      "methodOf",
      "mixin",
      "nthArg",
      "over",
      "overEvery",
      "overSome",
      "rest",
      "reverse",
      "round",
      "runInContext",
      "spread",
      "template",
      "trim",
      "trimEnd",
      "trimStart",
      "uniqueId",
      "words",
      "zipAll"
    ],
    2: [
      "add",
      "after",
      "ary",
      "assign",
      "assignAllWith",
      "assignIn",
      "assignInAllWith",
      "at",
      "before",
      "bind",
      "bindAll",
      "bindKey",
      "chunk",
      "cloneDeepWith",
      "cloneWith",
      "concat",
      "conformsTo",
      "countBy",
      "curryN",
      "curryRightN",
      "debounce",
      "defaults",
      "defaultsDeep",
      "defaultTo",
      "delay",
      "difference",
      "divide",
      "drop",
      "dropRight",
      "dropRightWhile",
      "dropWhile",
      "endsWith",
      "eq",
      "every",
      "filter",
      "find",
      "findIndex",
      "findKey",
      "findLast",
      "findLastIndex",
      "findLastKey",
      "flatMap",
      "flatMapDeep",
      "flattenDepth",
      "forEach",
      "forEachRight",
      "forIn",
      "forInRight",
      "forOwn",
      "forOwnRight",
      "get",
      "groupBy",
      "gt",
      "gte",
      "has",
      "hasIn",
      "includes",
      "indexOf",
      "intersection",
      "invertBy",
      "invoke",
      "invokeMap",
      "isEqual",
      "isMatch",
      "join",
      "keyBy",
      "lastIndexOf",
      "lt",
      "lte",
      "map",
      "mapKeys",
      "mapValues",
      "matchesProperty",
      "maxBy",
      "meanBy",
      "merge",
      "mergeAllWith",
      "minBy",
      "multiply",
      "nth",
      "omit",
      "omitBy",
      "overArgs",
      "pad",
      "padEnd",
      "padStart",
      "parseInt",
      "partial",
      "partialRight",
      "partition",
      "pick",
      "pickBy",
      "propertyOf",
      "pull",
      "pullAll",
      "pullAt",
      "random",
      "range",
      "rangeRight",
      "rearg",
      "reject",
      "remove",
      "repeat",
      "restFrom",
      "result",
      "sampleSize",
      "some",
      "sortBy",
      "sortedIndex",
      "sortedIndexOf",
      "sortedLastIndex",
      "sortedLastIndexOf",
      "sortedUniqBy",
      "split",
      "spreadFrom",
      "startsWith",
      "subtract",
      "sumBy",
      "take",
      "takeRight",
      "takeRightWhile",
      "takeWhile",
      "tap",
      "throttle",
      "thru",
      "times",
      "trimChars",
      "trimCharsEnd",
      "trimCharsStart",
      "truncate",
      "union",
      "uniqBy",
      "uniqWith",
      "unset",
      "unzipWith",
      "without",
      "wrap",
      "xor",
      "zip",
      "zipObject",
      "zipObjectDeep"
    ],
    3: [
      "assignInWith",
      "assignWith",
      "clamp",
      "differenceBy",
      "differenceWith",
      "findFrom",
      "findIndexFrom",
      "findLastFrom",
      "findLastIndexFrom",
      "getOr",
      "includesFrom",
      "indexOfFrom",
      "inRange",
      "intersectionBy",
      "intersectionWith",
      "invokeArgs",
      "invokeArgsMap",
      "isEqualWith",
      "isMatchWith",
      "flatMapDepth",
      "lastIndexOfFrom",
      "mergeWith",
      "orderBy",
      "padChars",
      "padCharsEnd",
      "padCharsStart",
      "pullAllBy",
      "pullAllWith",
      "rangeStep",
      "rangeStepRight",
      "reduce",
      "reduceRight",
      "replace",
      "set",
      "slice",
      "sortedIndexBy",
      "sortedLastIndexBy",
      "transform",
      "unionBy",
      "unionWith",
      "update",
      "xorBy",
      "xorWith",
      "zipWith"
    ],
    4: [
      "fill",
      "setWith",
      "updateWith"
    ]
  }, u.aryRearg = {
    2: [1, 0],
    3: [2, 0, 1],
    4: [3, 2, 0, 1]
  }, u.iterateeAry = {
    dropRightWhile: 1,
    dropWhile: 1,
    every: 1,
    filter: 1,
    find: 1,
    findFrom: 1,
    findIndex: 1,
    findIndexFrom: 1,
    findKey: 1,
    findLast: 1,
    findLastFrom: 1,
    findLastIndex: 1,
    findLastIndexFrom: 1,
    findLastKey: 1,
    flatMap: 1,
    flatMapDeep: 1,
    flatMapDepth: 1,
    forEach: 1,
    forEachRight: 1,
    forIn: 1,
    forInRight: 1,
    forOwn: 1,
    forOwnRight: 1,
    map: 1,
    mapKeys: 1,
    mapValues: 1,
    partition: 1,
    reduce: 2,
    reduceRight: 2,
    reject: 1,
    remove: 1,
    some: 1,
    takeRightWhile: 1,
    takeWhile: 1,
    times: 1,
    transform: 2
  }, u.iterateeRearg = {
    mapKeys: [1],
    reduceRight: [1, 0]
  }, u.methodRearg = {
    assignInAllWith: [1, 0],
    assignInWith: [1, 2, 0],
    assignAllWith: [1, 0],
    assignWith: [1, 2, 0],
    differenceBy: [1, 2, 0],
    differenceWith: [1, 2, 0],
    getOr: [2, 1, 0],
    intersectionBy: [1, 2, 0],
    intersectionWith: [1, 2, 0],
    isEqualWith: [1, 2, 0],
    isMatchWith: [2, 1, 0],
    mergeAllWith: [1, 0],
    mergeWith: [1, 2, 0],
    padChars: [2, 1, 0],
    padCharsEnd: [2, 1, 0],
    padCharsStart: [2, 1, 0],
    pullAllBy: [2, 1, 0],
    pullAllWith: [2, 1, 0],
    rangeStep: [1, 2, 0],
    rangeStepRight: [1, 2, 0],
    setWith: [3, 1, 2, 0],
    sortedIndexBy: [2, 1, 0],
    sortedLastIndexBy: [2, 1, 0],
    unionBy: [1, 2, 0],
    unionWith: [1, 2, 0],
    updateWith: [3, 1, 2, 0],
    xorBy: [1, 2, 0],
    xorWith: [1, 2, 0],
    zipWith: [1, 2, 0]
  }, u.methodSpread = {
    assignAll: { start: 0 },
    assignAllWith: { start: 0 },
    assignInAll: { start: 0 },
    assignInAllWith: { start: 0 },
    defaultsAll: { start: 0 },
    defaultsDeepAll: { start: 0 },
    invokeArgs: { start: 2 },
    invokeArgsMap: { start: 2 },
    mergeAll: { start: 0 },
    mergeAllWith: { start: 0 },
    partial: { start: 1 },
    partialRight: { start: 1 },
    without: { start: 1 },
    zipAll: { start: 0 }
  }, u.mutate = {
    array: {
      fill: !0,
      pull: !0,
      pullAll: !0,
      pullAllBy: !0,
      pullAllWith: !0,
      pullAt: !0,
      remove: !0,
      reverse: !0
    },
    object: {
      assign: !0,
      assignAll: !0,
      assignAllWith: !0,
      assignIn: !0,
      assignInAll: !0,
      assignInAllWith: !0,
      assignInWith: !0,
      assignWith: !0,
      defaults: !0,
      defaultsAll: !0,
      defaultsDeep: !0,
      defaultsDeepAll: !0,
      merge: !0,
      mergeAll: !0,
      mergeAllWith: !0,
      mergeWith: !0
    },
    set: {
      set: !0,
      setWith: !0,
      unset: !0,
      update: !0,
      updateWith: !0
    }
  }, u.realToAlias = function() {
    var l = Object.prototype.hasOwnProperty, f = u.aliasToReal, p = {};
    for (var m in f) {
      var b = f[m];
      l.call(p, b) ? p[b].push(m) : p[b] = [m];
    }
    return p;
  }(), u.remap = {
    assignAll: "assign",
    assignAllWith: "assignWith",
    assignInAll: "assignIn",
    assignInAllWith: "assignInWith",
    curryN: "curry",
    curryRightN: "curryRight",
    defaultsAll: "defaults",
    defaultsDeepAll: "defaultsDeep",
    findFrom: "find",
    findIndexFrom: "findIndex",
    findLastFrom: "findLast",
    findLastIndexFrom: "findLastIndex",
    getOr: "get",
    includesFrom: "includes",
    indexOfFrom: "indexOf",
    invokeArgs: "invoke",
    invokeArgsMap: "invokeMap",
    lastIndexOfFrom: "lastIndexOf",
    mergeAll: "merge",
    mergeAllWith: "mergeWith",
    padChars: "pad",
    padCharsEnd: "padEnd",
    padCharsStart: "padStart",
    propertyOf: "get",
    rangeStep: "range",
    rangeStepRight: "rangeRight",
    restFrom: "rest",
    spreadFrom: "spread",
    trimChars: "trim",
    trimCharsEnd: "trimEnd",
    trimCharsStart: "trimStart",
    zipAll: "zip"
  }, u.skipFixed = {
    castArray: !0,
    flow: !0,
    flowRight: !0,
    iteratee: !0,
    mixin: !0,
    rearg: !0,
    runInContext: !0
  }, u.skipRearg = {
    add: !0,
    assign: !0,
    assignIn: !0,
    bind: !0,
    bindKey: !0,
    concat: !0,
    difference: !0,
    divide: !0,
    eq: !0,
    gt: !0,
    gte: !0,
    isEqual: !0,
    lt: !0,
    lte: !0,
    matchesProperty: !0,
    merge: !0,
    multiply: !0,
    overArgs: !0,
    partial: !0,
    partialRight: !0,
    propertyOf: !0,
    random: !0,
    range: !0,
    rangeRight: !0,
    subtract: !0,
    zip: !0,
    zipObject: !0,
    zipObjectDeep: !0
  };
})(_mapping);
var placeholder, hasRequiredPlaceholder;
function requirePlaceholder() {
  return hasRequiredPlaceholder || (hasRequiredPlaceholder = 1, placeholder = {}), placeholder;
}
var mapping = _mapping, fallbackHolder = requirePlaceholder(), push$1 = Array.prototype.push;
function baseArity(u, l) {
  return l == 2 ? function(f, p) {
    return u.apply(void 0, arguments);
  } : function(f) {
    return u.apply(void 0, arguments);
  };
}
function baseAry(u, l) {
  return l == 2 ? function(f, p) {
    return u(f, p);
  } : function(f) {
    return u(f);
  };
}
function cloneArray(u) {
  for (var l = u ? u.length : 0, f = Array(l); l--; )
    f[l] = u[l];
  return f;
}
function createCloner(u) {
  return function(l) {
    return u({}, l);
  };
}
function flatSpread(u, l) {
  return function() {
    for (var f = arguments.length, p = f - 1, m = Array(f); f--; )
      m[f] = arguments[f];
    var b = m[l], y = m.slice(0, l);
    return b && push$1.apply(y, b), l != p && push$1.apply(y, m.slice(l + 1)), u.apply(this, y);
  };
}
function wrapImmutable(u, l) {
  return function() {
    var f = arguments.length;
    if (f) {
      for (var p = Array(f); f--; )
        p[f] = arguments[f];
      var m = p[0] = l.apply(void 0, p);
      return u.apply(void 0, p), m;
    }
  };
}
function baseConvert$1(u, l, f, p) {
  var m = typeof l == "function", b = l === Object(l);
  if (b && (p = f, f = l, l = void 0), f == null)
    throw new TypeError();
  p || (p = {});
  var y = {
    cap: "cap" in p ? p.cap : !0,
    curry: "curry" in p ? p.curry : !0,
    fixed: "fixed" in p ? p.fixed : !0,
    immutable: "immutable" in p ? p.immutable : !0,
    rearg: "rearg" in p ? p.rearg : !0
  }, v = m ? f : fallbackHolder, k = "curry" in p && p.curry, S = "fixed" in p && p.fixed, $ = "rearg" in p && p.rearg, w = m ? f.runInContext() : void 0, T = m ? f : {
    ary: u.ary,
    assign: u.assign,
    clone: u.clone,
    curry: u.curry,
    forEach: u.forEach,
    isArray: u.isArray,
    isError: u.isError,
    isFunction: u.isFunction,
    isWeakMap: u.isWeakMap,
    iteratee: u.iteratee,
    keys: u.keys,
    rearg: u.rearg,
    toInteger: u.toInteger,
    toPath: u.toPath
  }, E = T.ary, R = T.assign, O = T.clone, P = T.curry, L = T.forEach, M = T.isArray, B = T.isError, j = T.isFunction, x = T.isWeakMap, N = T.keys, D = T.rearg, V = T.toInteger, W = T.toPath, F = N(mapping.aryMethod), U = {
    castArray: function(ae) {
      return function() {
        var ne = arguments[0];
        return M(ne) ? ae(cloneArray(ne)) : ae.apply(void 0, arguments);
      };
    },
    iteratee: function(ae) {
      return function() {
        var ne = arguments[0], K = arguments[1], ce = ae(ne, K), te = ce.length;
        return y.cap && typeof K == "number" ? (K = K > 2 ? K - 2 : 1, te && te <= K ? ce : baseAry(ce, K)) : ce;
      };
    },
    mixin: function(ae) {
      return function(ne) {
        var K = this;
        if (!j(K))
          return ae(K, Object(ne));
        var ce = [];
        return L(N(ne), function(te) {
          j(ne[te]) && ce.push([te, K.prototype[te]]);
        }), ae(K, Object(ne)), L(ce, function(te) {
          var ue = te[1];
          j(ue) ? K.prototype[te[0]] = ue : delete K.prototype[te[0]];
        }), K;
      };
    },
    nthArg: function(ae) {
      return function(ne) {
        var K = ne < 0 ? 1 : V(ne) + 1;
        return P(ae(ne), K);
      };
    },
    rearg: function(ae) {
      return function(ne, K) {
        var ce = K ? K.length : 0;
        return P(ae(ne, K), ce);
      };
    },
    runInContext: function(ae) {
      return function(ne) {
        return baseConvert$1(u, ae(ne), p);
      };
    }
  };
  function Y(ae, ne) {
    if (y.cap) {
      var K = mapping.iterateeRearg[ae];
      if (K)
        return ee(ne, K);
      var ce = !m && mapping.iterateeAry[ae];
      if (ce)
        return oe(ne, ce);
    }
    return ne;
  }
  function q(ae, ne, K) {
    return k || y.curry && K > 1 ? P(ne, K) : ne;
  }
  function Q(ae, ne, K) {
    if (y.fixed && (S || !mapping.skipFixed[ae])) {
      var ce = mapping.methodSpread[ae], te = ce && ce.start;
      return te === void 0 ? E(ne, K) : flatSpread(ne, te);
    }
    return ne;
  }
  function z(ae, ne, K) {
    return y.rearg && K > 1 && ($ || !mapping.skipRearg[ae]) ? D(ne, mapping.methodRearg[ae] || mapping.aryRearg[K]) : ne;
  }
  function H(ae, ne) {
    ne = W(ne);
    for (var K = -1, ce = ne.length, te = ce - 1, ue = O(Object(ae)), J = ue; J != null && ++K < ce; ) {
      var fe = ne[K], _e = J[fe];
      _e != null && !(j(_e) || B(_e) || x(_e)) && (J[fe] = O(K == te ? _e : Object(_e))), J = J[fe];
    }
    return ue;
  }
  function X(ae) {
    return pe.runInContext.convert(ae)(void 0);
  }
  function Z(ae, ne) {
    var K = mapping.aliasToReal[ae] || ae, ce = mapping.remap[K] || K, te = p;
    return function(ue) {
      var J = m ? w : T, fe = m ? w[ce] : ne, _e = R(R({}, te), ue);
      return baseConvert$1(J, K, fe, _e);
    };
  }
  function oe(ae, ne) {
    return ie(ae, function(K) {
      return typeof K == "function" ? baseAry(K, ne) : K;
    });
  }
  function ee(ae, ne) {
    return ie(ae, function(K) {
      var ce = ne.length;
      return baseArity(D(baseAry(K, ce), ne), ce);
    });
  }
  function ie(ae, ne) {
    return function() {
      var K = arguments.length;
      if (!K)
        return ae();
      for (var ce = Array(K); K--; )
        ce[K] = arguments[K];
      var te = y.rearg ? 0 : K - 1;
      return ce[te] = ne(ce[te]), ae.apply(void 0, ce);
    };
  }
  function de(ae, ne, K) {
    var ce, te = mapping.aliasToReal[ae] || ae, ue = ne, J = U[te];
    return J ? ue = J(ne) : y.immutable && (mapping.mutate.array[te] ? ue = wrapImmutable(ne, cloneArray) : mapping.mutate.object[te] ? ue = wrapImmutable(ne, createCloner(ne)) : mapping.mutate.set[te] && (ue = wrapImmutable(ne, H))), L(F, function(fe) {
      return L(mapping.aryMethod[fe], function(_e) {
        if (te == _e) {
          var ye = mapping.methodSpread[te], ke = ye && ye.afterRearg;
          return ce = ke ? Q(te, z(te, ue, fe), fe) : z(te, Q(te, ue, fe), fe), ce = Y(te, ce), ce = q(te, ce, fe), !1;
        }
      }), !ce;
    }), ce || (ce = ue), ce == ne && (ce = k ? P(ce, 1) : function() {
      return ne.apply(this, arguments);
    }), ce.convert = Z(te, ne), ce.placeholder = ne.placeholder = K, ce;
  }
  if (!b)
    return de(l, f, v);
  var pe = f, le = [];
  return L(F, function(ae) {
    L(mapping.aryMethod[ae], function(ne) {
      var K = pe[mapping.remap[ne] || ne];
      K && le.push([ne, de(ne, K, pe)]);
    });
  }), L(N(pe), function(ae) {
    var ne = pe[ae];
    if (typeof ne == "function") {
      for (var K = le.length; K--; )
        if (le[K][0] == ae)
          return;
      ne.convert = Z(ae, ne), le.push([ae, ne]);
    }
  }), L(le, function(ae) {
    pe[ae[0]] = ae[1];
  }), pe.convert = X, pe.placeholder = pe, L(N(pe), function(ae) {
    L(mapping.realToAlias[ae] || [], function(ne) {
      pe[ne] = pe[ae];
    });
  }), pe;
}
var _baseConvert = baseConvert$1, WeakMap$1 = _WeakMap$1, metaMap$2 = WeakMap$1 && new WeakMap$1(), _metaMap = metaMap$2, identity = identity_1$1, metaMap$1 = _metaMap, baseSetData$2 = metaMap$1 ? function(u, l) {
  return metaMap$1.set(u, l), u;
} : identity, _baseSetData = baseSetData$2, isObject$4 = isObject_1$1, objectCreate = Object.create, baseCreate$4 = function() {
  function u() {
  }
  return function(l) {
    if (!isObject$4(l))
      return {};
    if (objectCreate)
      return objectCreate(l);
    u.prototype = l;
    var f = new u();
    return u.prototype = void 0, f;
  };
}(), _baseCreate = baseCreate$4, baseCreate$3 = _baseCreate, isObject$3 = isObject_1$1;
function createCtor$4(u) {
  return function() {
    var l = arguments;
    switch (l.length) {
      case 0:
        return new u();
      case 1:
        return new u(l[0]);
      case 2:
        return new u(l[0], l[1]);
      case 3:
        return new u(l[0], l[1], l[2]);
      case 4:
        return new u(l[0], l[1], l[2], l[3]);
      case 5:
        return new u(l[0], l[1], l[2], l[3], l[4]);
      case 6:
        return new u(l[0], l[1], l[2], l[3], l[4], l[5]);
      case 7:
        return new u(l[0], l[1], l[2], l[3], l[4], l[5], l[6]);
    }
    var f = baseCreate$3(u.prototype), p = u.apply(f, l);
    return isObject$3(p) ? p : f;
  };
}
var _createCtor = createCtor$4, createCtor$3 = _createCtor, root$3 = _root$1, WRAP_BIND_FLAG$6 = 1;
function createBind$1(u, l, f) {
  var p = l & WRAP_BIND_FLAG$6, m = createCtor$3(u);
  function b() {
    var y = this && this !== root$3 && this instanceof b ? m : u;
    return y.apply(p ? f : this, arguments);
  }
  return b;
}
var _createBind = createBind$1, nativeMax$2 = Math.max;
function composeArgs$2(u, l, f, p) {
  for (var m = -1, b = u.length, y = f.length, v = -1, k = l.length, S = nativeMax$2(b - y, 0), $ = Array(k + S), w = !p; ++v < k; )
    $[v] = l[v];
  for (; ++m < y; )
    (w || m < b) && ($[f[m]] = u[m]);
  for (; S--; )
    $[v++] = u[m++];
  return $;
}
var _composeArgs = composeArgs$2, nativeMax$1 = Math.max;
function composeArgsRight$2(u, l, f, p) {
  for (var m = -1, b = u.length, y = -1, v = f.length, k = -1, S = l.length, $ = nativeMax$1(b - v, 0), w = Array($ + S), T = !p; ++m < $; )
    w[m] = u[m];
  for (var E = m; ++k < S; )
    w[E + k] = l[k];
  for (; ++y < v; )
    (T || m < b) && (w[E + f[y]] = u[m++]);
  return w;
}
var _composeArgsRight = composeArgsRight$2;
function countHolders$1(u, l) {
  for (var f = u.length, p = 0; f--; )
    u[f] === l && ++p;
  return p;
}
var _countHolders = countHolders$1;
function baseLodash$3() {
}
var _baseLodash = baseLodash$3, baseCreate$2 = _baseCreate, baseLodash$2 = _baseLodash, MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper$3(u) {
  this.__wrapped__ = u, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = MAX_ARRAY_LENGTH, this.__views__ = [];
}
LazyWrapper$3.prototype = baseCreate$2(baseLodash$2.prototype);
LazyWrapper$3.prototype.constructor = LazyWrapper$3;
var _LazyWrapper = LazyWrapper$3;
function noop$1() {
}
var noop_1 = noop$1, metaMap = _metaMap, noop = noop_1, getData$2 = metaMap ? function(u) {
  return metaMap.get(u);
} : noop, _getData = getData$2, realNames$1 = {}, _realNames = realNames$1, realNames = _realNames, objectProto$2 = Object.prototype, hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function getFuncName$1(u) {
  for (var l = u.name + "", f = realNames[l], p = hasOwnProperty$2.call(realNames, l) ? f.length : 0; p--; ) {
    var m = f[p], b = m.func;
    if (b == null || b == u)
      return m.name;
  }
  return l;
}
var _getFuncName = getFuncName$1, baseCreate$1 = _baseCreate, baseLodash$1 = _baseLodash;
function LodashWrapper$2(u, l) {
  this.__wrapped__ = u, this.__actions__ = [], this.__chain__ = !!l, this.__index__ = 0, this.__values__ = void 0;
}
LodashWrapper$2.prototype = baseCreate$1(baseLodash$1.prototype);
LodashWrapper$2.prototype.constructor = LodashWrapper$2;
var _LodashWrapper = LodashWrapper$2;
function copyArray$4(u, l) {
  var f = -1, p = u.length;
  for (l || (l = Array(p)); ++f < p; )
    l[f] = u[f];
  return l;
}
var _copyArray = copyArray$4, LazyWrapper$2 = _LazyWrapper, LodashWrapper$1 = _LodashWrapper, copyArray$3 = _copyArray;
function wrapperClone$1(u) {
  if (u instanceof LazyWrapper$2)
    return u.clone();
  var l = new LodashWrapper$1(u.__wrapped__, u.__chain__);
  return l.__actions__ = copyArray$3(u.__actions__), l.__index__ = u.__index__, l.__values__ = u.__values__, l;
}
var _wrapperClone = wrapperClone$1, LazyWrapper$1 = _LazyWrapper, LodashWrapper = _LodashWrapper, baseLodash = _baseLodash, isArray$2 = isArray_1$1, isObjectLike$4 = isObjectLike_1$1, wrapperClone = _wrapperClone, objectProto$1 = Object.prototype, hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function lodash$1(u) {
  if (isObjectLike$4(u) && !isArray$2(u) && !(u instanceof LazyWrapper$1)) {
    if (u instanceof LodashWrapper)
      return u;
    if (hasOwnProperty$1.call(u, "__wrapped__"))
      return wrapperClone(u);
  }
  return new LodashWrapper(u);
}
lodash$1.prototype = baseLodash.prototype;
lodash$1.prototype.constructor = lodash$1;
var wrapperLodash = lodash$1, LazyWrapper = _LazyWrapper, getData$1 = _getData, getFuncName = _getFuncName, lodash = wrapperLodash;
function isLaziable$1(u) {
  var l = getFuncName(u), f = lodash[l];
  if (typeof f != "function" || !(l in LazyWrapper.prototype))
    return !1;
  if (u === f)
    return !0;
  var p = getData$1(f);
  return !!p && u === p[0];
}
var _isLaziable = isLaziable$1, baseSetData$1 = _baseSetData, shortOut = _shortOut$1, setData$2 = shortOut(baseSetData$1), _setData = setData$2, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
function getWrapDetails$1(u) {
  var l = u.match(reWrapDetails);
  return l ? l[1].split(reSplitDetails) : [];
}
var _getWrapDetails = getWrapDetails$1, reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails$1(u, l) {
  var f = l.length;
  if (!f)
    return u;
  var p = f - 1;
  return l[p] = (f > 1 ? "& " : "") + l[p], l = l.join(f > 2 ? ", " : " "), u.replace(reWrapComment, `{
/* [wrapped with ` + l + `] */
`);
}
var _insertWrapDetails = insertWrapDetails$1;
function arrayEach$2(u, l) {
  for (var f = -1, p = u == null ? 0 : u.length; ++f < p && l(u[f], f, u) !== !1; )
    ;
  return u;
}
var _arrayEach = arrayEach$2;
function baseFindIndex$1(u, l, f, p) {
  for (var m = u.length, b = f + (p ? 1 : -1); p ? b-- : ++b < m; )
    if (l(u[b], b, u))
      return b;
  return -1;
}
var _baseFindIndex = baseFindIndex$1;
function baseIsNaN$1(u) {
  return u !== u;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(u, l, f) {
  for (var p = f - 1, m = u.length; ++p < m; )
    if (u[p] === l)
      return p;
  return -1;
}
var _strictIndexOf = strictIndexOf$1, baseFindIndex = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
function baseIndexOf$1(u, l, f) {
  return l === l ? strictIndexOf(u, l, f) : baseFindIndex(u, baseIsNaN, f);
}
var _baseIndexOf = baseIndexOf$1, baseIndexOf = _baseIndexOf;
function arrayIncludes$1(u, l) {
  var f = u == null ? 0 : u.length;
  return !!f && baseIndexOf(u, l, 0) > -1;
}
var _arrayIncludes = arrayIncludes$1, arrayEach$1 = _arrayEach, arrayIncludes = _arrayIncludes, WRAP_BIND_FLAG$5 = 1, WRAP_BIND_KEY_FLAG$4 = 2, WRAP_CURRY_FLAG$5 = 8, WRAP_CURRY_RIGHT_FLAG$2 = 16, WRAP_PARTIAL_FLAG$2 = 32, WRAP_PARTIAL_RIGHT_FLAG$2 = 64, WRAP_ARY_FLAG$3 = 128, WRAP_REARG_FLAG$2 = 256, WRAP_FLIP_FLAG$1 = 512, wrapFlags = [
  ["ary", WRAP_ARY_FLAG$3],
  ["bind", WRAP_BIND_FLAG$5],
  ["bindKey", WRAP_BIND_KEY_FLAG$4],
  ["curry", WRAP_CURRY_FLAG$5],
  ["curryRight", WRAP_CURRY_RIGHT_FLAG$2],
  ["flip", WRAP_FLIP_FLAG$1],
  ["partial", WRAP_PARTIAL_FLAG$2],
  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG$2],
  ["rearg", WRAP_REARG_FLAG$2]
];
function updateWrapDetails$1(u, l) {
  return arrayEach$1(wrapFlags, function(f) {
    var p = "_." + f[0];
    l & f[1] && !arrayIncludes(u, p) && u.push(p);
  }), u.sort();
}
var _updateWrapDetails = updateWrapDetails$1, getWrapDetails = _getWrapDetails, insertWrapDetails = _insertWrapDetails, setToString = _setToString$1, updateWrapDetails = _updateWrapDetails;
function setWrapToString$2(u, l, f) {
  var p = l + "";
  return setToString(u, insertWrapDetails(p, updateWrapDetails(getWrapDetails(p), f)));
}
var _setWrapToString = setWrapToString$2, isLaziable = _isLaziable, setData$1 = _setData, setWrapToString$1 = _setWrapToString, WRAP_BIND_FLAG$4 = 1, WRAP_BIND_KEY_FLAG$3 = 2, WRAP_CURRY_BOUND_FLAG$1 = 4, WRAP_CURRY_FLAG$4 = 8, WRAP_PARTIAL_FLAG$1 = 32, WRAP_PARTIAL_RIGHT_FLAG$1 = 64;
function createRecurry$2(u, l, f, p, m, b, y, v, k, S) {
  var $ = l & WRAP_CURRY_FLAG$4, w = $ ? y : void 0, T = $ ? void 0 : y, E = $ ? b : void 0, R = $ ? void 0 : b;
  l |= $ ? WRAP_PARTIAL_FLAG$1 : WRAP_PARTIAL_RIGHT_FLAG$1, l &= ~($ ? WRAP_PARTIAL_RIGHT_FLAG$1 : WRAP_PARTIAL_FLAG$1), l & WRAP_CURRY_BOUND_FLAG$1 || (l &= ~(WRAP_BIND_FLAG$4 | WRAP_BIND_KEY_FLAG$3));
  var O = [
    u,
    l,
    m,
    E,
    w,
    R,
    T,
    v,
    k,
    S
  ], P = f.apply(void 0, O);
  return isLaziable(u) && setData$1(P, O), P.placeholder = p, setWrapToString$1(P, u, l);
}
var _createRecurry = createRecurry$2;
function getHolder$2(u) {
  var l = u;
  return l.placeholder;
}
var _getHolder = getHolder$2, copyArray$2 = _copyArray, isIndex = _isIndex$1, nativeMin$1 = Math.min;
function reorder$1(u, l) {
  for (var f = u.length, p = nativeMin$1(l.length, f), m = copyArray$2(u); p--; ) {
    var b = l[p];
    u[p] = isIndex(b, f) ? m[b] : void 0;
  }
  return u;
}
var _reorder = reorder$1, PLACEHOLDER$1 = "__lodash_placeholder__";
function replaceHolders$3(u, l) {
  for (var f = -1, p = u.length, m = 0, b = []; ++f < p; ) {
    var y = u[f];
    (y === l || y === PLACEHOLDER$1) && (u[f] = PLACEHOLDER$1, b[m++] = f);
  }
  return b;
}
var _replaceHolders = replaceHolders$3, composeArgs$1 = _composeArgs, composeArgsRight$1 = _composeArgsRight, countHolders = _countHolders, createCtor$2 = _createCtor, createRecurry$1 = _createRecurry, getHolder$1 = _getHolder, reorder = _reorder, replaceHolders$2 = _replaceHolders, root$2 = _root$1, WRAP_BIND_FLAG$3 = 1, WRAP_BIND_KEY_FLAG$2 = 2, WRAP_CURRY_FLAG$3 = 8, WRAP_CURRY_RIGHT_FLAG$1 = 16, WRAP_ARY_FLAG$2 = 128, WRAP_FLIP_FLAG = 512;
function createHybrid$2(u, l, f, p, m, b, y, v, k, S) {
  var $ = l & WRAP_ARY_FLAG$2, w = l & WRAP_BIND_FLAG$3, T = l & WRAP_BIND_KEY_FLAG$2, E = l & (WRAP_CURRY_FLAG$3 | WRAP_CURRY_RIGHT_FLAG$1), R = l & WRAP_FLIP_FLAG, O = T ? void 0 : createCtor$2(u);
  function P() {
    for (var L = arguments.length, M = Array(L), B = L; B--; )
      M[B] = arguments[B];
    if (E)
      var j = getHolder$1(P), x = countHolders(M, j);
    if (p && (M = composeArgs$1(M, p, m, E)), b && (M = composeArgsRight$1(M, b, y, E)), L -= x, E && L < S) {
      var N = replaceHolders$2(M, j);
      return createRecurry$1(
        u,
        l,
        createHybrid$2,
        P.placeholder,
        f,
        M,
        N,
        v,
        k,
        S - L
      );
    }
    var D = w ? f : this, V = T ? D[u] : u;
    return L = M.length, v ? M = reorder(M, v) : R && L > 1 && M.reverse(), $ && k < L && (M.length = k), this && this !== root$2 && this instanceof P && (V = O || createCtor$2(V)), V.apply(D, M);
  }
  return P;
}
var _createHybrid = createHybrid$2, apply$1 = _apply$1, createCtor$1 = _createCtor, createHybrid$1 = _createHybrid, createRecurry = _createRecurry, getHolder = _getHolder, replaceHolders$1 = _replaceHolders, root$1 = _root$1;
function createCurry$1(u, l, f) {
  var p = createCtor$1(u);
  function m() {
    for (var b = arguments.length, y = Array(b), v = b, k = getHolder(m); v--; )
      y[v] = arguments[v];
    var S = b < 3 && y[0] !== k && y[b - 1] !== k ? [] : replaceHolders$1(y, k);
    if (b -= S.length, b < f)
      return createRecurry(
        u,
        l,
        createHybrid$1,
        m.placeholder,
        void 0,
        y,
        S,
        void 0,
        void 0,
        f - b
      );
    var $ = this && this !== root$1 && this instanceof m ? p : u;
    return apply$1($, this, y);
  }
  return m;
}
var _createCurry = createCurry$1, apply = _apply$1, createCtor = _createCtor, root = _root$1, WRAP_BIND_FLAG$2 = 1;
function createPartial$1(u, l, f, p) {
  var m = l & WRAP_BIND_FLAG$2, b = createCtor(u);
  function y() {
    for (var v = -1, k = arguments.length, S = -1, $ = p.length, w = Array($ + k), T = this && this !== root && this instanceof y ? b : u; ++S < $; )
      w[S] = p[S];
    for (; k--; )
      w[S++] = arguments[++v];
    return apply(T, m ? f : this, w);
  }
  return y;
}
var _createPartial = createPartial$1, composeArgs = _composeArgs, composeArgsRight = _composeArgsRight, replaceHolders = _replaceHolders, PLACEHOLDER = "__lodash_placeholder__", WRAP_BIND_FLAG$1 = 1, WRAP_BIND_KEY_FLAG$1 = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG$2 = 8, WRAP_ARY_FLAG$1 = 128, WRAP_REARG_FLAG$1 = 256, nativeMin = Math.min;
function mergeData$1(u, l) {
  var f = u[1], p = l[1], m = f | p, b = m < (WRAP_BIND_FLAG$1 | WRAP_BIND_KEY_FLAG$1 | WRAP_ARY_FLAG$1), y = p == WRAP_ARY_FLAG$1 && f == WRAP_CURRY_FLAG$2 || p == WRAP_ARY_FLAG$1 && f == WRAP_REARG_FLAG$1 && u[7].length <= l[8] || p == (WRAP_ARY_FLAG$1 | WRAP_REARG_FLAG$1) && l[7].length <= l[8] && f == WRAP_CURRY_FLAG$2;
  if (!(b || y))
    return u;
  p & WRAP_BIND_FLAG$1 && (u[2] = l[2], m |= f & WRAP_BIND_FLAG$1 ? 0 : WRAP_CURRY_BOUND_FLAG);
  var v = l[3];
  if (v) {
    var k = u[3];
    u[3] = k ? composeArgs(k, v, l[4]) : v, u[4] = k ? replaceHolders(u[3], PLACEHOLDER) : l[4];
  }
  return v = l[5], v && (k = u[5], u[5] = k ? composeArgsRight(k, v, l[6]) : v, u[6] = k ? replaceHolders(u[5], PLACEHOLDER) : l[6]), v = l[7], v && (u[7] = v), p & WRAP_ARY_FLAG$1 && (u[8] = u[8] == null ? l[8] : nativeMin(u[8], l[8])), u[9] == null && (u[9] = l[9]), u[0] = l[0], u[1] = m, u;
}
var _mergeData = mergeData$1, reWhitespace = /\s/;
function trimmedEndIndex$1(u) {
  for (var l = u.length; l-- && reWhitespace.test(u.charAt(l)); )
    ;
  return l;
}
var _trimmedEndIndex = trimmedEndIndex$1, trimmedEndIndex = _trimmedEndIndex, reTrimStart = /^\s+/;
function baseTrim$1(u) {
  return u && u.slice(0, trimmedEndIndex(u) + 1).replace(reTrimStart, "");
}
var _baseTrim = baseTrim$1, baseTrim = _baseTrim, isObject$2 = isObject_1$1, isSymbol$1 = isSymbol_1$1, NAN = 0 / 0, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt;
function toNumber$1(u) {
  if (typeof u == "number")
    return u;
  if (isSymbol$1(u))
    return NAN;
  if (isObject$2(u)) {
    var l = typeof u.valueOf == "function" ? u.valueOf() : u;
    u = isObject$2(l) ? l + "" : l;
  }
  if (typeof u != "string")
    return u === 0 ? u : +u;
  u = baseTrim(u);
  var f = reIsBinary.test(u);
  return f || reIsOctal.test(u) ? freeParseInt(u.slice(2), f ? 2 : 8) : reIsBadHex.test(u) ? NAN : +u;
}
var toNumber_1 = toNumber$1, toNumber = toNumber_1, INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite$1(u) {
  if (!u)
    return u === 0 ? u : 0;
  if (u = toNumber(u), u === INFINITY || u === -INFINITY) {
    var l = u < 0 ? -1 : 1;
    return l * MAX_INTEGER;
  }
  return u === u ? u : 0;
}
var toFinite_1 = toFinite$1, toFinite = toFinite_1;
function toInteger$1(u) {
  var l = toFinite(u), f = l % 1;
  return l === l ? f ? l - f : l : 0;
}
var toInteger_1 = toInteger$1, baseSetData = _baseSetData, createBind = _createBind, createCurry = _createCurry, createHybrid = _createHybrid, createPartial = _createPartial, getData = _getData, mergeData = _mergeData, setData = _setData, setWrapToString = _setWrapToString, toInteger = toInteger_1, FUNC_ERROR_TEXT = "Expected a function", WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_FLAG$1 = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, nativeMax = Math.max;
function createWrap$3(u, l, f, p, m, b, y, v) {
  var k = l & WRAP_BIND_KEY_FLAG;
  if (!k && typeof u != "function")
    throw new TypeError(FUNC_ERROR_TEXT);
  var S = p ? p.length : 0;
  if (S || (l &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG), p = m = void 0), y = y === void 0 ? y : nativeMax(toInteger(y), 0), v = v === void 0 ? v : toInteger(v), S -= m ? m.length : 0, l & WRAP_PARTIAL_RIGHT_FLAG) {
    var $ = p, w = m;
    p = m = void 0;
  }
  var T = k ? void 0 : getData(u), E = [
    u,
    l,
    f,
    p,
    m,
    $,
    w,
    b,
    y,
    v
  ];
  if (T && mergeData(E, T), u = E[0], l = E[1], f = E[2], p = E[3], m = E[4], v = E[9] = E[9] === void 0 ? k ? 0 : u.length : nativeMax(E[9] - S, 0), !v && l & (WRAP_CURRY_FLAG$1 | WRAP_CURRY_RIGHT_FLAG) && (l &= ~(WRAP_CURRY_FLAG$1 | WRAP_CURRY_RIGHT_FLAG)), !l || l == WRAP_BIND_FLAG)
    var R = createBind(u, l, f);
  else
    l == WRAP_CURRY_FLAG$1 || l == WRAP_CURRY_RIGHT_FLAG ? R = createCurry(u, l, v) : (l == WRAP_PARTIAL_FLAG || l == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !m.length ? R = createPartial(u, l, f, p) : R = createHybrid.apply(void 0, E);
  var O = T ? baseSetData : setData;
  return setWrapToString(O(R, E), u, l);
}
var _createWrap = createWrap$3, createWrap$2 = _createWrap, WRAP_ARY_FLAG = 128;
function ary(u, l, f) {
  return l = f ? void 0 : l, l = u && l == null ? u.length : l, createWrap$2(u, WRAP_ARY_FLAG, void 0, void 0, void 0, void 0, l);
}
var ary_1 = ary, assignValue$1 = _assignValue$1, baseAssignValue = _baseAssignValue$1;
function copyObject$4(u, l, f, p) {
  var m = !f;
  f || (f = {});
  for (var b = -1, y = l.length; ++b < y; ) {
    var v = l[b], k = p ? p(f[v], u[v], v, f, u) : void 0;
    k === void 0 && (k = u[v]), m ? baseAssignValue(f, v, k) : assignValue$1(f, v, k);
  }
  return f;
}
var _copyObject = copyObject$4, copyObject$3 = _copyObject, keys$1 = keys_1$1;
function baseAssign$1(u, l) {
  return u && copyObject$3(l, keys$1(l), u);
}
var _baseAssign = baseAssign$1, copyObject$2 = _copyObject, keysIn$1 = keysIn_1$1;
function baseAssignIn$1(u, l) {
  return u && copyObject$2(l, keysIn$1(l), u);
}
var _baseAssignIn = baseAssignIn$1, _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
(function(u, l) {
  var f = _root$1, p = l && !l.nodeType && l, m = p && !0 && u && !u.nodeType && u, b = m && m.exports === p, y = b ? f.Buffer : void 0, v = y ? y.allocUnsafe : void 0;
  function k(S, $) {
    if ($)
      return S.slice();
    var w = S.length, T = v ? v(w) : new S.constructor(w);
    return S.copy(T), T;
  }
  u.exports = k;
})(_cloneBuffer, _cloneBuffer.exports);
var _cloneBufferExports = _cloneBuffer.exports, copyObject$1 = _copyObject, getSymbols = _getSymbols$1;
function copySymbols$1(u, l) {
  return copyObject$1(u, getSymbols(u), l);
}
var _copySymbols = copySymbols$1, copyObject = _copyObject, getSymbolsIn = _getSymbolsIn$1;
function copySymbolsIn$1(u, l) {
  return copyObject(u, getSymbolsIn(u), l);
}
var _copySymbolsIn = copySymbolsIn$1, objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray$1(u) {
  var l = u.length, f = new u.constructor(l);
  return l && typeof u[0] == "string" && hasOwnProperty.call(u, "index") && (f.index = u.index, f.input = u.input), f;
}
var _initCloneArray = initCloneArray$1, Uint8Array$1 = _Uint8Array$1;
function cloneArrayBuffer$3(u) {
  var l = new u.constructor(u.byteLength);
  return new Uint8Array$1(l).set(new Uint8Array$1(u)), l;
}
var _cloneArrayBuffer = cloneArrayBuffer$3, cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(u, l) {
  var f = l ? cloneArrayBuffer$2(u.buffer) : u.buffer;
  return new u.constructor(f, u.byteOffset, u.byteLength);
}
var _cloneDataView = cloneDataView$1, reFlags = /\w*$/;
function cloneRegExp$1(u) {
  var l = new u.constructor(u.source, reFlags.exec(u));
  return l.lastIndex = u.lastIndex, l;
}
var _cloneRegExp = cloneRegExp$1, Symbol$1 = _Symbol$1, symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(u) {
  return symbolValueOf ? Object(symbolValueOf.call(u)) : {};
}
var _cloneSymbol = cloneSymbol$1, cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$1(u, l) {
  var f = l ? cloneArrayBuffer$1(u.buffer) : u.buffer;
  return new u.constructor(f, u.byteOffset, u.length);
}
var _cloneTypedArray = cloneTypedArray$1, cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray, boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(u, l, f) {
  var p = u.constructor;
  switch (l) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(u);
    case boolTag$1:
    case dateTag$1:
      return new p(+u);
    case dataViewTag$1:
      return cloneDataView(u, f);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(u, f);
    case mapTag$2:
      return new p();
    case numberTag$1:
    case stringTag$1:
      return new p(u);
    case regexpTag$1:
      return cloneRegExp(u);
    case setTag$2:
      return new p();
    case symbolTag$1:
      return cloneSymbol(u);
  }
}
var _initCloneByTag = initCloneByTag$1, baseCreate = _baseCreate, getPrototype = _getPrototype$1, isPrototype = _isPrototype$1;
function initCloneObject$1(u) {
  return typeof u.constructor == "function" && !isPrototype(u) ? baseCreate(getPrototype(u)) : {};
}
var _initCloneObject = initCloneObject$1, getTag$3 = _getTag$1, isObjectLike$3 = isObjectLike_1$1, mapTag$1 = "[object Map]";
function baseIsMap$1(u) {
  return isObjectLike$3(u) && getTag$3(u) == mapTag$1;
}
var _baseIsMap = baseIsMap$1, baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary$1, nodeUtil$1 = _nodeUtilExports, nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap, isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap, isMap_1 = isMap$1, getTag$2 = _getTag$1, isObjectLike$2 = isObjectLike_1$1, setTag$1 = "[object Set]";
function baseIsSet$1(u) {
  return isObjectLike$2(u) && getTag$2(u) == setTag$1;
}
var _baseIsSet = baseIsSet$1, baseIsSet = _baseIsSet, baseUnary = _baseUnary$1, nodeUtil = _nodeUtilExports, nodeIsSet = nodeUtil && nodeUtil.isSet, isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, isSet_1 = isSet$1, Stack = _Stack$1, arrayEach = _arrayEach, assignValue = _assignValue$1, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBufferExports, copyArray$1 = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys$1, getAllKeysIn = _getAllKeysIn$1, getTag$1 = _getTag$1, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray$1 = isArray_1$1, isBuffer = isBufferExports, isMap = isMap_1, isObject$1 = isObject_1$1, isSet = isSet_1, keys = keys_1$1, keysIn = keysIn_1$1, CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$2 = 4, argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag$1 = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag$1] = !1;
function baseClone$3(u, l, f, p, m, b) {
  var y, v = l & CLONE_DEEP_FLAG$2, k = l & CLONE_FLAT_FLAG, S = l & CLONE_SYMBOLS_FLAG$2;
  if (f && (y = m ? f(u, p, m, b) : f(u)), y !== void 0)
    return y;
  if (!isObject$1(u))
    return u;
  var $ = isArray$1(u);
  if ($) {
    if (y = initCloneArray(u), !v)
      return copyArray$1(u, y);
  } else {
    var w = getTag$1(u), T = w == funcTag || w == genTag;
    if (isBuffer(u))
      return cloneBuffer(u, v);
    if (w == objectTag || w == argsTag || T && !m) {
      if (y = k || T ? {} : initCloneObject(u), !v)
        return k ? copySymbolsIn(u, baseAssignIn(y, u)) : copySymbols(u, baseAssign(y, u));
    } else {
      if (!cloneableTags[w])
        return m ? u : {};
      y = initCloneByTag(u, w, v);
    }
  }
  b || (b = new Stack());
  var E = b.get(u);
  if (E)
    return E;
  b.set(u, y), isSet(u) ? u.forEach(function(P) {
    y.add(baseClone$3(P, l, f, P, u, b));
  }) : isMap(u) && u.forEach(function(P, L) {
    y.set(L, baseClone$3(P, l, f, L, u, b));
  });
  var R = S ? k ? getAllKeysIn : getAllKeys : k ? keysIn : keys, O = $ ? void 0 : R(u);
  return arrayEach(O || u, function(P, L) {
    O && (L = P, P = u[L]), assignValue(y, L, baseClone$3(P, l, f, L, u, b));
  }), y;
}
var _baseClone = baseClone$3, baseClone$2 = _baseClone, CLONE_SYMBOLS_FLAG$1 = 4;
function clone(u) {
  return baseClone$2(u, CLONE_SYMBOLS_FLAG$1);
}
var clone_1 = clone, createWrap$1 = _createWrap, WRAP_CURRY_FLAG = 8;
function curry(u, l, f) {
  l = f ? void 0 : l;
  var p = createWrap$1(u, WRAP_CURRY_FLAG, void 0, void 0, void 0, void 0, void 0, l);
  return p.placeholder = curry.placeholder, p;
}
curry.placeholder = {};
var curry_1 = curry, baseGetTag = _baseGetTag$1, isObjectLike$1 = isObjectLike_1$1, isPlainObject = isPlainObject_1$1, domExcTag = "[object DOMException]", errorTag = "[object Error]";
function isError(u) {
  if (!isObjectLike$1(u))
    return !1;
  var l = baseGetTag(u);
  return l == errorTag || l == domExcTag || typeof u.message == "string" && typeof u.name == "string" && !isPlainObject(u);
}
var isError_1 = isError, getTag = _getTag$1, isObjectLike = isObjectLike_1$1, weakMapTag = "[object WeakMap]";
function isWeakMap(u) {
  return isObjectLike(u) && getTag(u) == weakMapTag;
}
var isWeakMap_1 = isWeakMap, baseClone$1 = _baseClone, baseIteratee = _baseIteratee$1, CLONE_DEEP_FLAG$1 = 1;
function iteratee(u) {
  return baseIteratee(typeof u == "function" ? u : baseClone$1(u, CLONE_DEEP_FLAG$1));
}
var iteratee_1 = iteratee, createWrap = _createWrap, flatRest = _flatRest$1, WRAP_REARG_FLAG = 256, rearg = flatRest(function(u, l) {
  return createWrap(u, WRAP_REARG_FLAG, void 0, void 0, void 0, l);
}), rearg_1 = rearg, arrayMap = _arrayMap$1, copyArray = _copyArray, isArray = isArray_1$1, isSymbol = isSymbol_1$1, stringToPath = _stringToPath$1, toKey = _toKey$1, toString$1 = toString_1$1;
function toPath(u) {
  return isArray(u) ? arrayMap(u, toKey) : isSymbol(u) ? [u] : copyArray(stringToPath(toString$1(u)));
}
var toPath_1 = toPath, _util = {
  ary: ary_1,
  assign: _baseAssign,
  clone: clone_1,
  curry: curry_1,
  forEach: _arrayEach,
  isArray: isArray_1$1,
  isError: isError_1,
  isFunction: isFunction_1$1,
  isWeakMap: isWeakMap_1,
  iteratee: iteratee_1,
  keys: _baseKeys$1,
  rearg: rearg_1,
  toInteger: toInteger_1,
  toPath: toPath_1
}, baseConvert = _baseConvert, util = _util;
function convert$1(u, l, f) {
  return baseConvert(util, u, l, f);
}
var convert_1 = convert$1, baseClone = _baseClone, CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep$2(u) {
  return baseClone(u, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1 = cloneDeep$2;
const cloneDeep$3 = /* @__PURE__ */ getDefaultExportFromCjs$1(cloneDeep_1);
var _falseOptions, hasRequired_falseOptions;
function require_falseOptions() {
  return hasRequired_falseOptions || (hasRequired_falseOptions = 1, _falseOptions = {
    cap: !1,
    curry: !1,
    fixed: !1,
    immutable: !1,
    rearg: !1
  }), _falseOptions;
}
var convert = convert_1, func = convert("cloneDeep", cloneDeep_1, require_falseOptions());
func.placeholder = requirePlaceholder();
var cloneDeep = func;
const cloneDeep$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(cloneDeep), getJSONArrayDatasourceSchema = (u, l) => {
  let f = u, p = [];
  l.prefixKeys && (p = l.prefixKeys.concat(["schema"])), p = p.concat(l.label.split(".").slice(2));
  for (let m = 0; m < p.length; m++)
    f = f == null ? void 0 : f[p[m]], f != null && f.schema && (f = f.schema);
  return convertJSONSchemaToTableSchema(f, {
    squashObjects: !0,
    prefixKeys: p
  });
}, convertJSONSchemaToTableSchema = (u, l) => {
  if (!u)
    return null;
  l = { squashObjects: !1, prefixKeys: null, ...l }, u.schema ? u = u.schema : u = {
    value: u
  };
  const f = extractJSONSchemaKeys(u, l.squashObjects);
  let p = {};
  return f.forEach(({ key: m, type: b }) => {
    p[m] = { type: b, name: m, prefixKeys: l.prefixKeys };
  }), p;
}, extractJSONSchemaKeys = (u, l = !1) => {
  if (!u || !Object.keys(u).length)
    return [];
  let f = [];
  return Object.keys(u).forEach((p) => {
    const m = u[p].type;
    if (m === "json" && l) {
      const b = extractJSONSchemaKeys(
        u[p].schema,
        l
      );
      f = f.concat(
        b.map((y) => ({
          key: `${p}.${y.key}`,
          type: y.type
        }))
      );
    } else
      f.push({
        key: p,
        type: m === "array" ? "jsonarray" : m
      });
  }), f;
}, generateQueryArraySchemas = (u, l) => {
  var f, p;
  for (let m in u)
    ((f = u[m]) == null ? void 0 : f.type) === "json" && ((p = u[m]) == null ? void 0 : p.subtype) === "array" && hasSchema(l[m]) && (u[m] = {
      schema: {
        schema: Object.entries(l[m] || {}).reduce(
          (b, [y, v]) => (b[y] = {
            name: y,
            type: v.type,
            subtype: v.subtype
          }, b),
          {}
        ),
        type: "json"
      },
      type: "json",
      subtype: "array"
    });
  return u;
};
function setCookie(u, l, f) {
  getCookie(u) && removeCookie(u);
  let p = `${u}=${l}; Path=/;`;
  f && (p += ` Domain=${f};`), window.document.cookie = p;
}
function getCookie(u) {
  const f = `; ${document.cookie}`.split(`; ${u}=`);
  if (f.length === 2)
    return f[1].split(";").shift();
}
function removeCookie(u) {
  getCookie(u) && (document.cookie = `${u}=; Max-Age=-99999999; Path=/;`);
}
const RolePriorities = {
  [Roles.ADMIN]: 5,
  [Roles.CREATOR]: 4,
  [Roles.POWER]: 3,
  [Roles.BASIC]: 2,
  [Roles.PUBLIC]: 1
}, getRolePriority = (u) => RolePriorities[u] ?? 0, sleep = (u) => new Promise((l) => setTimeout(l, u)), debounce = (u, l = 1e3) => {
  let f;
  return async (...p) => new Promise((m) => {
    f && clearTimeout(f), f = setTimeout(async () => {
      const b = await u(...p);
      m(b);
    }, l);
  });
}, throttle = (u, l = 1e3) => {
  let f, p = !1, m = !1;
  const b = (...y) => {
    if (f = y, p) {
      m = !0;
      return;
    }
    u(...f), p = !0, setTimeout(() => {
      p = !1, m && (m = !1, b(...f));
    }, l);
  };
  return b;
}, domDebounce = (u) => {
  let l = !1, f;
  return (...p) => {
    f = p, l || (l = !0, requestAnimationFrame(() => {
      u(...f), l = !1;
    }));
  };
}, buildFormBlockButtonConfig = (u) => {
  const {
    _id: l,
    actionType: f,
    dataSource: p,
    notificationOverride: m,
    actionUrl: b,
    showDeleteButton: y,
    deleteButtonLabel: v,
    showSaveButton: k,
    saveButtonLabel: S
  } = u || {};
  if (!l)
    return;
  const $ = `${l}-form`, w = `${l}-repeater`, T = p == null ? void 0 : p.resourceId, E = y === !1 ? "" : v == null ? void 0 : v.trim(), R = k === !1 ? "" : S == null ? void 0 : S.trim(), O = [
    {
      "##eventHandlerType": "Validate Form",
      parameters: {
        componentId: $
      }
    },
    {
      "##eventHandlerType": "Save Row",
      parameters: {
        providerId: $,
        tableId: T,
        notificationOverride: m,
        confirm: null
      }
    },
    {
      "##eventHandlerType": "Close Screen Modal"
    },
    {
      "##eventHandlerType": "Close Side Panel"
    },
    {
      "##eventHandlerType": "Close Modal"
    },
    // Clear a create form once submitted
    ...f !== "Create" ? [] : [
      {
        "##eventHandlerType": "Clear Form",
        parameters: {
          componentId: $
        }
      }
    ],
    ...b ? [
      {
        "##eventHandlerType": "Navigate To",
        parameters: {
          url: b
        }
      }
    ] : []
  ], P = [
    {
      "##eventHandlerType": "Delete Row",
      parameters: {
        confirm: !0,
        tableId: T,
        rowId: `{{ ${makePropSafe(w)}.${makePropSafe("_id")} }}`,
        revId: `{{ ${makePropSafe(w)}.${makePropSafe("_rev")} }}`,
        notificationOverride: m
      }
    },
    {
      "##eventHandlerType": "Close Screen Modal"
    },
    {
      "##eventHandlerType": "Close Side Panel"
    },
    {
      "##eventHandlerType": "Close Modal"
    },
    ...b ? [
      {
        "##eventHandlerType": "Navigate To",
        parameters: {
          url: b
        }
      }
    ] : []
  ], L = [];
  return f && ["Update", "Create"].includes(f) && k !== !1 && L.push({
    text: R || "Save",
    _id: uuid(),
    _component: "@budibase/standard-components/button",
    onClick: O,
    type: "cta"
  }), f === "Update" && y !== !1 && L.push({
    text: E || "Delete",
    _id: uuid(),
    _component: "@budibase/standard-components/button",
    onClick: P,
    quiet: !0,
    type: "warning"
  }), L;
}, buildMultiStepFormBlockDefaultProps = (u) => {
  const { _id: l, stepCount: f, currentStep: p, actionType: m, dataSource: b } = u || {};
  if (!l || !f)
    return;
  const y = `Step {{ [${l}-form].[__currentStep] }}`, v = b == null ? void 0 : b.resourceId, k = `${l}-form`;
  let S = [];
  return p !== 0 && S.push({
    _id: uuid(),
    _component: "@budibase/standard-components/button",
    _instanceName: uuid(),
    text: "Back",
    type: "secondary",
    size: "M",
    onClick: [
      {
        parameters: {
          type: "prev",
          componentId: k
        },
        "##eventHandlerType": "Change Form Step"
      }
    ]
  }), p !== f - 1 && S.push({
    _id: uuid(),
    _component: "@budibase/standard-components/button",
    _instanceName: uuid(),
    text: "Next",
    type: "cta",
    size: "M",
    onClick: [
      {
        "##eventHandlerType": "Validate Form",
        parameters: {
          componentId: k
        }
      },
      {
        parameters: {
          type: "next",
          componentId: k
        },
        "##eventHandlerType": "Change Form Step"
      }
    ]
  }), m !== "View" && p === f - 1 && S.push({
    _id: uuid(),
    _component: "@budibase/standard-components/button",
    _instanceName: uuid(),
    text: "Save",
    type: "cta",
    size: "M",
    onClick: [
      {
        "##eventHandlerType": "Validate Form",
        parameters: {
          componentId: k
        }
      },
      {
        "##eventHandlerType": "Save Row",
        parameters: {
          tableId: v,
          providerId: k
        }
      },
      // Clear a create form once submitted
      ...m !== "Create" ? [] : [
        {
          "##eventHandlerType": "Clear Form",
          parameters: {
            componentId: k
          }
        }
      ]
    ]
  }), {
    buttons: S,
    title: y
  };
};
function parseFilter(u) {
  if (!(u != null && u.groups))
    return u;
  const l = cloneDeep$3(u);
  return l.groups && (l.groups = l.groups.map((f) => {
    var p;
    return f.filters ? (f.filters = f.filters.filter((m) => m.field && m.operator), (p = f.filters) != null && p.length ? f : null) : f;
  }).filter((f) => !!f)), l;
}
const isBetterSample = (u, l) => {
  if (l == null && u != null)
    return !0;
  if (l != null && u == null)
    return !1;
  const f = typeof l, p = typeof u;
  return f !== p ? !1 : p === "string" && u.length > l.length || p === "object" && Object.keys(u).length > Object.keys(l).length;
}, generateGoldenSample = (u) => {
  let l = {};
  return u == null || u.slice(0, 100).forEach((f) => {
    Object.keys(f).forEach((p) => {
      isBetterSample(f[p], l[p]) && (l[p] = f[p]);
    });
  }), l;
}, memo = (u) => {
  const l = writable(u);
  let f = JSON.stringify(u);
  const p = (m) => {
    const b = JSON.stringify(m);
    b !== f && (l.set(m), f = b);
  };
  return {
    subscribe: l.subscribe,
    set: p,
    update: (m) => {
      let b = JSON.parse(f);
      const y = m(b);
      p(y);
    }
  };
}, derivedMemo = (u, l) => {
  const f = derived(u, l), p = memo(get_store_value(f));
  return f.subscribe(p.set), p;
}, PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES.open = "0";
PACKET_TYPES.close = "1";
PACKET_TYPES.ping = "2";
PACKET_TYPES.pong = "3";
PACKET_TYPES.message = "4";
PACKET_TYPES.upgrade = "5";
PACKET_TYPES.noop = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((u) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[u]] = u;
});
const ERROR_PACKET = { type: "error", data: "parser error" }, withNativeBlob$1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", withNativeArrayBuffer$2 = typeof ArrayBuffer == "function", isView$1 = (u) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(u) : u && u.buffer instanceof ArrayBuffer, encodePacket = ({ type: u, data: l }, f, p) => withNativeBlob$1 && l instanceof Blob ? f ? p(l) : encodeBlobAsBase64(l, p) : withNativeArrayBuffer$2 && (l instanceof ArrayBuffer || isView$1(l)) ? f ? p(l) : encodeBlobAsBase64(new Blob([l]), p) : p(PACKET_TYPES[u] + (l || "")), encodeBlobAsBase64 = (u, l) => {
  const f = new FileReader();
  return f.onload = function() {
    const p = f.result.split(",")[1];
    l("b" + (p || ""));
  }, f.readAsDataURL(u);
};
function toArray(u) {
  return u instanceof Uint8Array ? u : u instanceof ArrayBuffer ? new Uint8Array(u) : new Uint8Array(u.buffer, u.byteOffset, u.byteLength);
}
let TEXT_ENCODER;
function encodePacketToBinary(u, l) {
  if (withNativeBlob$1 && u.data instanceof Blob)
    return u.data.arrayBuffer().then(toArray).then(l);
  if (withNativeArrayBuffer$2 && (u.data instanceof ArrayBuffer || isView$1(u.data)))
    return l(toArray(u.data));
  encodePacket(u, !1, (f) => {
    TEXT_ENCODER || (TEXT_ENCODER = new TextEncoder()), l(TEXT_ENCODER.encode(f));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup$2 = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let u = 0; u < chars.length; u++)
  lookup$2[chars.charCodeAt(u)] = u;
const decode$1 = (u) => {
  let l = u.length * 0.75, f = u.length, p, m = 0, b, y, v, k;
  u[u.length - 1] === "=" && (l--, u[u.length - 2] === "=" && l--);
  const S = new ArrayBuffer(l), $ = new Uint8Array(S);
  for (p = 0; p < f; p += 4)
    b = lookup$2[u.charCodeAt(p)], y = lookup$2[u.charCodeAt(p + 1)], v = lookup$2[u.charCodeAt(p + 2)], k = lookup$2[u.charCodeAt(p + 3)], $[m++] = b << 2 | y >> 4, $[m++] = (y & 15) << 4 | v >> 2, $[m++] = (v & 3) << 6 | k & 63;
  return S;
}, withNativeArrayBuffer$1 = typeof ArrayBuffer == "function", decodePacket = (u, l) => {
  if (typeof u != "string")
    return {
      type: "message",
      data: mapBinary(u, l)
    };
  const f = u.charAt(0);
  return f === "b" ? {
    type: "message",
    data: decodeBase64Packet(u.substring(1), l)
  } : PACKET_TYPES_REVERSE[f] ? u.length > 1 ? {
    type: PACKET_TYPES_REVERSE[f],
    data: u.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[f]
  } : ERROR_PACKET;
}, decodeBase64Packet = (u, l) => {
  if (withNativeArrayBuffer$1) {
    const f = decode$1(u);
    return mapBinary(f, l);
  } else
    return { base64: !0, data: u };
}, mapBinary = (u, l) => {
  switch (l) {
    case "blob":
      return u instanceof Blob ? u : new Blob([u]);
    case "arraybuffer":
    default:
      return u instanceof ArrayBuffer ? u : u.buffer;
  }
}, SEPARATOR = String.fromCharCode(30), encodePayload = (u, l) => {
  const f = u.length, p = new Array(f);
  let m = 0;
  u.forEach((b, y) => {
    encodePacket(b, !1, (v) => {
      p[y] = v, ++m === f && l(p.join(SEPARATOR));
    });
  });
}, decodePayload = (u, l) => {
  const f = u.split(SEPARATOR), p = [];
  for (let m = 0; m < f.length; m++) {
    const b = decodePacket(f[m], l);
    if (p.push(b), b.type === "error")
      break;
  }
  return p;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(u, l) {
      encodePacketToBinary(u, (f) => {
        const p = f.length;
        let m;
        if (p < 126)
          m = new Uint8Array(1), new DataView(m.buffer).setUint8(0, p);
        else if (p < 65536) {
          m = new Uint8Array(3);
          const b = new DataView(m.buffer);
          b.setUint8(0, 126), b.setUint16(1, p);
        } else {
          m = new Uint8Array(9);
          const b = new DataView(m.buffer);
          b.setUint8(0, 127), b.setBigUint64(1, BigInt(p));
        }
        u.data && typeof u.data != "string" && (m[0] |= 128), l.enqueue(m), l.enqueue(f);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(u) {
  return u.reduce((l, f) => l + f.length, 0);
}
function concatChunks(u, l) {
  if (u[0].length === l)
    return u.shift();
  const f = new Uint8Array(l);
  let p = 0;
  for (let m = 0; m < l; m++)
    f[m] = u[0][p++], p === u[0].length && (u.shift(), p = 0);
  return u.length && p < u[0].length && (u[0] = u[0].slice(p)), f;
}
function createPacketDecoderStream(u, l) {
  TEXT_DECODER || (TEXT_DECODER = new TextDecoder());
  const f = [];
  let p = 0, m = -1, b = !1;
  return new TransformStream({
    transform(y, v) {
      for (f.push(y); ; ) {
        if (p === 0) {
          if (totalLength(f) < 1)
            break;
          const k = concatChunks(f, 1);
          b = (k[0] & 128) === 128, m = k[0] & 127, m < 126 ? p = 3 : m === 126 ? p = 1 : p = 2;
        } else if (p === 1) {
          if (totalLength(f) < 2)
            break;
          const k = concatChunks(f, 2);
          m = new DataView(k.buffer, k.byteOffset, k.length).getUint16(0), p = 3;
        } else if (p === 2) {
          if (totalLength(f) < 8)
            break;
          const k = concatChunks(f, 8), S = new DataView(k.buffer, k.byteOffset, k.length), $ = S.getUint32(0);
          if ($ > Math.pow(2, 53 - 32) - 1) {
            v.enqueue(ERROR_PACKET);
            break;
          }
          m = $ * Math.pow(2, 32) + S.getUint32(4), p = 3;
        } else {
          if (totalLength(f) < m)
            break;
          const k = concatChunks(f, m);
          v.enqueue(decodePacket(b ? k : TEXT_DECODER.decode(k), l)), p = 0;
        }
        if (m === 0 || m > u) {
          v.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$1 = 4;
function Emitter(u) {
  if (u)
    return mixin(u);
}
function mixin(u) {
  for (var l in Emitter.prototype)
    u[l] = Emitter.prototype[l];
  return u;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(u, l) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + u] = this._callbacks["$" + u] || []).push(l), this;
};
Emitter.prototype.once = function(u, l) {
  function f() {
    this.off(u, f), l.apply(this, arguments);
  }
  return f.fn = l, this.on(u, f), this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(u, l) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var f = this._callbacks["$" + u];
  if (!f)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + u], this;
  for (var p, m = 0; m < f.length; m++)
    if (p = f[m], p === l || p.fn === l) {
      f.splice(m, 1);
      break;
    }
  return f.length === 0 && delete this._callbacks["$" + u], this;
};
Emitter.prototype.emit = function(u) {
  this._callbacks = this._callbacks || {};
  for (var l = new Array(arguments.length - 1), f = this._callbacks["$" + u], p = 1; p < arguments.length; p++)
    l[p - 1] = arguments[p];
  if (f) {
    f = f.slice(0);
    for (var p = 0, m = f.length; p < m; ++p)
      f[p].apply(this, l);
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(u) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + u] || [];
};
Emitter.prototype.hasListeners = function(u) {
  return !!this.listeners(u).length;
};
const nextTick = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (l) => Promise.resolve().then(l) : (l, f) => f(l, 0))(), globalThisShim = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())(), defaultBinaryType = "arraybuffer";
function createCookieJar() {
}
function pick(u, ...l) {
  return l.reduce((f, p) => (u.hasOwnProperty(p) && (f[p] = u[p]), f), {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout, NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(u, l) {
  l.useNativeTimers ? (u.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim), u.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim)) : (u.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim), u.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim));
}
const BASE64_OVERHEAD = 1.33;
function byteLength(u) {
  return typeof u == "string" ? utf8Length(u) : Math.ceil((u.byteLength || u.size) * BASE64_OVERHEAD);
}
function utf8Length(u) {
  let l = 0, f = 0;
  for (let p = 0, m = u.length; p < m; p++)
    l = u.charCodeAt(p), l < 128 ? f += 1 : l < 2048 ? f += 2 : l < 55296 || l >= 57344 ? f += 3 : (p++, f += 4);
  return f;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function encode(u) {
  let l = "";
  for (let f in u)
    u.hasOwnProperty(f) && (l.length && (l += "&"), l += encodeURIComponent(f) + "=" + encodeURIComponent(u[f]));
  return l;
}
function decode(u) {
  let l = {}, f = u.split("&");
  for (let p = 0, m = f.length; p < m; p++) {
    let b = f[p].split("=");
    l[decodeURIComponent(b[0])] = decodeURIComponent(b[1]);
  }
  return l;
}
class TransportError extends Error {
  constructor(l, f, p) {
    super(l), this.description = f, this.context = p, this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(l) {
    super(), this.writable = !1, installTimerFunctions(this, l), this.opts = l, this.query = l.query, this.socket = l.socket, this.supportsBinary = !l.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(l, f, p) {
    return super.emitReserved("error", new TransportError(l, f, p)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(l) {
    this.readyState === "open" && this.write(l);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(l) {
    const f = decodePacket(l, this.socket.binaryType);
    this.onPacket(f);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(l) {
    super.emitReserved("packet", l);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(l) {
    this.readyState = "closed", super.emitReserved("close", l);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(l) {
  }
  createUri(l, f = {}) {
    return l + "://" + this._hostname() + this._port() + this.opts.path + this._query(f);
  }
  _hostname() {
    const l = this.opts.hostname;
    return l.indexOf(":") === -1 ? l : "[" + l + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(l) {
    const f = encode(l);
    return f.length ? "?" + f : "";
  }
}
class Polling extends Transport {
  constructor() {
    super(...arguments), this._polling = !1;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(l) {
    this.readyState = "pausing";
    const f = () => {
      this.readyState = "paused", l();
    };
    if (this._polling || !this.writable) {
      let p = 0;
      this._polling && (p++, this.once("pollComplete", function() {
        --p || f();
      })), this.writable || (p++, this.once("drain", function() {
        --p || f();
      }));
    } else
      f();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(l) {
    const f = (p) => {
      if (this.readyState === "opening" && p.type === "open" && this.onOpen(), p.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(p);
    };
    decodePayload(l, this.socket.binaryType).forEach(f), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const l = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? l() : this.once("open", l);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(l) {
    this.writable = !1, encodePayload(l, (f) => {
      this.doWrite(f, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const l = this.opts.secure ? "https" : "http", f = this.query || {};
    return this.opts.timestampRequests !== !1 && (f[this.opts.timestampParam] = randomString()), !this.supportsBinary && !f.sid && (f.b64 = 1), this.createUri(l, f);
  }
}
let value$1 = !1;
try {
  value$1 = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch (u) {
}
const hasCORS = value$1;
function empty() {
}
class BaseXHR extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(l) {
    if (super(l), typeof location < "u") {
      const f = location.protocol === "https:";
      let p = location.port;
      p || (p = f ? "443" : "80"), this.xd = typeof location < "u" && l.hostname !== location.hostname || p !== l.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(l, f) {
    const p = this.request({
      method: "POST",
      data: l
    });
    p.on("success", f), p.on("error", (m, b) => {
      this.onError("xhr post error", m, b);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const l = this.request();
    l.on("data", this.onData.bind(this)), l.on("error", (f, p) => {
      this.onError("xhr poll error", f, p);
    }), this.pollXhr = l;
  }
}
class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(l, f, p) {
    super(), this.createRequest = l, installTimerFunctions(this, p), this._opts = p, this._method = p.method || "GET", this._uri = f, this._data = p.data !== void 0 ? p.data : null, this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var l;
    const f = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    f.xdomain = !!this._opts.xd;
    const p = this._xhr = this.createRequest(f);
    try {
      p.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          p.setDisableHeaderCheck && p.setDisableHeaderCheck(!0);
          for (let m in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(m) && p.setRequestHeader(m, this._opts.extraHeaders[m]);
        }
      } catch {
      }
      if (this._method === "POST")
        try {
          p.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        p.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (l = this._opts.cookieJar) === null || l === void 0 || l.addCookies(p), "withCredentials" in p && (p.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (p.timeout = this._opts.requestTimeout), p.onreadystatechange = () => {
        var m;
        p.readyState === 3 && ((m = this._opts.cookieJar) === null || m === void 0 || m.parseCookies(
          // @ts-ignore
          p.getResponseHeader("set-cookie")
        )), p.readyState === 4 && (p.status === 200 || p.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof p.status == "number" ? p.status : 0);
        }, 0));
      }, p.send(this._data);
    } catch (m) {
      this.setTimeoutFn(() => {
        this._onError(m);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = Request.requestsCount++, Request.requests[this._index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(l) {
    this.emitReserved("error", l, this._xhr), this._cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(l) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = empty, l)
        try {
          this._xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Request.requests[this._index], this._xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const l = this._xhr.responseText;
    l !== null && (this.emitReserved("data", l), this.emitReserved("success"), this._cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", unloadHandler);
  else if (typeof addEventListener == "function") {
    const u = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(u, unloadHandler, !1);
  }
}
function unloadHandler() {
  for (let u in Request.requests)
    Request.requests.hasOwnProperty(u) && Request.requests[u].abort();
}
const hasXHR2 = function() {
  const u = newRequest({
    xdomain: !1
  });
  return u && u.responseType !== null;
}();
class XHR extends BaseXHR {
  constructor(l) {
    super(l);
    const f = l && l.forceBase64;
    this.supportsBinary = hasXHR2 && !f;
  }
  request(l = {}) {
    return Object.assign(l, { xd: this.xd }, this.opts), new Request(newRequest, this.uri(), l);
  }
}
function newRequest(u) {
  const l = u.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!l || hasCORS))
      return new XMLHttpRequest();
  } catch {
  }
  if (!l)
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
const isReactNative = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class BaseWS extends Transport {
  get name() {
    return "websocket";
  }
  doOpen() {
    const l = this.uri(), f = this.opts.protocols, p = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (p.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(l, f, p);
    } catch (m) {
      return this.emitReserved("error", m);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (l) => this.onClose({
      description: "websocket connection closed",
      context: l
    }), this.ws.onmessage = (l) => this.onData(l.data), this.ws.onerror = (l) => this.onError("websocket error", l);
  }
  write(l) {
    this.writable = !1;
    for (let f = 0; f < l.length; f++) {
      const p = l[f], m = f === l.length - 1;
      encodePacket(p, this.supportsBinary, (b) => {
        try {
          this.doWrite(p, b);
        } catch {
        }
        m && nextTick(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const l = this.opts.secure ? "wss" : "ws", f = this.query || {};
    return this.opts.timestampRequests && (f[this.opts.timestampParam] = randomString()), this.supportsBinary || (f.b64 = 1), this.createUri(l, f);
  }
}
const WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
class WS extends BaseWS {
  createSocket(l, f, p) {
    return isReactNative ? new WebSocketCtor(l, f, p) : f ? new WebSocketCtor(l, f) : new WebSocketCtor(l);
  }
  doWrite(l, f) {
    this.ws.send(f);
  }
}
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (l) {
      return this.emitReserved("error", l);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((l) => {
      this.onError("webtransport error", l);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((l) => {
        const f = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType), p = l.readable.pipeThrough(f).getReader(), m = createPacketEncoderStream();
        m.readable.pipeTo(l.writable), this._writer = m.writable.getWriter();
        const b = () => {
          p.read().then(({ done: v, value: k }) => {
            v || (this.onPacket(k), b());
          }).catch((v) => {
          });
        };
        b();
        const y = { type: "open" };
        this.query.sid && (y.data = `{"sid":"${this.query.sid}"}`), this._writer.write(y).then(() => this.onOpen());
      });
    });
  }
  write(l) {
    this.writable = !1;
    for (let f = 0; f < l.length; f++) {
      const p = l[f], m = f === l.length - 1;
      this._writer.write(p).then(() => {
        m && nextTick(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var l;
    (l = this._transport) === null || l === void 0 || l.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
}, re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse$1(u) {
  if (u.length > 8e3)
    throw "URI too long";
  const l = u, f = u.indexOf("["), p = u.indexOf("]");
  f != -1 && p != -1 && (u = u.substring(0, f) + u.substring(f, p).replace(/:/g, ";") + u.substring(p, u.length));
  let m = re.exec(u || ""), b = {}, y = 14;
  for (; y--; )
    b[parts[y]] = m[y] || "";
  return f != -1 && p != -1 && (b.source = l, b.host = b.host.substring(1, b.host.length - 1).replace(/;/g, ":"), b.authority = b.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), b.ipv6uri = !0), b.pathNames = pathNames(b, b.path), b.queryKey = queryKey(b, b.query), b;
}
function pathNames(u, l) {
  const f = /\/{2,9}/g, p = l.replace(f, "/").split("/");
  return (l.slice(0, 1) == "/" || l.length === 0) && p.splice(0, 1), l.slice(-1) == "/" && p.splice(p.length - 1, 1), p;
}
function queryKey(u, l) {
  const f = {};
  return l.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(p, m, b) {
    m && (f[m] = b);
  }), f;
}
const withEventListeners = typeof addEventListener == "function" && typeof removeEventListener == "function", OFFLINE_EVENT_LISTENERS = [];
withEventListeners && addEventListener("offline", () => {
  OFFLINE_EVENT_LISTENERS.forEach((u) => u());
}, !1);
class SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(l, f) {
    if (super(), this.binaryType = defaultBinaryType, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, l && typeof l == "object" && (f = l, l = null), l) {
      const p = parse$1(l);
      f.hostname = p.host, f.secure = p.protocol === "https" || p.protocol === "wss", f.port = p.port, p.query && (f.query = p.query);
    } else
      f.host && (f.hostname = parse$1(f.host).host);
    installTimerFunctions(this, f), this.secure = f.secure != null ? f.secure : typeof location < "u" && location.protocol === "https:", f.hostname && !f.port && (f.port = this.secure ? "443" : "80"), this.hostname = f.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = f.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, f.transports.forEach((p) => {
      const m = p.prototype.name;
      this.transports.push(m), this._transportsByName[m] = p;
    }), this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, f), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = decode(this.opts.query)), withEventListeners && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", {
        description: "network connection lost"
      });
    }, OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(l) {
    const f = Object.assign({}, this.opts.query);
    f.EIO = protocol$1, f.transport = l, this.id && (f.sid = this.id);
    const p = Object.assign({}, this.opts, {
      query: f,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[l]);
    return new this._transportsByName[l](p);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const l = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const f = this.createTransport(l);
    f.open(), this.setTransport(f);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(l) {
    this.transport && this.transport.removeAllListeners(), this.transport = l, l.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (f) => this._onClose("transport close", f));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open", SocketWithoutUpgrade.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(l) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", l), this.emitReserved("heartbeat"), l.type) {
        case "open":
          this.onHandshake(JSON.parse(l.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const f = new Error("server error");
          f.code = l.data, this._onError(f);
          break;
        case "message":
          this.emitReserved("data", l.data), this.emitReserved("message", l.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(l) {
    this.emitReserved("handshake", l), this.id = l.sid, this.transport.query.sid = l.sid, this._pingInterval = l.pingInterval, this._pingTimeout = l.pingTimeout, this._maxPayload = l.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const l = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + l, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, l), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const l = this._getWritablePackets();
      this.transport.send(l), this._prevBufferLen = l.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let f = 1;
    for (let p = 0; p < this.writeBuffer.length; p++) {
      const m = this.writeBuffer[p].data;
      if (m && (f += byteLength(m)), p > 0 && f > this._maxPayload)
        return this.writeBuffer.slice(0, p);
      f += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return !0;
    const l = Date.now() > this._pingTimeoutTime;
    return l && (this._pingTimeoutTime = 0, nextTick(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), l;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(l, f, p) {
    return this._sendPacket("message", l, f, p), this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(l, f, p) {
    return this._sendPacket("message", l, f, p), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(l, f, p, m) {
    if (typeof f == "function" && (m = f, f = void 0), typeof p == "function" && (m = p, p = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    p = p || {}, p.compress = p.compress !== !1;
    const b = {
      type: l,
      data: f,
      options: p
    };
    this.emitReserved("packetCreate", b), this.writeBuffer.push(b), m && this.once("flush", m), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const l = () => {
      this._onClose("forced close"), this.transport.close();
    }, f = () => {
      this.off("upgrade", f), this.off("upgradeError", f), l();
    }, p = () => {
      this.once("upgrade", f), this.once("upgradeError", f);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? p() : l();
    }) : this.upgrading ? p() : l()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(l) {
    if (SocketWithoutUpgrade.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
      return this.transports.shift(), this._open();
    this.emitReserved("error", l), this._onClose("transport error", l);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(l, f) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), withEventListeners && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
        const p = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
        p !== -1 && OFFLINE_EVENT_LISTENERS.splice(p, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", l, f), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
SocketWithoutUpgrade.protocol = protocol$1;
class SocketWithUpgrade extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade)
      for (let l = 0; l < this._upgrades.length; l++)
        this._probe(this._upgrades[l]);
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(l) {
    let f = this.createTransport(l), p = !1;
    SocketWithoutUpgrade.priorWebsocketSuccess = !1;
    const m = () => {
      p || (f.send([{ type: "ping", data: "probe" }]), f.once("packet", (w) => {
        if (!p)
          if (w.type === "pong" && w.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", f), !f)
              return;
            SocketWithoutUpgrade.priorWebsocketSuccess = f.name === "websocket", this.transport.pause(() => {
              p || this.readyState !== "closed" && ($(), this.setTransport(f), f.send([{ type: "upgrade" }]), this.emitReserved("upgrade", f), f = null, this.upgrading = !1, this.flush());
            });
          } else {
            const T = new Error("probe error");
            T.transport = f.name, this.emitReserved("upgradeError", T);
          }
      }));
    };
    function b() {
      p || (p = !0, $(), f.close(), f = null);
    }
    const y = (w) => {
      const T = new Error("probe error: " + w);
      T.transport = f.name, b(), this.emitReserved("upgradeError", T);
    };
    function v() {
      y("transport closed");
    }
    function k() {
      y("socket closed");
    }
    function S(w) {
      f && w.name !== f.name && b();
    }
    const $ = () => {
      f.removeListener("open", m), f.removeListener("error", y), f.removeListener("close", v), this.off("close", k), this.off("upgrading", S);
    };
    f.once("open", m), f.once("error", y), f.once("close", v), this.once("close", k), this.once("upgrading", S), this._upgrades.indexOf("webtransport") !== -1 && l !== "webtransport" ? this.setTimeoutFn(() => {
      p || f.open();
    }, 200) : f.open();
  }
  onHandshake(l) {
    this._upgrades = this._filterUpgrades(l.upgrades), super.onHandshake(l);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(l) {
    const f = [];
    for (let p = 0; p < l.length; p++)
      ~this.transports.indexOf(l[p]) && f.push(l[p]);
    return f;
  }
}
let Socket$1 = class extends SocketWithUpgrade {
  constructor(l, f = {}) {
    const p = typeof l == "object" ? l : f;
    (!p.transports || p.transports && typeof p.transports[0] == "string") && (p.transports = (p.transports || ["polling", "websocket", "webtransport"]).map((m) => transports[m]).filter((m) => !!m)), super(l, p);
  }
};
function url(u, l = "", f) {
  let p = u;
  f = f || typeof location < "u" && location, u == null && (u = f.protocol + "//" + f.host), typeof u == "string" && (u.charAt(0) === "/" && (u.charAt(1) === "/" ? u = f.protocol + u : u = f.host + u), /^(https?|wss?):\/\//.test(u) || (typeof f < "u" ? u = f.protocol + "//" + u : u = "https://" + u), p = parse$1(u)), p.port || (/^(http|ws)$/.test(p.protocol) ? p.port = "80" : /^(http|ws)s$/.test(p.protocol) && (p.port = "443")), p.path = p.path || "/";
  const b = p.host.indexOf(":") !== -1 ? "[" + p.host + "]" : p.host;
  return p.id = p.protocol + "://" + b + ":" + p.port + l, p.href = p.protocol + "://" + b + (f && f.port === p.port ? "" : ":" + p.port), p;
}
const withNativeArrayBuffer = typeof ArrayBuffer == "function", isView = (u) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(u) : u.buffer instanceof ArrayBuffer, toString = Object.prototype.toString, withNativeBlob = typeof Blob == "function" || typeof Blob < "u" && toString.call(Blob) === "[object BlobConstructor]", withNativeFile = typeof File == "function" || typeof File < "u" && toString.call(File) === "[object FileConstructor]";
function isBinary(u) {
  return withNativeArrayBuffer && (u instanceof ArrayBuffer || isView(u)) || withNativeBlob && u instanceof Blob || withNativeFile && u instanceof File;
}
function hasBinary(u, l) {
  if (!u || typeof u != "object")
    return !1;
  if (Array.isArray(u)) {
    for (let f = 0, p = u.length; f < p; f++)
      if (hasBinary(u[f]))
        return !0;
    return !1;
  }
  if (isBinary(u))
    return !0;
  if (u.toJSON && typeof u.toJSON == "function" && arguments.length === 1)
    return hasBinary(u.toJSON(), !0);
  for (const f in u)
    if (Object.prototype.hasOwnProperty.call(u, f) && hasBinary(u[f]))
      return !0;
  return !1;
}
function deconstructPacket(u) {
  const l = [], f = u.data, p = u;
  return p.data = _deconstructPacket(f, l), p.attachments = l.length, { packet: p, buffers: l };
}
function _deconstructPacket(u, l) {
  if (!u)
    return u;
  if (isBinary(u)) {
    const f = { _placeholder: !0, num: l.length };
    return l.push(u), f;
  } else if (Array.isArray(u)) {
    const f = new Array(u.length);
    for (let p = 0; p < u.length; p++)
      f[p] = _deconstructPacket(u[p], l);
    return f;
  } else if (typeof u == "object" && !(u instanceof Date)) {
    const f = {};
    for (const p in u)
      Object.prototype.hasOwnProperty.call(u, p) && (f[p] = _deconstructPacket(u[p], l));
    return f;
  }
  return u;
}
function reconstructPacket(u, l) {
  return u.data = _reconstructPacket(u.data, l), delete u.attachments, u;
}
function _reconstructPacket(u, l) {
  if (!u)
    return u;
  if (u && u._placeholder === !0) {
    if (typeof u.num == "number" && u.num >= 0 && u.num < l.length)
      return l[u.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(u))
    for (let f = 0; f < u.length; f++)
      u[f] = _reconstructPacket(u[f], l);
  else if (typeof u == "object")
    for (const f in u)
      Object.prototype.hasOwnProperty.call(u, f) && (u[f] = _reconstructPacket(u[f], l));
  return u;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], protocol = 5;
var PacketType;
(function(u) {
  u[u.CONNECT = 0] = "CONNECT", u[u.DISCONNECT = 1] = "DISCONNECT", u[u.EVENT = 2] = "EVENT", u[u.ACK = 3] = "ACK", u[u.CONNECT_ERROR = 4] = "CONNECT_ERROR", u[u.BINARY_EVENT = 5] = "BINARY_EVENT", u[u.BINARY_ACK = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(l) {
    this.replacer = l;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(l) {
    return (l.type === PacketType.EVENT || l.type === PacketType.ACK) && hasBinary(l) ? this.encodeAsBinary({
      type: l.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
      nsp: l.nsp,
      data: l.data,
      id: l.id
    }) : [this.encodeAsString(l)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(l) {
    let f = "" + l.type;
    return (l.type === PacketType.BINARY_EVENT || l.type === PacketType.BINARY_ACK) && (f += l.attachments + "-"), l.nsp && l.nsp !== "/" && (f += l.nsp + ","), l.id != null && (f += l.id), l.data != null && (f += JSON.stringify(l.data, this.replacer)), f;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(l) {
    const f = deconstructPacket(l), p = this.encodeAsString(f.packet), m = f.buffers;
    return m.unshift(p), m;
  }
}
function isObject(u) {
  return Object.prototype.toString.call(u) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(l) {
    super(), this.reviver = l;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(l) {
    let f;
    if (typeof l == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      f = this.decodeString(l);
      const p = f.type === PacketType.BINARY_EVENT;
      p || f.type === PacketType.BINARY_ACK ? (f.type = p ? PacketType.EVENT : PacketType.ACK, this.reconstructor = new BinaryReconstructor(f), f.attachments === 0 && super.emitReserved("decoded", f)) : super.emitReserved("decoded", f);
    } else if (isBinary(l) || l.base64)
      if (this.reconstructor)
        f = this.reconstructor.takeBinaryData(l), f && (this.reconstructor = null, super.emitReserved("decoded", f));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + l);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(l) {
    let f = 0;
    const p = {
      type: Number(l.charAt(0))
    };
    if (PacketType[p.type] === void 0)
      throw new Error("unknown packet type " + p.type);
    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
      const b = f + 1;
      for (; l.charAt(++f) !== "-" && f != l.length; )
        ;
      const y = l.substring(b, f);
      if (y != Number(y) || l.charAt(f) !== "-")
        throw new Error("Illegal attachments");
      p.attachments = Number(y);
    }
    if (l.charAt(f + 1) === "/") {
      const b = f + 1;
      for (; ++f && !(l.charAt(f) === "," || f === l.length); )
        ;
      p.nsp = l.substring(b, f);
    } else
      p.nsp = "/";
    const m = l.charAt(f + 1);
    if (m !== "" && Number(m) == m) {
      const b = f + 1;
      for (; ++f; ) {
        const y = l.charAt(f);
        if (y == null || Number(y) != y) {
          --f;
          break;
        }
        if (f === l.length)
          break;
      }
      p.id = Number(l.substring(b, f + 1));
    }
    if (l.charAt(++f)) {
      const b = this.tryParse(l.substr(f));
      if (Decoder.isPayloadValid(p.type, b))
        p.data = b;
      else
        throw new Error("invalid payload");
    }
    return p;
  }
  tryParse(l) {
    try {
      return JSON.parse(l, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(l, f) {
    switch (l) {
      case PacketType.CONNECT:
        return isObject(f);
      case PacketType.DISCONNECT:
        return f === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof f == "string" || isObject(f);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(f) && (typeof f[0] == "number" || typeof f[0] == "string" && RESERVED_EVENTS$1.indexOf(f[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(f);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class BinaryReconstructor {
  constructor(l) {
    this.packet = l, this.buffers = [], this.reconPack = l;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(l) {
    if (this.buffers.push(l), this.buffers.length === this.reconPack.attachments) {
      const f = reconstructPacket(this.reconPack, this.buffers);
      return this.finishedReconstruction(), f;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(u, l, f) {
  return u.on(l, f), function() {
    u.off(l, f);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(l, f, p) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = l, this.nsp = f, p && p.auth && (this.auth = p.auth), this._opts = Object.assign({}, p), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const l = this.io;
    this.subs = [
      on(l, "open", this.onopen.bind(this)),
      on(l, "packet", this.onpacket.bind(this)),
      on(l, "error", this.onerror.bind(this)),
      on(l, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...l) {
    return l.unshift("message"), this.emit.apply(this, l), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(l, ...f) {
    var p, m, b;
    if (RESERVED_EVENTS.hasOwnProperty(l))
      throw new Error('"' + l.toString() + '" is a reserved event name');
    if (f.unshift(l), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(f), this;
    const y = {
      type: PacketType.EVENT,
      data: f
    };
    if (y.options = {}, y.options.compress = this.flags.compress !== !1, typeof f[f.length - 1] == "function") {
      const $ = this.ids++, w = f.pop();
      this._registerAckCallback($, w), y.id = $;
    }
    const v = (m = (p = this.io.engine) === null || p === void 0 ? void 0 : p.transport) === null || m === void 0 ? void 0 : m.writable, k = this.connected && !(!((b = this.io.engine) === null || b === void 0) && b._hasPingExpired());
    return this.flags.volatile && !v || (k ? (this.notifyOutgoingListeners(y), this.packet(y)) : this.sendBuffer.push(y)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(l, f) {
    var p;
    const m = (p = this.flags.timeout) !== null && p !== void 0 ? p : this._opts.ackTimeout;
    if (m === void 0) {
      this.acks[l] = f;
      return;
    }
    const b = this.io.setTimeoutFn(() => {
      delete this.acks[l];
      for (let v = 0; v < this.sendBuffer.length; v++)
        this.sendBuffer[v].id === l && this.sendBuffer.splice(v, 1);
      f.call(this, new Error("operation has timed out"));
    }, m), y = (...v) => {
      this.io.clearTimeoutFn(b), f.apply(this, v);
    };
    y.withError = !0, this.acks[l] = y;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(l, ...f) {
    return new Promise((p, m) => {
      const b = (y, v) => y ? m(y) : p(v);
      b.withError = !0, f.push(b), this.emit(l, ...f);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(l) {
    let f;
    typeof l[l.length - 1] == "function" && (f = l.pop());
    const p = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: l,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    l.push((m, ...b) => p !== this._queue[0] ? void 0 : (m !== null ? p.tryCount > this._opts.retries && (this._queue.shift(), f && f(m)) : (this._queue.shift(), f && f(null, ...b)), p.pending = !1, this._drainQueue())), this._queue.push(p), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(l = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const f = this._queue[0];
    f.pending && !l || (f.pending = !0, f.tryCount++, this.flags = f.flags, this.emit.apply(this, f.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(l) {
    l.nsp = this.nsp, this.io._packet(l);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((l) => {
      this._sendConnectPacket(l);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(l) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, l) : l
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(l) {
    this.connected || this.emitReserved("connect_error", l);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(l, f) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", l, f), this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((l) => {
      if (!this.sendBuffer.some((p) => String(p.id) === l)) {
        const p = this.acks[l];
        delete this.acks[l], p.withError && p.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(l) {
    if (l.nsp === this.nsp)
      switch (l.type) {
        case PacketType.CONNECT:
          l.data && l.data.sid ? this.onconnect(l.data.sid, l.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          this.onevent(l);
          break;
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          this.onack(l);
          break;
        case PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case PacketType.CONNECT_ERROR:
          this.destroy();
          const p = new Error(l.data.message);
          p.data = l.data.data, this.emitReserved("connect_error", p);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(l) {
    const f = l.data || [];
    l.id != null && f.push(this.ack(l.id)), this.connected ? this.emitEvent(f) : this.receiveBuffer.push(Object.freeze(f));
  }
  emitEvent(l) {
    if (this._anyListeners && this._anyListeners.length) {
      const f = this._anyListeners.slice();
      for (const p of f)
        p.apply(this, l);
    }
    super.emit.apply(this, l), this._pid && l.length && typeof l[l.length - 1] == "string" && (this._lastOffset = l[l.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(l) {
    const f = this;
    let p = !1;
    return function(...m) {
      p || (p = !0, f.packet({
        type: PacketType.ACK,
        id: l,
        data: m
      }));
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(l) {
    const f = this.acks[l.id];
    typeof f == "function" && (delete this.acks[l.id], f.withError && l.data.unshift(null), f.apply(this, l.data));
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(l, f) {
    this.id = l, this.recovered = f && this._pid === f, this._pid = f, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((l) => this.emitEvent(l)), this.receiveBuffer = [], this.sendBuffer.forEach((l) => {
      this.notifyOutgoingListeners(l), this.packet(l);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((l) => l()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: PacketType.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(l) {
    return this.flags.compress = l, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(l) {
    return this.flags.timeout = l, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(l) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(l), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(l) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(l), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(l) {
    if (!this._anyListeners)
      return this;
    if (l) {
      const f = this._anyListeners;
      for (let p = 0; p < f.length; p++)
        if (l === f[p])
          return f.splice(p, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(l) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(l), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(l) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(l), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(l) {
    if (!this._anyOutgoingListeners)
      return this;
    if (l) {
      const f = this._anyOutgoingListeners;
      for (let p = 0; p < f.length; p++)
        if (l === f[p])
          return f.splice(p, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(l) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const f = this._anyOutgoingListeners.slice();
      for (const p of f)
        p.apply(this, l.data);
    }
  }
}
function Backoff(u) {
  u = u || {}, this.ms = u.min || 100, this.max = u.max || 1e4, this.factor = u.factor || 2, this.jitter = u.jitter > 0 && u.jitter <= 1 ? u.jitter : 0, this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var u = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var l = Math.random(), f = Math.floor(l * this.jitter * u);
    u = Math.floor(l * 10) & 1 ? u + f : u - f;
  }
  return Math.min(u, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(u) {
  this.ms = u;
};
Backoff.prototype.setMax = function(u) {
  this.max = u;
};
Backoff.prototype.setJitter = function(u) {
  this.jitter = u;
};
class Manager extends Emitter {
  constructor(l, f) {
    var p;
    super(), this.nsps = {}, this.subs = [], l && typeof l == "object" && (f = l, l = void 0), f = f || {}, f.path = f.path || "/socket.io", this.opts = f, installTimerFunctions(this, f), this.reconnection(f.reconnection !== !1), this.reconnectionAttempts(f.reconnectionAttempts || 1 / 0), this.reconnectionDelay(f.reconnectionDelay || 1e3), this.reconnectionDelayMax(f.reconnectionDelayMax || 5e3), this.randomizationFactor((p = f.randomizationFactor) !== null && p !== void 0 ? p : 0.5), this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(f.timeout == null ? 2e4 : f.timeout), this._readyState = "closed", this.uri = l;
    const m = f.parser || parser;
    this.encoder = new m.Encoder(), this.decoder = new m.Decoder(), this._autoConnect = f.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(l) {
    return arguments.length ? (this._reconnection = !!l, l || (this.skipReconnect = !0), this) : this._reconnection;
  }
  reconnectionAttempts(l) {
    return l === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = l, this);
  }
  reconnectionDelay(l) {
    var f;
    return l === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = l, (f = this.backoff) === null || f === void 0 || f.setMin(l), this);
  }
  randomizationFactor(l) {
    var f;
    return l === void 0 ? this._randomizationFactor : (this._randomizationFactor = l, (f = this.backoff) === null || f === void 0 || f.setJitter(l), this);
  }
  reconnectionDelayMax(l) {
    var f;
    return l === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = l, (f = this.backoff) === null || f === void 0 || f.setMax(l), this);
  }
  timeout(l) {
    return arguments.length ? (this._timeout = l, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(l) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const f = this.engine, p = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const m = on(f, "open", function() {
      p.onopen(), l && l();
    }), b = (v) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", v), l ? l(v) : this.maybeReconnectOnOpen();
    }, y = on(f, "error", b);
    if (this._timeout !== !1) {
      const v = this._timeout, k = this.setTimeoutFn(() => {
        m(), b(new Error("timeout")), f.close();
      }, v);
      this.opts.autoUnref && k.unref(), this.subs.push(() => {
        this.clearTimeoutFn(k);
      });
    }
    return this.subs.push(m), this.subs.push(y), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(l) {
    return this.open(l);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const l = this.engine;
    this.subs.push(
      on(l, "ping", this.onping.bind(this)),
      on(l, "data", this.ondata.bind(this)),
      on(l, "error", this.onerror.bind(this)),
      on(l, "close", this.onclose.bind(this)),
      // @ts-ignore
      on(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(l) {
    try {
      this.decoder.add(l);
    } catch (f) {
      this.onclose("parse error", f);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(l) {
    nextTick(() => {
      this.emitReserved("packet", l);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(l) {
    this.emitReserved("error", l);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(l, f) {
    let p = this.nsps[l];
    return p ? this._autoConnect && !p.active && p.connect() : (p = new Socket(this, l, f), this.nsps[l] = p), p;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(l) {
    const f = Object.keys(this.nsps);
    for (const p of f)
      if (this.nsps[p].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(l) {
    const f = this.encoder.encode(l);
    for (let p = 0; p < f.length; p++)
      this.engine.write(f[p], l.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((l) => l()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(l, f) {
    var p;
    this.cleanup(), (p = this.engine) === null || p === void 0 || p.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", l, f), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const l = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const f = this.backoff.duration();
      this._reconnecting = !0;
      const p = this.setTimeoutFn(() => {
        l.skipReconnect || (this.emitReserved("reconnect_attempt", l.backoff.attempts), !l.skipReconnect && l.open((m) => {
          m ? (l._reconnecting = !1, l.reconnect(), this.emitReserved("reconnect_error", m)) : l.onreconnect();
        }));
      }, f);
      this.opts.autoUnref && p.unref(), this.subs.push(() => {
        this.clearTimeoutFn(p);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const l = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", l);
  }
}
const cache = {};
function lookup$1(u, l) {
  typeof u == "object" && (l = u, u = void 0), l = l || {};
  const f = url(u, l.path || "/socket.io"), p = f.source, m = f.id, b = f.path, y = cache[m] && b in cache[m].nsps, v = l.forceNew || l["force new connection"] || l.multiplex === !1 || y;
  let k;
  return v ? k = new Manager(p, l) : (cache[m] || (cache[m] = new Manager(p, l)), k = cache[m]), f.query && !l.query && (l.query = f.queryKey), k.socket(f.path, l);
}
Object.assign(lookup$1, {
  Manager,
  Socket,
  io: lookup$1,
  connect: lookup$1
});
const DefaultOptions = {
  heartbeat: !0
}, createWebsocket = (u, l = DefaultOptions) => {
  if (!u)
    throw "A websocket path must be provided";
  const { heartbeat: f } = {
    ...DefaultOptions,
    ...l
  }, p = location.protocol === "https:", m = p ? "wss:" : "ws:", b = location.hostname, y = location.port || (p ? 443 : 80);
  let v = lookup$1(`${m}//${b}:${y}`, {
    path: u,
    // Cap reconnection attempts to 3 (total of 15 seconds before giving up)
    reconnectionAttempts: 3,
    // Delay reconnection attempt by 5 seconds
    reconnectionDelay: 5e3,
    reconnectionDelayMax: 5e3,
    // Timeout after 4 seconds so we never stack requests
    timeout: 4e3,
    // Disable polling and rely on websocket only, as HTTP transport
    // will only work with sticky sessions which we don't have
    transports: ["websocket"]
  }), k;
  return f && (k = setInterval(() => {
    v.emit(SocketEvent.Heartbeat);
  }, SocketSessionTTL * 500)), v.on("disconnect", () => {
    clearInterval(k);
  }), v.onOther = (S, $) => {
    v.on(S, (w) => {
      (w == null ? void 0 : w.apiSessionId) !== APISessionID && $(w);
    });
  }, v;
}, extractFileNameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
async function downloadStream(u) {
  const l = await u.blob(), f = u.headers.get("Content-Disposition"), m = extractFileNameRegex.exec(f)[1].replace(/['"]/g, ""), b = new Blob([l]), y = URL.createObjectURL(b), v = document.createElement("a");
  v.href = y, v.download = m, v.click(), URL.revokeObjectURL(y);
}
const shouldDisplaySetting = (u, l) => {
  if (l.nestedOnly && !l.nested)
    return !1;
  let f = l.dependsOn;
  return f && !Array.isArray(f) && (f = [f]), f != null && f.length ? f.every((p) => {
    let m = p, b = null, y = !!p.invert;
    if (typeof p == "object" && (m = p.setting, b = p.value), !m)
      return !1;
    Array.isArray(b) || (b = [b]);
    const v = deepGet$1(u, m);
    return b.some((S) => S == null ? v != null && v !== !1 && v !== "" : S === v) !== y;
  }) : !0;
}, columnTypeManyTypeOverrides = {
  [FieldType.DATETIME]: FieldType.STRING,
  [FieldType.BOOLEAN]: FieldType.STRING,
  [FieldType.SIGNATURE_SINGLE]: FieldType.ATTACHMENTS
}, columnTypeManyParser = {
  [FieldType.DATETIME]: (u, l) => {
    function f(p) {
      const { timeOnly: m, dateOnly: b } = l || {}, y = !b, v = parseDate(p, { enableTime: y });
      return getDateDisplayValue(v, {
        enableTime: y,
        timeOnly: m
      });
    }
    return u.map((p) => f(p));
  },
  [FieldType.BOOLEAN]: (u) => u.map((l) => !!l),
  [FieldType.BB_REFERENCE_SINGLE]: (u) => [
    ...new Map(u.map((l) => [l._id, l])).values()
  ],
  [FieldType.BB_REFERENCE]: (u) => [
    ...new Map(u.map((l) => [l._id, l])).values()
  ],
  [FieldType.ARRAY]: (u) => Array.from(new Set(u))
};
function enrichSchemaWithRelColumns(u) {
  return Object.keys(u).reduce(
    (f, p) => {
      const m = u[p];
      if (f[p] = m, m.visible !== !1 && isRelationshipField(m) && m.columns) {
        const b = (m == null ? void 0 : m.relationshipType) === RelationshipType.ONE_TO_MANY;
        for (const y of Object.keys(m.columns)) {
          const v = m.columns[y];
          if (!v.visible)
            continue;
          const k = `${m.name}.${y}`;
          f[k] = {
            ...v,
            type: v.type,
            // TODO
            name: k,
            related: { field: p, subField: y },
            cellRenderType: !b && columnTypeManyTypeOverrides[v.type] || v.type
          };
        }
      }
      return f;
    },
    {}
  );
}
function getRelatedTableValues(u, l, f) {
  var b, y, v, k;
  const p = isRelationshipField(f) && (f == null ? void 0 : f.relationshipType) === RelationshipType.ONE_TO_MANY;
  let m = "";
  if (p)
    m = (y = (b = u[l.related.field]) == null ? void 0 : b[0]) == null ? void 0 : y[l.related.subField];
  else {
    const S = columnTypeManyParser[l.type] || ((T) => T), $ = (k = (v = u[l.related.field]) == null ? void 0 : v.flatMap((T) => T[l.related.subField])) == null ? void 0 : k.filter((T) => T != null), w = S($ || [], l);
    m = w, [
      FieldType.STRING,
      FieldType.NUMBER,
      FieldType.BIGINT,
      FieldType.BOOLEAN,
      FieldType.DATETIME,
      FieldType.LONGFORM,
      FieldType.BARCODEQR
    ].includes(l.type) && (m = w == null ? void 0 : w.join(", "));
  }
  return m;
}
const getSettingsDefinition = (u) => {
  var f;
  if (!u)
    return [];
  let l = [];
  return (f = u.settings) == null || f.forEach((p) => {
    var m;
    p.section ? l = l.concat(
      (m = p.settings || []) == null ? void 0 : m.map((b) => ({
        ...b,
        sectionDependsOn: p.dependsOn
      }))
    ) : l.push(p);
  }), l;
}, NumberFormatter = Intl.NumberFormat(), formatNumber = (u) => {
  const l = typeof u;
  if (l !== "string" && l !== "number" || l === "string" && !u.trim().length)
    return "";
  const f = NumberFormatter.format(u);
  return f === "NaN" ? stringifyValue(u) : f;
}, stringifyValue = (u) => {
  if (u == null)
    return "";
  if (typeof u == "string")
    return u;
  if (typeof u.toString == "function")
    return stringifyValue(u.toString());
  try {
    return JSON.stringify(u);
  } catch {
    return "";
  }
}, stringifyField = (u, l) => {
  switch (l.type) {
    case FieldType.AUTO:
      return "";
    case FieldType.SIGNATURE_SINGLE:
      return u ? "Yes" : "No";
    case FieldType.ATTACHMENT_SINGLE:
    case FieldType.ATTACHMENTS:
      return u ? (Array.isArray(u) ? u : [u]).map((p) => p.name).filter((p) => !!p).join(", ") : "";
    case FieldType.LINK:
      return u ? (Array.isArray(u) ? u : [u]).map((p) => p.primaryDisplay).filter((p) => !!p).join(", ") : "";
    case FieldType.JSON:
      return u ? JSON.stringify(u) : "";
    case FieldType.BB_REFERENCE:
    case FieldType.BB_REFERENCE_SINGLE: {
      if (l.subtype !== BBReferenceFieldSubType.USERS && l.subtype !== BBReferenceFieldSubType.USER || !u)
        return "";
      const f = Array.isArray(u) ? u : [u];
      return (f == null ? void 0 : f.map((p) => p.primaryDisplay).join(", ")) || "";
    }
    case FieldType.ARRAY:
      return (u == null ? void 0 : u.join(", ")) || "";
    case FieldType.BOOLEAN:
      return capitalise((u == null ? void 0 : u.toString()) || "false");
    case FieldType.DATETIME:
      return getDateDisplayValue(u, {
        enableTime: !l.dateOnly,
        timeOnly: l.timeOnly
      });
    case FieldType.NUMBER:
      return formatNumber(u);
    case FieldType.STRING:
    case FieldType.LONGFORM:
    case FieldType.BIGINT:
    case FieldType.OPTIONS:
    case FieldType.AI:
    case FieldType.BARCODEQR:
      return u || "";
    case FieldType.FORMULA:
    default:
      return stringifyValue(u);
  }
}, stringifyRow = (u, l) => {
  let f = {};
  return Object.entries(l).forEach(([p, m]) => {
    f[p] = stringifyField(
      deepGet(u, p),
      m
    );
  }), f;
}, SESSIONS_INVALIDATED_KEY = "bb-sessions-invalidated";
function popNumSessionsInvalidated() {
  const u = parseInt(
    localStorage.getItem(SESSIONS_INVALIDATED_KEY) || "0",
    10
  );
  return localStorage.removeItem(SESSIONS_INVALIDATED_KEY), u;
}
function invalidationMessage(u) {
  return `You've been logged out of ${u} other ${u === 1 ? "session" : "sessions"} because users are only allowed ${MAX_SESSIONS_PER_USER} active sessions at any one time.`;
}
const { buildQuery, limit: queryLimit, runQuery, sort } = QueryUtils;
class BaseDataFetch {
  /**
   * Constructs a new DataFetch instance.
   * @param opts the fetch options
   */
  constructor(l) {
    me(this, "API");
    me(this, "features");
    me(this, "options");
    me(this, "store");
    me(this, "derivedStore");
    if (this.features = {
      supportsSearch: !1,
      supportsSort: !1,
      supportsPagination: !1
    }, this.options = {
      datasource: l.datasource,
      limit: 10,
      // Search config
      filter: null,
      query: l.query,
      // Sorting config
      sortColumn: null,
      sortOrder: SortOrder.ASCENDING,
      sortType: null,
      // Pagination config
      paginate: !0,
      // Client side feature customisation
      clientSideSearching: !0,
      clientSideSorting: !0,
      clientSideLimiting: !0
    }, this.store = writable({
      rows: [],
      info: null,
      schema: null,
      loading: !1,
      loaded: !1,
      query: l.query,
      pageNumber: 0,
      cursor: null,
      cursors: [],
      resetKey: Math.random().toString(),
      error: null
    }), this.API = l == null ? void 0 : l.API, this.options = {
      ...this.options,
      ...l
    }, !this.API)
      throw "An API client is required for fetching data";
    if (this.getData = this.getData.bind(this), this.getPage = this.getPage.bind(this), this.getInitialData = this.getInitialData.bind(this), this.determineFeatureFlags = this.determineFeatureFlags.bind(this), this.refresh = this.refresh.bind(this), this.update = this.update.bind(this), this.hasNextPage = this.hasNextPage.bind(this), this.hasPrevPage = this.hasPrevPage.bind(this), this.nextPage = this.nextPage.bind(this), this.prevPage = this.prevPage.bind(this), this.derivedStore = derived(this.store, (f) => ({
      ...f,
      ...this.features,
      hasNextPage: this.hasNextPage(f),
      hasPrevPage: this.hasPrevPage(f)
    })), !this.options.datasource) {
      this.store.update((f) => ({ ...f, loaded: !0 }));
      return;
    }
  }
  /**
   * Extend the svelte store subscribe method to that instances of this class
   * can be treated like stores
   */
  get subscribe() {
    return this.derivedStore.subscribe;
  }
  /**
   * Gets the default sort column for this datasource
   */
  getDefaultSortColumn(l, f) {
    return l != null && l.primaryDisplay && f[l.primaryDisplay] ? l.primaryDisplay : Object.keys(f)[0];
  }
  /**
   * Fetches a fresh set of data from the server, resetting pagination
   */
  async getInitialData() {
    const { filter: l, paginate: f } = this.options, p = await this.getDefinition(), m = await this.determineFeatureFlags();
    this.features = {
      supportsSearch: !!(m != null && m.supportsSearch),
      supportsSort: !!(m != null && m.supportsSort),
      supportsPagination: f && !!(m != null && m.supportsPagination)
    };
    let b = this.getSchema(p);
    if (!b)
      return;
    if (b = this.enrichSchema(b), this.options.sortColumn && !b[this.options.sortColumn] && (this.options.sortColumn = null), this.options.sortColumn || (this.options.sortColumn = this.getDefaultSortColumn(p, b)), !this.options.sortColumn)
      this.options.sortOrder = SortOrder.ASCENDING, this.options.sortType = null;
    else {
      this.options.sortType = SortType.STRING;
      const k = b == null ? void 0 : b[this.options.sortColumn];
      ((k == null ? void 0 : k.type) === FieldType.NUMBER || (k == null ? void 0 : k.type) === FieldType.BIGINT || "calculationType" in k && (k != null && k.calculationType)) && (this.options.sortType = SortType.NUMBER), this.options.sortOrder ? this.options.sortOrder = this.options.sortOrder.toLowerCase() : this.options.sortOrder = SortOrder.ASCENDING;
    }
    let y = this.options.query;
    y || (y = buildQuery(l ?? void 0)), this.store.update((k) => ({
      ...k,
      definition: p,
      schema: b,
      query: y,
      loading: !0,
      cursors: [],
      cursor: null
    }));
    const v = await this.getPage();
    this.store.update((k) => ({
      ...k,
      loading: !1,
      loaded: !0,
      pageNumber: 0,
      rows: v.rows,
      info: v.info,
      cursors: f && v.hasNextPage ? [null, v.cursor] : [null],
      error: v.error,
      resetKey: Math.random().toString()
    }));
  }
  /**
   * Fetches some filtered, sorted and paginated data
   */
  async getPage() {
    const {
      sortColumn: l,
      sortOrder: f,
      sortType: p,
      limit: m,
      clientSideSearching: b,
      clientSideSorting: y,
      clientSideLimiting: v
    } = this.options, { query: k } = get_store_value(this.store);
    let { rows: S, info: $, hasNextPage: w, cursor: T, error: E } = await this.getData();
    return !this.features.supportsSearch && b && (S = runQuery(S, k)), !this.features.supportsSort && y && p && (S = sort(S, l, f, p)), !this.features.supportsPagination && v && (S = queryLimit(S, m)), {
      rows: S,
      info: $,
      hasNextPage: w,
      cursor: T,
      error: E
    };
  }
  /**
   * Gets the schema definition for a datasource.
   * @param definition the datasource definition
   * @return {object} the schema
   */
  getSchema(l) {
    return (l == null ? void 0 : l.schema) ?? void 0;
  }
  /**
   * Enriches a datasource schema with nested fields and ensures the structure
   * is correct.
   * @param schema the datasource schema
   * @return {object} the enriched datasource schema
   */
  enrichSchema(l) {
    let f = {};
    for (const m of Object.keys(l)) {
      const b = l[m];
      if (b.type === FieldType.JSON) {
        const y = convertJSONSchemaToTableSchema(b, {
          squashObjects: !0
        });
        if (y)
          for (const v of Object.keys(y))
            f[`${m}.${v}`] = {
              type: y[v].type,
              nestedJSON: !0
            };
      }
    }
    let p = {};
    return Object.entries({ ...l, ...f }).forEach(
      ([m, b]) => {
        typeof b == "string" ? p[m] = {
          type: b,
          name: m
        } : p[m] = {
          ...b,
          type: b.type,
          // TODO: check type union definition conflicts
          name: m
        };
      }
    ), p;
  }
  /**
   * Determine the feature flag for this datasource
   */
  async determineFeatureFlags() {
    return {
      supportsSearch: !1,
      supportsSort: !1,
      supportsPagination: !1
    };
  }
  /**
   * Resets the data set and updates options
   * @param newOptions any new options
   */
  async update(l) {
    let f = !1;
    for (const [p, m] of Object.entries(l || {})) {
      const b = this.options[p] ?? null;
      if (JSON.stringify(m ?? null) !== JSON.stringify(b)) {
        f = !0;
        break;
      }
    }
    f && (this.options = {
      ...this.options,
      ...cloneDeep$1(l)
    }, await this.getInitialData());
  }
  /**
   * Loads the same page again
   */
  async refresh() {
    if (get_store_value(this.store).loading)
      return;
    this.store.update((k) => ({ ...k, loading: !0 }));
    const { rows: l, info: f, error: p, cursor: m } = await this.getPage();
    let { cursors: b } = get_store_value(this.store);
    const { pageNumber: y } = get_store_value(this.store);
    if (!l.length && y > 0)
      return this.store.update((k) => ({
        ...k,
        loading: !1,
        cursors: b.slice(0, y)
      })), await this.prevPage();
    b[y + 1] != m && (b = b.slice(0, y + 1), b[y + 1] = m), this.store.update((k) => ({
      ...k,
      rows: l,
      info: f,
      loading: !1,
      error: p,
      cursors: b
    }));
  }
  /**
   * Determines whether there is a next page of data based on the state of the
   * store
   * @param state the current store state
   * @return {boolean} whether there is a next page of data or not
   */
  hasNextPage(l) {
    return l.cursors[l.pageNumber + 1] != null;
  }
  /**
   * Determines whether there is a previous page of data based on the state of
   * the store
   * @param state the current store state
   * @return {boolean} whether there is a previous page of data or not
   */
  hasPrevPage(l) {
    return l.pageNumber > 0;
  }
  /**
   * Fetches the next page of data
   */
  async nextPage() {
    const l = get_store_value(this.derivedStore);
    if (l.loading || !this.options.paginate || !l.hasNextPage)
      return;
    const f = l.cursors[l.pageNumber + 1];
    this.store.update((k) => ({
      ...k,
      loading: !0,
      cursor: f,
      pageNumber: k.pageNumber + 1
    }));
    const { rows: p, info: m, hasNextPage: b, cursor: y, error: v } = await this.getPage();
    this.store.update((k) => {
      let { cursors: S, pageNumber: $ } = k;
      return b && (S[$ + 1] = y), {
        ...k,
        rows: p,
        info: m,
        cursors: S,
        loading: !1,
        error: v
      };
    });
  }
  /**
   * Fetches the previous page of data
   */
  async prevPage() {
    const l = get_store_value(this.derivedStore);
    if (l.loading || !this.options.paginate || !l.hasPrevPage)
      return;
    const f = l.cursors[l.pageNumber - 1];
    this.store.update((y) => ({
      ...y,
      loading: !0,
      cursor: f,
      pageNumber: y.pageNumber - 1
    }));
    const { rows: p, info: m, error: b } = await this.getPage();
    this.store.update((y) => ({
      ...y,
      rows: p,
      info: m,
      loading: !1,
      error: b
    }));
  }
}
class CustomFetch extends BaseDataFetch {
  // Gets the correct Budibase type for a JS value
  getType(l) {
    return l == null ? "string" : typeof l === "object" ? Array.isArray(l) ? "array" : "json" : isNaN(l) ? "string" : "number";
  }
  // Parses the custom data into an array format
  parseCustomData(l) {
    if (!l)
      return [];
    if (Array.isArray(l))
      return l;
    if (typeof l == "string") {
      try {
        const f = JSON.parse(l);
        return Array.isArray(f) ? f : [f];
      } catch {
      }
      return l.includes(`
`) ? l.split(`
`).map((f) => f.trim()) : l.split(",").map((f) => f.trim());
    }
    return [l];
  }
  // Enriches the custom data to ensure the structure and format is usable
  enrichCustomData(l) {
    return l != null && l.length ? (l = l.filter((f) => f != null && f !== "" && !Array.isArray(f)), l.map((f) => {
      if (typeof f == "object")
        return f;
      if (typeof f == "string") {
        const p = f.split(",").map((b) => b.trim()), m = {};
        for (let b = 0; b < p.length; b++) {
          const v = `Value${b === 0 ? "" : ` ${b + 1}`}`;
          m[v] = p[b];
        }
        return m;
      }
      return { Value: f };
    })) : [];
  }
  // Extracts and parses the custom data from the datasource definition
  getCustomData(l) {
    return this.enrichCustomData(this.parseCustomData(l == null ? void 0 : l.data));
  }
  async getDefinition() {
    const { datasource: l } = this.options, f = {}, p = this.getCustomData(l);
    if (!(p != null && p.length))
      return { schema: f };
    for (const m of p)
      for (const b of Object.keys(m))
        if (b !== "_id" && !f[b]) {
          let y = this.getType(m[b]);
          const v = {};
          if (y === "string") {
            const k = [...new Set(p.map(($) => $[b]))];
            k.length / p.length <= 0.8 && k.length > 1 && (y = "options", v.inclusion = k);
          } else
            y === "array" && (v.inclusion = [...new Set(p.map((k) => k[b]).flat())]);
          f[b] = {
            type: y,
            constraints: v
          };
        }
    return { schema: f };
  }
  async getData() {
    const { datasource: l } = this.options;
    return {
      rows: this.getCustomData(l),
      hasNextPage: !1,
      cursor: null
    };
  }
}
function isArrayOfStrings(u) {
  return Array.isArray(u) && !!u[0] && typeof u[0] != "object";
}
class FieldFetch extends BaseDataFetch {
  async getDefinition() {
    const { datasource: l } = this.options;
    let f;
    return l.fieldType === "attachment" ? f = {
      url: {
        type: "string"
      },
      name: {
        type: "string"
      }
    } : l.fieldType === "array" && (f = {
      value: {
        type: "string"
      }
    }), { schema: f };
  }
  async getData() {
    const { datasource: l } = this.options, f = (l == null ? void 0 : l.value) || [];
    let p;
    return isArrayOfStrings(f) ? p = f.map((m) => ({ value: m })) : p = f, {
      rows: p || [],
      hasNextPage: !1,
      cursor: null
    };
  }
}
class GroupUserFetch extends BaseDataFetch {
  constructor(l) {
    super({
      ...l,
      datasource: {
        type: "groupUser"
      }
    });
  }
  async determineFeatureFlags() {
    return {
      supportsSearch: !0,
      supportsSort: !1,
      supportsPagination: !0
    };
  }
  async getDefinition() {
    return {
      schema: {}
    };
  }
  async getData() {
    const { query: l, cursor: f } = get_store_value(this.store);
    try {
      const p = await this.API.getGroupUsers({
        id: l.groupId,
        emailSearch: l.emailSearch,
        bookmark: f ?? void 0
      });
      return {
        rows: (p == null ? void 0 : p.users) || [],
        hasNextPage: (p == null ? void 0 : p.hasNextPage) || !1,
        cursor: (p == null ? void 0 : p.bookmark) || null
      };
    } catch (p) {
      return {
        rows: [],
        hasNextPage: !1,
        error: p
      };
    }
  }
}
class JSONArrayFetch extends FieldFetch {
  async getDefinition() {
    const { datasource: l } = this.options;
    try {
      const { fieldName: f } = l, p = await this.API.fetchTableDefinition(l.tableId);
      return { schema: p.schema[f].schema ?? getJSONArrayDatasourceSchema(p.schema, l) };
    } catch {
      return null;
    }
  }
}
class NestedProviderFetch extends BaseDataFetch {
  async getDefinition() {
    var f, p;
    const { datasource: l } = this.options;
    return {
      schema: (f = l == null ? void 0 : l.value) == null ? void 0 : f.schema,
      primaryDisplay: (p = l == null ? void 0 : l.value) == null ? void 0 : p.primaryDisplay
    };
  }
  async getData() {
    var f;
    const { datasource: l } = this.options;
    return {
      rows: ((f = l == null ? void 0 : l.value) == null ? void 0 : f.rows) || [],
      hasNextPage: !1,
      cursor: null
    };
  }
}
class QueryArrayFetch extends FieldFetch {
  async getDefinition() {
    const { datasource: l } = this.options;
    if (!(l != null && l.tableId))
      return null;
    try {
      const f = await this.API.fetchQueryDefinition(l.tableId), p = generateQueryArraySchemas(
        f.schema,
        f.nestedSchemaFields
      );
      return {
        schema: getJSONArrayDatasourceSchema(p, l)
      };
    } catch {
      return null;
    }
  }
}
class QueryFetch extends BaseDataFetch {
  async determineFeatureFlags() {
    var p, m, b, y, v, k;
    const l = await this.getDefinition();
    return { supportsPagination: !!((m = (p = l == null ? void 0 : l.fields) == null ? void 0 : p.pagination) != null && m.type) && !!((y = (b = l == null ? void 0 : l.fields) == null ? void 0 : b.pagination) != null && y.location) && !!((k = (v = l == null ? void 0 : l.fields) == null ? void 0 : v.pagination) != null && k.pageParam) };
  }
  async getDefinition() {
    const { datasource: l } = this.options;
    if (!(l != null && l._id))
      return null;
    try {
      const f = await this.API.fetchQueryDefinition(l._id);
      return f.fields || (f.fields = l.fields), f;
    } catch {
      return null;
    }
  }
  getDefaultSortColumn() {
    return null;
  }
  async getData() {
    var $, w;
    const { datasource: l, limit: f, paginate: p } = this.options, { supportsPagination: m } = this.features, { cursor: b, definition: y } = get_store_value(this.store), v = (w = ($ = y == null ? void 0 : y.fields) == null ? void 0 : $.pagination) == null ? void 0 : w.type, k = cloneDeep$5(l.queryParams || {});
    for (const T of (l == null ? void 0 : l.parameters) || [])
      k[T.name] || (k[T.name] = T.default);
    const S = { parameters: k };
    if (p && m) {
      const T = v === "page" ? parseInt(b || "1") : b;
      S.pagination = { page: T, limit: f };
    }
    try {
      const T = await this.API.executeQuery(l == null ? void 0 : l._id, S), { data: E, pagination: R, ...O } = T;
      let P = null, L = !1;
      return p && m && (v === "page" ? (P = S.pagination.page + 1, L = (E == null ? void 0 : E.length) === f && f > 0) : (P = R == null ? void 0 : R.cursor, L = P != null)), {
        rows: E || [],
        info: O,
        cursor: P,
        hasNextPage: L
      };
    } catch {
      return {
        rows: [],
        hasNextPage: !1
      };
    }
  }
}
class RelationshipFetch extends BaseDataFetch {
  async getDefinition() {
    const { datasource: l } = this.options;
    if (!(l != null && l.tableId))
      return null;
    try {
      return await this.API.fetchTableDefinition(l.tableId);
    } catch (f) {
      return this.store.update((p) => ({
        ...p,
        error: f
      })), null;
    }
  }
  async getData() {
    const { datasource: l } = this.options;
    if (!(l != null && l.rowId) || !(l != null && l.rowTableId))
      return { rows: [] };
    try {
      return { rows: await this.API.fetchRelationshipData(
        l.rowTableId,
        l.rowId,
        l.fieldName
      ) };
    } catch {
      return { rows: [] };
    }
  }
}
class TableFetch extends BaseDataFetch {
  async determineFeatureFlags() {
    return {
      supportsSearch: !0,
      supportsSort: !0,
      supportsPagination: !0
    };
  }
  async getDefinition() {
    const { datasource: l } = this.options;
    if (!(l != null && l.tableId))
      return null;
    try {
      return await this.API.fetchTableDefinition(l.tableId);
    } catch (f) {
      return this.store.update((p) => ({
        ...p,
        error: f
      })), null;
    }
  }
  async getData() {
    const { datasource: l, limit: f, sortColumn: p, sortOrder: m, sortType: b, paginate: y } = this.options, { tableId: v } = l, { cursor: k, query: S } = get_store_value(this.store);
    try {
      const $ = await this.API.searchTable(v, {
        query: S,
        limit: f,
        sort: p,
        sortOrder: m ?? SortOrder.ASCENDING,
        sortType: b,
        paginate: y,
        bookmark: k
      });
      return {
        rows: ($ == null ? void 0 : $.rows) || [],
        hasNextPage: ($ == null ? void 0 : $.hasNextPage) || !1,
        cursor: ($ == null ? void 0 : $.bookmark) || null
      };
    } catch ($) {
      return {
        rows: [],
        hasNextPage: !1,
        error: $
      };
    }
  }
}
class UserFetch extends BaseDataFetch {
  constructor(l) {
    super({
      ...l,
      datasource: {
        type: "user"
      }
    });
  }
  async determineFeatureFlags() {
    return {
      supportsSearch: !0,
      supportsSort: !1,
      supportsPagination: !0
    };
  }
  async getDefinition() {
    return { schema: {} };
  }
  async getData() {
    const { limit: l, paginate: f } = this.options, { cursor: p, query: m } = get_store_value(this.store), { appId: b, paginated: y, ...v } = m, k = isSupportedUserSearch(v) ? v : {};
    try {
      const S = {
        bookmark: p ?? void 0,
        query: k ?? void 0,
        appId: b,
        paginate: y || f,
        limit: l
      }, $ = await this.API.searchUsers(S);
      return {
        rows: ($ == null ? void 0 : $.data) || [],
        hasNextPage: ($ == null ? void 0 : $.hasNextPage) || !1,
        cursor: ($ == null ? void 0 : $.nextPage) || null
      };
    } catch (S) {
      return {
        rows: [],
        hasNextPage: !1,
        error: S
      };
    }
  }
}
class ViewFetch extends BaseDataFetch {
  async getDefinition() {
    const { datasource: l } = this.options;
    if (!(l != null && l.tableId))
      return null;
    try {
      return await this.API.fetchTableDefinition(l.tableId);
    } catch (f) {
      return this.store.update((p) => ({
        ...p,
        error: f
      })), null;
    }
  }
  getSchema(l) {
    var p, m;
    const { datasource: f } = this.options;
    return (m = (p = l == null ? void 0 : l.views) == null ? void 0 : p[f == null ? void 0 : f.name]) == null ? void 0 : m.schema;
  }
  async getData() {
    const { datasource: l } = this.options;
    try {
      return { rows: await this.API.fetchViewData(l.name, {
        calculation: l.calculation,
        field: l.field,
        groupBy: l.groupBy,
        tableId: l.tableId
      }) || [] };
    } catch (f) {
      return console.error(f, { datasource: l }), { rows: [] };
    }
  }
}
class ViewV2Fetch extends BaseDataFetch {
  async determineFeatureFlags() {
    return {
      supportsSearch: !0,
      supportsSort: !0,
      supportsPagination: !0
    };
  }
  async getDefinition() {
    const { datasource: l } = this.options;
    try {
      const f = await this.API.viewV2.fetchDefinition(l.id);
      return f == null ? void 0 : f.data;
    } catch (f) {
      return this.store.update((p) => ({
        ...p,
        error: f
      })), null;
    }
  }
  getDefaultSortColumn() {
    return null;
  }
  async getData() {
    var $;
    const { datasource: l, limit: f, sortColumn: p, sortOrder: m, sortType: b, paginate: y } = this.options, { cursor: v, query: k, definition: S } = get_store_value(this.store);
    if ((S == null ? void 0 : S.type) === ViewV2Type.CALCULATION && !Object.values(S.schema || {}).some(
      isCalculationField
    ))
      return {
        rows: [],
        hasNextPage: !1,
        cursor: null,
        error: null
      };
    !p && (($ = S == null ? void 0 : S.sort) != null && $.field) && (this.options.sortColumn = S.sort.field, this.options.sortOrder = S.sort.order || SortOrder.ASCENDING);
    try {
      const w = {
        query: k,
        paginate: y,
        limit: f,
        bookmark: v,
        sort: p,
        sortOrder: m,
        sortType: b
      };
      if (y) {
        const T = await this.API.viewV2.fetch(l.id, {
          ...w,
          paginate: y
        });
        return {
          rows: (T == null ? void 0 : T.rows) || [],
          hasNextPage: (T == null ? void 0 : T.hasNextPage) || !1,
          cursor: (T == null ? void 0 : T.bookmark) || null
        };
      } else {
        const T = await this.API.viewV2.fetch(l.id, {
          ...w,
          paginate: y
        });
        return {
          rows: (T == null ? void 0 : T.rows) || [],
          hasNextPage: !1,
          cursor: null
        };
      }
    } catch (w) {
      return {
        rows: [],
        hasNextPage: !1,
        cursor: null,
        error: w
      };
    }
  }
}
const DataFetchMap = {
  table: TableFetch,
  view: ViewFetch,
  viewV2: ViewV2Fetch,
  query: QueryFetch,
  link: RelationshipFetch,
  user: UserFetch,
  groupUser: GroupUserFetch,
  custom: CustomFetch,
  // Client specific datasource types
  provider: NestedProviderFetch,
  field: FieldFetch,
  jsonarray: JSONArrayFetch,
  queryarray: QueryArrayFetch
}, fetchData = ({
  API: u,
  datasource: l,
  options: f
}) => {
  const p = DataFetchMap[l == null ? void 0 : l.type] || TableFetch, m = new p({ API: u, datasource: l, ...f });
  return m.getInitialData(), m;
}, createEmptyFetchInstance = ({
  API: u,
  datasource: l
}) => {
  const f = DataFetchMap[l == null ? void 0 : l.type];
  return f ? new f({
    API: u,
    datasource: l,
    query: null
  }) : null;
}, getDatasourceDefinition = async ({
  API: u,
  datasource: l
}) => {
  const f = createEmptyFetchInstance({ API: u, datasource: l });
  return await (f == null ? void 0 : f.getDefinition());
}, getDatasourceSchema = ({
  API: u,
  datasource: l,
  definition: f
}) => {
  const p = createEmptyFetchInstance({ API: u, datasource: l });
  return p == null ? void 0 : p.getSchema(f);
}, createLocalStorageStore = (u, l) => {
  const f = writable(l, () => {
    b();
    const y = ({ key: v }) => v === u && b();
    return window.addEventListener("storage", y), () => window.removeEventListener("storage", y);
  }), p = (y) => {
    f.set(y), localStorage.setItem(u, JSON.stringify(y));
  }, m = (y) => p(y(get_store_value(f))), b = () => {
    const y = localStorage.getItem(u);
    if (y == null)
      p(l);
    else
      try {
        f.set(JSON.parse(y));
      } catch {
        p(l);
      }
  };
  return {
    ...f,
    set: p,
    update: m
  };
}, createGridClipboard = () => {
  const u = writable({
    value: void 0,
    multiCellCopy: !1,
    sourceTableId: void 0,
    sourceViewId: void 0
  });
  return {
    subscribe: u.subscribe,
    set: u.set,
    update: u.update,
    copy: (l, f, p, m) => {
      u.set({
        value: l,
        multiCellCopy: f,
        sourceTableId: p,
        sourceViewId: m
      });
    },
    clear: () => {
      u.set({
        value: void 0,
        multiCellCopy: !1,
        sourceTableId: void 0,
        sourceViewId: void 0
      });
    },
    get: () => get_store_value(u)
  };
};
createGridClipboard();
const SplitPage_svelte_svelte_type_style_lang = "", SignatureModal_svelte_svelte_type_style_lang = "";
function create_default_slot_2$8(u) {
  let l, f, p, m = {
    darkMode: (
      /*darkMode*/
      u[3]
    ),
    value: (
      /*value*/
      u[1]
    ),
    saveIcon: !1
  };
  return f = new Signature({ props: m }), u[8](f), f.$on(
    "update",
    /*update_handler*/
    u[9]
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "signature-wrap modal svelte-1jbgrys");
    },
    m(b, y) {
      insert(b, l, y), mount_component(f, l, null), p = !0;
    },
    p(b, y) {
      const v = {};
      y & /*darkMode*/
      8 && (v.darkMode = /*darkMode*/
      b[3]), y & /*value*/
      2 && (v.value = /*value*/
      b[1]), f.$set(v);
    },
    i(b) {
      p || (transition_in(f.$$.fragment, b), p = !0);
    },
    o(b) {
      transition_out(f.$$.fragment, b), p = !1;
    },
    d(b) {
      b && detach(l), u[8](null), destroy_component(f);
    }
  };
}
function create_default_slot_1$c(u) {
  let l;
  return {
    c() {
      l = text$2(
        /*title*/
        u[2]
      );
    },
    m(f, p) {
      insert(f, l, p);
    },
    p(f, p) {
      p & /*title*/
      4 && set_data(
        l,
        /*title*/
        f[2]
      );
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_header_slot(u) {
  let l, f, p;
  return f = new Body({
    props: {
      $$slots: { default: [create_default_slot_1$c] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "slot", "header");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b & /*$$scope, title*/
      4100 && (y.$$scope = { dirty: b, ctx: m }), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_default_slot$w(u) {
  let l, f;
  return l = new ModalContent({
    props: {
      showConfirmButton: !0,
      showCancelButton: !1,
      showCloseIcon: !1,
      custom: !0,
      disabled: !/*edited*/
      u[6],
      showDivider: !1,
      onConfirm: (
        /*func*/
        u[10]
      ),
      $$slots: {
        header: [create_header_slot],
        default: [create_default_slot_2$8]
      },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*edited*/
      64 && (b.disabled = !/*edited*/
      p[6]), m & /*onConfirm, canvas*/
      33 && (b.onConfirm = /*func*/
      p[10]), m & /*$$scope, title, darkMode, value, canvas, edited*/
      4206 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$11(u) {
  let l, f, p = {
    $$slots: { default: [create_default_slot$w] },
    $$scope: { ctx: u }
  };
  return l = new Modal({ props: p }), u[11](l), {
    c() {
      create_component(l.$$.fragment);
    },
    m(m, b) {
      mount_component(l, m, b), f = !0;
    },
    p(m, [b]) {
      const y = {};
      b & /*$$scope, edited, onConfirm, canvas, title, darkMode, value*/
      4207 && (y.$$scope = { dirty: b, ctx: m }), l.$set(y);
    },
    i(m) {
      f || (transition_in(l.$$.fragment, m), f = !0);
    },
    o(m) {
      transition_out(l.$$.fragment, m), f = !1;
    },
    d(m) {
      u[11](null), destroy_component(l, m);
    }
  };
}
function instance$$(u, l, f) {
  let { onConfirm: p = () => {
  } } = l, { value: m } = l, { title: b } = l, { darkMode: y } = l;
  const v = () => {
    f(6, $ = !1), k.show();
  };
  let k, S, $ = !1;
  function w(O) {
    binding_callbacks[O ? "unshift" : "push"](() => {
      S = O, f(5, S);
    });
  }
  const T = () => {
    f(6, $ = !0);
  }, E = () => {
    p(S);
  };
  function R(O) {
    binding_callbacks[O ? "unshift" : "push"](() => {
      k = O, f(4, k);
    });
  }
  return u.$$set = (O) => {
    "onConfirm" in O && f(0, p = O.onConfirm), "value" in O && f(1, m = O.value), "title" in O && f(2, b = O.title), "darkMode" in O && f(3, y = O.darkMode);
  }, [
    p,
    m,
    b,
    y,
    k,
    S,
    $,
    v,
    w,
    T,
    E,
    R
  ];
}
class SignatureModal extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$$, create_fragment$11, safe_not_equal, {
      onConfirm: 0,
      value: 1,
      title: 2,
      darkMode: 3,
      show: 7
    });
  }
  get show() {
    return this.$$.ctx[7];
  }
}
const UserAvatars_svelte_svelte_type_style_lang$1 = "", Updating_svelte_svelte_type_style_lang = "";
function create_else_block_1$2(u) {
  let l;
  return {
    c() {
      l = text$2("Something went wrong!");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_if_block_1$f(u) {
  let l;
  return {
    c() {
      l = text$2("System update");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_else_block$a(u) {
  let l, f, p, m, b;
  return {
    c() {
      l = text$2(`An error occurred, please try again later.
      `), f = element("br"), p = text$2(`
      Contact
      `), m = element("a"), m.textContent = "support", b = text$2(` if the
      issue persists.`), attr(m, "href", "https://budibase.com/support/"), attr(m, "target", "_blank"), attr(m, "class", "svelte-1kjb5e");
    },
    m(y, v) {
      insert(y, l, v), insert(y, f, v), insert(y, p, v), insert(y, m, v), insert(y, b, v);
    },
    d(y) {
      y && (detach(l), detach(f), detach(p), detach(m), detach(b));
    }
  };
}
function create_if_block$w(u) {
  let l, f, p, m, b;
  return {
    c() {
      l = text$2(`Please wait and we'll be back in a second!
      `), f = element("br"), p = text$2(`
      Check out the
      `), m = element("a"), m.textContent = "documentation", b = text$2(" on app migrations."), attr(m, "href", "https://docs.budibase.com/docs/app-migrations"), attr(m, "target", "_blank"), attr(m, "class", "svelte-1kjb5e");
    },
    m(y, v) {
      insert(y, l, v), insert(y, f, v), insert(y, p, v), insert(y, m, v), insert(y, b, v);
    },
    d(y) {
      y && (detach(l), detach(f), detach(p), detach(m), detach(b));
    }
  };
}
function create_fragment$10(u) {
  let l, f, p, m;
  function b(w, T) {
    return (
      /*timedOut*/
      w[0] ? create_else_block_1$2 : create_if_block_1$f
    );
  }
  let y = b(u), v = y(u);
  function k(w, T) {
    return (
      /*timedOut*/
      w[0] ? create_else_block$a : create_if_block$w
    );
  }
  let S = k(u), $ = S(u);
  return {
    c() {
      l = element("div"), f = element("span"), v.c(), p = space(), m = element("span"), $.c(), attr(f, "class", "header svelte-1kjb5e"), attr(m, "class", "subtext svelte-1kjb5e"), attr(l, "class", "loading svelte-1kjb5e"), toggle_class(
        l,
        "timeout",
        /*timedOut*/
        u[0]
      );
    },
    m(w, T) {
      insert(w, l, T), append$1(l, f), v.m(f, null), append$1(l, p), append$1(l, m), $.m(m, null);
    },
    p(w, [T]) {
      y !== (y = b(w)) && (v.d(1), v = y(w), v && (v.c(), v.m(f, null))), S !== (S = k(w)) && ($.d(1), $ = S(w), $ && ($.c(), $.m(m, null))), T & /*timedOut*/
      1 && toggle_class(
        l,
        "timeout",
        /*timedOut*/
        w[0]
      );
    },
    i: noop$4,
    o: noop$4,
    d(w) {
      w && detach(l), v.d(), $.d();
    }
  };
}
function instance$_(u, l, f) {
  let { isMigrationDone: p } = l, { onMigrationDone: m } = l, { timeoutSeconds: b = 60 } = l, y = !1;
  async function v() {
    let k = 0;
    for (; ; ) {
      const S = 5e3 + Math.random() * 5e3;
      if (await new Promise((w) => setTimeout(w, S)), k += S, await p()) {
        m();
        return;
      }
      if (k > b * 1e3) {
        f(0, y = !0);
        return;
      }
    }
  }
  return v(), u.$$set = (k) => {
    "isMigrationDone" in k && f(1, p = k.isMigrationDone), "onMigrationDone" in k && f(2, m = k.onMigrationDone), "timeoutSeconds" in k && f(3, b = k.timeoutSeconds);
  }, [y, p, m, b];
}
class Updating extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$_, create_fragment$10, safe_not_equal, {
      isMigrationDone: 1,
      onMigrationDone: 2,
      timeoutSeconds: 3
    });
  }
}
const SmallRowHeight = 36, MediumRowHeight = 64, LargeRowHeight = 92, DefaultRowHeight = SmallRowHeight, VPadding = 0, HPadding = 80, ScrollBarSize = 8, GutterWidth = 72, DefaultColumnWidth = 200, MinColumnWidth = 56, NewRowID = "new", BlankRowID = "blank", GeneratedIDPrefix = "â€½â€½", CellIDSeparator = "â€½â€½", RowPageSize = 100, FocusedCellMinOffset = ScrollBarSize * 3, ControlsHeight = 50, PopoverMinWidth = 200, PopoverMaxWidth = 400, PopoverMaxHeight = 236, MaxCellRenderOverflow = 222, Constants = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BlankRowID,
  CellIDSeparator,
  ControlsHeight,
  DefaultColumnWidth,
  DefaultRowHeight,
  FocusedCellMinOffset,
  GeneratedIDPrefix,
  GutterWidth,
  HPadding,
  LargeRowHeight,
  MaxCellRenderOverflow,
  MediumRowHeight,
  MinColumnWidth,
  NewRowID,
  PopoverMaxHeight,
  PopoverMaxWidth,
  PopoverMinWidth,
  RowPageSize,
  ScrollBarSize,
  SmallRowHeight,
  VPadding
}, Symbol.toStringTag, { value: "Module" })), createStores = () => ({
  metadata: writable({})
}), deriveStores = (u) => {
  const { columns: l, props: f } = u;
  return {
    conditions: derivedMemo(
      derived([l, f], ([m, b]) => {
        let y = [];
        for (let v of m)
          for (let k of v.conditions || [])
            y.push({
              ...k,
              column: v.name,
              type: v.schema.type
            });
        if (b.buttons)
          for (let v = 0; v < b.buttons.length; v++) {
            const k = b.buttons[v];
            for (let S of k.conditions || [])
              y.push({
                ...S,
                target: "button",
                buttonIndex: v
              });
          }
        return y;
      }),
      (m) => m
    )
  };
}, initialise$1 = (u) => {
  const { metadata: l, conditions: f, rows: p } = u;
  f.subscribe((m) => {
    let b = {};
    if (m != null && m.length)
      for (let y of get_store_value(p))
        b[y._id] = evaluateConditions(y, m, u);
    l.set(b);
  }), p.subscribe((m) => {
    const b = get_store_value(f);
    if (!(b != null && b.length))
      return;
    const y = get_store_value(l);
    let v = {};
    for (let k of m) {
      const S = y[k._id];
      !// No _rev indicates a new row
      (!k._rev || // _rev changed since last evaluation
      S && S.version !== k._rev || // this is an external row, we have no way to know if it has changed, so
      // we always re-evaluate
      k._rev === EXTERNAL_ROW_REV) && S || (y[k._id] = evaluateConditions(k, b, u));
    }
    Object.keys(v).length && l.update((k) => ({
      ...k,
      ...v
    }));
  });
}, TypeCoercionMap = {
  [FieldType.NUMBER]: parseFloat,
  [FieldType.DATETIME]: (u) => u ? new Date(u).toISOString() : null,
  [FieldType.BOOLEAN]: (u) => `${u}`.toLowerCase().trim() === "true" ? !0 : `${u}`.toLowerCase().trim() === "false" ? !1 : null
}, evaluateConditions = (u, l, f) => {
  const p = {
    version: u._rev,
    row: {},
    cell: {},
    button: {}
  }, { props: m } = f, b = get_store_value(m);
  let y = [...l];
  if (b.buttons)
    for (let k = 0; k < b.buttons.length; k++) {
      const S = b.buttons[k];
      if (!S.getRowConditions)
        continue;
      const $ = S.getRowConditions(u) || [];
      if ($.length) {
        y = y.filter((w) => !(w.target === "button" && w.buttonIndex === k));
        for (let w of $)
          y.push({
            ...w,
            target: "button",
            buttonIndex: k
          });
      }
    }
  const v = /* @__PURE__ */ new Set();
  for (let k of y)
    k.target === "button" && k.action === "show" && typeof k.buttonIndex == "number" && (v.add(k.buttonIndex), p.button[k.buttonIndex] || (p.button[k.buttonIndex] = {}), p.button[k.buttonIndex].hidden = !0);
  for (let k of y)
    try {
      let {
        column: S,
        type: $,
        referenceValue: w,
        operator: T,
        metadataKey: E,
        metadataValue: R,
        target: O,
        buttonIndex: P,
        newValue: L,
        action: M,
        setting: B,
        settingValue: j
      } = k, x;
      O === "button" ? x = L : x = u[S];
      let N = $;
      $ === FieldType.FORMULA && (x === !0 || x === !1 ? N = FieldType.BOOLEAN : typeof x == "number" && (N = FieldType.NUMBER));
      const D = TypeCoercionMap[N];
      D && (x = D(x), w = D(w));
      let W = buildQuery$1([{
        operator: T,
        type: $,
        field: "value",
        value: w
      }]);
      W.onEmptyFilter = EmptyFilterOption.RETURN_NONE, runQuery$1([{ value: x }], W).length > 0 && (O === "button" && typeof P == "number" ? (p.button[P] || (p.button[P] = {}), M === "hide" ? p.button[P].hidden = !0 : M === "show" ? p.button[P].hidden = !1 : M === "update" && B && (p.button[P][B] = j)) : O === "row" ? p.row = {
        ...p.row,
        [E]: R
      } : p.cell[S] = {
        ...p.cell[S],
        [E]: R
      });
    } catch {
    }
  return p;
}, Conditions = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createStores,
  deriveStores,
  initialise: initialise$1
}, Symbol.toStringTag, { value: "Module" })), GridScrollWrapper_svelte_svelte_type_style_lang = "", GridCell_svelte_svelte_type_style_lang = "", GridPopover_svelte_svelte_type_style_lang = "";
function create_default_slot$v(u) {
  let l, f, p, m;
  const b = (
    /*#slots*/
    u[13].default
  ), y = create_slot(
    b,
    u,
    /*$$scope*/
    u[15],
    null
  );
  return {
    c() {
      l = element("div"), y && y.c(), attr(l, "class", "grid-popover-contents svelte-5gc6hw"), attr(
        l,
        "style",
        /*style*/
        u[7]
      );
    },
    m(v, k) {
      insert(v, l, k), y && y.m(l, null), f = !0, p || (m = [
        action_destroyer(clickOutside.call(
          null,
          l,
          /*clickOutside_function*/
          u[14]
        )),
        listen(l, "wheel", wheel_handler)
      ], p = !0);
    },
    p(v, k) {
      y && y.p && (!f || k & /*$$scope*/
      32768) && update_slot_base(
        y,
        b,
        v,
        /*$$scope*/
        v[15],
        f ? get_slot_changes(
          b,
          /*$$scope*/
          v[15],
          k,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          v[15]
        ),
        null
      ), (!f || k & /*style*/
      128) && attr(
        l,
        "style",
        /*style*/
        v[7]
      );
    },
    i(v) {
      f || (transition_in(y, v), f = !0);
    },
    o(v) {
      transition_out(y, v), f = !1;
    },
    d(v) {
      v && detach(l), y && y.d(v), p = !1, run_all(m);
    }
  };
}
function create_fragment$$(u) {
  let l, f;
  return l = new Popover({
    props: {
      open: (
        /*open*/
        u[2]
      ),
      anchor: (
        /*anchor*/
        u[0]
      ),
      align: (
        /*align*/
        u[1]
      ),
      resizable: (
        /*resizable*/
        u[3]
      ),
      wrap: (
        /*wrap*/
        u[4]
      ),
      offset: (
        /*offset*/
        u[5]
      ),
      clickOutsideOverride: (
        /*clickOutsideOverride*/
        u[6]
      ),
      portalTarget: "#" + /*gridID*/
      u[8] + " .grid-popover-container",
      $$slots: { default: [create_default_slot$v] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*open*/
      4 && (b.open = /*open*/
      p[2]), m & /*anchor*/
      1 && (b.anchor = /*anchor*/
      p[0]), m & /*align*/
      2 && (b.align = /*align*/
      p[1]), m & /*resizable*/
      8 && (b.resizable = /*resizable*/
      p[3]), m & /*wrap*/
      16 && (b.wrap = /*wrap*/
      p[4]), m & /*offset*/
      32 && (b.offset = /*offset*/
      p[5]), m & /*clickOutsideOverride*/
      64 && (b.clickOutsideOverride = /*clickOutsideOverride*/
      p[6]), m & /*$$scope, style*/
      32896 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
const wheel_handler = (u) => u.stopPropagation();
function instance$Z(u, l, f) {
  let p, { $$slots: m = {}, $$scope: b } = l, { anchor: y } = l, { minWidth: v = PopoverMinWidth } = l, { maxWidth: k = PopoverMaxWidth } = l, { maxHeight: S = PopoverMaxHeight } = l, { align: $ = "left" } = l, { open: w = !0 } = l, { resizable: T = !1 } = l, { wrap: E = !0 } = l, { offset: R = 0 } = l, { clickOutsideOverride: O } = l;
  const { gridID: P } = getContext$1("grid"), L = createEventDispatcher(), M = (j, x, N) => {
    let D = "";
    return j != null && (D += `min-width: ${j}px;`), x != null && (D += `max-width: ${x}px;`), N != null && (D += `max-height: ${N}px;`), D;
  }, B = () => L("close");
  return u.$$set = (j) => {
    "anchor" in j && f(0, y = j.anchor), "minWidth" in j && f(10, v = j.minWidth), "maxWidth" in j && f(11, k = j.maxWidth), "maxHeight" in j && f(12, S = j.maxHeight), "align" in j && f(1, $ = j.align), "open" in j && f(2, w = j.open), "resizable" in j && f(3, T = j.resizable), "wrap" in j && f(4, E = j.wrap), "offset" in j && f(5, R = j.offset), "clickOutsideOverride" in j && f(6, O = j.clickOutsideOverride), "$$scope" in j && f(15, b = j.$$scope);
  }, u.$$.update = () => {
    u.$$.dirty & /*minWidth, maxWidth, maxHeight*/
    7168 && f(7, p = M(v, k, S));
  }, [
    y,
    $,
    w,
    T,
    E,
    R,
    O,
    p,
    P,
    L,
    v,
    k,
    S,
    m,
    B,
    b
  ];
}
class GridPopover extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$Z, create_fragment$$, safe_not_equal, {
      anchor: 0,
      minWidth: 10,
      maxWidth: 11,
      maxHeight: 12,
      align: 1,
      open: 2,
      resizable: 3,
      wrap: 4,
      offset: 5,
      clickOutsideOverride: 6
    });
  }
}
const OptionsCell_svelte_svelte_type_style_lang = "";
function get_each_context$b(u, l, f) {
  const p = u.slice();
  p[23] = l[f], p[26] = f;
  const m = (
    /*optionColors*/
    p[8][
      /*option*/
      p[23]
    ] || /*getOptionColor*/
    p[11](
      /*option*/
      p[23]
    )
  );
  return p[24] = m, p;
}
function get_each_context_1$2(u, l, f) {
  const p = u.slice();
  p[27] = l[f];
  const m = (
    /*optionColors*/
    p[8][
      /*val*/
      p[27]
    ] || /*getOptionColor*/
    p[11](
      /*val*/
      p[27]
    )
  );
  return p[24] = m, p;
}
function create_else_block$9(u) {
  let l, f = (
    /*val*/
    (u[27] || "") + ""
  ), p, m;
  return {
    c() {
      l = element("div"), p = text$2(f), m = space(), attr(l, "class", "text svelte-14lr9ae");
    },
    m(b, y) {
      insert(b, l, y), append$1(l, p), append$1(l, m);
    },
    p(b, y) {
      y & /*values*/
      64 && f !== (f = /*val*/
      (b[27] || "") + "") && set_data(p, f);
    },
    d(b) {
      b && detach(l);
    }
  };
}
function create_if_block_3$5(u) {
  let l, f, p = (
    /*val*/
    u[27] + ""
  ), m, b;
  return {
    c() {
      l = element("div"), f = element("span"), m = text$2(p), b = space(), attr(f, "class", "svelte-14lr9ae"), attr(l, "class", "badge text svelte-14lr9ae"), set_style(
        l,
        "--color",
        /*color*/
        u[24]
      );
    },
    m(y, v) {
      insert(y, l, v), append$1(l, f), append$1(f, m), append$1(l, b);
    },
    p(y, v) {
      v & /*values*/
      64 && p !== (p = /*val*/
      y[27] + "") && set_data(m, p), v & /*optionColors, values*/
      320 && set_style(
        l,
        "--color",
        /*color*/
        y[24]
      );
    },
    d(y) {
      y && detach(l);
    }
  };
}
function create_each_block_1$2(u) {
  let l;
  function f(b, y) {
    return (
      /*color*/
      b[24] ? create_if_block_3$5 : create_else_block$9
    );
  }
  let p = f(u), m = p(u);
  return {
    c() {
      m.c(), l = empty$1();
    },
    m(b, y) {
      m.m(b, y), insert(b, l, y);
    },
    p(b, y) {
      p === (p = f(b)) && m ? m.p(b, y) : (m.d(1), m = p(b), m && (m.c(), m.m(l.parentNode, l)));
    },
    d(b) {
      b && detach(l), m.d(b);
    }
  };
}
function create_if_block_2$a(u) {
  let l, f, p, m, b;
  return f = new Icon({ props: { name: "caret-down" } }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "arrow svelte-14lr9ae");
    },
    m(y, v) {
      insert(y, l, v), mount_component(f, l, null), p = !0, m || (b = listen(
        l,
        "click",
        /*open*/
        u[9]
      ), m = !0);
    },
    p: noop$4,
    i(y) {
      p || (transition_in(f.$$.fragment, y), p = !0);
    },
    o(y) {
      transition_out(f.$$.fragment, y), p = !1;
    },
    d(y) {
      y && detach(l), destroy_component(f), m = !1, b();
    }
  };
}
function create_if_block$v(u) {
  let l, f;
  return l = new GridPopover({
    props: {
      anchor: (
        /*anchor*/
        u[4]
      ),
      $$slots: { default: [create_default_slot$u] },
      $$scope: { ctx: u }
    }
  }), l.$on(
    "close",
    /*close*/
    u[10]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*anchor*/
      16 && (b.anchor = /*anchor*/
      p[4]), m & /*$$scope, options, focusedOptionIdx, values, optionColors*/
      1073742184 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_1$e(u) {
  let l, f;
  return l = new Icon({
    props: {
      name: "check",
      color: "var(--accent-color)"
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_each_block$b(u) {
  let l, f, p, m = (
    /*option*/
    u[23] + ""
  ), b, y, v = (
    /*values*/
    u[6].includes(
      /*option*/
      u[23]
    )
  ), k, S, $, w, T = v && create_if_block_1$e();
  function E() {
    return (
      /*click_handler*/
      u[20](
        /*option*/
        u[23]
      )
    );
  }
  function R() {
    return (
      /*mouseenter_handler*/
      u[21](
        /*idx*/
        u[26]
      )
    );
  }
  return {
    c() {
      l = element("div"), f = element("div"), p = element("span"), b = text$2(m), y = space(), T && T.c(), k = space(), attr(p, "class", "svelte-14lr9ae"), attr(f, "class", "badge text svelte-14lr9ae"), set_style(
        f,
        "--color",
        /*color*/
        u[24]
      ), attr(l, "class", "option svelte-14lr9ae"), toggle_class(
        l,
        "focused",
        /*focusedOptionIdx*/
        u[3] === /*idx*/
        u[26]
      );
    },
    m(O, P) {
      insert(O, l, P), append$1(l, f), append$1(f, p), append$1(p, b), append$1(l, y), T && T.m(l, null), append$1(l, k), S = !0, $ || (w = [
        listen(l, "click", E),
        listen(l, "mouseenter", R)
      ], $ = !0);
    },
    p(O, P) {
      u = O, (!S || P & /*options*/
      32) && m !== (m = /*option*/
      u[23] + "") && set_data(b, m), (!S || P & /*optionColors, options*/
      288) && set_style(
        f,
        "--color",
        /*color*/
        u[24]
      ), P & /*values, options*/
      96 && (v = /*values*/
      u[6].includes(
        /*option*/
        u[23]
      )), v ? T ? P & /*values, options*/
      96 && transition_in(T, 1) : (T = create_if_block_1$e(), T.c(), transition_in(T, 1), T.m(l, k)) : T && (group_outros(), transition_out(T, 1, 1, () => {
        T = null;
      }), check_outros()), (!S || P & /*focusedOptionIdx*/
      8) && toggle_class(
        l,
        "focused",
        /*focusedOptionIdx*/
        u[3] === /*idx*/
        u[26]
      );
    },
    i(O) {
      S || (transition_in(T), S = !0);
    },
    o(O) {
      transition_out(T), S = !1;
    },
    d(O) {
      O && detach(l), T && T.d(), $ = !1, run_all(w);
    }
  };
}
function create_default_slot$u(u) {
  let l, f, p = ensure_array_like(
    /*options*/
    u[5]
  ), m = [];
  for (let y = 0; y < p.length; y += 1)
    m[y] = create_each_block$b(get_each_context$b(u, p, y));
  const b = (y) => transition_out(m[y], 1, 1, () => {
    m[y] = null;
  });
  return {
    c() {
      l = element("div");
      for (let y = 0; y < m.length; y += 1)
        m[y].c();
      attr(l, "class", "options svelte-14lr9ae");
    },
    m(y, v) {
      insert(y, l, v);
      for (let k = 0; k < m.length; k += 1)
        m[k] && m[k].m(l, null);
      f = !0;
    },
    p(y, v) {
      if (v & /*focusedOptionIdx, toggleOption, options, values, optionColors, getOptionColor*/
      6504) {
        p = ensure_array_like(
          /*options*/
          y[5]
        );
        let k;
        for (k = 0; k < p.length; k += 1) {
          const S = get_each_context$b(y, p, k);
          m[k] ? (m[k].p(S, v), transition_in(m[k], 1)) : (m[k] = create_each_block$b(S), m[k].c(), transition_in(m[k], 1), m[k].m(l, null));
        }
        for (group_outros(), k = p.length; k < m.length; k += 1)
          b(k);
        check_outros();
      }
    },
    i(y) {
      if (!f) {
        for (let v = 0; v < p.length; v += 1)
          transition_in(m[v]);
        f = !0;
      }
    },
    o(y) {
      m = m.filter(Boolean);
      for (let v = 0; v < m.length; v += 1)
        transition_out(m[v]);
      f = !1;
    },
    d(y) {
      y && detach(l), destroy_each(m, y);
    }
  };
}
function create_fragment$_(u) {
  let l, f, p, m, b, y, v, k, S = ensure_array_like(
    /*values*/
    u[6]
  ), $ = [];
  for (let E = 0; E < S.length; E += 1)
    $[E] = create_each_block_1$2(get_each_context_1$2(u, S, E));
  let w = (
    /*editable*/
    u[7] && create_if_block_2$a(u)
  ), T = (
    /*isOpen*/
    u[2] && create_if_block$v(u)
  );
  return {
    c() {
      l = element("div"), f = element("div");
      for (let E = 0; E < $.length; E += 1)
        $[E].c();
      p = space(), w && w.c(), m = space(), T && T.c(), b = empty$1(), attr(f, "class", "values svelte-14lr9ae"), toggle_class(
        f,
        "wrap",
        /*contentLines*/
        u[1] > 1
      ), attr(l, "class", "container svelte-14lr9ae"), toggle_class(
        l,
        "multi",
        /*multi*/
        u[0]
      ), toggle_class(
        l,
        "editable",
        /*editable*/
        u[7]
      ), toggle_class(
        l,
        "open",
        /*open*/
        u[9]
      );
    },
    m(E, R) {
      insert(E, l, R), append$1(l, f);
      for (let O = 0; O < $.length; O += 1)
        $[O] && $[O].m(f, null);
      append$1(l, p), w && w.m(l, null), u[19](l), insert(E, m, R), T && T.m(E, R), insert(E, b, R), y = !0, v || (k = [
        listen(f, "click", function() {
          is_function(
            /*editable*/
            u[7] ? (
              /*open*/
              u[9]
            ) : null
          ) && /*editable*/
          (u[7] ? (
            /*open*/
            u[9]
          ) : null).apply(this, arguments);
        }),
        listen(l, "click", self$1(function() {
          is_function(
            /*editable*/
            u[7] ? (
              /*open*/
              u[9]
            ) : null
          ) && /*editable*/
          (u[7] ? (
            /*open*/
            u[9]
          ) : null).apply(this, arguments);
        }))
      ], v = !0);
    },
    p(E, [R]) {
      if (u = E, R & /*optionColors, values, getOptionColor*/
      2368) {
        S = ensure_array_like(
          /*values*/
          u[6]
        );
        let O;
        for (O = 0; O < S.length; O += 1) {
          const P = get_each_context_1$2(u, S, O);
          $[O] ? $[O].p(P, R) : ($[O] = create_each_block_1$2(P), $[O].c(), $[O].m(f, null));
        }
        for (; O < $.length; O += 1)
          $[O].d(1);
        $.length = S.length;
      }
      (!y || R & /*contentLines*/
      2) && toggle_class(
        f,
        "wrap",
        /*contentLines*/
        u[1] > 1
      ), /*editable*/
      u[7] ? w ? (w.p(u, R), R & /*editable*/
      128 && transition_in(w, 1)) : (w = create_if_block_2$a(u), w.c(), transition_in(w, 1), w.m(l, null)) : w && (group_outros(), transition_out(w, 1, 1, () => {
        w = null;
      }), check_outros()), (!y || R & /*multi*/
      1) && toggle_class(
        l,
        "multi",
        /*multi*/
        u[0]
      ), (!y || R & /*editable*/
      128) && toggle_class(
        l,
        "editable",
        /*editable*/
        u[7]
      ), /*isOpen*/
      u[2] ? T ? (T.p(u, R), R & /*isOpen*/
      4 && transition_in(T, 1)) : (T = create_if_block$v(u), T.c(), transition_in(T, 1), T.m(b.parentNode, b)) : T && (group_outros(), transition_out(T, 1, 1, () => {
        T = null;
      }), check_outros());
    },
    i(E) {
      y || (transition_in(w), transition_in(T), y = !0);
    },
    o(E) {
      transition_out(w), transition_out(T), y = !1;
    },
    d(E) {
      E && (detach(l), detach(m), detach(b)), destroy_each($, E), w && w.d(), u[19](null), T && T.d(E), v = !1, run_all(k);
    }
  };
}
const InvalidColor = "hsla(0, 0%, 70%, 0.3)";
function instance$Y(u, l, f) {
  let p, m, b, y, { value: v } = l, { schema: k } = l, { onChange: S } = l, { focused: $ = !1 } = l, { multi: w = !1 } = l, { readonly: T = !1 } = l, { api: E } = l, { contentLines: R = 1 } = l, O = !1, P = null, L;
  const M = () => {
    f(2, O = !0), f(3, P = 0);
  }, B = () => {
    f(2, O = !1);
  }, j = (F) => {
    let U = F ? p.indexOf(F) : null;
    return U == null || U === -1 ? InvalidColor : OptionColours[U % OptionColours.length];
  }, x = (F) => {
    if (!w)
      S(F === v ? null : F), B();
    else {
      const U = y.filter((Y) => p.includes(Y));
      U.includes(F) ? S(U.filter((Y) => Y !== F)) : S([...U, F]);
    }
  }, N = (F) => O ? (F.preventDefault(), F.key === "ArrowDown" ? f(3, P = Math.min(P + 1, p.length - 1)) : F.key === "ArrowUp" ? f(3, P = Math.max(P - 1, 0)) : F.key === "Enter" && x(p[P]), !0) : !1;
  onMount(() => {
    f(13, E = {
      focus: M,
      blur: B,
      isActive: () => O,
      onKeyDown: N
    });
  });
  function D(F) {
    binding_callbacks[F ? "unshift" : "push"](() => {
      L = F, f(4, L);
    });
  }
  const V = (F) => x(F), W = (F) => f(3, P = F);
  return u.$$set = (F) => {
    "value" in F && f(14, v = F.value), "schema" in F && f(15, k = F.schema), "onChange" in F && f(16, S = F.onChange), "focused" in F && f(17, $ = F.focused), "multi" in F && f(0, w = F.multi), "readonly" in F && f(18, T = F.readonly), "api" in F && f(13, E = F.api), "contentLines" in F && f(1, R = F.contentLines);
  }, u.$$.update = () => {
    var F;
    u.$$.dirty & /*schema*/
    32768 && f(5, p = ((F = k == null ? void 0 : k.constraints) == null ? void 0 : F.inclusion) || []), u.$$.dirty & /*schema*/
    32768 && f(8, m = (k == null ? void 0 : k.optionColors) || {}), u.$$.dirty & /*focused, readonly*/
    393216 && f(7, b = $ && !T), u.$$.dirty & /*value*/
    16384 && f(6, y = Array.isArray(v) ? v : [v].filter((U) => U != null)), u.$$.dirty & /*focused, isOpen*/
    131076 && !$ && O && B();
  }, [
    w,
    R,
    O,
    P,
    L,
    p,
    y,
    b,
    m,
    M,
    B,
    j,
    x,
    E,
    v,
    k,
    S,
    $,
    T,
    D,
    V,
    W
  ];
}
class OptionsCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$Y, create_fragment$_, safe_not_equal, {
      value: 14,
      schema: 15,
      onChange: 16,
      focused: 17,
      multi: 0,
      readonly: 18,
      api: 13,
      contentLines: 1
    });
  }
}
const DateCell_svelte_svelte_type_style_lang = "";
function create_if_block_1$d(u) {
  let l, f;
  return l = new Icon({ props: { name: "calendar" } }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block$u(u) {
  let l, f;
  return l = new GridPopover({
    props: {
      anchor: (
        /*anchor*/
        u[6]
      ),
      maxHeight: null,
      $$slots: { default: [create_default_slot$t] },
      $$scope: { ctx: u }
    }
  }), l.$on(
    "close",
    /*close*/
    u[10]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*anchor*/
      64 && (b.anchor = /*anchor*/
      p[6]), m & /*$$scope, parsedValue, enableTime, timeOnly, ignoreTimezones, value*/
      2097213 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot$t(u) {
  let l, f;
  return l = new DatePickerPopoverContents({
    props: {
      value: (
        /*parsedValue*/
        u[5]
      ),
      useKeyboardShortcuts: !1,
      enableTime: (
        /*enableTime*/
        u[4]
      ),
      timeOnly: (
        /*timeOnly*/
        u[3]
      ),
      ignoreTimezones: (
        /*ignoreTimezones*/
        u[2]
      )
    }
  }), l.$on(
    "change",
    /*change_handler*/
    u[17]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*parsedValue*/
      32 && (b.value = /*parsedValue*/
      p[5]), m & /*enableTime*/
      16 && (b.enableTime = /*enableTime*/
      p[4]), m & /*timeOnly*/
      8 && (b.timeOnly = /*timeOnly*/
      p[3]), m & /*ignoreTimezones*/
      4 && (b.ignoreTimezones = /*ignoreTimezones*/
      p[2]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$Z(u) {
  let l, f, p, m, b, y, v, k, S, $ = (
    /*editable*/
    u[8] && create_if_block_1$d()
  ), w = (
    /*isOpen*/
    u[1] && create_if_block$u(u)
  );
  return {
    c() {
      l = element("div"), f = element("div"), p = text$2(
        /*displayValue*/
        u[7]
      ), m = space(), $ && $.c(), b = space(), w && w.c(), y = empty$1(), attr(f, "class", "value svelte-17mmumr"), attr(l, "class", "container svelte-17mmumr"), toggle_class(
        l,
        "editable",
        /*editable*/
        u[8]
      );
    },
    m(T, E) {
      insert(T, l, E), append$1(l, f), append$1(f, p), append$1(l, m), $ && $.m(l, null), u[16](l), insert(T, b, E), w && w.m(T, E), insert(T, y, E), v = !0, k || (S = listen(l, "click", function() {
        is_function(
          /*editable*/
          u[8] ? (
            /*open*/
            u[9]
          ) : null
        ) && /*editable*/
        (u[8] ? (
          /*open*/
          u[9]
        ) : null).apply(this, arguments);
      }), k = !0);
    },
    p(T, [E]) {
      u = T, (!v || E & /*displayValue*/
      128) && set_data(
        p,
        /*displayValue*/
        u[7]
      ), /*editable*/
      u[8] ? $ ? E & /*editable*/
      256 && transition_in($, 1) : ($ = create_if_block_1$d(), $.c(), transition_in($, 1), $.m(l, null)) : $ && (group_outros(), transition_out($, 1, 1, () => {
        $ = null;
      }), check_outros()), (!v || E & /*editable*/
      256) && toggle_class(
        l,
        "editable",
        /*editable*/
        u[8]
      ), /*isOpen*/
      u[1] ? w ? (w.p(u, E), E & /*isOpen*/
      2 && transition_in(w, 1)) : (w = create_if_block$u(u), w.c(), transition_in(w, 1), w.m(y.parentNode, y)) : w && (group_outros(), transition_out(w, 1, 1, () => {
        w = null;
      }), check_outros());
    },
    i(T) {
      v || (transition_in($), transition_in(w), v = !0);
    },
    o(T) {
      transition_out($), transition_out(w), v = !1;
    },
    d(T) {
      T && (detach(l), detach(b), detach(y)), $ && $.d(), u[16](null), w && w.d(T), k = !1, S();
    }
  };
}
function instance$X(u, l, f) {
  let p, m, b, y, v, k, { value: S } = l, { schema: $ } = l, { onChange: w } = l, { focused: T = !1 } = l, { readonly: E = !1 } = l, { api: R } = l, O, P;
  const L = (V, W, F) => getDateDisplayValue(V, { enableTime: F, timeOnly: W }), M = () => {
    f(1, O = !0);
  }, B = () => {
    f(1, O = !1), w(S);
  }, j = (V) => O ? (V.preventDefault(), V.key === "ArrowUp" ? x(-1, "week") : V.key === "ArrowDown" ? x(1, "week") : V.key === "ArrowLeft" ? x(-1, "day") : V.key === "ArrowRight" ? x(1, "day") : V.key === "Enter" && B(), !0) : !1, x = (V, W) => {
    let F;
    S ? F = dayjs(S).add(V, W) : F = dayjs(), f(0, S = stringifyDate(F, { enableTime: m, timeOnly: p, ignoreTimezones: b }));
  };
  onMount(() => {
    f(11, R = {
      onKeyDown: j,
      focus: M,
      blur: B,
      isActive: () => O
    });
  });
  function N(V) {
    binding_callbacks[V ? "unshift" : "push"](() => {
      P = V, f(6, P);
    });
  }
  const D = (V) => f(0, S = V.detail);
  return u.$$set = (V) => {
    "value" in V && f(0, S = V.value), "schema" in V && f(12, $ = V.schema), "onChange" in V && f(13, w = V.onChange), "focused" in V && f(14, T = V.focused), "readonly" in V && f(15, E = V.readonly), "api" in V && f(11, R = V.api);
  }, u.$$.update = () => {
    u.$$.dirty & /*schema*/
    4096 && f(3, p = $ == null ? void 0 : $.timeOnly), u.$$.dirty & /*schema*/
    4096 && f(4, m = !($ != null && $.dateOnly)), u.$$.dirty & /*schema*/
    4096 && f(2, b = $ == null ? void 0 : $.ignoreTimezones), u.$$.dirty & /*focused, readonly*/
    49152 && f(8, y = T && !E), u.$$.dirty & /*value, timeOnly, enableTime, ignoreTimezones*/
    29 && f(5, v = parseDate(S, { timeOnly: p, enableTime: m, ignoreTimezones: b })), u.$$.dirty & /*parsedValue, timeOnly, enableTime*/
    56 && f(7, k = L(v, p, m)), u.$$.dirty & /*focused, isOpen*/
    16386 && !T && O && B();
  }, [
    S,
    O,
    b,
    p,
    m,
    v,
    P,
    k,
    y,
    M,
    B,
    R,
    $,
    w,
    T,
    E,
    N,
    D
  ];
}
class DateCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$X, create_fragment$Z, safe_not_equal, {
      value: 0,
      schema: 12,
      onChange: 13,
      focused: 14,
      readonly: 15,
      api: 11
    });
  }
}
function create_fragment$Y(u) {
  let l, f, p;
  const m = [
    /*$$props*/
    u[1],
    { multi: !0 }
  ];
  function b(v) {
    u[2](v);
  }
  let y = {};
  for (let v = 0; v < m.length; v += 1)
    y = assign(y, m[v]);
  return (
    /*api*/
    u[0] !== void 0 && (y.api = /*api*/
    u[0]), l = new OptionsCell({ props: y }), binding_callbacks.push(() => bind(l, "api", b)), {
      c() {
        create_component(l.$$.fragment);
      },
      m(v, k) {
        mount_component(l, v, k), p = !0;
      },
      p(v, [k]) {
        const S = k & /*$$props*/
        2 ? get_spread_update(m, [get_spread_object(
          /*$$props*/
          v[1]
        ), m[1]]) : {};
        !f && k & /*api*/
        1 && (f = !0, S.api = /*api*/
        v[0], add_flush_callback(() => f = !1)), l.$set(S);
      },
      i(v) {
        p || (transition_in(l.$$.fragment, v), p = !0);
      },
      o(v) {
        transition_out(l.$$.fragment, v), p = !1;
      },
      d(v) {
        destroy_component(l, v);
      }
    }
  );
}
function instance$W(u, l, f) {
  let { api: p } = l;
  function m(b) {
    p = b, f(0, p);
  }
  return u.$$set = (b) => {
    f(1, l = assign(assign({}, l), exclude_internal_props(b))), "api" in b && f(0, p = b.api);
  }, l = exclude_internal_props(l), [p, l, m];
}
class MultiSelectCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$W, create_fragment$Y, safe_not_equal, { api: 0 });
  }
}
const TextCell_svelte_svelte_type_style_lang = "";
function create_else_block$8(u) {
  let l, f, p;
  return {
    c() {
      l = element("div"), f = element("div"), p = text$2(
        /*displayValue*/
        u[4]
      ), attr(f, "class", "value svelte-6ynh9c"), attr(l, "class", "text-cell svelte-6ynh9c"), toggle_class(
        l,
        "number",
        /*type*/
        u[1] === "number"
      );
    },
    m(m, b) {
      insert(m, l, b), append$1(l, f), append$1(f, p);
    },
    p(m, b) {
      b & /*displayValue*/
      16 && set_data(
        p,
        /*displayValue*/
        m[4]
      ), b & /*type*/
      2 && toggle_class(
        l,
        "number",
        /*type*/
        m[1] === "number"
      );
    },
    d(m) {
      m && detach(l);
    }
  };
}
function create_if_block$t(u) {
  let l, f, p, m;
  return {
    c() {
      l = element("input"), attr(
        l,
        "type",
        /*type*/
        u[1]
      ), l.value = f = /*value*/
      u[0] ?? "", attr(l, "spellcheck", "false"), attr(l, "class", "svelte-6ynh9c");
    },
    m(b, y) {
      insert(b, l, y), u[12](l), p || (m = [
        listen(
          l,
          "focus",
          /*focus_handler*/
          u[13]
        ),
        listen(
          l,
          "blur",
          /*blur_handler*/
          u[14]
        ),
        listen(
          l,
          "change",
          /*handleChange*/
          u[6]
        )
      ], p = !0);
    },
    p(b, y) {
      y & /*type*/
      2 && attr(
        l,
        "type",
        /*type*/
        b[1]
      ), y & /*value*/
      1 && f !== (f = /*value*/
      b[0] ?? "") && l.value !== f && (l.value = f);
    },
    d(b) {
      b && detach(l), u[12](null), p = !1, run_all(m);
    }
  };
}
function create_fragment$X(u) {
  let l;
  function f(b, y) {
    return (
      /*editable*/
      b[5] ? create_if_block$t : create_else_block$8
    );
  }
  let p = f(u), m = p(u);
  return {
    c() {
      m.c(), l = empty$1();
    },
    m(b, y) {
      m.m(b, y), insert(b, l, y);
    },
    p(b, [y]) {
      p === (p = f(b)) && m ? m.p(b, y) : (m.d(1), m = p(b), m && (m.c(), m.m(l.parentNode, l)));
    },
    i: noop$4,
    o: noop$4,
    d(b) {
      b && detach(l), m.d(b);
    }
  };
}
function instance$V(u, l, f) {
  let p, m, { value: b } = l, { focused: y = !1 } = l, { onChange: v } = l, { type: k = "text" } = l, { readonly: S = !1 } = l, { api: $ } = l, { format: w = null } = l, T, E = !1;
  const R = (B) => {
    v(B.target.value);
  }, O = (B) => {
    if (!E)
      return !1;
    if (B.key === "Enter") {
      T == null || T.blur();
      const j = new KeyboardEvent("keydown", { key: "ArrowDown" });
      document.dispatchEvent(j);
    }
    return !0;
  };
  onMount(() => {
    f(7, $ = {
      focus: () => T == null ? void 0 : T.focus(),
      blur: () => T == null ? void 0 : T.blur(),
      isActive: () => E,
      onKeyDown: O
    });
  });
  function P(B) {
    binding_callbacks[B ? "unshift" : "push"](() => {
      T = B, f(2, T);
    });
  }
  const L = () => f(3, E = !0), M = () => f(3, E = !1);
  return u.$$set = (B) => {
    "value" in B && f(0, b = B.value), "focused" in B && f(8, y = B.focused), "onChange" in B && f(9, v = B.onChange), "type" in B && f(1, k = B.type), "readonly" in B && f(10, S = B.readonly), "api" in B && f(7, $ = B.api), "format" in B && f(11, w = B.format);
  }, u.$$.update = () => {
    u.$$.dirty & /*focused, readonly*/
    1280 && f(5, p = y && !S), u.$$.dirty & /*format, value*/
    2049 && f(4, m = (w == null ? void 0 : w(b)) ?? b ?? "");
  }, [
    b,
    k,
    T,
    E,
    m,
    p,
    R,
    $,
    y,
    v,
    S,
    w,
    P,
    L,
    M
  ];
}
class TextCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$V, create_fragment$X, safe_not_equal, {
      value: 0,
      focused: 8,
      onChange: 9,
      type: 1,
      readonly: 10,
      api: 7,
      format: 11
    });
  }
}
function create_fragment$W(u) {
  let l, f, p;
  const m = [
    /*$$props*/
    u[2],
    { onChange: (
      /*numberOnChange*/
      u[1]
    ) },
    { type: "number" },
    { format: formatNumber }
  ];
  function b(v) {
    u[4](v);
  }
  let y = {};
  for (let v = 0; v < m.length; v += 1)
    y = assign(y, m[v]);
  return (
    /*api*/
    u[0] !== void 0 && (y.api = /*api*/
    u[0]), l = new TextCell({ props: y }), binding_callbacks.push(() => bind(l, "api", b)), {
      c() {
        create_component(l.$$.fragment);
      },
      m(v, k) {
        mount_component(l, v, k), p = !0;
      },
      p(v, [k]) {
        const S = k & /*$$props, numberOnChange*/
        6 ? get_spread_update(m, [
          k & /*$$props*/
          4 && get_spread_object(
            /*$$props*/
            v[2]
          ),
          k & /*numberOnChange*/
          2 && { onChange: (
            /*numberOnChange*/
            v[1]
          ) },
          m[2],
          m[3]
        ]) : {};
        !f && k & /*api*/
        1 && (f = !0, S.api = /*api*/
        v[0], add_flush_callback(() => f = !1)), l.$set(S);
      },
      i(v) {
        p || (transition_in(l.$$.fragment, v), p = !0);
      },
      o(v) {
        transition_out(l.$$.fragment, v), p = !1;
      },
      d(v) {
        destroy_component(l, v);
      }
    }
  );
}
function instance$U(u, l, f) {
  let { api: p } = l, { onChange: m } = l;
  const b = (v) => {
    const k = parseFloat(v), S = isNaN(k) ? null : k;
    m(S);
  };
  function y(v) {
    p = v, f(0, p);
  }
  return u.$$set = (v) => {
    f(2, l = assign(assign({}, l), exclude_internal_props(v))), "api" in v && f(0, p = v.api), "onChange" in v && f(3, m = v.onChange);
  }, l = exclude_internal_props(l), [p, b, l, m, y];
}
class NumberCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$U, create_fragment$W, safe_not_equal, { api: 0, onChange: 3 });
  }
}
const RelationshipCell_svelte_svelte_type_style_lang = "";
function get_each_context$a(u, l, f) {
  const p = u.slice();
  return p[44] = l[f], p[46] = f, p;
}
function get_each_context_1$1(u, l, f) {
  const p = u.slice();
  return p[47] = l[f], p;
}
function create_if_block_6$2(u) {
  let l, f, p = (
    /*readable*/
    u[18](
      /*relationship*/
      u[47][
        /*primaryDisplay*/
        u[0]
      ] || /*relationship*/
      u[47].primaryDisplay
    ) + ""
  ), m, b, y, v, k, S = (
    /*editable*/
    u[12] && create_if_block_7$2(u)
  );
  return {
    c() {
      l = element("div"), f = element("span"), m = text$2(p), b = space(), S && S.c(), attr(f, "class", "svelte-4yl685"), attr(l, "class", "badge svelte-4yl685"), toggle_class(l, "extra-info", !!/*relationFields*/
      u[11][
        /*relationship*/
        u[47]._id
      ]);
    },
    m($, w) {
      insert($, l, w), append$1(l, f), append$1(f, m), append$1(l, b), S && S.m(l, null), y = !0, v || (k = listen(l, "focus", focus_handler), v = !0);
    },
    p($, w) {
      (!y || w[0] & /*fieldValue, primaryDisplay*/
      65) && p !== (p = /*readable*/
      $[18](
        /*relationship*/
        $[47][
          /*primaryDisplay*/
          $[0]
        ] || /*relationship*/
        $[47].primaryDisplay
      ) + "") && set_data(m, p), /*editable*/
      $[12] ? S ? (S.p($, w), w[0] & /*editable*/
      4096 && transition_in(S, 1)) : (S = create_if_block_7$2($), S.c(), transition_in(S, 1), S.m(l, null)) : S && (group_outros(), transition_out(S, 1, 1, () => {
        S = null;
      }), check_outros()), (!y || w[0] & /*relationFields, fieldValue*/
      2112) && toggle_class(l, "extra-info", !!/*relationFields*/
      $[11][
        /*relationship*/
        $[47]._id
      ]);
    },
    i($) {
      y || (transition_in(S), y = !0);
    },
    o($) {
      transition_out(S), y = !1;
    },
    d($) {
      $ && detach(l), S && S.d(), v = !1, k();
    }
  };
}
function create_if_block_7$2(u) {
  let l, f;
  function p() {
    return (
      /*click_handler*/
      u[26](
        /*relationship*/
        u[47]
      )
    );
  }
  return l = new Icon({
    props: {
      name: "x",
      size: "XS",
      hoverable: !0,
      color: "var(--spectrum-global-color-gray-800)",
      weight: "bold"
    }
  }), l.$on("click", p), {
    c() {
      create_component(l.$$.fragment);
    },
    m(m, b) {
      mount_component(l, m, b), f = !0;
    },
    p(m, b) {
      u = m;
    },
    i(m) {
      f || (transition_in(l.$$.fragment, m), f = !0);
    },
    o(m) {
      transition_out(l.$$.fragment, m), f = !1;
    },
    d(m) {
      destroy_component(l, m);
    }
  };
}
function create_each_block_1$1(u) {
  let l, f, p = (
    /*relationship*/
    (u[47][
      /*primaryDisplay*/
      u[0]
    ] || /*relationship*/
    u[47].primaryDisplay) && create_if_block_6$2(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, b) {
      /*relationship*/
      m[47][
        /*primaryDisplay*/
        m[0]
      ] || /*relationship*/
      m[47].primaryDisplay ? p ? (p.p(m, b), b[0] & /*fieldValue, primaryDisplay*/
      65 && transition_in(p, 1)) : (p = create_if_block_6$2(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
function create_if_block_5$3(u) {
  let l, f, p, m, b;
  return f = new Icon({
    props: {
      name: "plus",
      size: "S",
      color: "var(--spectrum-global-color-gray-800)",
      weight: "bold"
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "add svelte-4yl685");
    },
    m(y, v) {
      insert(y, l, v), mount_component(f, l, null), p = !0, m || (b = listen(
        l,
        "click",
        /*open*/
        u[15]
      ), m = !0);
    },
    p: noop$4,
    i(y) {
      p || (transition_in(f.$$.fragment, y), p = !0);
    },
    o(y) {
      transition_out(f.$$.fragment, y), p = !1;
    },
    d(y) {
      y && detach(l), destroy_component(f), m = !1, b();
    }
  };
}
function create_if_block_4$3(u) {
  var m;
  let l, f = (
    /*fieldValue*/
    (((m = u[6]) == null ? void 0 : m.length) || 0) + ""
  ), p;
  return {
    c() {
      l = element("div"), p = text$2(f), attr(l, "class", "count svelte-4yl685");
    },
    m(b, y) {
      insert(b, l, y), append$1(l, p);
    },
    p(b, y) {
      var v;
      y[0] & /*fieldValue*/
      64 && f !== (f = /*fieldValue*/
      (((v = b[6]) == null ? void 0 : v.length) || 0) + "") && set_data(p, f);
    },
    d(b) {
      b && detach(l);
    }
  };
}
function create_if_block$s(u) {
  let l, f;
  return l = new GridPopover({
    props: {
      open: (
        /*isOpen*/
        u[4]
      ),
      anchor: (
        /*anchor*/
        u[10]
      ),
      $$slots: { default: [create_default_slot$s] },
      $$scope: { ctx: u }
    }
  }), l.$on(
    "close",
    /*close*/
    u[16]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*isOpen*/
      16 && (b.open = /*isOpen*/
      p[4]), m[0] & /*anchor*/
      1024 && (b.anchor = /*anchor*/
      p[10]), m[0] & /*searching, searchResults, candidateIndex, primaryDisplay, searchString*/
      929 | m[1] & /*$$scope*/
      524288 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_2$9(u) {
  let l, f, p = ensure_array_like(
    /*searchResults*/
    u[7]
  ), m = [];
  for (let y = 0; y < p.length; y += 1)
    m[y] = create_each_block$a(get_each_context$a(u, p, y));
  const b = (y) => transition_out(m[y], 1, 1, () => {
    m[y] = null;
  });
  return {
    c() {
      l = element("div");
      for (let y = 0; y < m.length; y += 1)
        m[y].c();
      attr(l, "class", "results svelte-4yl685");
    },
    m(y, v) {
      insert(y, l, v);
      for (let k = 0; k < m.length; k += 1)
        m[k] && m[k].m(l, null);
      f = !0;
    },
    p(y, v) {
      if (v[0] & /*candidateIndex, toggleRow, searchResults, isRowSelected, readable*/
      409984) {
        p = ensure_array_like(
          /*searchResults*/
          y[7]
        );
        let k;
        for (k = 0; k < p.length; k += 1) {
          const S = get_each_context$a(y, p, k);
          m[k] ? (m[k].p(S, v), transition_in(m[k], 1)) : (m[k] = create_each_block$a(S), m[k].c(), transition_in(m[k], 1), m[k].m(l, null));
        }
        for (group_outros(), k = p.length; k < m.length; k += 1)
          b(k);
        check_outros();
      }
    },
    i(y) {
      if (!f) {
        for (let v = 0; v < p.length; v += 1)
          transition_in(m[v]);
        f = !0;
      }
    },
    o(y) {
      m = m.filter(Boolean);
      for (let v = 0; v < m.length; v += 1)
        transition_out(m[v]);
      f = !1;
    },
    d(y) {
      y && detach(l), destroy_each(m, y);
    }
  };
}
function create_if_block_1$c(u) {
  let l, f, p;
  return f = new ProgressCircle({ props: { size: "S" } }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "searching svelte-4yl685");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p: noop$4,
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block_3$4(u) {
  let l, f;
  return l = new Icon({
    props: {
      size: "S",
      name: "check",
      color: "var(--accent-color)"
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_each_block$a(u) {
  let l, f, p, m = (
    /*readable*/
    u[18](
      /*row*/
      u[44].primaryDisplay
    ) + ""
  ), b, y, v = (
    /*isRowSelected*/
    u[14](
      /*row*/
      u[44]
    )
  ), k, S, $, w, T = v && create_if_block_3$4();
  function E() {
    return (
      /*click_handler_1*/
      u[30](
        /*row*/
        u[44]
      )
    );
  }
  function R() {
    return (
      /*mouseenter_handler*/
      u[31](
        /*idx*/
        u[46]
      )
    );
  }
  return {
    c() {
      l = element("div"), f = element("div"), p = element("span"), b = text$2(m), y = space(), T && T.c(), k = space(), attr(p, "class", "svelte-4yl685"), attr(f, "class", "badge svelte-4yl685"), attr(l, "class", "result svelte-4yl685"), toggle_class(
        l,
        "candidate",
        /*idx*/
        u[46] === /*candidateIndex*/
        u[8]
      );
    },
    m(O, P) {
      insert(O, l, P), append$1(l, f), append$1(f, p), append$1(p, b), append$1(l, y), T && T.m(l, null), append$1(l, k), S = !0, $ || (w = [
        listen(l, "click", E),
        listen(l, "mouseenter", R)
      ], $ = !0);
    },
    p(O, P) {
      u = O, (!S || P[0] & /*searchResults*/
      128) && m !== (m = /*readable*/
      u[18](
        /*row*/
        u[44].primaryDisplay
      ) + "") && set_data(b, m), P[0] & /*searchResults*/
      128 && (v = /*isRowSelected*/
      u[14](
        /*row*/
        u[44]
      )), v ? T ? P[0] & /*searchResults*/
      128 && transition_in(T, 1) : (T = create_if_block_3$4(), T.c(), transition_in(T, 1), T.m(l, k)) : T && (group_outros(), transition_out(T, 1, 1, () => {
        T = null;
      }), check_outros()), (!S || P[0] & /*candidateIndex*/
      256) && toggle_class(
        l,
        "candidate",
        /*idx*/
        u[46] === /*candidateIndex*/
        u[8]
      );
    },
    i(O) {
      S || (transition_in(T), S = !0);
    },
    o(O) {
      transition_out(T), S = !1;
    },
    d(O) {
      O && detach(l), T && T.d(), $ = !1, run_all(w);
    }
  };
}
function create_default_slot$s(u) {
  let l, f, p, m, b, y, v, k, S, $;
  function w(P) {
    u[29](P);
  }
  let T = {
    autofocus: !0,
    quiet: !0,
    type: "text",
    placeholder: (
      /*primaryDisplay*/
      u[0] ? `Search by ${/*primaryDisplay*/
      u[0]}` : null
    )
  };
  /*searchString*/
  u[5] !== void 0 && (T.value = /*searchString*/
  u[5]), p = new Input({ props: T }), binding_callbacks.push(() => bind(p, "value", w));
  const E = [create_if_block_1$c, create_if_block_2$9], R = [];
  function O(P, L) {
    var M;
    return (
      /*searching*/
      P[9] ? 0 : (
        /*searchResults*/
        (M = P[7]) != null && M.length ? 1 : -1
      )
    );
  }
  return ~(y = O(u)) && (v = R[y] = E[y](u)), {
    c() {
      l = element("div"), f = element("div"), create_component(p.$$.fragment), b = space(), v && v.c(), attr(f, "class", "search svelte-4yl685"), attr(l, "class", "dropdown svelte-4yl685");
    },
    m(P, L) {
      insert(P, l, L), append$1(l, f), mount_component(p, f, null), append$1(l, b), ~y && R[y].m(l, null), k = !0, S || ($ = listen(l, "wheel", stop_propagation(
        /*wheel_handler*/
        u[25]
      )), S = !0);
    },
    p(P, L) {
      const M = {};
      L[0] & /*primaryDisplay*/
      1 && (M.placeholder = /*primaryDisplay*/
      P[0] ? `Search by ${/*primaryDisplay*/
      P[0]}` : null), !m && L[0] & /*searchString*/
      32 && (m = !0, M.value = /*searchString*/
      P[5], add_flush_callback(() => m = !1)), p.$set(M);
      let B = y;
      y = O(P), y === B ? ~y && R[y].p(P, L) : (v && (group_outros(), transition_out(R[B], 1, 1, () => {
        R[B] = null;
      }), check_outros()), ~y ? (v = R[y], v ? v.p(P, L) : (v = R[y] = E[y](P), v.c()), transition_in(v, 1), v.m(l, null)) : v = null);
    },
    i(P) {
      k || (transition_in(p.$$.fragment, P), transition_in(v), k = !0);
    },
    o(P) {
      transition_out(p.$$.fragment, P), transition_out(v), k = !1;
    },
    d(P) {
      P && detach(l), destroy_component(p), ~y && R[y].d(), S = !1, $();
    }
  };
}
function create_fragment$V(u) {
  var L;
  let l, f, p, m, b, y, v, k, S, $, w = ensure_array_like(
    /*fieldValue*/
    u[6] || []
  ), T = [];
  for (let M = 0; M < w.length; M += 1)
    T[M] = create_each_block_1$1(get_each_context_1$1(u, w, M));
  const E = (M) => transition_out(T[M], 1, 1, () => {
    T[M] = null;
  });
  let R = (
    /*editable*/
    u[12] && create_if_block_5$3(u)
  ), O = !/*hideCounter*/
  u[3] && /*fieldValue*/
  ((L = u[6]) == null ? void 0 : L.length) && create_if_block_4$3(u), P = (
    /*isOpen*/
    u[4] && create_if_block$s(u)
  );
  return {
    c() {
      l = element("div"), f = element("div"), p = element("div");
      for (let M = 0; M < T.length; M += 1)
        T[M].c();
      m = space(), R && R.c(), b = space(), O && O.c(), y = space(), P && P.c(), v = empty$1(), attr(p, "class", "values svelte-4yl685"), toggle_class(
        p,
        "wrap",
        /*editable*/
        u[12] || /*contentLines*/
        u[2] > 1
      ), toggle_class(p, "disabled", !/*focused*/
      u[1]), attr(f, "class", "container svelte-4yl685"), attr(l, "class", "wrapper svelte-4yl685"), set_style(
        l,
        "--color",
        /*color*/
        u[13]
      ), toggle_class(
        l,
        "editable",
        /*editable*/
        u[12]
      ), toggle_class(
        l,
        "focused",
        /*focused*/
        u[1]
      );
    },
    m(M, B) {
      insert(M, l, B), append$1(l, f), append$1(f, p);
      for (let j = 0; j < T.length; j += 1)
        T[j] && T[j].m(p, null);
      append$1(p, m), R && R.m(p, null), append$1(f, b), O && O.m(f, null), u[28](l), insert(M, y, B), P && P.m(M, B), insert(M, v, B), k = !0, S || ($ = listen(
        p,
        "wheel",
        /*wheel_handler_1*/
        u[27]
      ), S = !0);
    },
    p(M, B) {
      var j;
      if (B[0] & /*relationFields, fieldValue, toggleRow, editable, readable, primaryDisplay*/
      399425) {
        w = ensure_array_like(
          /*fieldValue*/
          M[6] || []
        );
        let x;
        for (x = 0; x < w.length; x += 1) {
          const N = get_each_context_1$1(M, w, x);
          T[x] ? (T[x].p(N, B), transition_in(T[x], 1)) : (T[x] = create_each_block_1$1(N), T[x].c(), transition_in(T[x], 1), T[x].m(p, m));
        }
        for (group_outros(), x = w.length; x < T.length; x += 1)
          E(x);
        check_outros();
      }
      /*editable*/
      M[12] ? R ? (R.p(M, B), B[0] & /*editable*/
      4096 && transition_in(R, 1)) : (R = create_if_block_5$3(M), R.c(), transition_in(R, 1), R.m(p, null)) : R && (group_outros(), transition_out(R, 1, 1, () => {
        R = null;
      }), check_outros()), (!k || B[0] & /*editable, contentLines*/
      4100) && toggle_class(
        p,
        "wrap",
        /*editable*/
        M[12] || /*contentLines*/
        M[2] > 1
      ), (!k || B[0] & /*focused*/
      2) && toggle_class(p, "disabled", !/*focused*/
      M[1]), !/*hideCounter*/
      M[3] && /*fieldValue*/
      ((j = M[6]) != null && j.length) ? O ? O.p(M, B) : (O = create_if_block_4$3(M), O.c(), O.m(f, null)) : O && (O.d(1), O = null), (!k || B[0] & /*editable*/
      4096) && toggle_class(
        l,
        "editable",
        /*editable*/
        M[12]
      ), (!k || B[0] & /*focused*/
      2) && toggle_class(
        l,
        "focused",
        /*focused*/
        M[1]
      ), /*isOpen*/
      M[4] ? P ? (P.p(M, B), B[0] & /*isOpen*/
      16 && transition_in(P, 1)) : (P = create_if_block$s(M), P.c(), transition_in(P, 1), P.m(v.parentNode, v)) : P && (group_outros(), transition_out(P, 1, 1, () => {
        P = null;
      }), check_outros());
    },
    i(M) {
      if (!k) {
        for (let B = 0; B < w.length; B += 1)
          transition_in(T[B]);
        transition_in(R), transition_in(P), k = !0;
      }
    },
    o(M) {
      T = T.filter(Boolean);
      for (let B = 0; B < T.length; B += 1)
        transition_out(T[B]);
      transition_out(R), transition_out(P), k = !1;
    },
    d(M) {
      M && (detach(l), detach(y), detach(v)), destroy_each(T, M), R && R.d(), O && O.d(), u[28](null), P && P.d(M), S = !1, $();
    }
  };
}
const focus_handler = () => {
};
function instance$T(u, l, f) {
  let p, m, b, y, v;
  const { API: k, cache: S } = getContext$1("grid");
  let { value: $ = [] } = l, { api: w } = l, { readonly: T } = l, { focused: E } = l, { schema: R } = l, { onChange: O } = l, { contentLines: P = 1 } = l, { searchFunction: L = k.searchTable } = l, { primaryDisplay: M } = l, { hideCounter: B = !1 } = l;
  const j = OptionColours[0];
  let x = !1, N, D, V, W, F, U = !1, Y;
  const q = (J) => Array.isArray(J) && J.every((fe) => fe == null ? void 0 : fe._id) ? J : [], Q = (J, fe) => {
    let _e = {};
    if (!fe || !(J != null && J.length))
      return _e;
    for (let ye = 0; ye < J.length; ye++)
      _e[J[ye]._id] = !0;
    return _e;
  }, z = (J) => J != null && J._id ? (y == null ? void 0 : y[J._id]) === !0 : !1, H = async (J, fe = !1) => {
    var ke;
    if (!fe && !J && !V)
      return;
    if (!(R != null && R.tableId) || !x) {
      V = null, f(8, W = null), f(7, N = []);
      return;
    }
    F = Math.random(), f(9, U = !0);
    const _e = F, ye = await L(R.tableId, {
      paginate: !1,
      limit: 20,
      query: {
        string: {
          [`1:${M}`]: J || ""
        }
      }
    });
    f(9, U = !1), _e === F && (f(7, N = Z((ke = ye.rows) == null ? void 0 : ke.map((we) => ({
      ...we,
      primaryDisplay: we[M]
    })))), f(8, W = N != null && N.length ? 0 : null), V = J);
  }, X = debounce(H, 250), Z = (J) => J != null && J.length ? J.slice().sort((fe, _e) => fe.primaryDisplay < _e.primaryDisplay ? -1 : 1) : [], oe = async () => {
    f(4, x = !0), M || (f(9, U = !0), f(0, M = await S.actions.getPrimaryDisplayForTableId(R.tableId))), await H(null, !0);
  }, ee = () => {
    f(4, x = !1), f(7, N = []), f(5, D = null), V = null, f(8, W = null);
  }, ie = (J) => x ? (J.key === "ArrowDown" ? (J.preventDefault(), W == null ? f(8, W = 0) : f(8, W = Math.min(N.length - 1, W + 1))) : J.key === "ArrowUp" ? (J.preventDefault(), W === 0 ? f(8, W = null) : W != null && f(8, W = Math.max(0, W - 1))) : J.key === "Enter" && W != null && N[W] != null && de(N[W]), !0) : !1, de = async (J) => {
    if (p != null && p.some((fe) => fe._id === J._id))
      if (m)
        await O([]);
      else {
        const fe = p.filter((_e) => _e._id !== J._id);
        fe.length ? f(8, W = Math.min(W, fe.length - 1)) : f(8, W = null), await O(fe);
      }
    else
      m ? await O([J]) : await O(Z([...p || [], J])), f(8, W = null);
    ee();
  }, pe = (J) => J == null ? "" : J instanceof Object ? JSON.stringify(J) : J;
  onMount(() => {
    f(19, w = {
      focus: oe,
      blur: ee,
      isActive: () => x,
      onKeyDown: ie
    });
  });
  function le(J) {
    bubble.call(this, u, J);
  }
  const ae = (J) => de(J), ne = (J) => E ? J.stopPropagation() : null;
  function K(J) {
    binding_callbacks[J ? "unshift" : "push"](() => {
      Y = J, f(10, Y);
    });
  }
  function ce(J) {
    D = J, f(5, D);
  }
  const te = (J) => de(J), ue = (J) => f(8, W = J);
  return u.$$set = (J) => {
    "value" in J && f(20, $ = J.value), "api" in J && f(19, w = J.api), "readonly" in J && f(21, T = J.readonly), "focused" in J && f(1, E = J.focused), "schema" in J && f(22, R = J.schema), "onChange" in J && f(23, O = J.onChange), "contentLines" in J && f(2, P = J.contentLines), "searchFunction" in J && f(24, L = J.searchFunction), "primaryDisplay" in J && f(0, M = J.primaryDisplay), "hideCounter" in J && f(3, B = J.hideCounter);
  }, u.$$.update = () => {
    u.$$.dirty[0] & /*value*/
    1048576 && f(6, p = q($)), u.$$.dirty[0] & /*schema*/
    4194304 && (m = (R == null ? void 0 : R.relationshipType) === "one-to-many"), u.$$.dirty[0] & /*focused, readonly*/
    2097154 && f(12, b = E && !T), u.$$.dirty[0] & /*fieldValue, isOpen*/
    80 && (y = Q(p, x)), u.$$.dirty[0] & /*searchString*/
    32 && X(D), u.$$.dirty[0] & /*focused, isOpen*/
    18 && !E && x && ee(), u.$$.dirty[0] & /*fieldValue, schema*/
    4194368 && f(11, v = p == null ? void 0 : p.reduce(
      (J, fe) => {
        const _e = {};
        for (const [ye] of Object.entries((R == null ? void 0 : R.columns) || {}).filter(([ke, we]) => we.visible !== !1 && fe[ke] !== null && fe[ke] !== void 0))
          _e[ye] = fe[ye];
        return Object.keys(_e).length && (J[fe._id] = _e), J;
      },
      {}
    ));
  }, [
    M,
    E,
    P,
    B,
    x,
    D,
    p,
    N,
    W,
    U,
    Y,
    v,
    b,
    j,
    z,
    oe,
    ee,
    de,
    pe,
    w,
    $,
    T,
    R,
    O,
    L,
    le,
    ae,
    ne,
    K,
    ce,
    te,
    ue
  ];
}
class RelationshipCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(
      this,
      l,
      instance$T,
      create_fragment$V,
      safe_not_equal,
      {
        value: 20,
        api: 19,
        readonly: 21,
        focused: 1,
        schema: 22,
        onChange: 23,
        contentLines: 2,
        searchFunction: 24,
        primaryDisplay: 0,
        hideCounter: 3
      },
      null,
      [-1, -1]
    );
  }
}
const LongFormCell_svelte_svelte_type_style_lang = "";
function create_if_block$r(u) {
  let l, f;
  return l = new GridPopover({
    props: {
      anchor: (
        /*anchor*/
        u[3]
      ),
      $$slots: { default: [create_default_slot$r] },
      $$scope: { ctx: u }
    }
  }), l.$on(
    "close",
    /*close*/
    u[7]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*anchor*/
      8 && (b.anchor = /*anchor*/
      p[3]), m & /*$$scope, value, textarea*/
      65539 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot$r(u) {
  let l, f, p, m;
  return {
    c() {
      l = element("textarea"), l.value = f = /*value*/
      u[0] || "", attr(l, "spellcheck", "false"), attr(l, "class", "svelte-w9nhoo");
    },
    m(b, y) {
      insert(b, l, y), u[14](l), p || (m = [
        listen(
          l,
          "change",
          /*handleChange*/
          u[5]
        ),
        listen(l, "wheel", stop_propagation(
          /*wheel_handler*/
          u[12]
        )),
        action_destroyer(clickOutside.call(
          null,
          l,
          /*close*/
          u[7]
        ))
      ], p = !0);
    },
    p(b, y) {
      y & /*value*/
      1 && f !== (f = /*value*/
      b[0] || "") && (l.value = f);
    },
    d(b) {
      b && detach(l), u[14](null), p = !1, run_all(m);
    }
  };
}
function create_fragment$U(u) {
  let l, f, p = (
    /*value*/
    (u[0] || "") + ""
  ), m, b, y, v, k, S, $ = (
    /*isOpen*/
    u[2] && create_if_block$r(u)
  );
  return {
    c() {
      l = element("div"), f = element("div"), m = text$2(p), b = space(), $ && $.c(), y = empty$1(), attr(f, "class", "value svelte-w9nhoo"), attr(l, "class", "long-form-cell svelte-w9nhoo"), toggle_class(
        l,
        "editable",
        /*editable*/
        u[4]
      );
    },
    m(w, T) {
      insert(w, l, T), append$1(l, f), append$1(f, m), u[13](l), insert(w, b, T), $ && $.m(w, T), insert(w, y, T), v = !0, k || (S = listen(l, "click", function() {
        is_function(
          /*editable*/
          u[4] ? (
            /*open*/
            u[6]
          ) : null
        ) && /*editable*/
        (u[4] ? (
          /*open*/
          u[6]
        ) : null).apply(this, arguments);
      }), k = !0);
    },
    p(w, [T]) {
      u = w, (!v || T & /*value*/
      1) && p !== (p = /*value*/
      (u[0] || "") + "") && set_data(m, p), (!v || T & /*editable*/
      16) && toggle_class(
        l,
        "editable",
        /*editable*/
        u[4]
      ), /*isOpen*/
      u[2] ? $ ? ($.p(u, T), T & /*isOpen*/
      4 && transition_in($, 1)) : ($ = create_if_block$r(u), $.c(), transition_in($, 1), $.m(y.parentNode, y)) : $ && (group_outros(), transition_out($, 1, 1, () => {
        $ = null;
      }), check_outros());
    },
    i(w) {
      v || (transition_in($), v = !0);
    },
    o(w) {
      transition_out($), v = !1;
    },
    d(w) {
      w && (detach(l), detach(b), detach(y)), u[13](null), $ && $.d(w), k = !1, S();
    }
  };
}
function instance$S(u, l, f) {
  let p, { value: m } = l, { focused: b = !1 } = l, { onChange: y } = l, { readonly: v = !1 } = l, { api: k } = l, S, $ = !1, w;
  const T = (B) => {
    y(B.target.value);
  }, E = () => $, R = async () => {
    f(2, $ = !0), await tick(), S.focus(), (m == null ? void 0 : m.length) > 100 && S.setSelectionRange(0, 0);
  }, O = () => {
    S == null || S.blur(), f(2, $ = !1);
  };
  onMount(() => {
    f(8, k = {
      focus: () => R(),
      blur: () => O(),
      isActive: () => $,
      onKeyDown: E
    });
  });
  function P(B) {
    bubble.call(this, u, B);
  }
  function L(B) {
    binding_callbacks[B ? "unshift" : "push"](() => {
      w = B, f(3, w);
    });
  }
  function M(B) {
    binding_callbacks[B ? "unshift" : "push"](() => {
      S = B, f(1, S);
    });
  }
  return u.$$set = (B) => {
    "value" in B && f(0, m = B.value), "focused" in B && f(9, b = B.focused), "onChange" in B && f(10, y = B.onChange), "readonly" in B && f(11, v = B.readonly), "api" in B && f(8, k = B.api);
  }, u.$$.update = () => {
    u.$$.dirty & /*focused, readonly*/
    2560 && f(4, p = b && !v), u.$$.dirty & /*focused*/
    512 && (b || f(2, $ = !1));
  }, [
    m,
    S,
    $,
    w,
    p,
    T,
    R,
    O,
    k,
    b,
    y,
    v,
    P,
    L,
    M
  ];
}
class LongFormCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$S, create_fragment$U, safe_not_equal, {
      value: 0,
      focused: 9,
      onChange: 10,
      readonly: 11,
      api: 8
    });
  }
}
const BooleanCell_svelte_svelte_type_style_lang = "";
function create_fragment$T(u) {
  let l, f, p;
  return f = new Checkbox_1({ props: { value: (
    /*value*/
    u[0]
  ) } }), f.$on(
    "change",
    /*handleChange*/
    u[2]
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "boolean-cell svelte-1l7j6r7"), toggle_class(
        l,
        "editable",
        /*editable*/
        u[1]
      );
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, [b]) {
      const y = {};
      b & /*value*/
      1 && (y.value = /*value*/
      m[0]), f.$set(y), (!p || b & /*editable*/
      2) && toggle_class(
        l,
        "editable",
        /*editable*/
        m[1]
      );
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function instance$R(u, l, f) {
  let p, { value: m } = l, { focused: b = !1 } = l, { onChange: y } = l, { readonly: v = !1 } = l, { api: k } = l;
  const S = (w) => {
    y(w.detail);
  }, $ = (w) => w.key === "Enter" ? (y(!m), !0) : !1;
  return onMount(() => {
    f(3, k = { onKeyDown: $ });
  }), u.$$set = (w) => {
    "value" in w && f(0, m = w.value), "focused" in w && f(4, b = w.focused), "onChange" in w && f(5, y = w.onChange), "readonly" in w && f(6, v = w.readonly), "api" in w && f(3, k = w.api);
  }, u.$$.update = () => {
    u.$$.dirty & /*focused, readonly*/
    80 && f(1, p = b && !v);
  }, [m, p, S, k, b, y, v];
}
class BooleanCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$R, create_fragment$T, safe_not_equal, {
      value: 0,
      focused: 4,
      onChange: 5,
      readonly: 6,
      api: 3
    });
  }
}
function create_else_block$7(u) {
  let l, f;
  const p = [
    /*$$props*/
    u[1],
    { readonly: !0 }
  ];
  let m = {};
  for (let b = 0; b < p.length; b += 1)
    m = assign(m, p[b]);
  return l = new TextCell({ props: m }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(b, y) {
      mount_component(l, b, y), f = !0;
    },
    p(b, y) {
      const v = y & /*$$props*/
      2 ? get_spread_update(p, [get_spread_object(
        /*$$props*/
        b[1]
      ), p[1]]) : {};
      l.$set(v);
    },
    i(b) {
      f || (transition_in(l.$$.fragment, b), f = !0);
    },
    o(b) {
      transition_out(l.$$.fragment, b), f = !1;
    },
    d(b) {
      destroy_component(l, b);
    }
  };
}
function create_if_block_2$8(u) {
  let l, f;
  const p = [
    /*$$props*/
    u[1],
    { readonly: !0 }
  ];
  let m = {};
  for (let b = 0; b < p.length; b += 1)
    m = assign(m, p[b]);
  return l = new DateCell({ props: m }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(b, y) {
      mount_component(l, b, y), f = !0;
    },
    p(b, y) {
      const v = y & /*$$props*/
      2 ? get_spread_update(p, [get_spread_object(
        /*$$props*/
        b[1]
      ), p[1]]) : {};
      l.$set(v);
    },
    i(b) {
      f || (transition_in(l.$$.fragment, b), f = !0);
    },
    o(b) {
      transition_out(l.$$.fragment, b), f = !1;
    },
    d(b) {
      destroy_component(l, b);
    }
  };
}
function create_if_block_1$b(u) {
  let l, f;
  const p = [
    /*$$props*/
    u[1],
    { readonly: !0 }
  ];
  let m = {};
  for (let b = 0; b < p.length; b += 1)
    m = assign(m, p[b]);
  return l = new BooleanCell({ props: m }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(b, y) {
      mount_component(l, b, y), f = !0;
    },
    p(b, y) {
      const v = y & /*$$props*/
      2 ? get_spread_update(p, [get_spread_object(
        /*$$props*/
        b[1]
      ), p[1]]) : {};
      l.$set(v);
    },
    i(b) {
      f || (transition_in(l.$$.fragment, b), f = !0);
    },
    o(b) {
      transition_out(l.$$.fragment, b), f = !1;
    },
    d(b) {
      destroy_component(l, b);
    }
  };
}
function create_if_block$q(u) {
  let l, f;
  const p = [
    /*$$props*/
    u[1],
    { readonly: !0 }
  ];
  let m = {};
  for (let b = 0; b < p.length; b += 1)
    m = assign(m, p[b]);
  return l = new NumberCell({ props: m }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(b, y) {
      mount_component(l, b, y), f = !0;
    },
    p(b, y) {
      const v = y & /*$$props*/
      2 ? get_spread_update(p, [get_spread_object(
        /*$$props*/
        b[1]
      ), p[1]]) : {};
      l.$set(v);
    },
    i(b) {
      f || (transition_in(l.$$.fragment, b), f = !0);
    },
    o(b) {
      transition_out(l.$$.fragment, b), f = !1;
    },
    d(b) {
      destroy_component(l, b);
    }
  };
}
function create_fragment$S(u) {
  let l, f, p, m;
  const b = [create_if_block$q, create_if_block_1$b, create_if_block_2$8, create_else_block$7], y = [];
  function v(k, S) {
    return (
      /*responseType*/
      k[0] === FieldType.NUMBER ? 0 : (
        /*responseType*/
        k[0] === FieldType.BOOLEAN ? 1 : (
          /*responseType*/
          k[0] === FieldType.DATETIME ? 2 : 3
        )
      )
    );
  }
  return l = v(u), f = y[l] = b[l](u), {
    c() {
      f.c(), p = empty$1();
    },
    m(k, S) {
      y[l].m(k, S), insert(k, p, S), m = !0;
    },
    p(k, [S]) {
      let $ = l;
      l = v(k), l === $ ? y[l].p(k, S) : (group_outros(), transition_out(y[$], 1, 1, () => {
        y[$] = null;
      }), check_outros(), f = y[l], f ? f.p(k, S) : (f = y[l] = b[l](k), f.c()), transition_in(f, 1), f.m(p.parentNode, p));
    },
    i(k) {
      m || (transition_in(f), m = !0);
    },
    o(k) {
      transition_out(f), m = !1;
    },
    d(k) {
      k && detach(p), y[l].d(k);
    }
  };
}
function instance$Q(u, l, f) {
  let p, { schema: m } = l;
  return u.$$set = (b) => {
    f(1, l = assign(assign({}, l), exclude_internal_props(b))), "schema" in b && f(2, m = b.schema);
  }, u.$$.update = () => {
    u.$$.dirty & /*schema*/
    4 && f(0, p = m.responseType);
  }, l = exclude_internal_props(l), [p, l, m];
}
class FormulaCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$Q, create_fragment$S, safe_not_equal, { schema: 2 });
  }
}
const AICell_svelte_svelte_type_style_lang = "";
function create_if_block$p(u) {
  let l, f;
  return l = new GridPopover({
    props: {
      anchor: (
        /*anchor*/
        u[3]
      ),
      $$slots: { default: [create_default_slot$q] },
      $$scope: { ctx: u }
    }
  }), l.$on(
    "close",
    /*close*/
    u[5]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*anchor*/
      8 && (b.anchor = /*anchor*/
      p[3]), m & /*$$scope, value, textarea*/
      4099 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot$q(u) {
  let l, f, p, m;
  return {
    c() {
      l = element("textarea"), l.disabled = !0, l.value = f = /*value*/
      u[0] || "", attr(l, "spellcheck", "false"), attr(l, "class", "svelte-13x28l0");
    },
    m(b, y) {
      insert(b, l, y), u[10](l), p || (m = [
        listen(l, "wheel", stop_propagation(
          /*wheel_handler*/
          u[8]
        )),
        action_destroyer(clickOutside.call(
          null,
          l,
          /*close*/
          u[5]
        ))
      ], p = !0);
    },
    p(b, y) {
      y & /*value*/
      1 && f !== (f = /*value*/
      b[0] || "") && (l.value = f);
    },
    d(b) {
      b && detach(l), u[10](null), p = !1, run_all(m);
    }
  };
}
function create_fragment$R(u) {
  let l, f, p = (
    /*value*/
    (u[0] || "") + ""
  ), m, b, y, v, k, S, $ = (
    /*isOpen*/
    u[2] && create_if_block$p(u)
  );
  return {
    c() {
      l = element("div"), f = element("div"), m = text$2(p), b = space(), $ && $.c(), y = empty$1(), attr(f, "class", "value svelte-13x28l0"), attr(l, "class", "long-form-cell svelte-13x28l0");
    },
    m(w, T) {
      insert(w, l, T), append$1(l, f), append$1(f, m), u[9](l), insert(w, b, T), $ && $.m(w, T), insert(w, y, T), v = !0, k || (S = listen(
        l,
        "click",
        /*open*/
        u[4]
      ), k = !0);
    },
    p(w, [T]) {
      (!v || T & /*value*/
      1) && p !== (p = /*value*/
      (w[0] || "") + "") && set_data(m, p), /*isOpen*/
      w[2] ? $ ? ($.p(w, T), T & /*isOpen*/
      4 && transition_in($, 1)) : ($ = create_if_block$p(w), $.c(), transition_in($, 1), $.m(y.parentNode, y)) : $ && (group_outros(), transition_out($, 1, 1, () => {
        $ = null;
      }), check_outros());
    },
    i(w) {
      v || (transition_in($), v = !0);
    },
    o(w) {
      transition_out($), v = !1;
    },
    d(w) {
      w && (detach(l), detach(b), detach(y)), u[9](null), $ && $.d(w), k = !1, S();
    }
  };
}
function instance$P(u, l, f) {
  let { value: p } = l, { focused: m = !1 } = l, { api: b } = l, y, v = !1, k;
  const S = () => v, $ = async () => {
    f(2, v = !0);
  }, w = () => {
    y == null || y.blur(), f(2, v = !1);
  };
  onMount(() => {
    f(6, b = {
      focus: () => $(),
      blur: () => w(),
      isActive: () => v,
      onKeyDown: S
    });
  });
  function T(O) {
    bubble.call(this, u, O);
  }
  function E(O) {
    binding_callbacks[O ? "unshift" : "push"](() => {
      k = O, f(3, k);
    });
  }
  function R(O) {
    binding_callbacks[O ? "unshift" : "push"](() => {
      y = O, f(1, y);
    });
  }
  return u.$$set = (O) => {
    "value" in O && f(0, p = O.value), "focused" in O && f(7, m = O.focused), "api" in O && f(6, b = O.api);
  }, u.$$.update = () => {
    u.$$.dirty & /*focused*/
    128 && (m || f(2, v = !1));
  }, [
    p,
    y,
    v,
    k,
    $,
    w,
    b,
    m,
    T,
    E,
    R
  ];
}
class AICell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$P, create_fragment$R, safe_not_equal, { value: 0, focused: 7, api: 6 });
  }
}
function create_fragment$Q(u) {
  let l, f, p;
  const m = [
    /*$$props*/
    u[3],
    { value: (
      /*stringified*/
      u[1]
    ) },
    { onChange: (
      /*parse*/
      u[2]
    ) }
  ];
  function b(v) {
    u[6](v);
  }
  let y = {};
  for (let v = 0; v < m.length; v += 1)
    y = assign(y, m[v]);
  return (
    /*api*/
    u[0] !== void 0 && (y.api = /*api*/
    u[0]), l = new LongFormCell({ props: y }), binding_callbacks.push(() => bind(l, "api", b)), {
      c() {
        create_component(l.$$.fragment);
      },
      m(v, k) {
        mount_component(l, v, k), p = !0;
      },
      p(v, [k]) {
        const S = k & /*$$props, stringified, parse*/
        14 ? get_spread_update(m, [
          k & /*$$props*/
          8 && get_spread_object(
            /*$$props*/
            v[3]
          ),
          k & /*stringified*/
          2 && { value: (
            /*stringified*/
            v[1]
          ) },
          k & /*parse*/
          4 && { onChange: (
            /*parse*/
            v[2]
          ) }
        ]) : {};
        !f && k & /*api*/
        1 && (f = !0, S.api = /*api*/
        v[0], add_flush_callback(() => f = !1)), l.$set(S);
      },
      i(v) {
        p || (transition_in(l.$$.fragment, v), p = !0);
      },
      o(v) {
        transition_out(l.$$.fragment, v), p = !1;
      },
      d(v) {
        destroy_component(l, v);
      }
    }
  );
}
function instance$O(u, l, f) {
  let p, { onChange: m } = l, { value: b } = l, { api: y } = l;
  const v = ($) => {
    if (!$)
      return $;
    try {
      return JSON.stringify($, null, 2);
    } catch {
      return null;
    }
  }, k = ($) => {
    const w = $ == null ? void 0 : $.trim();
    if (!w) {
      m(null);
      return;
    }
    try {
      const T = JSON.parse(w);
      m(T);
    } catch {
    }
  };
  function S($) {
    y = $, f(0, y);
  }
  return u.$$set = ($) => {
    f(3, l = assign(assign({}, l), exclude_internal_props($))), "onChange" in $ && f(4, m = $.onChange), "value" in $ && f(5, b = $.value), "api" in $ && f(0, y = $.api);
  }, u.$$.update = () => {
    u.$$.dirty & /*value*/
    32 && f(1, p = v(b));
  }, l = exclude_internal_props(l), [y, p, k, l, m, b, S];
}
class JSONCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$O, create_fragment$Q, safe_not_equal, { onChange: 4, value: 5, api: 0 });
  }
}
const AttachmentCell_svelte_svelte_type_style_lang = "";
function get_each_context$9(u, l, f) {
  const p = u.slice();
  return p[26] = l[f], p;
}
function create_else_block$6(u) {
  let l, f = (
    /*attachment*/
    u[26].extension + ""
  ), p, m, b;
  return {
    c() {
      l = element("div"), p = text$2(f), m = space(), attr(l, "class", "file svelte-1iu2dac"), attr(l, "title", b = /*attachment*/
      u[26].name);
    },
    m(y, v) {
      insert(y, l, v), append$1(l, p), append$1(l, m);
    },
    p(y, v) {
      v & /*value*/
      1 && f !== (f = /*attachment*/
      y[26].extension + "") && set_data(p, f), v & /*value*/
      1 && b !== (b = /*attachment*/
      y[26].name) && attr(l, "title", b);
    },
    d(y) {
      y && detach(l);
    }
  };
}
function create_if_block_1$a(u) {
  let l, f, p;
  return {
    c() {
      var m;
      l = element("img"), src_url_equal(l.src, f = /*attachment*/
      u[26].url) || attr(l, "src", f), attr(l, "alt", p = /*attachment*/
      u[26].extension), attr(l, "class", "svelte-1iu2dac"), toggle_class(l, "light", !/*$props*/
      ((m = u[7]) != null && m.darkMode) && /*schema*/
      u[2].type === FieldType.SIGNATURE_SINGLE);
    },
    m(m, b) {
      insert(m, l, b);
    },
    p(m, b) {
      var y;
      b & /*value*/
      1 && !src_url_equal(l.src, f = /*attachment*/
      m[26].url) && attr(l, "src", f), b & /*value*/
      1 && p !== (p = /*attachment*/
      m[26].extension) && attr(l, "alt", p), b & /*$props, schema*/
      132 && toggle_class(l, "light", !/*$props*/
      ((y = m[7]) != null && y.darkMode) && /*schema*/
      m[2].type === FieldType.SIGNATURE_SINGLE);
    },
    d(m) {
      m && detach(l);
    }
  };
}
function create_each_block$9(u) {
  let l, f;
  function p(y, v) {
    return v & /*value*/
    1 && (l = null), l == null && (l = !!/*isImage*/
    y[13](
      /*attachment*/
      y[26].extension
    )), l ? create_if_block_1$a : create_else_block$6;
  }
  let m = p(u, -1), b = m(u);
  return {
    c() {
      b.c(), f = empty$1();
    },
    m(y, v) {
      b.m(y, v), insert(y, f, v);
    },
    p(y, v) {
      m === (m = p(y, v)) && b ? b.p(y, v) : (b.d(1), b = m(y), b && (b.c(), b.m(f.parentNode, f)));
    },
    d(y) {
      y && detach(f), b.d(y);
    }
  };
}
function create_if_block$o(u) {
  let l, f;
  return l = new GridPopover({
    props: {
      open: (
        /*isOpen*/
        u[4]
      ),
      anchor: (
        /*anchor*/
        u[5]
      ),
      maxHeight: null,
      $$slots: { default: [create_default_slot$p] },
      $$scope: { ctx: u }
    }
  }), l.$on(
    "close",
    /*close*/
    u[12]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*isOpen*/
      16 && (b.open = /*isOpen*/
      p[4]), m & /*anchor*/
      32 && (b.anchor = /*anchor*/
      p[5]), m & /*$$scope, value, maximum, schema, $props, onChange*/
      536871055 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot$p(u) {
  var m, b;
  let l, f, p;
  return f = new Dropzone({
    props: {
      value: (
        /*value*/
        u[0]
      ),
      compact: !0,
      maximum: (
        /*maximum*/
        u[3] || /*schema*/
        ((b = (m = u[2].constraints) == null ? void 0 : m.length) == null ? void 0 : b.maximum)
      ),
      processFiles: (
        /*processFiles*/
        u[15]
      ),
      handleFileTooLarge: (
        /*$props*/
        u[7].isCloud ? (
          /*handleFileTooLarge*/
          u[14]
        ) : null
      )
    }
  }), f.$on(
    "change",
    /*change_handler*/
    u[20]
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "dropzone svelte-1iu2dac");
    },
    m(y, v) {
      insert(y, l, v), mount_component(f, l, null), p = !0;
    },
    p(y, v) {
      var S, $;
      const k = {};
      v & /*value*/
      1 && (k.value = /*value*/
      y[0]), v & /*maximum, schema*/
      12 && (k.maximum = /*maximum*/
      y[3] || /*schema*/
      (($ = (S = y[2].constraints) == null ? void 0 : S.length) == null ? void 0 : $.maximum)), v & /*$props*/
      128 && (k.handleFileTooLarge = /*$props*/
      y[7].isCloud ? (
        /*handleFileTooLarge*/
        y[14]
      ) : null), f.$set(k);
    },
    i(y) {
      p || (transition_in(f.$$.fragment, y), p = !0);
    },
    o(y) {
      transition_out(f.$$.fragment, y), p = !1;
    },
    d(y) {
      y && detach(l), destroy_component(f);
    }
  };
}
function create_fragment$P(u) {
  let l, f, p, m, b, y, v = ensure_array_like(
    /*value*/
    u[0] || []
  ), k = [];
  for (let $ = 0; $ < v.length; $ += 1)
    k[$] = create_each_block$9(get_each_context$9(u, v, $));
  let S = (
    /*isOpen*/
    u[4] && create_if_block$o(u)
  );
  return {
    c() {
      l = element("div");
      for (let $ = 0; $ < k.length; $ += 1)
        k[$].c();
      f = space(), S && S.c(), p = empty$1(), attr(l, "class", "attachment-cell svelte-1iu2dac"), toggle_class(
        l,
        "editable",
        /*editable*/
        u[6]
      );
    },
    m($, w) {
      insert($, l, w);
      for (let T = 0; T < k.length; T += 1)
        k[T] && k[T].m(l, null);
      u[19](l), insert($, f, w), S && S.m($, w), insert($, p, w), m = !0, b || (y = listen(l, "click", function() {
        is_function(
          /*editable*/
          u[6] ? (
            /*open*/
            u[11]
          ) : null
        ) && /*editable*/
        (u[6] ? (
          /*open*/
          u[11]
        ) : null).apply(this, arguments);
      }), b = !0);
    },
    p($, [w]) {
      if (u = $, w & /*value, $props, schema, isImage*/
      8325) {
        v = ensure_array_like(
          /*value*/
          u[0] || []
        );
        let T;
        for (T = 0; T < v.length; T += 1) {
          const E = get_each_context$9(u, v, T);
          k[T] ? k[T].p(E, w) : (k[T] = create_each_block$9(E), k[T].c(), k[T].m(l, null));
        }
        for (; T < k.length; T += 1)
          k[T].d(1);
        k.length = v.length;
      }
      (!m || w & /*editable*/
      64) && toggle_class(
        l,
        "editable",
        /*editable*/
        u[6]
      ), /*isOpen*/
      u[4] ? S ? (S.p(u, w), w & /*isOpen*/
      16 && transition_in(S, 1)) : (S = create_if_block$o(u), S.c(), transition_in(S, 1), S.m(p.parentNode, p)) : S && (group_outros(), transition_out(S, 1, 1, () => {
        S = null;
      }), check_outros());
    },
    i($) {
      m || (transition_in(S), m = !0);
    },
    o($) {
      transition_out(S), m = !1;
    },
    d($) {
      $ && (detach(l), detach(f), detach(p)), destroy_each(k, $), u[19](null), S && S.d($), b = !1, y();
    }
  };
}
function instance$N(u, l, f) {
  let p, m, b, y, { value: v } = l, { focused: k = !1 } = l, { onChange: S } = l, { readonly: $ = !1 } = l, { api: w } = l, { schema: T } = l, { maximum: E } = l;
  const { API: R, notifications: O, props: P, datasource: L } = getContext$1("grid");
  component_subscribe(u, O, (q) => f(21, m = q)), component_subscribe(u, P, (q) => f(7, y = q)), component_subscribe(u, L, (q) => f(22, b = q));
  const M = ["png", "tiff", "gif", "raw", "jpg", "jpeg"];
  let B = !1, j;
  const x = () => B, N = () => {
    f(4, B = !0);
  }, D = () => {
    f(4, B = !1);
  }, V = (q) => M.includes(q == null ? void 0 : q.toLowerCase()), W = (q) => {
    m.error(`Files cannot exceed ${q / 1e6}MB. Please try again with smaller files.`);
  }, F = async (q) => {
    let Q = new FormData();
    for (let z = 0; z < q.length; z++)
      Q.append("file", q[z]);
    try {
      const z = (b == null ? void 0 : b.tableId) || (b == null ? void 0 : b.id);
      return z ? await R.uploadAttachment(z, Q) : await R.uploadBuilderAttachment(Q);
    } catch (z) {
      return m.error(z.message || "Failed to upload attachment"), [];
    }
  };
  onMount(() => {
    f(16, w = {
      focus: () => N(),
      blur: () => D(),
      isActive: () => B,
      onKeyDown: x
    });
  });
  function U(q) {
    binding_callbacks[q ? "unshift" : "push"](() => {
      j = q, f(5, j);
    });
  }
  const Y = (q) => S(q.detail);
  return u.$$set = (q) => {
    "value" in q && f(0, v = q.value), "focused" in q && f(17, k = q.focused), "onChange" in q && f(1, S = q.onChange), "readonly" in q && f(18, $ = q.readonly), "api" in q && f(16, w = q.api), "schema" in q && f(2, T = q.schema), "maximum" in q && f(3, E = q.maximum);
  }, u.$$.update = () => {
    u.$$.dirty & /*focused, readonly*/
    393216 && f(6, p = k && !$), u.$$.dirty & /*focused*/
    131072 && (k || D());
  }, [
    v,
    S,
    T,
    E,
    B,
    j,
    p,
    y,
    O,
    P,
    L,
    N,
    D,
    V,
    W,
    F,
    w,
    k,
    $,
    U,
    Y
  ];
}
class AttachmentCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$N, create_fragment$P, safe_not_equal, {
      value: 0,
      focused: 17,
      onChange: 1,
      readonly: 18,
      api: 16,
      schema: 2,
      maximum: 3
    });
  }
}
function create_fragment$O(u) {
  let l, f, p;
  const m = [
    /*$$restProps*/
    u[3],
    { maximum: 1 },
    { value: (
      /*arrayValue*/
      u[2]
    ) },
    { onChange: (
      /*onFileChange*/
      u[1]
    ) }
  ];
  function b(v) {
    u[6](v);
  }
  let y = {};
  for (let v = 0; v < m.length; v += 1)
    y = assign(y, m[v]);
  return (
    /*api*/
    u[0] !== void 0 && (y.api = /*api*/
    u[0]), l = new AttachmentCell({ props: y }), binding_callbacks.push(() => bind(l, "api", b)), {
      c() {
        create_component(l.$$.fragment);
      },
      m(v, k) {
        mount_component(l, v, k), p = !0;
      },
      p(v, [k]) {
        const S = k & /*$$restProps, arrayValue, onFileChange*/
        14 ? get_spread_update(m, [
          k & /*$$restProps*/
          8 && get_spread_object(
            /*$$restProps*/
            v[3]
          ),
          m[1],
          k & /*arrayValue*/
          4 && { value: (
            /*arrayValue*/
            v[2]
          ) },
          k & /*onFileChange*/
          2 && { onChange: (
            /*onFileChange*/
            v[1]
          ) }
        ]) : {};
        !f && k & /*api*/
        1 && (f = !0, S.api = /*api*/
        v[0], add_flush_callback(() => f = !1)), l.$set(S);
      },
      i(v) {
        p || (transition_in(l.$$.fragment, v), p = !0);
      },
      o(v) {
        transition_out(l.$$.fragment, v), p = !1;
      },
      d(v) {
        destroy_component(l, v);
      }
    }
  );
}
function instance$M(u, l, f) {
  let p, m;
  const b = ["value", "onChange", "api"];
  let y = compute_rest_props(l, b), { value: v } = l, { onChange: k } = l, { api: S } = l;
  function $(w) {
    S = w, f(0, S);
  }
  return u.$$set = (w) => {
    l = assign(assign({}, l), exclude_internal_props(w)), f(3, y = compute_rest_props(l, b)), "value" in w && f(4, v = w.value), "onChange" in w && f(5, k = w.onChange), "api" in w && f(0, S = w.api);
  }, u.$$.update = () => {
    u.$$.dirty & /*onChange*/
    32 && f(1, m = (w) => {
      w = w[0] || null, k(w);
    }), u.$$.dirty & /*value*/
    16 && f(2, p = (!Array.isArray(v) && v ? [v] : v) || []);
  }, [
    S,
    m,
    p,
    y,
    v,
    k,
    $
  ];
}
class AttachmentSingleCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$M, create_fragment$O, safe_not_equal, { value: 4, onChange: 5, api: 0 });
  }
}
function create_fragment$N(u) {
  let l, f, p;
  const m = [
    /*$$restProps*/
    u[4],
    { schema: (
      /*schema*/
      u[0]
    ) },
    {
      searchFunction: (
        /*searchFunction*/
        u[3]
      )
    },
    { primaryDisplay: "email" },
    { hideCounter: (
      /*hideCounter*/
      u[2]
    ) }
  ];
  function b(v) {
    u[5](v);
  }
  let y = {};
  for (let v = 0; v < m.length; v += 1)
    y = assign(y, m[v]);
  return (
    /*api*/
    u[1] !== void 0 && (y.api = /*api*/
    u[1]), l = new RelationshipCell({ props: y }), binding_callbacks.push(() => bind(l, "api", b)), {
      c() {
        create_component(l.$$.fragment);
      },
      m(v, k) {
        mount_component(l, v, k), p = !0;
      },
      p(v, [k]) {
        const S = k & /*$$restProps, schema, searchFunction, hideCounter*/
        29 ? get_spread_update(m, [
          k & /*$$restProps*/
          16 && get_spread_object(
            /*$$restProps*/
            v[4]
          ),
          k & /*schema*/
          1 && { schema: (
            /*schema*/
            v[0]
          ) },
          k & /*searchFunction*/
          8 && {
            searchFunction: (
              /*searchFunction*/
              v[3]
            )
          },
          m[3],
          k & /*hideCounter*/
          4 && { hideCounter: (
            /*hideCounter*/
            v[2]
          ) }
        ]) : {};
        !f && k & /*api*/
        2 && (f = !0, S.api = /*api*/
        v[1], add_flush_callback(() => f = !1)), l.$set(S);
      },
      i(v) {
        p || (transition_in(l.$$.fragment, v), p = !0);
      },
      o(v) {
        transition_out(l.$$.fragment, v), p = !1;
      },
      d(v) {
        destroy_component(l, v);
      }
    }
  );
}
function instance$L(u, l, f) {
  const p = ["api", "hideCounter", "schema"];
  let m = compute_rest_props(l, p), { api: b } = l, { hideCounter: y = !1 } = l, { schema: v } = l;
  const { API: k } = getContext$1("grid"), { type: S, subtype: $ } = v;
  async function w(E, R) {
    if ($ !== BBReferenceFieldSubType.USER && $ !== BBReferenceFieldSubType.USERS)
      throw `Search for '${$}' not implemented`;
    const O = Object.values(R.query.string)[0], P = await k.searchUsers({ query: { string: { email: O } } });
    return {
      ...P,
      data: void 0,
      rows: P.data
    };
  }
  function T(E) {
    b = E, f(1, b);
  }
  return u.$$set = (E) => {
    f(9, l = assign(assign({}, l), exclude_internal_props(E))), f(4, m = compute_rest_props(l, p)), "api" in E && f(1, b = E.api), "hideCounter" in E && f(2, y = E.hideCounter), "schema" in E && f(0, v = E.schema);
  }, u.$$.update = () => {
    f(0, v = {
      ...l.schema,
      // This is not really used, just adding some content to be able to render the relationship cell
      tableId: "external",
      relationshipType: S === FieldType.BB_REFERENCE_SINGLE || isDeprecatedSingleUserColumn(v) ? RelationshipType.ONE_TO_MANY : RelationshipType.MANY_TO_MANY
    });
  }, l = exclude_internal_props(l), [
    v,
    b,
    y,
    w,
    m,
    T
  ];
}
class BBReferenceCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$L, create_fragment$N, safe_not_equal, { api: 1, hideCounter: 2, schema: 0 });
  }
}
const SignatureCell_svelte_svelte_type_style_lang = "";
function create_if_block_2$7(u) {
  let l, f;
  return {
    c() {
      var p;
      l = element("img"), src_url_equal(l.src, f = /*value*/
      (p = u[1]) == null ? void 0 : p.url) || attr(l, "src", f), attr(l, "class", "svelte-34a6jk");
    },
    m(p, m) {
      insert(p, l, m);
    },
    p(p, m) {
      var b;
      m & /*value*/
      2 && !src_url_equal(l.src, f = /*value*/
      (b = p[1]) == null ? void 0 : b.url) && attr(l, "src", f);
    },
    d(p) {
      p && detach(l);
    }
  };
}
function create_if_block$n(u) {
  let l, f;
  return l = new GridPopover({
    props: {
      open: (
        /*isOpen*/
        u[2]
      ),
      anchor: (
        /*anchor*/
        u[4]
      ),
      maxHeight: null,
      $$slots: { default: [create_default_slot$o] },
      $$scope: { ctx: u }
    }
  }), l.$on(
    "close",
    /*close*/
    u[11]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*isOpen*/
      4 && (b.open = /*isOpen*/
      p[2]), m & /*anchor*/
      16 && (b.anchor = /*anchor*/
      p[4]), m & /*$$scope, value, $props, modal*/
      33554506 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_else_block$5(u) {
  let l, f, p;
  return f = new ActionButton({
    props: {
      fullWidth: !0,
      $$slots: { default: [create_default_slot_1$b] },
      $$scope: { ctx: u }
    }
  }), f.$on(
    "click",
    /*click_handler*/
    u[20]
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "add-signature");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b & /*$$scope*/
      33554432 && (y.$$scope = { dirty: b, ctx: m }), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block_1$9(u) {
  let l, f, p;
  return f = new Signature({
    props: {
      darkMode: (
        /*$props*/
        u[6].darkMode
      ),
      editable: !1,
      value: (
        /*value*/
        u[1]
      )
    }
  }), f.$on(
    "change",
    /*saveSignature*/
    u[13]
  ), f.$on(
    "clear",
    /*deleteSignature*/
    u[12]
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "signature-wrap svelte-34a6jk");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b & /*$props*/
      64 && (y.darkMode = /*$props*/
      m[6].darkMode), b & /*value*/
      2 && (y.value = /*value*/
      m[1]), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_default_slot_1$b(u) {
  let l;
  return {
    c() {
      l = text$2("Add signature");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot$o(u) {
  let l, f, p, m;
  const b = [create_if_block_1$9, create_else_block$5], y = [];
  function v(k, S) {
    var $;
    return (
      /*value*/
      ($ = k[1]) != null && $.key ? 0 : 1
    );
  }
  return f = v(u), p = y[f] = b[f](u), {
    c() {
      l = element("div"), p.c(), attr(l, "class", "signature svelte-34a6jk"), toggle_class(l, "empty", !/*value*/
      u[1]);
    },
    m(k, S) {
      insert(k, l, S), y[f].m(l, null), m = !0;
    },
    p(k, S) {
      let $ = f;
      f = v(k), f === $ ? y[f].p(k, S) : (group_outros(), transition_out(y[$], 1, 1, () => {
        y[$] = null;
      }), check_outros(), p = y[f], p ? p.p(k, S) : (p = y[f] = b[f](k), p.c()), transition_in(p, 1), p.m(l, null)), (!m || S & /*value*/
      2) && toggle_class(l, "empty", !/*value*/
      k[1]);
    },
    i(k) {
      m || (transition_in(p), m = !0);
    },
    o(k) {
      transition_out(p), m = !1;
    },
    d(k) {
      k && detach(l), y[f].d();
    }
  };
}
function create_fragment$M(u) {
  var T, E;
  let l, f, p, m, b, y, v, k, S = (
    /*value*/
    ((T = u[1]) == null ? void 0 : T.url) && create_if_block_2$7(u)
  ), $ = {
    onConfirm: (
      /*saveSignature*/
      u[13]
    ),
    title: (
      /*schema*/
      (E = u[0]) == null ? void 0 : E.name
    ),
    value: (
      /*value*/
      u[1]
    ),
    darkMode: (
      /*$props*/
      u[6].darkMode
    )
  };
  p = new SignatureModal({ props: $ }), u[19](p);
  let w = (
    /*isOpen*/
    u[2] && create_if_block$n(u)
  );
  return {
    c() {
      var R;
      l = element("div"), S && S.c(), f = space(), create_component(p.$$.fragment), m = space(), w && w.c(), b = empty$1(), attr(l, "class", "signature-cell svelte-34a6jk"), toggle_class(l, "light", !/*$props*/
      ((R = u[6]) != null && R.darkMode)), toggle_class(
        l,
        "editable",
        /*editable*/
        u[5]
      );
    },
    m(R, O) {
      insert(R, l, O), S && S.m(l, null), u[18](l), insert(R, f, O), mount_component(p, R, O), insert(R, m, O), w && w.m(R, O), insert(R, b, O), y = !0, v || (k = listen(l, "click", function() {
        is_function(
          /*editable*/
          u[5] ? (
            /*open*/
            u[10]
          ) : null
        ) && /*editable*/
        (u[5] ? (
          /*open*/
          u[10]
        ) : null).apply(this, arguments);
      }), v = !0);
    },
    p(R, [O]) {
      var L, M, B;
      u = R, /*value*/
      (L = u[1]) != null && L.url ? S ? S.p(u, O) : (S = create_if_block_2$7(u), S.c(), S.m(l, null)) : S && (S.d(1), S = null), (!y || O & /*$props*/
      64) && toggle_class(l, "light", !/*$props*/
      ((M = u[6]) != null && M.darkMode)), (!y || O & /*editable*/
      32) && toggle_class(
        l,
        "editable",
        /*editable*/
        u[5]
      );
      const P = {};
      O & /*schema*/
      1 && (P.title = /*schema*/
      (B = u[0]) == null ? void 0 : B.name), O & /*value*/
      2 && (P.value = /*value*/
      u[1]), O & /*$props*/
      64 && (P.darkMode = /*$props*/
      u[6].darkMode), p.$set(P), /*isOpen*/
      u[2] ? w ? (w.p(u, O), O & /*isOpen*/
      4 && transition_in(w, 1)) : (w = create_if_block$n(u), w.c(), transition_in(w, 1), w.m(b.parentNode, b)) : w && (group_outros(), transition_out(w, 1, 1, () => {
        w = null;
      }), check_outros());
    },
    i(R) {
      y || (transition_in(p.$$.fragment, R), transition_in(w), y = !0);
    },
    o(R) {
      transition_out(p.$$.fragment, R), transition_out(w), y = !1;
    },
    d(R) {
      R && (detach(l), detach(f), detach(m), detach(b)), S && S.d(), u[18](null), u[19](null), destroy_component(p, R), w && w.d(R), v = !1, k();
    }
  };
}
function instance$K(u, l, f) {
  let p, m, b, y, { schema: v } = l, { value: k } = l, { focused: S = !1 } = l, { onChange: $ } = l, { readonly: w = !1 } = l, { api: T } = l;
  const { API: E, notifications: R, props: O, datasource: P } = getContext$1("grid");
  component_subscribe(u, R, (Y) => f(21, m = Y)), component_subscribe(u, O, (Y) => f(6, y = Y)), component_subscribe(u, P, (Y) => f(22, b = Y));
  let L = !1, M, B;
  const j = () => !1, x = () => {
    f(2, L = !0);
  }, N = () => {
    f(2, L = !1);
  }, D = async () => {
    $(null);
  }, V = async (Y) => {
    const q = Y.toFile();
    let Q = new FormData();
    Q.append("file", q);
    try {
      const z = (b == null ? void 0 : b.tableId) || (b == null ? void 0 : b.id), H = await (z ? E.uploadAttachment(z, Q) : E.uploadBuilderAttachment(Q));
      $(H[0]);
    } catch (z) {
      return m.error(z.message || "Failed to save signature"), [];
    }
  };
  onMount(() => {
    f(14, T = {
      focus: () => x(),
      blur: () => N(),
      isActive: () => L,
      onKeyDown: j
    });
  });
  function W(Y) {
    binding_callbacks[Y ? "unshift" : "push"](() => {
      B = Y, f(4, B);
    });
  }
  function F(Y) {
    binding_callbacks[Y ? "unshift" : "push"](() => {
      M = Y, f(3, M);
    });
  }
  const U = () => {
    M.show();
  };
  return u.$$set = (Y) => {
    "schema" in Y && f(0, v = Y.schema), "value" in Y && f(1, k = Y.value), "focused" in Y && f(15, S = Y.focused), "onChange" in Y && f(16, $ = Y.onChange), "readonly" in Y && f(17, w = Y.readonly), "api" in Y && f(14, T = Y.api);
  }, u.$$.update = () => {
    u.$$.dirty & /*focused, readonly*/
    163840 && f(5, p = S && !w), u.$$.dirty & /*focused*/
    32768 && (S || N());
  }, [
    v,
    k,
    L,
    M,
    B,
    p,
    y,
    R,
    O,
    P,
    x,
    N,
    D,
    V,
    T,
    S,
    $,
    w,
    W,
    F,
    U
  ];
}
class SignatureCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$K, create_fragment$M, safe_not_equal, {
      schema: 0,
      value: 1,
      focused: 15,
      onChange: 16,
      readonly: 17,
      api: 14
    });
  }
}
function create_fragment$L(u) {
  let l, f, p;
  const m = [
    /*$$restProps*/
    u[3],
    { value: (
      /*arrayValue*/
      u[2]
    ) },
    { onChange: (
      /*onValueChange*/
      u[1]
    ) },
    { hideCounter: !0 }
  ];
  function b(v) {
    u[6](v);
  }
  let y = {};
  for (let v = 0; v < m.length; v += 1)
    y = assign(y, m[v]);
  return (
    /*api*/
    u[0] !== void 0 && (y.api = /*api*/
    u[0]), l = new BBReferenceCell({ props: y }), binding_callbacks.push(() => bind(l, "api", b)), {
      c() {
        create_component(l.$$.fragment);
      },
      m(v, k) {
        mount_component(l, v, k), p = !0;
      },
      p(v, [k]) {
        const S = k & /*$$restProps, arrayValue, onValueChange*/
        14 ? get_spread_update(m, [
          k & /*$$restProps*/
          8 && get_spread_object(
            /*$$restProps*/
            v[3]
          ),
          k & /*arrayValue*/
          4 && { value: (
            /*arrayValue*/
            v[2]
          ) },
          k & /*onValueChange*/
          2 && { onChange: (
            /*onValueChange*/
            v[1]
          ) },
          m[3]
        ]) : {};
        !f && k & /*api*/
        1 && (f = !0, S.api = /*api*/
        v[0], add_flush_callback(() => f = !1)), l.$set(S);
      },
      i(v) {
        p || (transition_in(l.$$.fragment, v), p = !0);
      },
      o(v) {
        transition_out(l.$$.fragment, v), p = !1;
      },
      d(v) {
        destroy_component(l, v);
      }
    }
  );
}
function instance$J(u, l, f) {
  let p, m;
  const b = ["value", "onChange", "api"];
  let y = compute_rest_props(l, b), { value: v } = l, { onChange: k } = l, { api: S } = l;
  function $(w) {
    S = w, f(0, S);
  }
  return u.$$set = (w) => {
    l = assign(assign({}, l), exclude_internal_props(w)), f(3, y = compute_rest_props(l, b)), "value" in w && f(4, v = w.value), "onChange" in w && f(5, k = w.onChange), "api" in w && f(0, S = w.api);
  }, u.$$.update = () => {
    u.$$.dirty & /*onChange*/
    32 && f(1, m = (w) => {
      w = w[0] || null, k(w);
    }), u.$$.dirty & /*value*/
    16 && f(2, p = (!Array.isArray(v) && v ? [v] : v) || []);
  }, [
    S,
    m,
    p,
    y,
    v,
    k,
    $
  ];
}
class BBReferenceSingleCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$J, create_fragment$L, safe_not_equal, { value: 4, onChange: 5, api: 0 });
  }
}
const RoleCell_svelte_svelte_type_style_lang = "";
function create_fragment$K(u) {
  var S, $, w, T, E;
  let l, f, p, m, b, y = (
    /*role*/
    ((($ = (S = u[0]) == null ? void 0 : S.uiMetadata) == null ? void 0 : $.displayName) || /*role*/
    ((w = u[0]) == null ? void 0 : w.name) || "Unknown role") + ""
  ), v, k;
  return p = new StatusLight({
    props: {
      square: !0,
      size: "L",
      color: (
        /*role*/
        ((E = (T = u[0]) == null ? void 0 : T.uiMetadata) == null ? void 0 : E.color) || "var(--spectrum-global-color-static-magenta-400)"
      )
    }
  }), {
    c() {
      l = element("div"), f = element("div"), create_component(p.$$.fragment), m = space(), b = element("div"), v = text$2(y), attr(f, "class", "light svelte-7aaju2"), attr(b, "class", "value svelte-7aaju2"), attr(l, "class", "role-cell svelte-7aaju2");
    },
    m(R, O) {
      insert(R, l, O), append$1(l, f), mount_component(p, f, null), append$1(l, m), append$1(l, b), append$1(b, v), k = !0;
    },
    p(R, [O]) {
      var L, M, B, j, x;
      const P = {};
      O & /*role*/
      1 && (P.color = /*role*/
      ((M = (L = R[0]) == null ? void 0 : L.uiMetadata) == null ? void 0 : M.color) || "var(--spectrum-global-color-static-magenta-400)"), p.$set(P), (!k || O & /*role*/
      1) && y !== (y = /*role*/
      (((j = (B = R[0]) == null ? void 0 : B.uiMetadata) == null ? void 0 : j.displayName) || /*role*/
      ((x = R[0]) == null ? void 0 : x.name) || "Unknown role") + "") && set_data(v, y);
    },
    i(R) {
      k || (transition_in(p.$$.fragment, R), k = !0);
    },
    o(R) {
      transition_out(p.$$.fragment, R), k = !1;
    },
    d(R) {
      R && detach(l), destroy_component(p);
    }
  };
}
function instance$I(u, l, f) {
  let p, { value: m } = l, { schema: b } = l;
  return u.$$set = (y) => {
    "value" in y && f(1, m = y.value), "schema" in y && f(2, b = y.schema);
  }, u.$$.update = () => {
    var y;
    u.$$.dirty & /*schema, value*/
    6 && f(0, p = (y = b.roles) == null ? void 0 : y.find((v) => v._id === m));
  }, [p, m, b];
}
class RoleCell extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$I, create_fragment$K, safe_not_equal, { value: 1, schema: 2 });
  }
}
const TypeComponentMap = {
  [FieldType.STRING]: TextCell,
  [FieldType.OPTIONS]: OptionsCell,
  [FieldType.DATETIME]: DateCell,
  [FieldType.BARCODEQR]: TextCell,
  [FieldType.SIGNATURE_SINGLE]: SignatureCell,
  [FieldType.LONGFORM]: LongFormCell,
  [FieldType.ARRAY]: MultiSelectCell,
  [FieldType.NUMBER]: NumberCell,
  [FieldType.BOOLEAN]: BooleanCell,
  [FieldType.ATTACHMENTS]: AttachmentCell,
  [FieldType.ATTACHMENT_SINGLE]: AttachmentSingleCell,
  [FieldType.LINK]: RelationshipCell,
  [FieldType.FORMULA]: FormulaCell,
  [FieldType.AI]: AICell,
  [FieldType.JSON]: JSONCell,
  [FieldType.BB_REFERENCE]: BBReferenceCell,
  [FieldType.BB_REFERENCE_SINGLE]: BBReferenceSingleCell,
  // Custom types for UI only
  role: RoleCell
};
function getCellRendererByType(u) {
  if (u)
    return TypeComponentMap[u];
}
const getCellRenderer = (u) => {
  var l, f;
  return u.calculationType ? NumberCell : getCellRendererByType((l = u.schema) == null ? void 0 : l.cellRenderType) || getCellRendererByType((f = u.schema) == null ? void 0 : f.type) || TextCell;
}, GridRow_svelte_svelte_type_style_lang = "", ButtonColumn_svelte_svelte_type_style_lang = "", GridBody_svelte_svelte_type_style_lang = "", ResizeOverlay_svelte_svelte_type_style_lang = "", ReorderOverlay_svelte_svelte_type_style_lang = "", PopoverOverlay_svelte_svelte_type_style_lang = "", NewColumnButton_svelte_svelte_type_style_lang = "", HeaderCell_svelte_svelte_type_style_lang = "", HeaderRow_svelte_svelte_type_style_lang = "", ScrollOverlay_svelte_svelte_type_style_lang = "", MenuOverlay_svelte_svelte_type_style_lang = "", GutterCell_svelte_svelte_type_style_lang = "", KeyboardShortcut_svelte_svelte_type_style_lang = "", StickyColumn_svelte_svelte_type_style_lang = "", UserAvatars_svelte_svelte_type_style_lang = "", NewRow_svelte_svelte_type_style_lang = "", Grid_svelte_svelte_type_style_lang = "", ClientAppSkeleton_svelte_svelte_type_style_lang = "", FilterField_svelte_svelte_type_style_lang = "", ConditionField_svelte_svelte_type_style_lang = "", CoreFilterBuilder_svelte_svelte_type_style_lang = "", enrichDataBindings = (u, l) => processObjectSync(cloneDeep$5(u), l, { cache: !0 });
var download$1 = { exports: {} };
(function(u, l) {
  (function(f, p) {
    u.exports = p();
  })(commonjsGlobal$1, function() {
    return function f(p, m, b) {
      var y = window, v = "application/octet-stream", k = b || v, S = p, $ = !m && !b && S, w = document.createElement("a"), T = function(D) {
        return String(D);
      }, E = y.Blob || y.MozBlob || y.WebKitBlob || T, R = m || "download", O, P;
      if (E = E.call ? E.bind(y) : Blob, String(this) === "true" && (S = [S, k], k = S[0], S = S[1]), $ && $.length < 2048 && (R = $.split("/").pop().split("?")[0], w.href = $, w.href.indexOf($) !== -1)) {
        var L = new XMLHttpRequest();
        return L.open("GET", $, !0), L.responseType = "blob", L.onload = function(D) {
          f(D.target.response, R, v);
        }, setTimeout(function() {
          L.send();
        }, 0), L;
      }
      if (/^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(S))
        if (S.length > 1024 * 1024 * 1.999 && E !== T)
          S = x(S), k = S.type || v;
        else
          return navigator.msSaveBlob ? (
            // IE10 can't do a[download], only Blobs:
            navigator.msSaveBlob(x(S), R)
          ) : N(S);
      else if (/([\x80-\xff])/.test(S)) {
        var M = 0, B = new Uint8Array(S.length), j = B.length;
        for (M; M < j; ++M)
          B[M] = S.charCodeAt(M);
        S = new E([B], { type: k });
      }
      O = S instanceof E ? S : new E([S], { type: k });
      function x(D) {
        var V = D.split(/[:;,]/), W = V[1], F = V[2] == "base64" ? atob : decodeURIComponent, U = F(V.pop()), Y = U.length, q = 0, Q = new Uint8Array(Y);
        for (q; q < Y; ++q)
          Q[q] = U.charCodeAt(q);
        return new E([Q], { type: W });
      }
      function N(D, V) {
        if ("download" in w)
          return w.href = D, w.setAttribute("download", R), w.className = "download-js-link", w.innerHTML = "downloading...", w.style.display = "none", document.body.appendChild(w), setTimeout(function() {
            w.click(), document.body.removeChild(w), V === !0 && setTimeout(function() {
              y.URL.revokeObjectURL(w.href);
            }, 250);
          }, 66), !0;
        if (/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent))
          return /^data:/.test(D) && (D = "data:" + D.replace(/^data:([\w\/\-\+]+)/, v)), window.open(D) || confirm(`Displaying New Document

Use Save As... to download, then click back to return to this page.`) && (location.href = D), !0;
        var W = document.createElement("iframe");
        document.body.appendChild(W), !V && /^data:/.test(D) && (D = "data:" + D.replace(/^data:([\w\/\-\+]+)/, v)), W.src = D, setTimeout(function() {
          document.body.removeChild(W);
        }, 333);
      }
      if (navigator.msSaveBlob)
        return navigator.msSaveBlob(O, R);
      if (y.URL)
        N(y.URL.createObjectURL(O), !0);
      else {
        if (typeof O == "string" || O.constructor === T)
          try {
            return N("data:" + k + ";base64," + y.btoa(O));
          } catch {
            return N("data:" + k + "," + encodeURIComponent(O));
          }
        P = new FileReader(), P.onload = function(D) {
          N(this.result);
        }, P.readAsDataURL(O);
      }
      return !0;
    };
  });
})(download$1);
var downloadExports = download$1.exports;
const download = /* @__PURE__ */ getDefaultExportFromCjs$1(downloadExports), API = createAPIClient({
  // Enable caching of cacheable endpoints to speed things up,
  enableCaching: !0,
  // Attach client specific headers
  attachHeaders: (u) => {
    window["##BUDIBASE_APP_ID##"] && (u["x-budibase-app-id"] = window["##BUDIBASE_APP_ID##"]), get_store_value(appStore).embedded && (u["x-budibase-embed-location"] = window.location.pathname), window["##BUDIBASE_IN_BUILDER##"] || (u["x-budibase-type"] = "client");
    const f = get_store_value(authStore);
    f != null && f.csrfToken && (u["x-csrf-token"] = f.csrfToken);
    const p = get_store_value(devToolsStore);
    get_store_value(devToolsEnabled) && p.role && (u["x-budibase-role"] = p.role);
  },
  // Show an error notification for all API failures.
  // We could also log these to Posthog.
  // Or we could check error.status and redirect to login on a 403 etc.
  onError: (u) => {
    var k;
    const { status: l, method: f, url: p, message: m, handled: b, suppressErrors: y } = u || {}, v = [
      "bbtel",
      "/api/global/self",
      "/api/tables/ta_users"
    ];
    if (l === 498) {
      recaptchaStore.actions.unverified();
      return;
    }
    if (!b) {
      console.error("Unhandled error from API client", u);
      return;
    }
    if (m && !y) {
      let S = !1;
      for (let $ of v)
        if (p != null && p.includes($)) {
          S = !0;
          break;
        }
      if (!S) {
        const $ = (k = u == null ? void 0 : u.json) == null ? void 0 : k.validationErrors;
        if ($)
          for (let w in $)
            notificationStore.actions.error(
              `${w} ${$[w]}`
            );
        else
          notificationStore.actions.error(m);
      }
    }
    console.warn(`[Client] HTTP ${l} on ${f}:${p}
	${m}`);
  },
  onMigrationDetected: (u) => {
    window.MIGRATING_APP || window.location.reload();
  }
}), ActionTypes = {
  ValidateForm: "ValidateForm",
  UpdateFieldValue: "UpdateFieldValue",
  RefreshDatasource: "RefreshDatasource",
  AddDataProviderQueryExtension: "AddDataProviderQueryExtension",
  RemoveDataProviderQueryExtension: "RemoveDataProviderQueryExtension",
  AddDataProviderFilterExtension: "AddDataProviderFilterExtension",
  RemoveDataProviderFilterExtension: "RemoveDataProviderFilterExtension",
  SetDataProviderSorting: "SetDataProviderSorting",
  ClearForm: "ClearForm",
  ChangeFormStep: "ChangeFormStep",
  ScrollTo: "ScrollTo",
  ClearRowSelection: "ClearRowSelection"
}, PeekMessages = {
  NOTIFICATION: "notification",
  CLOSE_SCREEN_MODAL: "close-screen-modal",
  INVALIDATE_DATASOURCE: "invalidate-datasource",
  UPDATE_STATE: "update-state",
  REFRESH_ALL_DATASOURCES: "refresh-all-datasources"
}, DNDPlaceholderID = "dnd-placeholder", ScreenslotType = "screenslot", ScreenslotID = "screenslot", GridRowHeight = 24, GridColumns = 12, GridSpacing = 4, patchAPI = (u) => {
  const l = async (k, S) => {
    var $;
    if (!Array.isArray(k))
      return [];
    if (k.length) {
      const w = {};
      for (let T of k) {
        let E = T.tableId || S, R = w[E];
        R || (R = await u.fetchTableDefinition(E), w[E] = R);
        const O = R == null ? void 0 : R.schema;
        if (O) {
          const P = Object.keys(O);
          for (let L of P) {
            const M = O[L].type;
            if (M === FieldType.LINK && Array.isArray(T[L]))
              T[`${L}_text`] = (($ = T[L]) == null ? void 0 : $.map((B) => B == null ? void 0 : B.primaryDisplay).filter((B) => !!B).join(", ")) || "";
            else if (M === "attachment") {
              let B = null;
              Array.isArray(T[L]) && T[L][0] != null && (B = T[L][0].url), T[`${L}_first`] = B;
            }
          }
        }
      }
    }
    return k;
  }, f = u.fetchSelf;
  u.fetchSelf = async () => {
    const k = await f();
    return k && "_id" in k && k._id ? k.roleId === "PUBLIC" ? k : (await l([k], TableNames.USERS))[0] : null;
  };
  const p = u.fetchRelationshipData;
  u.fetchRelationshipData = async (k, S, $) => {
    const w = await p(k, S, $);
    return await l(w, k);
  };
  const m = u.fetchTableData;
  u.fetchTableData = async (k) => {
    const S = await m(k);
    return await l(S, k);
  };
  const b = u.searchTable;
  u.searchTable = async (k, S) => {
    const $ = await b(k, S);
    return {
      ...$,
      rows: await l($.rows, k)
    };
  };
  const y = u.fetchViewData;
  u.fetchViewData = async (k, S) => {
    const $ = S == null ? void 0 : S.tableId, w = await y(k, S);
    return await l(w, $);
  };
  const v = u.fetchTableDefinition;
  u.fetchTableDefinition = async (k) => {
    const S = await v(k);
    return Object.keys((S == null ? void 0 : S.schema) || {}).forEach(($) => {
      var w;
      ((w = S.schema[$]) == null ? void 0 : w.type) === "formula" && delete S.schema[$].formula;
    }), S;
  };
};
patchAPI(API);
const createAuthStore = () => {
  const u = writable(), l = (m) => m != null && "_id" in m, f = async () => {
    let m, b;
    try {
      m = await API.fetchBuilderSelf();
    } catch {
      u.set(void 0);
      return;
    }
    try {
      const y = await API.fetchSelf();
      l(y) && (b = y);
    } catch {
    }
    u.set(b || m);
  }, p = async () => {
    try {
      await API.logOut(), window.location.href = "/";
    } catch {
    }
    window.document.cookie = "budibase:auth=; budibase:currentapp=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;";
  };
  return {
    subscribe: u.subscribe,
    actions: { fetchUser: f, logOut: p }
  };
}, authStore = createAuthStore(), initialState$4 = {
  appId: null,
  isDevApp: !1,
  clientLoadTime: window.INIT_TIME ? Date.now() - window.INIT_TIME : null,
  embedded: !1,
  inIframe: window.self !== window.top
}, createAppStore = () => {
  const u = writable(initialState$4), l = derived(u, (b) => {
    var y;
    return {
      ...b,
      isDevApp: (y = b.appId) == null ? void 0 : y.startsWith("app_dev")
    };
  }), f = async () => {
    var y, v;
    const b = (y = get_store_value(u)) == null ? void 0 : y.appId;
    if (!b)
      throw "Cannot fetch app definition without app ID set";
    try {
      const k = await API.fetchAppPackage(b);
      u.set({
        ...initialState$4,
        ...k,
        appId: (v = k == null ? void 0 : k.application) == null ? void 0 : v.appId
      });
    } catch {
      u.set(initialState$4);
    }
  }, p = (b) => {
    u.update((y) => ({ ...y, appId: b }));
  }, m = (b) => {
    u.update((y) => ({ ...y, embedded: b }));
  };
  return {
    subscribe: l.subscribe,
    actions: { setAppId: p, setAppEmbedded: m, fetchAppDefinition: f }
  };
}, appStore = createAppStore();
function parse(u, l) {
  if (u instanceof RegExp)
    return { keys: !1, pattern: u };
  var f, p, m, b, y = [], v = "", k = u.split("/");
  for (k[0] || k.shift(); m = k.shift(); )
    f = m[0], f === "*" ? (y.push("wild"), v += "/(.*)") : f === ":" ? (p = m.indexOf("?", 1), b = m.indexOf(".", 1), y.push(m.substring(1, ~p ? p : ~b ? b : m.length)), v += ~p && !~b ? "(?:/([^/]+?))?" : "/([^/]+?)", ~b && (v += (~p ? "?" : "") + "\\" + m.substring(b))) : v += "/" + m;
  return {
    keys: y,
    pattern: new RegExp("^" + v + (l ? "(?=$|/)" : "/?$"), "i")
  };
}
function create_else_block$4(u) {
  let l, f, p;
  const m = [
    /*props*/
    u[2]
  ];
  var b = (
    /*component*/
    u[0]
  );
  function y(v, k) {
    let S = {};
    for (let $ = 0; $ < m.length; $ += 1)
      S = assign(S, m[$]);
    return k !== void 0 && k & /*props*/
    4 && (S = assign(S, get_spread_update(m, [get_spread_object(
      /*props*/
      v[2]
    )]))), { props: S };
  }
  return b && (l = construct_svelte_component(b, y(u)), l.$on(
    "routeEvent",
    /*routeEvent_handler_1*/
    u[7]
  )), {
    c() {
      l && create_component(l.$$.fragment), f = empty$1();
    },
    m(v, k) {
      l && mount_component(l, v, k), insert(v, f, k), p = !0;
    },
    p(v, k) {
      if (k & /*component*/
      1 && b !== (b = /*component*/
      v[0])) {
        if (l) {
          group_outros();
          const S = l;
          transition_out(S.$$.fragment, 1, 0, () => {
            destroy_component(S, 1);
          }), check_outros();
        }
        b ? (l = construct_svelte_component(b, y(v, k)), l.$on(
          "routeEvent",
          /*routeEvent_handler_1*/
          v[7]
        ), create_component(l.$$.fragment), transition_in(l.$$.fragment, 1), mount_component(l, f.parentNode, f)) : l = null;
      } else if (b) {
        const S = k & /*props*/
        4 ? get_spread_update(m, [get_spread_object(
          /*props*/
          v[2]
        )]) : {};
        l.$set(S);
      }
    },
    i(v) {
      p || (l && transition_in(l.$$.fragment, v), p = !0);
    },
    o(v) {
      l && transition_out(l.$$.fragment, v), p = !1;
    },
    d(v) {
      v && detach(f), l && destroy_component(l, v);
    }
  };
}
function create_if_block$m(u) {
  let l, f, p;
  const m = [
    { params: (
      /*componentParams*/
      u[1]
    ) },
    /*props*/
    u[2]
  ];
  var b = (
    /*component*/
    u[0]
  );
  function y(v, k) {
    let S = {};
    for (let $ = 0; $ < m.length; $ += 1)
      S = assign(S, m[$]);
    return k !== void 0 && k & /*componentParams, props*/
    6 && (S = assign(S, get_spread_update(m, [
      k & /*componentParams*/
      2 && { params: (
        /*componentParams*/
        v[1]
      ) },
      k & /*props*/
      4 && get_spread_object(
        /*props*/
        v[2]
      )
    ]))), { props: S };
  }
  return b && (l = construct_svelte_component(b, y(u)), l.$on(
    "routeEvent",
    /*routeEvent_handler*/
    u[6]
  )), {
    c() {
      l && create_component(l.$$.fragment), f = empty$1();
    },
    m(v, k) {
      l && mount_component(l, v, k), insert(v, f, k), p = !0;
    },
    p(v, k) {
      if (k & /*component*/
      1 && b !== (b = /*component*/
      v[0])) {
        if (l) {
          group_outros();
          const S = l;
          transition_out(S.$$.fragment, 1, 0, () => {
            destroy_component(S, 1);
          }), check_outros();
        }
        b ? (l = construct_svelte_component(b, y(v, k)), l.$on(
          "routeEvent",
          /*routeEvent_handler*/
          v[6]
        ), create_component(l.$$.fragment), transition_in(l.$$.fragment, 1), mount_component(l, f.parentNode, f)) : l = null;
      } else if (b) {
        const S = k & /*componentParams, props*/
        6 ? get_spread_update(m, [
          k & /*componentParams*/
          2 && { params: (
            /*componentParams*/
            v[1]
          ) },
          k & /*props*/
          4 && get_spread_object(
            /*props*/
            v[2]
          )
        ]) : {};
        l.$set(S);
      }
    },
    i(v) {
      p || (l && transition_in(l.$$.fragment, v), p = !0);
    },
    o(v) {
      l && transition_out(l.$$.fragment, v), p = !1;
    },
    d(v) {
      v && detach(f), l && destroy_component(l, v);
    }
  };
}
function create_fragment$J(u) {
  let l, f, p, m;
  const b = [create_if_block$m, create_else_block$4], y = [];
  function v(k, S) {
    return (
      /*componentParams*/
      k[1] ? 0 : 1
    );
  }
  return l = v(u), f = y[l] = b[l](u), {
    c() {
      f.c(), p = empty$1();
    },
    m(k, S) {
      y[l].m(k, S), insert(k, p, S), m = !0;
    },
    p(k, [S]) {
      let $ = l;
      l = v(k), l === $ ? y[l].p(k, S) : (group_outros(), transition_out(y[$], 1, 1, () => {
        y[$] = null;
      }), check_outros(), f = y[l], f ? f.p(k, S) : (f = y[l] = b[l](k), f.c()), transition_in(f, 1), f.m(p.parentNode, p));
    },
    i(k) {
      m || (transition_in(f), m = !0);
    },
    o(k) {
      transition_out(f), m = !1;
    },
    d(k) {
      k && detach(p), y[l].d(k);
    }
  };
}
function getLocation() {
  const u = window.location.href.indexOf("#/");
  let l = u > -1 ? window.location.href.substr(u + 1) : "/";
  const f = l.indexOf("?");
  let p = "";
  return f > -1 && (p = l.substr(f + 1), l = l.substr(0, f)), { location: l, querystring: p };
}
const loc = readable(
  null,
  // eslint-disable-next-line prefer-arrow-callback
  function u(l) {
    l(getLocation());
    const f = () => {
      l(getLocation());
    };
    return window.addEventListener("hashchange", f, !1), function() {
      window.removeEventListener("hashchange", f, !1);
    };
  }
);
derived(loc, (u) => u.location);
const querystring = derived(loc, (u) => u.querystring), params = writable(void 0);
async function push(u) {
  if (!u || u.length < 1 || u.charAt(0) != "/" && u.indexOf("#/") !== 0)
    throw Error("Invalid parameter location");
  await tick(), history.replaceState(
    {
      ...history.state,
      __svelte_spa_router_scrollX: window.scrollX,
      __svelte_spa_router_scrollY: window.scrollY
    },
    void 0
  ), window.location.hash = (u.charAt(0) == "#" ? "" : "#") + u;
}
function link$2(u, l) {
  if (l = linkOpts(l), !u || !u.tagName || u.tagName.toLowerCase() != "a")
    throw Error('Action "link" can only be used with <a> tags');
  return updateLink(u, l), {
    update(f) {
      f = linkOpts(f), updateLink(u, f);
    }
  };
}
function restoreScroll(u) {
  u ? window.scrollTo(u.__svelte_spa_router_scrollX, u.__svelte_spa_router_scrollY) : window.scrollTo(0, 0);
}
function updateLink(u, l) {
  let f = l.href || u.getAttribute("href");
  if (f && f.charAt(0) == "/")
    f = "#" + f;
  else if (!f || f.length < 2 || f.slice(0, 2) != "#/")
    throw Error('Invalid value for "href" attribute: ' + f);
  u.setAttribute("href", f), u.addEventListener("click", (p) => {
    p.preventDefault(), l.disabled || scrollstateHistoryHandler(p.currentTarget.getAttribute("href"));
  });
}
function linkOpts(u) {
  return u && typeof u == "string" ? { href: u } : u || {};
}
function scrollstateHistoryHandler(u) {
  history.replaceState(
    {
      ...history.state,
      __svelte_spa_router_scrollX: window.scrollX,
      __svelte_spa_router_scrollY: window.scrollY
    },
    void 0
  ), window.location.hash = u;
}
function instance$H(u, l, f) {
  let { routes: p = {} } = l, { prefix: m = "" } = l, { restoreScrollState: b = !1 } = l;
  class y {
    /**
    * Initializes the object and creates a regular expression from the path, using regexparam.
    *
    * @param {string} path - Path to the route (must start with '/' or '*')
    * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
    */
    constructor(x, N) {
      if (!N || typeof N != "function" && (typeof N != "object" || N._sveltesparouter !== !0))
        throw Error("Invalid component object");
      if (!x || typeof x == "string" && (x.length < 1 || x.charAt(0) != "/" && x.charAt(0) != "*") || typeof x == "object" && !(x instanceof RegExp))
        throw Error('Invalid value for "path" argument - strings must start with / or *');
      const { pattern: D, keys: V } = parse(x);
      this.path = x, typeof N == "object" && N._sveltesparouter === !0 ? (this.component = N.component, this.conditions = N.conditions || [], this.userData = N.userData, this.props = N.props || {}) : (this.component = () => Promise.resolve(N), this.conditions = [], this.props = {}), this._pattern = D, this._keys = V;
    }
    /**
    * Checks if `path` matches the current route.
    * If there's a match, will return the list of parameters from the URL (if any).
    * In case of no match, the method will return `null`.
    *
    * @param {string} path - Path to test
    * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
    */
    match(x) {
      if (m) {
        if (typeof m == "string")
          if (x.startsWith(m))
            x = x.substr(m.length) || "/";
          else
            return null;
        else if (m instanceof RegExp) {
          const W = x.match(m);
          if (W && W[0])
            x = x.substr(W[0].length) || "/";
          else
            return null;
        }
      }
      const N = this._pattern.exec(x);
      if (N === null)
        return null;
      if (this._keys === !1)
        return N;
      const D = {};
      let V = 0;
      for (; V < this._keys.length; ) {
        try {
          D[this._keys[V]] = decodeURIComponent(N[V + 1] || "") || null;
        } catch {
          D[this._keys[V]] = null;
        }
        V++;
      }
      return D;
    }
    /**
    * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
    * @typedef {Object} RouteDetail
    * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
    * @property {string} location - Location path
    * @property {string} querystring - Querystring from the hash
    * @property {object} [userData] - Custom data passed by the user
    * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
    * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
    */
    /**
    * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
    * 
    * @param {RouteDetail} detail - Route detail
    * @returns {boolean} Returns true if all the conditions succeeded
    */
    async checkConditions(x) {
      for (let N = 0; N < this.conditions.length; N++)
        if (!await this.conditions[N](x))
          return !1;
      return !0;
    }
  }
  const v = [];
  p instanceof Map ? p.forEach((j, x) => {
    v.push(new y(x, j));
  }) : Object.keys(p).forEach((j) => {
    v.push(new y(j, p[j]));
  });
  let k = null, S = null, $ = {};
  const w = createEventDispatcher();
  async function T(j, x) {
    await tick(), w(j, x);
  }
  let E = null, R = null;
  b && (R = (j) => {
    j.state && (j.state.__svelte_spa_router_scrollY || j.state.__svelte_spa_router_scrollX) ? E = j.state : E = null;
  }, window.addEventListener("popstate", R), afterUpdate(() => {
    restoreScroll(E);
  }));
  let O = null, P = null;
  const L = loc.subscribe(async (j) => {
    O = j;
    let x = 0;
    for (; x < v.length; ) {
      const N = v[x].match(j.location);
      if (!N) {
        x++;
        continue;
      }
      const D = {
        route: v[x].path,
        location: j.location,
        querystring: j.querystring,
        userData: v[x].userData,
        params: N && typeof N == "object" && Object.keys(N).length ? N : null
      };
      if (!await v[x].checkConditions(D)) {
        f(0, k = null), P = null, T("conditionsFailed", D);
        return;
      }
      T("routeLoading", Object.assign({}, D));
      const V = v[x].component;
      if (P != V) {
        V.loading ? (f(0, k = V.loading), P = V, f(1, S = V.loadingParams), f(2, $ = {}), T("routeLoaded", Object.assign({}, D, {
          component: k,
          name: k.name,
          params: S
        }))) : (f(0, k = null), P = null);
        const W = await V();
        if (j != O)
          return;
        f(0, k = W && W.default || W), P = V;
      }
      N && typeof N == "object" && Object.keys(N).length ? f(1, S = N) : f(1, S = null), f(2, $ = v[x].props), T("routeLoaded", Object.assign({}, D, {
        component: k,
        name: k.name,
        params: S
      })).then(() => {
        params.set(S);
      });
      return;
    }
    f(0, k = null), P = null, params.set(void 0);
  });
  onDestroy(() => {
    L(), R && window.removeEventListener("popstate", R);
  });
  function M(j) {
    bubble.call(this, u, j);
  }
  function B(j) {
    bubble.call(this, u, j);
  }
  return u.$$set = (j) => {
    "routes" in j && f(3, p = j.routes), "prefix" in j && f(4, m = j.prefix), "restoreScrollState" in j && f(5, b = j.restoreScrollState);
  }, u.$$.update = () => {
    u.$$.dirty & /*restoreScrollState*/
    32 && (history.scrollRestoration = b ? "manual" : "auto");
  }, [
    k,
    S,
    $,
    p,
    m,
    b,
    M,
    B
  ];
}
class Router extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$H, create_fragment$J, safe_not_equal, {
      routes: 3,
      prefix: 4,
      restoreScrollState: 5
    });
  }
}
const createStateStore = () => {
  const l = `${window["##BUDIBASE_APP_ID##"] || "app"}.state`, f = createLocalStorageStore(l, {}), p = writable(get_store_value(f)), m = (k, S, $ = !1) => {
    const w = $ ? f : p, T = $ ? p : f;
    w.update((E) => (E[k] = S, E)), T.update((E) => (delete E[k], E));
  }, b = (k) => {
    [p, f].forEach(($) => {
      $.update((w) => (delete w[k], w));
    });
  }, y = p.set;
  return {
    subscribe: derived(
      [p, f],
      ([k, S]) => ({
        ...k,
        ...S
      })
    ).subscribe,
    actions: { setValue: m, deleteValue: b, initialise: y }
  };
}, stateStore = createStateStore(), initialState$3 = {
  showPeek: !1,
  url: null,
  href: null,
  external: !1
}, createPeekStore = () => {
  const u = writable(initialState$3), l = (p) => {
    let m = p, b = !p.startsWith("/");
    if (!b) {
      const y = get_store_value(stateStore), k = `peek=true&state=${encodeURIComponent(btoa(JSON.stringify(y)))}`;
      m = `${window.location.href.split("#")[0]}#${p}?${k}`;
    }
    u.set({
      showPeek: !0,
      url: p,
      href: m,
      external: b
    });
  }, f = () => {
    u.set(initialState$3);
  };
  return {
    subscribe: u.subscribe,
    actions: { showPeek: l, hidePeek: f }
  };
}, peekStore = createPeekStore(), createOrgStore = () => {
  const u = writable(null), { subscribe: l, set: f } = u;
  async function p() {
    var b;
    const m = (b = get_store_value(appStore).application) == null ? void 0 : b.tenantId;
    if (m)
      try {
        const y = await API.getTenantConfig(m);
        f({ logoUrl: y.config.logoUrl });
      } catch (y) {
        console.error("Could not init org ", y);
      }
  }
  return {
    subscribe: l,
    actions: {
      init: p
    }
  };
}, orgStore = createOrgStore(), createRecaptchaStore = () => {
  const u = writable({ verified: !1 }), l = async () => {
    const { verified: p } = await API.recaptcha.check();
    u.update((m) => (m.verified = p, m));
  }, f = () => {
    u.update((p) => (p.verified = !1, p));
  };
  return {
    subscribe: u.subscribe,
    actions: { checkVerified: l, unverified: f }
  };
}, recaptchaStore = createRecaptchaStore();
async function initialise() {
  await routeStore.actions.fetchRoutes(), await appStore.actions.fetchAppDefinition(), get_store_value(appStore).recaptchaKey && await recaptchaStore.actions.checkVerified(), await orgStore.actions.init();
}
const initialState$2 = {
  visible: !1,
  allowSelection: !1,
  role: null
}, createDevToolStore = () => {
  const u = createLocalStorageStore("bb-devtools", initialState$2), l = (m) => {
    u.update((b) => ({
      ...b,
      visible: m
    }));
  }, f = (m) => {
    u.update((b) => ({
      ...b,
      allowSelection: m
    }));
  }, p = async (m) => {
    m === "self" && (m = null), m !== get_store_value(u).role && (u.update((b) => ({
      ...b,
      role: m
    })), API.invalidateCache(), await authStore.actions.fetchUser(), await initialise());
  };
  return {
    subscribe: u.subscribe,
    actions: { setVisible: l, setAllowSelection: f, changeRole: p }
  };
}, devToolsStore = createDevToolStore(), createEventStore = () => {
  const l = writable({
    eventResolvers: {}
  }), f = {
    dispatchEvent: (p, m) => {
      const b = Math.random();
      return new Promise((y) => {
        window.parent.postMessage({ type: p, data: m, id: b }), l.update((v) => (v.eventResolvers[b] = y, v));
      });
    },
    resolveEvent: (p) => {
      var m, b;
      (b = (m = get_store_value(l).eventResolvers)[p]) == null || b.call(m);
    }
  };
  return {
    subscribe: l.subscribe,
    actions: f
  };
}, eventStore = createEventStore(), createBuilderStore = () => {
  const u = {
    inBuilder: !1,
    screen: null,
    selectedComponentId: void 0,
    editMode: !1,
    previewId: null,
    theme: null,
    customTheme: null,
    previewDevice: "desktop",
    navigation: null,
    hiddenComponentIds: [],
    usedPlugins: null,
    metadata: null,
    snippets: null,
    componentErrors: {}
  }, l = writable(u);
  return {
    ...l,
    set: (p) => l.set({ ...u, ...p }),
    actions: {
      selectComponent: (p) => {
        p !== get_store_value(l).selectedComponentId && (l.update((m) => ({
          ...m,
          editMode: !1,
          selectedComponentId: p
        })), devToolsStore.actions.setAllowSelection(!1), eventStore.actions.dispatchEvent("select-component", { id: p }));
      },
      updateProp: (p, m) => {
        eventStore.actions.dispatchEvent("update-prop", { prop: p, value: m });
      },
      updateStyles: async (p, m) => {
        await eventStore.actions.dispatchEvent("update-styles", {
          styles: p,
          id: m
        });
      },
      keyDown: (p, m) => {
        eventStore.actions.dispatchEvent("key-down", { key: p, ctrlKey: m });
      },
      duplicateComponent: (p, m = DropPosition.BELOW, b = !0) => {
        eventStore.actions.dispatchEvent("duplicate-component", {
          id: p,
          mode: m,
          selectComponent: b
        });
      },
      deleteComponent: (p) => {
        eventStore.actions.dispatchEvent("delete-component", { id: p });
      },
      notifyLoaded: () => {
        eventStore.actions.dispatchEvent("preview-loaded");
      },
      analyticsPing: async ({ embedded: p }) => {
        try {
          await API.analyticsPing({ source: PingSource.APP, embedded: p });
        } catch {
        }
      },
      moveComponent: async (p, m, b) => {
        await eventStore.actions.dispatchEvent("move-component", {
          componentId: p,
          destinationComponentId: m,
          mode: b
        });
      },
      dropNewComponent: (p, m, b, y) => {
        eventStore.actions.dispatchEvent("drop-new-component", {
          component: p,
          parent: m,
          index: b,
          props: y
        });
      },
      setEditMode: (p) => {
        p !== get_store_value(l).editMode && l.update((m) => ({ ...m, editMode: p }));
      },
      requestAddComponent: () => {
        eventStore.actions.dispatchEvent("request-add-component");
      },
      highlightSetting: (p) => {
        eventStore.actions.dispatchEvent("highlight-setting", { setting: p });
      },
      ejectBlock: (p, m) => {
        eventStore.actions.dispatchEvent("eject-block", { id: p, definition: m });
      },
      updateUsedPlugin: (p, m) => {
        var y, v;
        const b = (v = (y = get_store_value(l)) == null ? void 0 : y.usedPlugins) == null ? void 0 : v.find((k) => k.name === p);
        b && l.update((k) => (k.usedPlugins = k.usedPlugins.filter((S) => S.name !== p), k.usedPlugins.push({
          ...b,
          hash: m
        }), k)), eventStore.actions.dispatchEvent("reload-plugin");
      },
      addParentComponent: (p, m) => {
        eventStore.actions.dispatchEvent("add-parent-component", {
          componentId: p,
          parentType: m
        });
      },
      setMetadata: (p) => {
        l.update((m) => ({
          ...m,
          metadata: p
        }));
      }
    }
  };
}, builderStore = createBuilderStore(), createRouteStore = () => {
  const u = {
    routes: [],
    routeParams: {},
    activeRoute: null,
    routeSessionId: Math.random(),
    routerLoaded: !1,
    queryParams: {}
  }, l = writable(u), f = async () => {
    let $;
    try {
      $ = await API.fetchClientAppRoutes();
    } catch {
      $ = null;
    }
    const w = [];
    Object.values(($ == null ? void 0 : $.routes) || {}).forEach((T) => {
      Object.entries(T.subpaths || {}).forEach(([E, R]) => {
        w.push({
          path: E,
          screenId: R.screenId
        });
      });
    }), w.sort((T, E) => T.path > E.path ? -1 : 1), l.update((T) => (T.routes = w, T.routeSessionId = Math.random(), T));
  }, p = ($) => {
    l.update((w) => (w.routeParams = $, w));
  }, m = ($) => {
    l.update((w) => {
      var T;
      return w.queryParams = {
        ...$,
        // Never unset the peek param - screen peek modals should always be
        // in a peek state, even if they navigate to a different page
        peek: $.peek || ((T = w.queryParams) == null ? void 0 : T.peek)
      }, w;
    });
  }, b = ($) => {
    l.update((w) => (w.activeRoute = w.routes.find((T) => T.path === $), w));
  }, y = ($, w, T) => {
    var E;
    if (!get_store_value(builderStore).inBuilder && $) {
      const R = (E = get_store_value(l).queryParams) == null ? void 0 : E.peek, O = !$.startsWith("/");
      w && !R && !O ? peekStore.actions.showPeek($) : O ? ($.startsWith("www") && ($ = `https://${$}`), T ? window.open($, "_blank") : window.location.href = $) : push($);
    }
  }, v = () => {
    l.update(($) => ({ ...$, routerLoaded: !0 }));
  }, k = ($) => $ != null && $.startsWith("/") ? window.location.href.includes("#") ? `${window.location.href.split("#")[0]}#${$}` : `${window.location.href}#${$}` : $, S = ($, w) => {
    var j;
    if ($ === "/")
      return;
    const [T, E] = w.split("?"), R = $.split("/").filter(Boolean), O = (j = R[0]) != null && j.startsWith(":") ? 0 : 1, P = R.slice(O), L = T.split("/"), M = {};
    P.forEach((x, N) => {
      x.startsWith(":") && N < L.length && (M[x.slice(1)] = L[N]);
    });
    const B = {};
    E && E.split("&").forEach((x) => {
      const [N, D] = x.split("=");
      N && D && (B[N] = D);
    }), m({ ...B }), l.update((x) => ({ ...x, testUrlParams: M }));
  };
  return {
    subscribe: l.subscribe,
    actions: {
      fetchRoutes: f,
      navigate: y,
      createFullURL: k,
      setRouteParams: p,
      setQueryParams: m,
      setActiveRoute: b,
      setRouterLoaded: v,
      setTestUrlParams: S
    }
  };
}, routeStore = createRouteStore(), DEFAULT_NOTIFICATION_TIMEOUT = 3e3, createNotificationStore = () => {
  let u = !1;
  const l = writable([]), f = (y = 1e3) => {
    u = !0, setTimeout(() => u = !1, y);
  }, p = (y, v = "info", k, S = !0, $, w = 1) => {
    var E;
    if (u)
      return;
    if ((E = get_store_value(routeStore).queryParams) != null && E.peek) {
      window.parent.postMessage({
        type: PeekMessages.NOTIFICATION,
        detail: {
          message: y,
          type: v,
          icon: k,
          duration: $,
          autoDismiss: S
        }
      });
      return;
    }
    const T = b();
    l.update((R) => {
      const O = R.find((P) => P.message === y);
      return O ? (O.count += 1, [...R]) : [
        ...R,
        {
          id: T,
          type: v,
          message: y,
          icon: k,
          dismissable: !S,
          delay: get_store_value(l) != null,
          count: w
        }
      ];
    }), S && setTimeout(() => {
      m(T);
    }, $ || DEFAULT_NOTIFICATION_TIMEOUT);
  }, m = (y) => {
    l.update((v) => v.filter((k) => k.id !== y));
  };
  return {
    subscribe: l.subscribe,
    actions: {
      send: p,
      info: (y, v, k) => p(y, "info", "info", v ?? !0, k),
      success: (y, v, k) => p(y, "success", "check-circle", v ?? !0, k),
      warning: (y, v, k) => p(y, "warning", "warning", v ?? !0, k),
      error: (y, v, k) => p(y, "error", "warning", v ?? !1, k),
      blockNotifications: f,
      dismiss: m
    }
  };
  function b() {
    return "_" + Math.random().toString(36).slice(2, 9);
  }
}, notificationStore = createNotificationStore(), createDndStore = () => {
  const u = writable({}), l = (v) => {
    u.set({
      source: {
        ...v,
        isNew: !1
      }
    });
  }, f = (v) => {
    var E, R, O, P, L;
    let k, S;
    if (get_store_value(isGridScreen)) {
      const M = (E = get_store_value(screenStore)) == null ? void 0 : E.activeScreen, B = M.props._id;
      k = {
        id: B,
        parent: ScreenslotID,
        empty: !1,
        acceptsChildren: !0
      }, S = {
        parent: B,
        index: ((O = (R = M == null ? void 0 : M.props) == null ? void 0 : R._children) == null ? void 0 : O.length) || 0
      };
    }
    const $ = componentStore.actions.getComponentDefinition(v), w = ((P = $ == null ? void 0 : $.size) == null ? void 0 : P.width) || 128, T = ((L = $ == null ? void 0 : $.size) == null ? void 0 : L.height) || 64;
    u.set({
      source: {
        bounds: { height: T, width: w },
        type: v,
        isNew: !0,
        name: `New ${($ == null ? void 0 : $.name) || "component"}`,
        icon: ($ == null ? void 0 : $.icon) || "selection"
      },
      target: k,
      drop: S
    });
  }, p = (v) => {
    u.update((k) => (k.target = v, k));
  }, m = (v) => {
    u.update((k) => (k.drop = v, k));
  }, b = () => {
    u.set({});
  }, y = (v) => {
    u.update((k) => ({
      ...k,
      meta: {
        ...k.meta,
        props: v
      }
    }));
  };
  return {
    subscribe: u.subscribe,
    actions: {
      startDraggingExistingComponent: l,
      startDraggingNewComponent: f,
      updateTarget: p,
      updateDrop: m,
      reset: b,
      updateNewComponentProps: y
    }
  };
}, dndStore = createDndStore(), dndParent = derivedMemo(dndStore, (u) => {
  var l;
  return (l = u.drop) == null ? void 0 : l.parent;
}), dndIndex = derivedMemo(dndStore, (u) => {
  var l;
  return (l = u.drop) == null ? void 0 : l.index;
}), dndSource = derivedMemo(dndStore, (u) => u.source), dndIsDragging = derivedMemo(dndStore, (u) => !!u.source), findComponentById = (u, l) => {
  var f;
  if (!u || !l)
    return null;
  if (u._id === l)
    return u;
  if (!((f = u._children) != null && f.length))
    return null;
  for (let p of u._children) {
    const m = findComponentById(p, l);
    if (m)
      return m;
  }
  return null;
}, findComponentPathById = (u, l, f = []) => {
  var p;
  if (!u || !l)
    return null;
  if (f = [...f, u], u._id === l)
    return f;
  if (!((p = u._children) != null && p.length))
    return null;
  for (let m of u._children) {
    const b = findComponentPathById(m, l, f);
    if (b)
      return b;
  }
  return null;
}, findComponentParent = (u, l, f) => {
  if (!u || !l)
    return null;
  if (u._id === l)
    return f || null;
  if (!u._children)
    return null;
  for (const p of u._children) {
    const m = findComponentParent(p, l, u);
    if (m)
      return m;
  }
  return null;
}, createScreenStore = () => ({
  subscribe: derived(
    [
      appStore,
      routeStore,
      builderStore,
      orgStore,
      dndParent,
      dndIndex,
      dndSource
    ],
    ([
      l,
      f,
      p,
      m,
      b,
      y,
      v
    ]) => {
      var w, T, E, R, O, P, L, M, B;
      let k, S, $;
      if (p.inBuilder) {
        S = cloneDeep$5(p.screen), $ = [S];
        const j = p.componentErrors || {}, x = (N) => {
          var D;
          N._meta = { errors: j[N._id] || [] }, (D = N._children) == null || D.forEach(x);
        };
        x(S.props);
      } else {
        $ = l.screens || [];
        const { activeRoute: j } = f;
        if (j && (S = cloneDeep$5(
          $.find((x) => x._id === j.screenId)
        )), S) {
          const x = (w = l.layouts) == null ? void 0 : w.find(
            (N) => N._id === S.layoutId
          );
          x && (k = x);
        }
      }
      if (S && b && y != null) {
        const { selectedComponentId: j } = p;
        let x = findComponentParent(
          S.props,
          j
        );
        !v.isNew && x && (x._children = (T = x._children) == null ? void 0 : T.filter(
          (V) => V._id !== j
        ));
        const N = {
          _instanceName: "",
          _component: "@budibase/standard-components/container",
          _id: DNDPlaceholderID,
          _styles: {
            normal: {
              width: `${((E = v == null ? void 0 : v.bounds) == null ? void 0 : E.width) || 400}px`,
              height: `${((R = v == null ? void 0 : v.bounds) == null ? void 0 : R.height) || 200}px`,
              opacity: 0,
              "--default-width": ((O = v == null ? void 0 : v.bounds) == null ? void 0 : O.width) || 400,
              "--default-height": ((P = v == null ? void 0 : v.bounds) == null ? void 0 : P.height) || 200
            }
          },
          static: !0
        };
        let D = findComponentById(S.props, b);
        D && ((L = D._children) != null && L.length ? D._children.splice(y, 0, N) : D._children = [N]);
      }
      if ($.forEach((j) => {
        const x = j.routing.roleId;
        let N = getRolePriority(x);
        j.routing.homeScreen && (N += 100), j.rank = N;
      }), $ = $.sort((j, x) => j.rank !== x.rank ? j.rank > x.rank ? -1 : 1 : j.routing.route < x.routing.route ? -1 : 1), !k) {
        let j = {
          navigation: "None",
          pageWidth: (S == null ? void 0 : S.width) || "Large",
          embedded: l.embedded
        };
        S != null && S.showNavigation && (j = {
          ...j,
          ...p.navigation || ((M = l.application) == null ? void 0 : M.navigation)
        }, j.navigation || (j.navigation = "Top"), !j.title && !j.hideTitle && (j.title = (B = l.application) == null ? void 0 : B.name), j.logoUrl || (j.logoUrl = m == null ? void 0 : m.logoUrl)), k = {
          _id: "layout",
          props: {
            _component: "@budibase/standard-components/layout",
            _children: [
              {
                _component: ScreenslotType,
                _id: ScreenslotID,
                _styles: {
                  normal: {
                    flex: "1 1 auto",
                    display: "flex",
                    "flex-direction": "column",
                    "justify-content": "flex-start",
                    "align-items": "stretch"
                  }
                }
              }
            ],
            ...j
          }
        };
      }
      return { screens: $, activeLayout: k, activeScreen: S };
    }
  ).subscribe
}), screenStore = createScreenStore(), isGridScreen = derived(screenStore, (u) => {
  var l, f, p;
  return ((f = (l = u.activeScreen) == null ? void 0 : l.props) == null ? void 0 : f.layout) === "grid" || ((p = u.activeScreen) == null ? void 0 : p.variant) === ScreenVariant.PDF;
}), createDataSourceStore = () => {
  const u = writable([]), l = (b, y, v) => {
    if (!b || !y || !v)
      return;
    let k = null;
    b.type === "table" || b.type === "view" ? k = b.tableId : b.type === "viewV2" ? k = b.id : b.type === FieldType.LINK ? k = b.tableId || b.rowTableId : b.type === "query" && (k = b.datasourceId), k && u.update((S) => (S.push({
      dataSourceId: k,
      instanceId: y,
      refresh: v
    }), S));
  }, f = (b) => {
    u.update((y) => y.filter((v) => v.instanceId !== b));
  }, p = async (b, y) => {
    var $;
    if (!b)
      return;
    y = {
      invalidateRelationships: !1,
      ...y
    }, (($ = get_store_value(routeStore).queryParams) == null ? void 0 : $.peek) && window.parent.postMessage({
      type: PeekMessages.INVALIDATE_DATASOURCE,
      detail: { dataSourceId: b, options: y }
    });
    let k = [b], S;
    if (y.invalidateRelationships && !(b != null && b.includes("view_")))
      try {
        const w = await API.fetchTableDefinition(b);
        S = w == null ? void 0 : w.schema;
      } catch {
        S = null;
      }
    S && Object.values(S).forEach((w) => {
      w.type === FieldType.LINK && w.tableId && !w.autocolumn && k.push(w.tableId);
    }), k = [...new Set(k)], k.forEach((w) => {
      const T = get_store_value(u).filter((E) => E.dataSourceId === w);
      T == null || T.forEach((E) => {
        E.refresh();
      });
    });
  }, m = () => {
    var y;
    get_store_value(u).forEach((v) => v.refresh()), ((y = get_store_value(routeStore).queryParams) == null ? void 0 : y.peek) && window.parent.postMessage({
      type: PeekMessages.REFRESH_ALL_DATASOURCES
    });
  };
  return {
    subscribe: u.subscribe,
    actions: {
      registerDataSource: l,
      unregisterInstance: f,
      invalidateDataSource: p,
      refreshAll: m
    }
  };
}, dataSourceStore = createDataSourceStore(), initialState$1 = {
  showConfirmation: !1,
  title: null,
  text: null,
  confirmButtonText: null,
  cancelButtonText: null,
  onConfirm: null,
  onCancel: null
}, createConfirmationStore = () => {
  const u = writable(initialState$1), l = (m, b, y, v, k, S) => {
    u.set({
      showConfirmation: !0,
      title: m,
      text: b,
      confirmButtonText: k,
      cancelButtonText: S,
      onConfirm: y,
      onCancel: v
    });
  }, f = async () => {
    const m = get_store_value(u);
    !m.showConfirmation || !m.onConfirm || (u.set(initialState$1), await m.onConfirm());
  }, p = () => {
    const m = get_store_value(u);
    u.set(initialState$1), m.onCancel && m.onCancel();
  };
  return {
    subscribe: u.subscribe,
    actions: { showConfirmation: l, confirm: f, cancel: p }
  };
}, confirmationStore = createConfirmationStore();
class UIStateStore {
  constructor() {
    me(this, "appId");
    me(this, "localStorageKey");
    me(this, "persistentStore");
    me(this, "subscribe");
    me(this, "set");
    me(this, "update");
    this.appId = window["##BUDIBASE_APP_ID##"] || "app", this.localStorageKey = `${this.appId}.ui`, this.persistentStore = createLocalStorageStore(this.localStorageKey, {}), this.subscribe = this.persistentStore.subscribe, this.set = this.persistentStore.set, this.update = this.persistentStore.update;
  }
}
const uiStateStore = new UIStateStore(), defaultCustomTheme = {
  primaryColor: "var(--spectrum-global-color-blue-600)",
  primaryColorHover: "var(--spectrum-global-color-blue-500)",
  buttonBorderRadius: "16px",
  navBackground: "var(--spectrum-global-color-gray-100)",
  navTextColor: "var(--spectrum-global-color-gray-800)"
}, createThemeStore = () => ({
  subscribe: derived(
    [builderStore, appStore],
    ([l, f]) => {
      var y, v;
      let p = (y = f.application) == null ? void 0 : y.theme, m = (v = f.application) == null ? void 0 : v.customTheme;
      l.inBuilder && (p = l.theme, m = l.customTheme), p = ensureValidTheme(p, DefaultAppTheme), m && Object.entries(m).forEach(([k, S]) => {
        (S == null || S === "") && delete m[k];
      }), m = {
        ...defaultCustomTheme,
        ...m
      };
      let b = "";
      return Object.entries(m).forEach(([k, S]) => {
        b += `--${k}:${S};`;
      }), {
        theme: p,
        customTheme: m,
        customThemeCss: b
      };
    }
  ).subscribe
}), themeStore = createThemeStore(), spectrumGlobal = "", spectrumMedium = "", spectrumLarge = "", spectrumDarkest = "", spectrumDark = "", spectrumLight = "", spectrumLightest = "", nord = "", midnight = "", indexVars = "", features = {
  spectrumThemes: !0,
  unifiedTheme: !0,
  intelligentLoading: !0,
  deviceAwareness: !0,
  state: !0,
  customThemes: !0,
  devicePreview: !0,
  messagePassing: !0,
  rowSelection: !0,
  continueIfAction: !0,
  showNotificationAction: !0,
  sidePanel: !0,
  modal: !0,
  skeletonLoader: !0
}, typeSupportPresets = {
  numberLike: {
    supported: [
      "number",
      "boolean"
    ],
    partialSupport: [
      {
        type: "longform",
        message: "stringAsNumber"
      },
      {
        type: "string",
        message: "stringAsNumber"
      },
      {
        type: "bigint",
        message: "stringAsNumber"
      },
      {
        type: "options",
        message: "stringAsNumber"
      },
      {
        type: "formula",
        message: "stringAsNumber"
      },
      {
        type: "datetime",
        message: "dateAsNumber"
      }
    ],
    unsupported: [
      {
        type: "json",
        message: "jsonPrimitivesOnly"
      }
    ]
  },
  stringLike: {
    supported: [
      "string",
      "number",
      "bigint",
      "options",
      "longform",
      "boolean",
      "datetime"
    ],
    unsupported: [
      {
        type: "json",
        message: "jsonPrimitivesOnly"
      }
    ]
  },
  datetimeLike: {
    supported: [
      "datetime"
    ],
    partialSupport: [
      {
        type: "longform",
        message: "stringAsDate"
      },
      {
        type: "string",
        message: "stringAsDate"
      },
      {
        type: "options",
        message: "stringAsDate"
      },
      {
        type: "formula",
        message: "stringAsDate"
      },
      {
        type: "bigint",
        message: "stringAsDate"
      },
      {
        type: "number",
        message: "numberAsDate"
      }
    ],
    unsupported: [
      {
        type: "json",
        message: "jsonPrimitivesOnly"
      }
    ]
  }
}, layout$1 = {
  name: "Layout",
  description: "This component is specific only to layouts",
  icon: "columns",
  hasChildren: !0,
  styles: [
    "padding",
    "background"
  ],
  settings: [
    {
      type: "text",
      label: "Logo URL",
      key: "logoUrl"
    },
    {
      type: "text",
      label: "Title",
      key: "title"
    },
    {
      type: "select",
      label: "Navigation",
      key: "navigation",
      options: [
        "Top",
        "Left",
        "None"
      ],
      defaultValue: "Top"
    },
    {
      type: "select",
      label: "Width",
      key: "width",
      options: [
        "Small",
        "Medium",
        "Large",
        "Max"
      ],
      defaultValue: "Large"
    },
    {
      type: "navigation",
      label: "Links",
      key: "links"
    },
    {
      type: "boolean",
      label: "Hide title",
      key: "hideTitle",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Hide logo",
      key: "hideLogo",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Sticky header",
      key: "sticky",
      defaultValue: !1
    }
  ]
}, container$1 = {
  name: "Container",
  description: "This component contains things within itself",
  icon: "selection",
  hasChildren: !0,
  size: {
    width: 500,
    height: 200
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  styles: [
    "padding",
    "size",
    "background",
    "border",
    "shadow"
  ],
  settings: [
    {
      type: "select",
      label: "Layout",
      key: "layout",
      showInBar: !0,
      placeholder: !1,
      options: [
        {
          label: "Flex",
          value: "flex"
        },
        {
          label: "Grid",
          value: "grid"
        }
      ],
      defaultValue: "grid"
    },
    {
      type: "select",
      label: "Direction",
      key: "direction",
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "Column",
          value: "column",
          barIcon: "rows-plus-bottom",
          barTitle: "Column layout"
        },
        {
          label: "Row",
          value: "row",
          barIcon: "columns-plus-right",
          barTitle: "Row layout"
        }
      ],
      defaultValue: "column",
      dependsOn: {
        setting: "layout",
        value: "grid",
        invert: !0
      }
    },
    {
      type: "select",
      label: "Horiz. align",
      key: "hAlign",
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "Left",
          value: "left",
          barIcon: "AlignLeft",
          barTitle: "Align left"
        },
        {
          label: "Center",
          value: "center",
          barIcon: "AlignCenter",
          barTitle: "Align center"
        },
        {
          label: "Right",
          value: "right",
          barIcon: "AlignRight",
          barTitle: "Align right"
        },
        {
          label: "Stretch",
          value: "stretch",
          barIcon: "MoveLeftRight",
          barTitle: "Align stretched horizontally"
        }
      ],
      defaultValue: "stretch",
      dependsOn: {
        setting: "layout",
        value: "grid",
        invert: !0
      }
    },
    {
      type: "select",
      label: "Vert. align",
      key: "vAlign",
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "Top",
          value: "top",
          barIcon: "AlignTop",
          barTitle: "Align top"
        },
        {
          label: "Middle",
          value: "middle",
          barIcon: "AlignMiddle",
          barTitle: "Align middle"
        },
        {
          label: "Bottom",
          value: "bottom",
          barIcon: "AlignBottom",
          barTitle: "Align bottom"
        },
        {
          label: "Stretch",
          value: "stretch",
          barIcon: "MoveUpDown",
          barTitle: "Align stretched vertically"
        }
      ],
      defaultValue: "top",
      dependsOn: {
        setting: "layout",
        value: "grid",
        invert: !0
      }
    },
    {
      type: "select",
      label: "Size",
      key: "size",
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "Shrink",
          value: "shrink",
          barIcon: "Minimize",
          barTitle: "Shrink container"
        },
        {
          label: "Grow",
          value: "grow",
          barIcon: "Maximize",
          barTitle: "Grow container"
        }
      ],
      defaultValue: "shrink",
      dependsOn: {
        setting: "layout",
        value: "grid",
        invert: !0
      }
    },
    {
      type: "select",
      label: "Gap",
      key: "gap",
      showInBar: !0,
      barStyle: "picker",
      options: [
        {
          label: "None",
          value: "N"
        },
        {
          label: "Small",
          value: "S"
        },
        {
          label: "Medium",
          value: "M"
        },
        {
          label: "Large",
          value: "L"
        }
      ],
      defaultValue: "M",
      dependsOn: {
        setting: "layout",
        value: "grid",
        invert: !0
      }
    },
    {
      type: "boolean",
      label: "Wrap",
      key: "wrap",
      showInBar: !0,
      barIcon: "ModernGridView",
      barTitle: "Wrap",
      dependsOn: {
        setting: "layout",
        value: "grid",
        invert: !0
      }
    },
    {
      type: "event",
      label: "On click",
      key: "onClick"
    }
  ]
}, section$1 = {
  name: "Section",
  description: "Add a section to your application",
  icon: "columns",
  hasChildren: !0,
  illegalChildren: [
    "section"
  ],
  showEmptyState: !1,
  size: {
    width: 600,
    height: 200
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      type: "section",
      label: "Type",
      key: "type",
      defaultValue: "mainSidebar"
    }
  ]
}, screenslot$1 = {
  name: "Screenslot",
  icon: "browser",
  description: "Contains your app screens",
  static: !0
}, buttongroup$1 = {
  name: "Button group",
  icon: "circles-three-plus",
  hasChildren: !1,
  size: {
    width: 200,
    height: 60
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      section: !0,
      name: "Buttons",
      settings: [
        {
          type: "buttonConfiguration",
          key: "buttons",
          nested: !0,
          defaultValue: [
            {
              type: "cta",
              text: "Button 1"
            },
            {
              type: "primary",
              text: "Button 2"
            }
          ]
        }
      ]
    },
    {
      section: !0,
      name: "Layout",
      settings: [
        {
          type: "boolean",
          label: "Collapse",
          key: "collapsed"
        },
        {
          type: "text",
          label: "Collapsed text",
          key: "collapsedText",
          dependsOn: "collapsed",
          placeholder: "Action"
        },
        {
          type: "select",
          label: "Direction",
          key: "direction",
          showInBar: !0,
          barStyle: "buttons",
          options: [
            {
              label: "Column",
              value: "column",
              barIcon: "rows-plus-bottom",
              barTitle: "Column layout"
            },
            {
              label: "Row",
              value: "row",
              barIcon: "columns-plus-right",
              barTitle: "Row layout"
            }
          ],
          defaultValue: "row",
          dependsOn: {
            setting: "collapsed",
            invert: !0
          }
        },
        {
          type: "select",
          label: "Horiz. align",
          key: "hAlign",
          showInBar: !0,
          barStyle: "buttons",
          options: [
            {
              label: "Left",
              value: "left",
              barIcon: "AlignLeft",
              barTitle: "Align left"
            },
            {
              label: "Center",
              value: "center",
              barIcon: "AlignCenter",
              barTitle: "Align center"
            },
            {
              label: "Right",
              value: "right",
              barIcon: "AlignRight",
              barTitle: "Align right"
            },
            {
              label: "Stretch",
              value: "stretch",
              barIcon: "MoveLeftRight",
              barTitle: "Align stretched horizontally"
            }
          ],
          defaultValue: "left"
        },
        {
          type: "select",
          label: "Vert. align",
          key: "vAlign",
          showInBar: !0,
          barStyle: "buttons",
          options: [
            {
              label: "Top",
              value: "top",
              barIcon: "AlignTop",
              barTitle: "Align top"
            },
            {
              label: "Middle",
              value: "middle",
              barIcon: "AlignMiddle",
              barTitle: "Align middle"
            },
            {
              label: "Bottom",
              value: "bottom",
              barIcon: "AlignBottom",
              barTitle: "Align bottom"
            },
            {
              label: "Stretch",
              value: "stretch",
              barIcon: "MoveUpDown",
              barTitle: "Align stretched vertically"
            }
          ],
          defaultValue: "top"
        },
        {
          type: "select",
          label: "Size",
          key: "size",
          showInBar: !0,
          barStyle: "buttons",
          options: [
            {
              label: "Shrink",
              value: "shrink",
              barIcon: "Minimize",
              barTitle: "Shrink container"
            },
            {
              label: "Grow",
              value: "grow",
              barIcon: "Maximize",
              barTitle: "Grow container"
            }
          ],
          defaultValue: "shrink",
          dependsOn: {
            setting: "collapsed",
            invert: !0
          }
        },
        {
          type: "select",
          label: "Gap",
          key: "gap",
          showInBar: !0,
          barStyle: "picker",
          options: [
            {
              label: "None",
              value: "N"
            },
            {
              label: "Small",
              value: "S"
            },
            {
              label: "Medium",
              value: "M"
            },
            {
              label: "Large",
              value: "L"
            }
          ],
          defaultValue: "M",
          dependsOn: {
            setting: "collapsed",
            invert: !0
          }
        },
        {
          type: "boolean",
          label: "Wrap",
          key: "wrap",
          showInBar: !0,
          barIcon: "ModernGridView",
          barTitle: "Wrap",
          dependsOn: {
            setting: "collapsed",
            invert: !0
          }
        }
      ]
    }
  ]
}, button$1 = {
  name: "Button",
  description: "This component is a button",
  icon: "circle",
  editable: !0,
  size: {
    width: 120,
    height: 32
  },
  grid: {
    hAlign: "center",
    vAlign: "center"
  },
  styles: [
    "padding",
    "background",
    "font"
  ],
  settings: [
    {
      type: "text",
      label: "Text",
      key: "text",
      defaultValue: "New Button"
    },
    {
      type: "select",
      showInBar: !0,
      label: "Variant",
      key: "type",
      options: [
        {
          label: "Action",
          value: "cta"
        },
        {
          label: "Primary",
          value: "primary"
        },
        {
          label: "Secondary",
          value: "secondary"
        },
        {
          label: "Warning",
          value: "warning"
        },
        {
          label: "Over background",
          value: "overBackground"
        }
      ],
      defaultValue: "cta"
    },
    {
      type: "select",
      label: "Size",
      showInBar: !0,
      key: "size",
      options: [
        {
          label: "Small",
          value: "S"
        },
        {
          label: "Medium",
          value: "M"
        },
        {
          label: "Large",
          value: "L"
        },
        {
          label: "Extra large",
          value: "XL"
        }
      ],
      defaultValue: "M"
    },
    {
      type: "boolean",
      label: "Quiet",
      key: "quiet",
      showInBar: !0,
      barIcon: "VisibilityOff",
      barTitle: "Quiet variant",
      barSeparator: !1,
      dependsOn: {
        setting: "type",
        value: "cta",
        invert: !0
      }
    },
    {
      type: "boolean",
      label: "Disabled",
      showInBar: !0,
      barIcon: "NoEdit",
      barTitle: "Disable button",
      key: "disabled"
    },
    {
      type: "phosphorIcon",
      label: "Icon",
      key: "icon"
    },
    {
      type: "select",
      label: "Gap",
      key: "gap",
      showInBar: !0,
      barStyle: "picker",
      dependsOn: "icon",
      options: [
        {
          label: "None",
          value: "N"
        },
        {
          label: "Small",
          value: "S"
        },
        {
          label: "Medium",
          value: "M"
        },
        {
          label: "Large",
          value: "L"
        }
      ],
      defaultValue: "M"
    },
    {
      type: "event",
      label: "On click",
      key: "onClick"
    },
    {
      type: "buttonConditions",
      label: "Conditions",
      key: "conditions",
      nestedOnly: !0,
      contextAccess: {
        global: !1,
        self: !0
      }
    }
  ]
}, divider$1 = {
  name: "Divider",
  description: "A basic divider",
  icon: "line-segments",
  illegalChildren: [
    "section"
  ],
  size: {
    width: 400,
    height: 10
  },
  settings: [
    {
      type: "select",
      label: "Size",
      key: "size",
      options: [
        {
          label: "Small",
          value: "S"
        },
        {
          label: "Medium",
          value: "M"
        },
        {
          label: "Large",
          value: "L"
        }
      ],
      defaultValue: "M"
    },
    {
      type: "boolean",
      label: "Vertical",
      key: "vertical"
    }
  ]
}, repeater$1 = {
  name: "Repeater",
  description: "A configurable data list that attaches to your backend tables.",
  icon: "list-dashes",
  illegalChildren: [
    "section"
  ],
  hasChildren: !0,
  size: {
    width: 500,
    height: 200
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      type: "dataProvider",
      label: "Provider",
      key: "dataProvider",
      required: !0
    },
    {
      type: "text",
      label: "Empty text",
      key: "noRowsMessage",
      defaultValue: "No rows found"
    },
    {
      type: "select",
      label: "Direction",
      key: "direction",
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "Column",
          value: "column",
          barIcon: "rows-plus-bottom",
          barTitle: "Column layout"
        },
        {
          label: "Row",
          value: "row",
          barIcon: "columns-plus-right",
          barTitle: "Row layout"
        }
      ],
      defaultValue: "column"
    },
    {
      type: "select",
      label: "Horiz. align",
      key: "hAlign",
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "Left",
          value: "left",
          barIcon: "AlignLeft",
          barTitle: "Align left"
        },
        {
          label: "Center",
          value: "center",
          barIcon: "AlignCenter",
          barTitle: "Align center"
        },
        {
          label: "Right",
          value: "right",
          barIcon: "AlignRight",
          barTitle: "Align right"
        },
        {
          label: "Stretch",
          value: "stretch",
          barIcon: "MoveLeftRight",
          barTitle: "Align stretched horizontally"
        }
      ],
      defaultValue: "stretch"
    },
    {
      type: "select",
      label: "Vert. align",
      key: "vAlign",
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "Top",
          value: "top",
          barIcon: "AlignTop",
          barTitle: "Align top"
        },
        {
          label: "Middle",
          value: "middle",
          barIcon: "AlignMiddle",
          barTitle: "Align middle"
        },
        {
          label: "Bottom",
          value: "bottom",
          barIcon: "AlignBottom",
          barTitle: "Align bottom"
        },
        {
          label: "Stretch",
          value: "stretch",
          barIcon: "MoveUpDown",
          barTitle: "Align stretched vertically"
        }
      ],
      defaultValue: "top"
    },
    {
      type: "select",
      label: "Gap",
      key: "gap",
      showInBar: !0,
      barStyle: "picker",
      options: [
        {
          label: "None",
          value: "N"
        },
        {
          label: "Small",
          value: "S"
        },
        {
          label: "Medium",
          value: "M"
        },
        {
          label: "Large",
          value: "L"
        }
      ],
      defaultValue: "M"
    }
  ],
  context: [
    {
      type: "schema",
      scope: "local"
    },
    {
      type: "static",
      scope: "local",
      values: [
        {
          label: "Row index",
          key: "index",
          type: "number"
        }
      ]
    }
  ]
}, stackedlist$1 = {
  deprecated: !0,
  name: "Stacked List",
  icon: "list-checks",
  description: "A basic card component that can contain content and actions.",
  illegalChildren: [
    "section"
  ],
  settings: [
    {
      type: "text",
      label: "Image",
      key: "imageUrl"
    },
    {
      type: "text",
      label: "Heading",
      key: "heading"
    },
    {
      type: "text",
      label: "Subheading",
      key: "subheading"
    },
    {
      type: "text",
      label: "Link URL",
      key: "destinationUrl",
      placeholder: "/screen"
    }
  ]
}, card$1 = {
  deprecated: !0,
  name: "Vertical Card",
  description: "A basic card component that can contain content and actions.",
  icon: "cards",
  illegalChildren: [
    "section"
  ],
  settings: [
    {
      type: "text",
      label: "Image",
      key: "imageUrl"
    },
    {
      type: "text",
      label: "Heading",
      key: "heading"
    },
    {
      type: "text",
      label: "Description",
      key: "description"
    },
    {
      type: "text",
      label: "Link text",
      key: "linkText"
    },
    {
      type: "text",
      label: "Link URL",
      key: "linkUrl",
      placeholder: "/screen"
    },
    {
      type: "color",
      label: "Link color",
      key: "linkColor",
      defaultValue: "#000"
    },
    {
      type: "color",
      label: "Hover color",
      key: "linkHoverColor",
      defaultValue: "#222"
    },
    {
      type: "select",
      label: "Image height",
      key: "imageHeight",
      options: [
        "auto",
        "12rem",
        "16rem",
        "20rem",
        "24rem"
      ],
      defaultValue: "auto"
    },
    {
      type: "select",
      label: "Card width",
      key: "cardWidth",
      options: [
        "16rem",
        "20rem",
        "24rem"
      ],
      defaultValue: "20rem"
    }
  ]
}, text$1 = {
  name: "Paragraph",
  deprecated: !0,
  description: "A component for displaying paragraph text.",
  icon: "text-t",
  illegalChildren: [
    "section"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 24
  },
  settings: [
    {
      type: "text",
      label: "Text",
      key: "text"
    },
    {
      type: "select",
      label: "Size",
      key: "size",
      defaultValue: "M",
      showInBar: !0,
      barStyle: "picker",
      options: [
        {
          label: "Extra small",
          value: "XS"
        },
        {
          label: "Small",
          value: "S"
        },
        {
          label: "Medium",
          value: "M"
        },
        {
          label: "Large",
          value: "L"
        },
        {
          label: "Extra large",
          value: "XL"
        },
        {
          label: "2XL",
          value: "XXL"
        },
        {
          label: "3XL",
          value: "XXXL"
        }
      ]
    },
    {
      type: "color",
      label: "Color",
      key: "color",
      showInBar: !0,
      barSeparator: !1
    },
    {
      type: "boolean",
      label: "Bold",
      key: "bold",
      showInBar: !0,
      barIcon: "TagBold",
      barTitle: "Bold text",
      barSeparator: !1
    },
    {
      type: "boolean",
      label: "Italic",
      key: "italic",
      showInBar: !0,
      barIcon: "TagItalic",
      barTitle: "Italic text",
      barSeparator: !1
    },
    {
      type: "boolean",
      label: "Underline",
      key: "underline",
      showInBar: !0,
      barIcon: "TagUnderline",
      barTitle: "Underline text"
    },
    {
      type: "select",
      label: "Alignment",
      key: "align",
      defaultValue: "left",
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "Left",
          value: "left",
          barIcon: "TextAlignLeft",
          barTitle: "Align left"
        },
        {
          label: "Center",
          value: "center",
          barIcon: "TextAlignCenter",
          barTitle: "Align center"
        },
        {
          label: "Right",
          value: "right",
          barIcon: "TextAlignRight",
          barTitle: "Align right"
        },
        {
          label: "Justify",
          value: "justify",
          barIcon: "TextAlignJustify",
          barTitle: "Justify text"
        }
      ]
    }
  ]
}, heading$1 = {
  name: "Headline",
  deprecated: !0,
  description: "A component for displaying heading text",
  icon: "text-b",
  illegalChildren: [
    "section"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 32
  },
  settings: [
    {
      type: "text",
      key: "text",
      label: "Text"
    },
    {
      type: "select",
      label: "Size",
      key: "size",
      defaultValue: "M",
      showInBar: !0,
      barStyle: "picker",
      options: [
        {
          label: "Extra small",
          value: "XS"
        },
        {
          label: "Small",
          value: "S"
        },
        {
          label: "Medium",
          value: "M"
        },
        {
          label: "Large",
          value: "L"
        },
        {
          label: "Extra large",
          value: "XL"
        },
        {
          label: "2XL",
          value: "XXL"
        },
        {
          label: "3XL",
          value: "XXXL"
        }
      ]
    },
    {
      type: "color",
      label: "Color",
      key: "color",
      showInBar: !0,
      barSeparator: !1
    },
    {
      type: "boolean",
      label: "Bold",
      key: "bold",
      showInBar: !0,
      barIcon: "TagBold",
      barTitle: "Bold text",
      barSeparator: !1
    },
    {
      type: "boolean",
      label: "Italic",
      key: "italic",
      showInBar: !0,
      barIcon: "TagItalic",
      barTitle: "Italic text",
      barSeparator: !1
    },
    {
      type: "boolean",
      label: "Underline",
      key: "underline",
      showInBar: !0,
      barIcon: "TagUnderline",
      barTitle: "Underline text"
    },
    {
      type: "select",
      label: "Alignment",
      key: "align",
      defaultValue: "left",
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "Left",
          value: "left",
          barIcon: "TextAlignLeft",
          barTitle: "Align left"
        },
        {
          label: "Center",
          value: "center",
          barIcon: "TextAlignCenter",
          barTitle: "Align center"
        },
        {
          label: "Right",
          value: "right",
          barIcon: "TextAlignRight",
          barTitle: "Align right"
        },
        {
          label: "Justify",
          value: "justify",
          barIcon: "TextAlignJustify",
          barTitle: "Justify text"
        }
      ]
    }
  ]
}, tag$1 = {
  name: "Tag",
  description: "This component is a tag",
  icon: "tag",
  size: {
    width: 100,
    height: 25
  },
  grid: {
    hAlign: "center",
    vAlign: "center"
  },
  settings: [
    {
      type: "text",
      label: "Text",
      key: "text"
    },
    {
      type: "select",
      label: "Size",
      key: "size",
      defaultValue: "M",
      showInBar: !0,
      barStyle: "picker",
      options: [
        {
          label: "Small",
          value: "S"
        },
        {
          label: "Medium",
          value: "M"
        },
        {
          label: "Large",
          value: "L"
        }
      ]
    },
    {
      type: "color",
      label: "Color",
      key: "color",
      showInBar: !0
    },
    {
      type: "color",
      label: "Text Color",
      key: "textColor",
      showInBar: !0
    },
    {
      type: "boolean",
      label: "Allow delete",
      key: "closable"
    },
    {
      type: "event",
      label: "On click delete",
      key: "onClick",
      dependsOn: "closable"
    }
  ]
}, image$1 = {
  name: "Image",
  description: "A basic component for displaying images",
  icon: "image",
  styles: [
    "size"
  ],
  size: {
    width: 400,
    height: 300
  },
  settings: [
    {
      type: "text",
      label: "URL",
      key: "url",
      required: !0
    }
  ]
}, backgroundimage$1 = {
  name: "Background Image",
  description: "A background image",
  icon: "image-square",
  hasChildren: !0,
  styles: [
    "size"
  ],
  showEmptyState: !1,
  size: {
    width: 400,
    height: 300
  },
  settings: [
    {
      type: "text",
      label: "URL",
      key: "url",
      required: !0
    },
    {
      type: "select",
      label: "Position",
      key: "position",
      defaultValue: "center center",
      options: [
        {
          label: "Center top",
          value: "center top"
        },
        {
          label: "Center",
          value: "center center"
        },
        {
          label: "Center bottom",
          value: "center bottom"
        },
        {
          label: "Left top",
          value: "left top"
        },
        {
          label: "Left center",
          value: "left center"
        },
        {
          label: "Left bottom",
          value: "left bottom"
        },
        {
          label: "Right top",
          value: "right top"
        },
        {
          label: "Right center",
          value: "right center"
        },
        {
          label: "Right bottom",
          value: "right bottom"
        }
      ]
    }
  ]
}, icon$1 = {
  name: "Icon",
  description: "A basic component for displaying icons",
  icon: "shapes",
  size: {
    width: 25,
    height: 25
  },
  grid: {
    hAlign: "center",
    vAlign: "center"
  },
  settings: [
    {
      type: "phosphorIcon",
      label: "Icon",
      key: "icon",
      required: !0,
      defaultValue: "star"
    },
    {
      type: "select",
      label: "Size",
      key: "size",
      defaultValue: "ri-1x",
      options: [
        {
          value: "ri-xxs",
          label: "XXS"
        },
        {
          value: "ri-xs",
          label: "XS"
        },
        {
          value: "ri-sm",
          label: "Small"
        },
        {
          value: "ri-1x",
          label: "Medium"
        },
        {
          value: "ri-lg",
          label: "Large"
        },
        {
          value: "ri-xl",
          label: "XL"
        },
        {
          value: "ri-2x",
          label: "2XL"
        },
        {
          value: "ri-3x",
          label: "3XL"
        },
        {
          value: "ri-4x",
          label: "4XL"
        },
        {
          value: "ri-5x",
          label: "5XL"
        },
        {
          value: "ri-6x",
          label: "6XL"
        },
        {
          value: "ri-7x",
          label: "7XL"
        },
        {
          value: "ri-8x",
          label: "8XL"
        },
        {
          value: "ri-9x",
          label: "9XL"
        },
        {
          value: "ri-10x",
          label: "10XL"
        }
      ]
    },
    {
      type: "color",
      label: "Color",
      key: "color"
    },
    {
      type: "event",
      label: "On click",
      key: "onClick"
    }
  ]
}, iconphosphor$1 = {
  name: "Icon",
  description: "A basic component for displaying icons",
  icon: "phosphor-logo",
  size: {
    width: 64,
    height: 64
  },
  grid: {
    hAlign: "center",
    vAlign: "center"
  },
  settings: [
    {
      type: "phosphorIcon",
      label: "Icon",
      key: "icon",
      required: !0,
      defaultValue: "star"
    },
    {
      type: "number",
      label: "Size",
      key: "size",
      defaultValue: 48,
      min: 8,
      max: 256
    },
    {
      type: "select",
      label: "Weight",
      key: "weight",
      defaultValue: "regular",
      options: [
        {
          value: "thin",
          label: "Thin"
        },
        {
          value: "light",
          label: "Light"
        },
        {
          value: "regular",
          label: "Regular"
        },
        {
          value: "bold",
          label: "Bold"
        },
        {
          value: "fill",
          label: "Fill"
        },
        {
          value: "duotone",
          label: "Duotone"
        }
      ]
    },
    {
      type: "color",
      label: "Color",
      key: "color"
    },
    {
      type: "event",
      label: "On click",
      key: "onClick"
    }
  ]
}, navigation$1 = {
  deprecated: !0,
  name: "Nav Bar",
  description: "A component for handling the navigation within your app.",
  icon: "BreadcrumbNavigation",
  illegalChildren: [
    "section"
  ],
  hasChildren: !0,
  settings: [
    {
      type: "text",
      label: "Logo URL",
      key: "logoUrl"
    },
    {
      type: "boolean",
      label: "Hide logo",
      key: "hideLogo",
      defaultValue: !1
    }
  ]
}, link$1 = {
  name: "Link",
  description: "A basic link component for internal and external links",
  icon: "link",
  editable: !0,
  size: {
    width: 200,
    height: 30
  },
  settings: [
    {
      type: "text",
      label: "Text",
      key: "text"
    },
    {
      type: "url",
      label: "URL",
      key: "url",
      placeholder: "/screen"
    },
    {
      type: "boolean",
      label: "New tab",
      key: "openInNewTab"
    },
    {
      type: "select",
      label: "Size",
      key: "size",
      defaultValue: "M",
      showInBar: !0,
      barStyle: "picker",
      options: [
        {
          label: "Small",
          value: "S"
        },
        {
          label: "Medium",
          value: "M"
        },
        {
          label: "Large",
          value: "L"
        }
      ]
    },
    {
      type: "color",
      label: "Color",
      key: "color",
      showInBar: !0,
      barSeparator: !1
    },
    {
      type: "boolean",
      label: "Bold",
      key: "bold",
      showInBar: !0,
      barIcon: "TagBold",
      barTitle: "Bold text",
      barSeparator: !1
    },
    {
      type: "boolean",
      label: "Italic",
      key: "italic",
      showInBar: !0,
      barIcon: "TagItalic",
      barTitle: "Italic text",
      barSeparator: !1
    },
    {
      type: "boolean",
      label: "Underline",
      key: "underline",
      showInBar: !0,
      barIcon: "TagUnderline",
      barTitle: "Underline text"
    },
    {
      type: "select",
      label: "Alignment",
      key: "align",
      defaultValue: "left",
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "Left",
          value: "left",
          barIcon: "TextAlignLeft",
          barTitle: "Align left"
        },
        {
          label: "Center",
          value: "center",
          barIcon: "TextAlignCenter",
          barTitle: "Align center"
        },
        {
          label: "Right",
          value: "right",
          barIcon: "TextAlignRight",
          barTitle: "Align right"
        },
        {
          label: "Justify",
          value: "justify",
          barIcon: "TextAlignJustify",
          barTitle: "Justify text"
        }
      ]
    }
  ]
}, cardhorizontal$1 = {
  deprecated: !0,
  name: "Horizontal Card",
  description: "A basic card component that can contain content and actions.",
  icon: "cards",
  settings: [
    {
      type: "text",
      label: "Image",
      key: "imageUrl"
    },
    {
      type: "text",
      label: "Heading",
      key: "heading"
    },
    {
      type: "text",
      label: "Description",
      key: "description"
    },
    {
      type: "text",
      label: "Subtext",
      key: "subtext"
    },
    {
      type: "text",
      label: "Link text",
      key: "linkText"
    },
    {
      type: "text",
      label: "Link URL",
      key: "linkUrl",
      placeholder: "/screen"
    },
    {
      type: "color",
      label: "Link color",
      key: "linkColor",
      defaultValue: "#000"
    },
    {
      type: "color",
      label: "Hover color",
      key: "linkHoverColor",
      defaultValue: "#222"
    },
    {
      type: "select",
      label: "Card width",
      key: "cardWidth",
      options: [
        "24rem",
        "28rem",
        "32rem",
        "40rem",
        "48rem",
        "60rem",
        "100%"
      ],
      defaultValue: "32rem"
    },
    {
      type: "select",
      label: "Image width",
      key: "imageWidth",
      options: [
        "auto",
        "8rem",
        "12rem",
        "16rem"
      ],
      defaultValue: "8rem"
    },
    {
      type: "select",
      label: "Image height",
      key: "imageHeight",
      options: [
        "auto",
        "8rem",
        "12rem",
        "16rem",
        "auto"
      ],
      defaultValue: "auto"
    }
  ]
}, cardstat$1 = {
  name: "Stat Card",
  description: "A card component for displaying numbers.",
  icon: "cards",
  size: {
    width: 260,
    height: 143
  },
  grid: {
    hAlign: "center",
    vAlign: "center"
  },
  settings: [
    {
      type: "text",
      label: "Title",
      key: "title",
      placeholder: "Total Revenue",
      defaultValue: "Title"
    },
    {
      type: "text",
      label: "Value",
      key: "value",
      placeholder: "$1,981,983",
      defaultValue: "Value"
    },
    {
      type: "text",
      label: "Label",
      key: "label",
      placeholder: "Stripe",
      defaultValue: "Label"
    }
  ]
}, embed$1 = {
  name: "Embed",
  icon: "code",
  description: "Embed content from 3rd party sources",
  styles: [
    "size"
  ],
  size: {
    width: 400,
    height: 100
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      type: "text",
      label: "Embed",
      key: "embed",
      required: !0,
      allowHTML: !0
    }
  ]
}, bar$1 = {
  documentationLink: "https://docs.budibase.com/docs/bar-chart",
  name: "Bar Chart",
  description: "Bar chart",
  icon: "chart-bar",
  size: {
    width: 600,
    height: 420
  },
  grid: {
    hAlign: "stretch",
    vAlign: "center"
  },
  settings: [
    {
      type: "text",
      label: "Title",
      key: "title"
    },
    {
      type: "dataProvider",
      label: "Provider",
      key: "dataProvider",
      required: !0
    },
    {
      type: "field",
      label: "Label column",
      key: "labelColumn",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "stringLike"
        }
      },
      required: !0
    },
    {
      type: "multifield",
      label: "Data columns",
      key: "valueColumns",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "numberLike"
        }
      },
      required: !0
    },
    {
      type: "event",
      label: "On click bar",
      key: "onClick",
      context: [
        {
          label: "Clicked bar",
          key: "bar"
        }
      ]
    },
    {
      type: "select",
      label: "Format",
      key: "yAxisUnits",
      options: [
        "Default",
        "Thousands",
        "Millions"
      ],
      defaultValue: "Default"
    },
    {
      type: "text",
      label: "Y axis label",
      key: "yAxisLabel"
    },
    {
      type: "text",
      label: "X axis label",
      key: "xAxisLabel"
    },
    {
      type: "text",
      label: "Width",
      key: "width"
    },
    {
      type: "text",
      label: "Height",
      key: "height",
      defaultValue: "400"
    },
    {
      type: "select",
      label: "Colors",
      key: "palette",
      defaultValue: "Palette 1",
      options: [
        "Custom",
        "Palette 1",
        "Palette 2",
        "Palette 3",
        "Palette 4",
        "Palette 5",
        "Palette 6",
        "Palette 7",
        "Palette 8",
        "Palette 9",
        "Palette 10"
      ]
    },
    {
      type: "color",
      label: "C1",
      key: "c1",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C2",
      key: "c2",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C3",
      key: "c3",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C4",
      key: "c4",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C5",
      key: "c5",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "boolean",
      label: "Stacked",
      key: "stacked",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Horizontal",
      key: "horizontal",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Data labels",
      key: "dataLabels",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Animate",
      key: "animate",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Legend",
      key: "legend",
      defaultValue: !1
    }
  ]
}, line$1 = {
  documentationLink: "https://docs.budibase.com/docs/line-chart",
  name: "Line Chart",
  description: "Line chart",
  icon: "chart-line",
  size: {
    width: 600,
    height: 420
  },
  grid: {
    hAlign: "stretch",
    vAlign: "center"
  },
  settings: [
    {
      type: "text",
      label: "Title",
      key: "title"
    },
    {
      type: "dataProvider",
      label: "Provider",
      key: "dataProvider",
      required: !0
    },
    {
      type: "field",
      label: "Label column",
      key: "labelColumn",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "stringLike"
        }
      },
      required: !0
    },
    {
      type: "multifield",
      label: "Data columns",
      key: "valueColumns",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "numberLike"
        }
      },
      required: !0
    },
    {
      type: "event",
      label: "On click marker",
      key: "onClick",
      context: [
        {
          label: "Clicked marker",
          key: "marker"
        }
      ]
    },
    {
      type: "select",
      label: "Format",
      key: "yAxisUnits",
      options: [
        "Default",
        "Thousands",
        "Millions"
      ],
      defaultValue: "Default"
    },
    {
      type: "text",
      label: "Y axis label",
      key: "yAxisLabel"
    },
    {
      type: "text",
      label: "X axis label",
      key: "xAxisLabel"
    },
    {
      type: "text",
      label: "Width",
      key: "width"
    },
    {
      type: "text",
      label: "Height",
      key: "height",
      defaultValue: "400"
    },
    {
      type: "select",
      label: "Colors",
      key: "palette",
      defaultValue: "Palette 1",
      options: [
        "Custom",
        "Palette 1",
        "Palette 2",
        "Palette 3",
        "Palette 4",
        "Palette 5",
        "Palette 6",
        "Palette 7",
        "Palette 8",
        "Palette 9",
        "Palette 10"
      ]
    },
    {
      type: "color",
      label: "C1",
      key: "c1",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C2",
      key: "c2",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C3",
      key: "c3",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C4",
      key: "c4",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C5",
      key: "c5",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "select",
      label: "Curve",
      key: "curve",
      options: [
        "Smooth",
        "Straight",
        "Stepline"
      ],
      defaultValue: "Smooth"
    },
    {
      type: "boolean",
      label: "Data labels",
      key: "dataLabels",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Animate",
      key: "animate",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Legend",
      key: "legend",
      defaultValue: !1
    }
  ]
}, area$1 = {
  documentationLink: "https://docs.budibase.com/docs/area-chart",
  name: "Area Chart",
  description: "Line chart",
  icon: "chart-line-up",
  size: {
    width: 600,
    height: 420
  },
  grid: {
    hAlign: "stretch",
    vAlign: "center"
  },
  settings: [
    {
      type: "text",
      label: "Title",
      key: "title"
    },
    {
      type: "dataProvider",
      label: "Provider",
      key: "dataProvider",
      required: !0
    },
    {
      type: "field",
      label: "Label column",
      key: "labelColumn",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "stringLike"
        }
      },
      required: !0
    },
    {
      type: "multifield",
      label: "Data columns",
      key: "valueColumns",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "numberLike"
        }
      },
      required: !0
    },
    {
      type: "event",
      label: "On click marker",
      key: "onClick",
      context: [
        {
          label: "Clicked marker",
          key: "marker"
        }
      ]
    },
    {
      type: "select",
      label: "Format",
      key: "yAxisUnits",
      options: [
        "Default",
        "Thousands",
        "Millions"
      ],
      defaultValue: "Default"
    },
    {
      type: "text",
      label: "Y axis label",
      key: "yAxisLabel"
    },
    {
      type: "text",
      label: "X axis label",
      key: "xAxisLabel"
    },
    {
      type: "text",
      label: "Width",
      key: "width"
    },
    {
      type: "text",
      label: "Height",
      key: "height",
      defaultValue: "400"
    },
    {
      type: "select",
      label: "Colors",
      key: "palette",
      defaultValue: "Palette 1",
      options: [
        "Custom",
        "Palette 1",
        "Palette 2",
        "Palette 3",
        "Palette 4",
        "Palette 5",
        "Palette 6",
        "Palette 7",
        "Palette 8",
        "Palette 9",
        "Palette 10"
      ]
    },
    {
      type: "color",
      label: "C1",
      key: "c1",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C2",
      key: "c2",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C3",
      key: "c3",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C4",
      key: "c4",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C5",
      key: "c5",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "select",
      label: "Curve",
      key: "curve",
      options: [
        "Smooth",
        "Straight",
        "Stepline"
      ],
      defaultValue: "Smooth"
    },
    {
      type: "boolean",
      label: "Data labels",
      key: "dataLabels",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Animate",
      key: "animate",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Legend",
      key: "legend",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Stacked",
      key: "stacked",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Gradient",
      key: "gradient",
      defaultValue: !1
    }
  ]
}, pie$1 = {
  documentationLink: "https://docs.budibase.com/docs/pie-donut-chart",
  name: "Pie Chart",
  description: "Pie chart",
  icon: "chart-pie",
  size: {
    width: 600,
    height: 420
  },
  grid: {
    hAlign: "stretch",
    vAlign: "center"
  },
  settings: [
    {
      type: "text",
      label: "Title",
      key: "title"
    },
    {
      type: "dataProvider",
      label: "Provider",
      key: "dataProvider",
      required: !0
    },
    {
      type: "field",
      label: "Label column",
      key: "labelColumn",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "stringLike"
        }
      },
      required: !0
    },
    {
      type: "field",
      label: "Data column",
      key: "valueColumn",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "numberLike"
        }
      },
      required: !0
    },
    {
      type: "event",
      label: "On click segment",
      key: "onClick",
      context: [
        {
          label: "Clicked segment",
          key: "segment"
        },
        {
          label: "Segment Index",
          key: "index"
        },
        {
          label: "Segment Percentage",
          key: "percentage"
        }
      ]
    },
    {
      type: "text",
      label: "Width",
      key: "width"
    },
    {
      type: "text",
      label: "Height",
      key: "height",
      defaultValue: "400"
    },
    {
      type: "select",
      label: "Colors",
      key: "palette",
      defaultValue: "Palette 1",
      options: [
        "Custom",
        "Palette 1",
        "Palette 2",
        "Palette 3",
        "Palette 4",
        "Palette 5",
        "Palette 6",
        "Palette 7",
        "Palette 8",
        "Palette 9",
        "Palette 10"
      ]
    },
    {
      type: "color",
      label: "C1",
      key: "c1",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C2",
      key: "c2",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C3",
      key: "c3",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C4",
      key: "c4",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C5",
      key: "c5",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "boolean",
      label: "Data labels",
      key: "dataLabels",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Animate",
      key: "animate",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Legend",
      key: "legend",
      defaultValue: !1
    }
  ],
  context: [
    {
      type: "schema",
      scope: "local"
    }
  ]
}, donut$1 = {
  documentationLink: "https://docs.budibase.com/docs/pie-donut-chart",
  name: "Donut Chart",
  description: "Donut chart",
  icon: "chart-donut",
  size: {
    width: 600,
    height: 420
  },
  grid: {
    hAlign: "stretch",
    vAlign: "center"
  },
  settings: [
    {
      type: "text",
      label: "Title",
      key: "title"
    },
    {
      type: "dataProvider",
      label: "Provider",
      key: "dataProvider",
      required: !0
    },
    {
      type: "field",
      label: "Label column",
      key: "labelColumn",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "stringLike"
        }
      },
      required: !0
    },
    {
      type: "field",
      label: "Data columns",
      key: "valueColumn",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "numberLike"
        }
      },
      required: !0
    },
    {
      type: "event",
      label: "On click segment",
      key: "onClick",
      context: [
        {
          label: "Clicked segment",
          key: "segment"
        },
        {
          label: "Segment Index",
          key: "index"
        },
        {
          label: "Segment Percentage",
          key: "percentage"
        }
      ]
    },
    {
      type: "text",
      label: "Width",
      key: "width"
    },
    {
      type: "text",
      label: "Height",
      key: "height",
      defaultValue: "400"
    },
    {
      type: "select",
      label: "Colors",
      key: "palette",
      defaultValue: "Palette 1",
      options: [
        "Custom",
        "Palette 1",
        "Palette 2",
        "Palette 3",
        "Palette 4",
        "Palette 5",
        "Palette 6",
        "Palette 7",
        "Palette 8",
        "Palette 9",
        "Palette 10"
      ]
    },
    {
      type: "color",
      label: "C1",
      key: "c1",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C2",
      key: "c2",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C3",
      key: "c3",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C4",
      key: "c4",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C5",
      key: "c5",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "boolean",
      label: "Data labels",
      key: "dataLabels",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Animate",
      key: "animate",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Legend",
      key: "legend",
      defaultValue: !1
    }
  ]
}, candlestick$1 = {
  documentationLink: "https://docs.budibase.com/docs/candlestick-chart",
  name: "Candlestick Chart",
  description: "Candlestick chart",
  icon: "chart-bar",
  size: {
    width: 600,
    height: 420
  },
  grid: {
    hAlign: "stretch",
    vAlign: "center"
  },
  settings: [
    {
      type: "text",
      label: "Title",
      key: "title"
    },
    {
      type: "dataProvider",
      label: "Provider",
      key: "dataProvider",
      required: !0
    },
    {
      type: "field",
      label: "Date column",
      key: "dateColumn",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "datetimeLike"
        }
      },
      required: !0
    },
    {
      type: "field",
      label: "Open column",
      key: "openColumn",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "numberLike"
        }
      },
      required: !0
    },
    {
      type: "field",
      label: "Close column",
      key: "closeColumn",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "numberLike"
        }
      },
      required: !0
    },
    {
      type: "field",
      label: "High column",
      key: "highColumn",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "numberLike"
        }
      },
      required: !0
    },
    {
      type: "field",
      label: "Low column",
      key: "lowColumn",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "numberLike"
        }
      },
      required: !0
    },
    {
      type: "event",
      label: "On click candlestick",
      key: "onClick",
      context: [
        {
          label: "Clicked candlestick",
          key: "candlestick"
        }
      ]
    },
    {
      type: "select",
      label: "Format",
      key: "yAxisUnits",
      options: [
        "Default",
        "Thousands",
        "Millions"
      ],
      defaultValue: "Default"
    },
    {
      type: "text",
      label: "Y axis label",
      key: "yAxisLabel"
    },
    {
      type: "text",
      label: "X axis label",
      key: "xAxisLabel"
    },
    {
      type: "text",
      label: "Width",
      key: "width"
    },
    {
      type: "text",
      label: "Height",
      key: "height",
      defaultValue: "400"
    },
    {
      type: "boolean",
      label: "Animate",
      key: "animate",
      defaultValue: !0
    }
  ]
}, histogram$1 = {
  documentationLink: "https://docs.budibase.com/docs/histogram-chart",
  name: "Histogram Chart",
  description: "Histogram chart",
  icon: "chart-bar",
  size: {
    width: 600,
    height: 420
  },
  grid: {
    hAlign: "stretch",
    vAlign: "center"
  },
  settings: [
    {
      type: "text",
      label: "Title",
      key: "title"
    },
    {
      type: "dataProvider",
      label: "Provider",
      key: "dataProvider",
      required: !0
    },
    {
      type: "field",
      label: "Data column",
      key: "valueColumn",
      dependsOn: "dataProvider",
      explanation: {
        typeSupport: {
          preset: "numberLike"
        }
      },
      required: !0
    },
    {
      type: "text",
      label: "Y axis label",
      key: "yAxisLabel",
      defaultValue: "Frequency"
    },
    {
      type: "text",
      label: "X axis label",
      key: "xAxisLabel"
    },
    {
      type: "number",
      label: "Bucket count",
      key: "bucketCount",
      defaultValue: 10,
      min: 2
    },
    {
      type: "event",
      label: "On click bucket",
      key: "onClick",
      context: [
        {
          label: "Clicked bucket rows",
          key: "rowsInBucket"
        },
        {
          label: "Lower limit",
          key: "lowerLimit"
        },
        {
          label: "Upper limit",
          key: "upperLimit"
        }
      ]
    },
    {
      type: "boolean",
      label: "Data labels",
      key: "dataLabels",
      defaultValue: !1
    },
    {
      type: "text",
      label: "Width",
      key: "width"
    },
    {
      type: "text",
      label: "Height",
      key: "height",
      defaultValue: "400"
    },
    {
      type: "select",
      label: "Colors",
      key: "palette",
      defaultValue: "Palette 1",
      options: [
        "Custom",
        "Palette 1",
        "Palette 2",
        "Palette 3",
        "Palette 4",
        "Palette 5",
        "Palette 6",
        "Palette 7",
        "Palette 8",
        "Palette 9",
        "Palette 10"
      ]
    },
    {
      type: "color",
      label: "C1",
      key: "c1",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C2",
      key: "c2",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C3",
      key: "c3",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C4",
      key: "c4",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C5",
      key: "c5",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "boolean",
      label: "Animate",
      key: "animate",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Horizontal",
      key: "horizontal",
      defaultValue: !1
    }
  ]
}, form$1 = {
  name: "Form",
  description: "This component is a form",
  icon: "list",
  hasChildren: !0,
  illegalChildren: [
    "section",
    "form",
    "formblock"
  ],
  actions: [
    "ValidateForm",
    "ClearForm",
    "ChangeFormStep",
    "UpdateFieldValue",
    "ScrollTo"
  ],
  styles: [
    "padding",
    "size",
    "background",
    "border",
    "shadow"
  ],
  size: {
    width: 400,
    height: 400
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      type: "select",
      label: "Type",
      key: "actionType",
      options: [
        "Create",
        "Update"
      ],
      defaultValue: "Create"
    },
    {
      type: "schema",
      label: "Schema",
      key: "dataSource",
      defaultValue: {
        name: "Custom",
        label: "Custom"
      }
    },
    {
      type: "select",
      label: "Size",
      key: "size",
      options: [
        {
          label: "Medium",
          value: "spectrum--medium"
        },
        {
          label: "Large",
          value: "spectrum--large"
        }
      ],
      defaultValue: "spectrum--medium"
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "readonly",
      defaultValue: !1,
      dependsOn: {
        setting: "disabled",
        value: !0,
        invert: !0
      }
    },
    {
      type: "text",
      label: "Initial form step",
      key: "initialFormStep",
      defaultValue: 1
    }
  ],
  context: [
    {
      type: "static",
      values: [
        {
          label: "Value",
          key: "__value",
          type: "object"
        },
        {
          label: "Valid",
          key: "__valid",
          type: "boolean"
        },
        {
          label: "Current Step",
          key: "__currentStep",
          type: "number"
        },
        {
          label: "Current Step Valid",
          key: "__currentStepValid",
          type: "boolean"
        }
      ]
    },
    {
      type: "form"
    }
  ]
}, formstep$1 = {
  name: "Form Step",
  icon: "steps",
  hasChildren: !0,
  requiredAncestors: [
    "form"
  ],
  illegalChildren: [
    "section",
    "form",
    "formstep",
    "formblock"
  ],
  styles: [
    "size"
  ],
  size: {
    width: 400,
    height: 400
  },
  settings: [
    {
      type: "number",
      label: "Step",
      key: "step",
      defaultValue: 1,
      min: 1
    }
  ]
}, fieldgroup$1 = {
  name: "Field Group",
  icon: "stack",
  requiredAncestors: [
    "form"
  ],
  illegalChildren: [
    "section"
  ],
  styles: [
    "size"
  ],
  hasChildren: !0,
  size: {
    width: 400,
    height: 400
  },
  settings: [
    {
      type: "select",
      label: "Labels",
      key: "labelPosition",
      defaultValue: "above",
      options: [
        {
          label: "Left",
          value: "left"
        },
        {
          label: "Above",
          value: "above"
        }
      ]
    },
    {
      type: "section",
      label: "Type",
      key: "type",
      defaultValue: "oneColumn",
      dependsOn: {
        setting: "labelPosition",
        value: "above"
      }
    }
  ]
}, labelfield = {
  name: "Text Field",
  icon: "text-t",
  editable: !0,
  size: {
    width: 400,
    height: 60
  },
  settings: [
    {
      type: "plainText",
      label: "Label",
      key: "label"
    },
    {
      type: "number",
      label: "Initial width",
      key: "width",
      placeholder: "Auto",
      min: 80,
      max: 9999
    },
    {
      type: "tableConditions",
      label: "Conditions",
      key: "conditions",
      contextAccess: {
        global: !0,
        self: !1
      }
    },
    {
      type: "text",
      label: "Format",
      key: "format",
      info: "Changing format will display values as text",
      contextAccess: {
        global: !1,
        self: !0
      }
    }
  ]
}, stringfield$1 = {
  name: "Text Field",
  icon: "text-t",
  styles: [
    "size"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 60
  },
  settings: [
    {
      type: "field/string",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Placeholder",
      key: "placeholder"
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue",
      supportsConditions: !1
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "boolean",
      label: "Run on input",
      key: "runOnInput",
      dependsOn: "onChange",
      info: "Trigger actions by 'input' events as well as 'change' events",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "readonly",
      defaultValue: !1,
      dependsOn: {
        setting: "disabled",
        value: !0,
        invert: !0
      }
    },
    {
      type: "validation/string",
      label: "Validation",
      key: "validation"
    },
    {
      type: "select",
      label: "Alignment",
      key: "align",
      defaultValue: "left",
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "Left",
          value: "left",
          barIcon: "TextAlignLeft",
          barTitle: "Align left"
        },
        {
          label: "Center",
          value: "center",
          barIcon: "TextAlignCenter",
          barTitle: "Align center"
        },
        {
          label: "Right",
          value: "right",
          barIcon: "TextAlignRight",
          barTitle: "Align right"
        },
        {
          label: "Justify",
          value: "justify",
          barIcon: "TextAlignJustify",
          barTitle: "Justify text"
        }
      ]
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "string"
      }
    ]
  }
}, numberfield$1 = {
  name: "Number Field",
  icon: "number-circle-nine",
  styles: [
    "size"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 60
  },
  settings: [
    {
      type: "field/number",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Placeholder",
      key: "placeholder"
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue",
      supportsConditions: !1
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "boolean",
      label: "Run on input",
      key: "runOnInput",
      dependsOn: "onChange",
      info: "Trigger actions by 'input' events as well as 'change' events",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "readonly",
      defaultValue: !1,
      dependsOn: {
        setting: "disabled",
        value: !0,
        invert: !0
      }
    },
    {
      type: "validation/number",
      label: "Validation",
      key: "validation"
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "number"
      }
    ]
  }
}, bigintfield$1 = {
  name: "BigInt Field",
  icon: "hash-straight",
  styles: [
    "size"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 60
  },
  settings: [
    {
      type: "field/bigint",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Placeholder",
      key: "placeholder"
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue",
      supportsConditions: !1
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "boolean",
      label: "Run on input",
      key: "runOnInput",
      dependsOn: "onChange",
      info: "Trigger actions by 'input' events as well as 'change' events",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "number"
      }
    ]
  }
}, passwordfield$1 = {
  name: "Password Field",
  icon: "password",
  styles: [
    "size"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 60
  },
  settings: [
    {
      type: "field/string",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Placeholder",
      key: "placeholder"
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue",
      supportsConditions: !1
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "boolean",
      label: "Run on input",
      key: "runOnInput",
      dependsOn: "onChange",
      info: "Trigger actions by 'input' events as well as 'change' events",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "validation/string",
      label: "Validation",
      key: "validation"
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "string"
      }
    ]
  }
}, optionsfield$1 = {
  name: "Options Picker",
  icon: "list-plus",
  styles: [
    "size"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 60
  },
  settings: [
    {
      type: "field/options",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Placeholder",
      key: "placeholder",
      placeholder: "Choose an option"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "select",
      label: "Type",
      key: "optionsType",
      defaultValue: "select",
      placeholder: "Pick an options type",
      options: [
        {
          label: "Select",
          value: "select"
        },
        {
          label: "Radio buttons",
          value: "radio"
        }
      ]
    },
    {
      type: "select",
      label: "Direction",
      key: "direction",
      defaultValue: "vertical",
      options: [
        {
          label: "Horizontal",
          value: "horizontal"
        },
        {
          label: "Vertical",
          value: "vertical"
        }
      ],
      dependsOn: {
        setting: "optionsType",
        value: "radio"
      }
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue",
      supportsConditions: !1
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "boolean",
      label: "Autocomplete",
      key: "autocomplete",
      defaultValue: !1,
      dependsOn: {
        setting: "optionsType",
        value: "select"
      }
    },
    {
      type: "boolean",
      label: "Alphabetical",
      key: "sort",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "readonly",
      defaultValue: !1,
      dependsOn: {
        setting: "disabled",
        value: !0,
        invert: !0
      }
    },
    {
      type: "select",
      label: "Options source",
      key: "optionsSource",
      defaultValue: "schema",
      placeholder: "Pick an options source",
      options: [
        {
          label: "Schema",
          value: "schema"
        },
        {
          label: "Data provider",
          value: "provider"
        },
        {
          label: "Custom",
          value: "custom"
        }
      ]
    },
    {
      type: "dataProvider",
      label: "Options provider",
      key: "dataProvider",
      required: !0,
      dependsOn: {
        setting: "optionsSource",
        value: "provider"
      }
    },
    {
      type: "field",
      label: "Label column",
      key: "labelColumn",
      dependsOn: {
        setting: "optionsSource",
        value: "provider"
      }
    },
    {
      type: "field",
      label: "Value column",
      key: "valueColumn",
      dependsOn: {
        setting: "optionsSource",
        value: "provider"
      }
    },
    {
      type: "options",
      label: "Custom options",
      key: "customOptions",
      dependsOn: {
        setting: "optionsSource",
        value: "custom"
      }
    },
    {
      type: "validation/string",
      label: "Validation",
      key: "validation"
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "string"
      }
    ]
  }
}, multifieldselect$1 = {
  name: "Multi-select Picker",
  icon: "list-checks",
  styles: [
    "size"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 60
  },
  settings: [
    {
      type: "field/array",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Placeholder",
      key: "placeholder",
      placeholder: "Choose an option"
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue",
      supportsConditions: !1
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "boolean",
      label: "Autocomplete",
      key: "autocomplete",
      defaultValue: !1,
      dependsOn: {
        setting: "optionsType",
        value: "select"
      }
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "readonly",
      defaultValue: !1,
      dependsOn: {
        setting: "disabled",
        value: !0,
        invert: !0
      }
    },
    {
      type: "select",
      label: "Type",
      key: "optionsType",
      defaultValue: "select",
      placeholder: "Pick an options type",
      options: [
        {
          label: "Select",
          value: "select"
        },
        {
          label: "Checkboxes",
          value: "checkbox"
        }
      ]
    },
    {
      type: "select",
      label: "Direction",
      key: "direction",
      defaultValue: "vertical",
      options: [
        {
          label: "Horizontal",
          value: "horizontal"
        },
        {
          label: "Vertical",
          value: "vertical"
        }
      ],
      dependsOn: {
        setting: "optionsType",
        value: "checkbox"
      }
    },
    {
      type: "select",
      label: "Options source",
      key: "optionsSource",
      defaultValue: "schema",
      placeholder: "Pick an options source",
      options: [
        {
          label: "Schema",
          value: "schema"
        },
        {
          label: "Data provider",
          value: "provider"
        },
        {
          label: "Custom",
          value: "custom"
        }
      ]
    },
    {
      type: "dataProvider",
      label: "Options provider",
      key: "dataProvider",
      required: !0,
      dependsOn: {
        setting: "optionsSource",
        value: "provider"
      }
    },
    {
      type: "field",
      label: "Label column",
      key: "labelColumn",
      dependsOn: {
        setting: "optionsSource",
        value: "provider"
      }
    },
    {
      type: "field",
      label: "Value column",
      key: "valueColumn",
      dependsOn: {
        setting: "optionsSource",
        value: "provider"
      }
    },
    {
      type: "options",
      label: "Custom options",
      key: "customOptions",
      dependsOn: {
        setting: "optionsSource",
        value: "custom"
      }
    },
    {
      type: "validation/array",
      label: "Validation",
      key: "validation"
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "array"
      }
    ]
  }
}, booleanfield$1 = {
  name: "Checkbox",
  icon: "check-square",
  editable: !0,
  size: {
    width: 400,
    height: 60
  },
  settings: [
    {
      type: "field/boolean",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Text",
      key: "text"
    },
    {
      type: "select",
      label: "Size",
      key: "size",
      options: [
        {
          label: "Small",
          value: "S"
        },
        {
          label: "Medium",
          value: "M"
        },
        {
          label: "Large",
          value: "L"
        },
        {
          label: "Extra large",
          value: "XL"
        }
      ],
      defaultValue: "M"
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue",
      supportsConditions: !1
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "readonly",
      defaultValue: !1,
      dependsOn: {
        setting: "disabled",
        value: !0,
        invert: !0
      }
    },
    {
      type: "validation/boolean",
      label: "Validation",
      key: "validation"
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "boolean"
      }
    ]
  }
}, longformfield$1 = {
  name: "Long Form Field",
  icon: "text-align-left",
  styles: [
    "size"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 100
  },
  settings: [
    {
      type: "field/longform",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Placeholder",
      key: "placeholder",
      placeholder: "Type something..."
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue",
      supportsConditions: !1
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "select",
      label: "Formatting",
      key: "format",
      placeholder: null,
      options: [
        {
          label: "Auto",
          value: "auto"
        },
        {
          label: "Plain text",
          value: "plain"
        },
        {
          label: "Rich text (markdown)",
          value: "rich"
        }
      ],
      defaultValue: "auto"
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "readonly",
      defaultValue: !1,
      dependsOn: {
        setting: "disabled",
        value: !0,
        invert: !0
      }
    },
    {
      type: "validation/string",
      label: "Validation",
      key: "validation"
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "string"
      }
    ]
  }
}, datetimefield$1 = {
  name: "Date Picker",
  icon: "calendar",
  styles: [
    "size"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 60
  },
  settings: [
    {
      type: "field/datetime",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Placeholder",
      key: "placeholder"
    },
    {
      type: "boolean",
      label: "Show time",
      key: "enableTime",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Time only",
      key: "timeOnly",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Ignore time zones",
      key: "ignoreTimezones",
      defaultValue: !1
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue",
      supportsConditions: !1
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "readonly",
      defaultValue: !1,
      dependsOn: {
        setting: "disabled",
        value: !0,
        invert: !0
      }
    },
    {
      type: "validation/datetime",
      label: "Validation",
      key: "validation"
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "datetime"
      }
    ]
  }
}, codescanner$1 = {
  name: "Barcode/QR Scanner",
  icon: "barcode",
  styles: [
    "size"
  ],
  size: {
    width: 400,
    height: 60
  },
  settings: [
    {
      type: "field/barcodeqr",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Button text",
      key: "scanButtonText"
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue",
      supportsConditions: !1
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Manual entry",
      key: "allowManualEntry",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Auto confirm",
      key: "autoConfirm",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Play sound on scan",
      key: "beepOnScan",
      defaultValue: !1
    },
    {
      type: "select",
      label: "Sound pitch",
      key: "beepFrequency",
      dependsOn: "beepOnScan",
      defaultValue: 2637,
      options: [
        {
          label: "Low",
          value: 2096
        },
        {
          label: "Regular",
          value: 2637
        },
        {
          label: "High",
          value: 3136
        },
        {
          label: "Custom",
          value: "custom"
        }
      ]
    },
    {
      type: "number",
      label: "Sound frequency (Hz)",
      key: "customFrequency",
      defaultValue: 1046,
      min: 20,
      max: 8e3,
      dependsOn: {
        setting: "beepFrequency",
        value: "custom"
      }
    },
    {
      type: "select",
      label: "Preferred camera",
      key: "preferredCamera",
      defaultValue: "environment",
      options: [
        {
          label: "Front",
          value: "user"
        },
        {
          label: "Back",
          value: "environment"
        }
      ]
    },
    {
      type: "text",
      label: "Zoom level",
      key: "defaultZoom",
      defaultValue: "1"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "validation/string",
      label: "Validation",
      key: "validation"
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "string"
      }
    ]
  }
}, codegenerator$1 = {
  name: "Barcode/QR Generator",
  icon: "Vignette",
  new: !0,
  settings: [
    {
      type: "radio",
      label: "Barcode/QR",
      key: "codeType",
      options: [
        "QR Code",
        "Barcode"
      ],
      defaultValue: "QR Code"
    },
    {
      type: "select",
      label: "Size",
      key: "size",
      defaultValue: 200,
      required: !0,
      options: [
        {
          label: "X Small",
          value: 75
        },
        {
          label: "Small",
          value: 150
        },
        {
          label: "Medium",
          value: 200
        },
        {
          label: "Large",
          value: 250
        },
        {
          label: "X Large",
          value: 300
        },
        {
          label: "XX Large",
          value: 350
        },
        {
          label: "XXX Large",
          value: 400
        }
      ]
    },
    {
      type: "text",
      key: "value",
      label: "Value",
      defaultValue: "https://docs.budibase.com/"
    },
    {
      type: "boolean",
      key: "showValue",
      label: "Display value",
      defaultValue: !0
    },
    {
      section: !0,
      name: "Customisation",
      settings: [
        {
          type: "boolean",
          key: "showLogo",
          label: "Show Logo",
          defaultValue: !0
        },
        {
          type: "text",
          key: "customLogo",
          label: "Logo",
          dependsOn: {
            setting: "showLogo",
            value: !0
          }
        }
      ]
    },
    {
      section: !0,
      name: "Appearance",
      settings: [
        {
          type: "color",
          label: "Primary color",
          key: "primColor",
          defaultValue: "#000",
          dependsOn: {
            setting: "codeType",
            value: "QR Code",
            invert: !1
          }
        }
      ]
    }
  ]
}, signaturesinglefield$1 = {
  name: "Signature",
  icon: "signature",
  styles: [
    "size"
  ],
  size: {
    width: 400,
    height: 60
  },
  requiredAncestors: [
    "form"
  ],
  settings: [
    {
      type: "field/signature_single",
      label: "Field",
      key: "field",
      required: !0
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "text",
      label: "Button text",
      key: "buttonText",
      defaultValue: "Add signature",
      placeholder: "Add signature"
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "validation/signature_single",
      label: "Validation",
      key: "validation"
    }
  ]
}, embeddedmap$1 = {
  name: "Embedded Map",
  icon: "map-pin",
  styles: [
    "size"
  ],
  draggable: !1,
  size: {
    width: 400,
    height: 320
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      type: "dataProvider",
      label: "Provider",
      key: "dataProvider"
    },
    {
      type: "field",
      label: "Latitude key",
      key: "latitudeKey",
      dependsOn: "dataProvider"
    },
    {
      type: "field",
      label: "Longitude key",
      key: "longitudeKey",
      dependsOn: "dataProvider"
    },
    {
      type: "field",
      label: "Title key",
      key: "titleKey",
      dependsOn: "dataProvider"
    },
    {
      type: "event",
      label: "On click marker",
      key: "onClickMarker",
      context: [
        {
          label: "Clicked marker",
          key: "marker"
        }
      ]
    },
    {
      type: "boolean",
      label: "Enable adding",
      key: "creationEnabled",
      defaultValue: !1
    },
    {
      type: "event",
      label: "On create marker",
      key: "onCreateMarker",
      dependsOn: "creationEnabled",
      context: [
        {
          label: "New marker latitude",
          key: "lat"
        },
        {
          label: "New marker longitude",
          key: "lng"
        }
      ]
    },
    {
      type: "boolean",
      label: "Enable fullscreen",
      key: "fullScreenEnabled",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Enable location",
      key: "locationEnabled",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Enable zoom",
      key: "zoomEnabled",
      defaultValue: !0
    },
    {
      type: "text",
      label: "Tile URL",
      key: "tileURL",
      defaultValue: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
    },
    {
      type: "text",
      label: "Default location",
      key: "defaultLocation",
      placeholder: "51.5072,-0.1276"
    },
    {
      type: "number",
      label: "Default zoom (0-100)",
      key: "zoomLevel",
      placeholder: 50,
      max: 100,
      min: 0
    },
    {
      type: "text",
      label: "Map attribution",
      key: "mapAttribution",
      defaultValue: "OpenStreetMap contributors"
    }
  ]
}, attachmentfield$1 = {
  name: "Attachment List",
  icon: "files",
  styles: [
    "size"
  ],
  requiredAncestors: [
    "form"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 200
  },
  settings: [
    {
      type: "field/attachment",
      label: "Field",
      key: "field",
      required: !0
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "text",
      label: "Extensions",
      key: "extensions"
    },
    {
      type: "number",
      label: "Max attachments",
      key: "maximum",
      min: 1
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "boolean",
      label: "Compact",
      key: "compact",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "validation/attachment",
      label: "Validation",
      key: "validation"
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    },
    {
      section: !0,
      name: "Uploader Text Settings",
      dependsOn: [
        {
          setting: "disabled",
          value: !1
        }
      ],
      settings: [
        {
          type: "text",
          label: "Title Text",
          key: "titleText",
          dependsOn: {
            setting: "compact",
            value: !1
          }
        },
        {
          type: "text",
          label: "Upload text",
          key: "clickText"
        },
        {
          type: "text",
          label: "Sub text",
          key: "addText",
          dependsOn: {
            setting: "compact",
            value: !1
          }
        }
      ]
    }
  ]
}, attachmentsinglefield$1 = {
  name: "Single Attachment",
  icon: "file",
  styles: [
    "size"
  ],
  requiredAncestors: [
    "form"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 200
  },
  settings: [
    {
      type: "field/attachment_single",
      label: "Field",
      key: "field",
      required: !0
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "text",
      label: "Extensions",
      key: "extensions"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "boolean",
      label: "Compact",
      key: "compact",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "validation/attachment_single",
      label: "Validation",
      key: "validation"
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    },
    {
      section: !0,
      name: "Uploader Text Settings",
      dependsOn: [
        {
          setting: "disabled",
          value: !1
        }
      ],
      settings: [
        {
          type: "text",
          label: "Title Text",
          key: "titleText",
          dependsOn: {
            setting: "compact",
            value: !1
          }
        },
        {
          type: "text",
          label: "Upload text",
          key: "clickText"
        },
        {
          type: "text",
          label: "Sub text",
          key: "addText",
          dependsOn: {
            setting: "compact",
            value: !1
          }
        }
      ]
    }
  ]
}, relationshipfield$1 = {
  name: "Relationship Picker",
  icon: "git-fork",
  styles: [
    "size"
  ],
  requiredAncestors: [
    "form"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 60
  },
  settings: [
    {
      type: "field/link",
      label: "Field",
      key: "field",
      required: !0
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Placeholder",
      key: "placeholder"
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue",
      supportsConditions: !1
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "validation/link",
      label: "Validation",
      key: "validation"
    },
    {
      type: "filter/relationship",
      label: "Filtering",
      key: "filter"
    },
    {
      type: "boolean",
      label: "Search",
      key: "autocomplete",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "readonly",
      defaultValue: !1,
      dependsOn: {
        setting: "disabled",
        value: !0,
        invert: !0
      }
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ]
}, jsonfield$1 = {
  name: "JSON Field",
  icon: "brackets-curly",
  styles: [
    "size"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 100
  },
  settings: [
    {
      type: "field/json",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Placeholder",
      key: "placeholder"
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue",
      supportsConditions: !1
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "readonly",
      defaultValue: !1,
      dependsOn: {
        setting: "disabled",
        value: !0,
        invert: !0
      }
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "string"
      }
    ]
  }
}, s3upload$1 = {
  name: "S3 File Upload",
  icon: "cloud-arrow-up",
  styles: [
    "size"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 200
  },
  settings: [
    {
      type: "field/s3",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "dataSource/s3",
      label: "S3 datasource",
      key: "datasourceId",
      info: "This component can't be used with S3 datasources that use custom endpoints"
    },
    {
      type: "text",
      label: "Bucket",
      key: "bucket"
    },
    {
      type: "text",
      label: "File name",
      key: "key",
      nested: !0
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "validation/attachment",
      label: "Validation",
      key: "validation"
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "array"
      }
    ]
  }
}, dataprovider$1 = {
  name: "Data Provider",
  icon: "database",
  illegalChildren: [
    "section"
  ],
  hasChildren: !0,
  actions: [
    "RefreshDatasource",
    "AddDataProviderQueryExtension"
  ],
  size: {
    width: 500,
    height: 200
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      type: "dataSource",
      label: "Data",
      key: "dataSource",
      required: !0
    },
    {
      type: "select",
      label: "Auto-refresh",
      key: "autoRefresh",
      license: "premium",
      placeholder: "Never",
      options: [
        {
          label: "10 seconds",
          value: 10
        },
        {
          label: "30 seconds",
          value: 30
        },
        {
          label: "1 minute",
          value: 60
        },
        {
          label: "5 minutes",
          value: 300
        },
        {
          label: "10 minutes",
          value: 600
        }
      ]
    },
    {
      type: "filter",
      label: "Filtering",
      key: "filter",
      resetOn: "dataSource"
    },
    {
      type: "field/sortable",
      label: "Sort column",
      key: "sortColumn",
      placeholder: "None"
    },
    {
      type: "select",
      label: "Sort order",
      key: "sortOrder",
      options: [
        "Ascending",
        "Descending"
      ],
      defaultValue: "Ascending"
    },
    {
      type: "number",
      label: "Limit",
      key: "limit",
      defaultValue: 50
    },
    {
      type: "boolean",
      label: "Paginate",
      key: "paginate",
      defaultValue: !0,
      info: "Pagination is only available for data stored in tables"
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Rows",
        key: "rows",
        type: "array"
      },
      {
        label: "Extra Info",
        key: "info",
        type: "string"
      },
      {
        label: "Rows Length",
        key: "rowsLength",
        type: "number"
      },
      {
        label: "Schema",
        key: "schema",
        type: "object"
      },
      {
        label: "Page Number",
        key: "pageNumber",
        type: "number"
      }
    ]
  }
}, table$1 = {
  deprecated: !0,
  name: "Table",
  icon: "table",
  illegalChildren: [
    "section"
  ],
  hasChildren: !0,
  showEmptyState: !1,
  actions: [
    "ClearRowSelection"
  ],
  size: {
    width: 600,
    height: 400
  },
  settings: [
    {
      type: "dataProvider",
      label: "Data provider",
      key: "dataProvider",
      required: !0
    },
    {
      type: "columns",
      label: "Columns",
      key: "columns",
      dependsOn: "dataProvider",
      nested: !0
    },
    {
      type: "select",
      label: "Size",
      key: "size",
      defaultValue: "spectrum--medium",
      options: [
        {
          label: "Medium",
          value: "spectrum--medium"
        },
        {
          label: "Large",
          value: "spectrum--large"
        }
      ]
    },
    {
      type: "number",
      label: "Row count",
      key: "rowCount",
      defaultValue: 8
    },
    {
      type: "boolean",
      label: "Quiet",
      key: "quiet"
    },
    {
      type: "boolean",
      label: "Compact",
      key: "compact"
    },
    {
      type: "boolean",
      label: "Row selection",
      key: "allowSelectRows",
      defaultValue: !1,
      info: "Row selection is only compatible with internal or SQL tables"
    },
    {
      type: "text",
      label: "Empty text",
      key: "noRowsMessage",
      defaultValue: "No rows found"
    },
    {
      section: !0,
      name: "On Row Click",
      settings: [
        {
          type: "event",
          key: "onClick",
          context: [
            {
              label: "Clicked row",
              key: "row"
            }
          ]
        }
      ]
    }
  ],
  context: [
    {
      type: "schema",
      scope: "local"
    },
    {
      type: "static",
      values: [
        {
          label: "Selected Rows",
          key: "selectedRows",
          type: "array"
        }
      ]
    }
  ]
}, daterangepicker$1 = {
  name: "Date Range",
  icon: "calendar-plus",
  styles: [
    "size"
  ],
  hasChildren: !1,
  size: {
    width: 200,
    height: 50
  },
  settings: [
    {
      type: "dataProvider",
      label: "Provider",
      key: "dataProvider",
      required: !0,
      info: "Your data provider will be automatically filtered to the given date range."
    },
    {
      type: "field",
      label: "Date field",
      key: "field",
      required: !0
    },
    {
      type: "select",
      label: "Default range",
      key: "defaultValue",
      options: [
        "Last 1 day",
        "Last 7 days",
        "Last 30 days",
        "Last 3 months",
        "Last 6 months",
        "Last 1 year"
      ],
      defaultValue: "Last 30 days"
    }
  ]
}, spectrumcard$1 = {
  name: "Card",
  icon: "cards",
  styles: [
    "size"
  ],
  size: {
    width: 300,
    height: 120
  },
  grid: {
    hAlign: "center",
    vAlign: "center"
  },
  settings: [
    {
      type: "text",
      key: "title",
      label: "Title",
      defaultValue: "Title"
    },
    {
      type: "text",
      key: "subtitle",
      label: "Subtitle",
      defaultValue: "Subtitle"
    },
    {
      type: "text",
      key: "description",
      label: "Description",
      defaultValue: "Description"
    },
    {
      type: "text",
      key: "imageURL",
      label: "Image URL"
    },
    {
      type: "url",
      key: "linkURL",
      label: "Link URL"
    },
    {
      type: "boolean",
      key: "linkPeek",
      label: "Open in modal"
    },
    {
      type: "boolean",
      key: "horizontal",
      label: "Horizontal"
    },
    {
      type: "boolean",
      key: "showButton",
      label: "Show button"
    },
    {
      type: "text",
      key: "buttonText",
      label: "Button text",
      dependsOn: "showButton"
    },
    {
      type: "event",
      label: "Click action",
      key: "buttonOnClick"
    }
  ]
}, filter$1 = {
  name: "Filter",
  icon: "funnel",
  size: {
    width: 100,
    height: 35
  },
  new: !0,
  settings: [
    {
      type: "dataSource/filterable",
      label: "Target component",
      required: !0,
      key: "targetComponent",
      wide: !0
    },
    {
      type: "select",
      label: "Size",
      showInBar: !0,
      key: "size",
      options: [
        {
          label: "Small",
          value: "S"
        },
        {
          label: "Medium",
          value: "M"
        },
        {
          label: "Large",
          value: "L"
        }
      ],
      defaultValue: "M",
      wide: !0
    },
    {
      type: "text",
      key: "buttonText",
      label: "Button text",
      placeholder: "Apply",
      defaultValue: "Apply"
    },
    {
      type: "boolean",
      label: "Persist filters",
      key: "persistFilters",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Clear filters",
      key: "showClear",
      defaultValue: !1
    },
    {
      label: "",
      type: "filterConfiguration",
      key: "filterConfig",
      nested: !0,
      dependsOn: "targetComponent",
      resetOn: "targetComponent"
    }
  ]
}, filterconfig = {
  name: "",
  icon: "funnel-simple",
  editable: !0,
  settings: [
    {
      type: "plainText",
      label: "Label",
      key: "label"
    }
  ]
}, dynamicfilter$1 = {
  deprecated: !0,
  name: "Dynamic Filter",
  icon: "funnel",
  size: {
    width: 100,
    height: 35
  },
  grid: {
    hAlign: "center",
    vAlign: "center"
  },
  settings: [
    {
      type: "dataProvider",
      label: "Provider",
      key: "dataProvider",
      required: !0
    },
    {
      type: "columns/basic",
      label: "Allowed filter columns",
      key: "allowedFields",
      dependsOn: "dataProvider"
    },
    {
      type: "select",
      label: "Button size",
      showInBar: !0,
      key: "size",
      options: [
        {
          label: "Small",
          value: "S"
        },
        {
          label: "Medium",
          value: "M"
        },
        {
          label: "Large",
          value: "L"
        },
        {
          label: "Extra large",
          value: "XL"
        }
      ],
      defaultValue: "M"
    }
  ]
}, chartblock$1 = {
  documentationLink: "https://docs.budibase.com/docs/chart",
  block: !0,
  name: "Chart Block",
  icon: "chart-pie",
  hasChildren: !1,
  size: {
    width: 600,
    height: 420
  },
  grid: {
    hAlign: "stretch",
    vAlign: "center"
  },
  settings: [
    {
      type: "select",
      label: "Chart type",
      key: "chartType",
      required: !0,
      options: [
        {
          label: "Pie",
          value: "pie"
        },
        {
          label: "Bar",
          value: "bar"
        },
        {
          label: "Histogram",
          value: "histogram"
        },
        {
          label: "Line",
          value: "line"
        },
        {
          label: "Donut",
          value: "donut"
        },
        {
          label: "Candlestick",
          value: "candlestick"
        },
        {
          label: "Area",
          value: "area"
        }
      ]
    },
    {
      type: "dataSource",
      label: "Data",
      key: "dataSource",
      required: !0
    },
    {
      type: "select",
      label: "Auto-refresh",
      key: "autoRefresh",
      license: "premium",
      placeholder: "Never",
      options: [
        {
          label: "10 seconds",
          value: 10
        },
        {
          label: "30 seconds",
          value: 30
        },
        {
          label: "1 minute",
          value: 60
        },
        {
          label: "5 minutes",
          value: 300
        },
        {
          label: "10 minutes",
          value: 600
        }
      ]
    },
    {
      type: "text",
      label: "Title",
      key: "chartTitle"
    },
    {
      type: "filter",
      label: "Filtering",
      key: "filter",
      nested: !0
    },
    {
      type: "field",
      label: "Sort column",
      key: "sortColumn"
    },
    {
      type: "select",
      label: "Sort order",
      key: "sortOrder",
      options: [
        "Ascending",
        "Descending"
      ],
      defaultValue: "Ascending"
    },
    {
      type: "number",
      label: "Limit",
      key: "limit",
      defaultValue: 50
    },
    {
      type: "text",
      label: "Width",
      key: "width"
    },
    {
      type: "text",
      label: "Height",
      key: "height",
      defaultValue: "400"
    },
    {
      type: "select",
      label: "Colors",
      key: "palette",
      defaultValue: "Palette 1",
      options: [
        "Custom",
        "Palette 1",
        "Palette 2",
        "Palette 3",
        "Palette 4",
        "Palette 5",
        "Palette 6",
        "Palette 7",
        "Palette 8",
        "Palette 9",
        "Palette 10"
      ]
    },
    {
      type: "color",
      label: "C1",
      key: "c1",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C2",
      key: "c2",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C3",
      key: "c3",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C4",
      key: "c4",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "color",
      label: "C5",
      key: "c5",
      dependsOn: {
        setting: "palette",
        value: "Custom"
      }
    },
    {
      type: "boolean",
      label: "Data labels",
      key: "dataLabels",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Legend",
      key: "legend",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Animate",
      key: "animate",
      defaultValue: !1
    },
    {
      section: !0,
      name: "Pie Chart",
      icon: "chart-pie",
      dependsOn: {
        setting: "chartType",
        value: "pie"
      },
      settings: [
        {
          type: "field",
          label: "Label column",
          key: "labelColumn",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "stringLike"
            }
          },
          required: !0
        },
        {
          type: "field",
          label: "Data column",
          key: "valueColumn",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "numberLike"
            }
          },
          required: !0
        }
      ]
    },
    {
      section: !0,
      name: "Donut Chart",
      icon: "chart-donut",
      dependsOn: {
        setting: "chartType",
        value: "donut"
      },
      settings: [
        {
          type: "field",
          label: "Label column",
          key: "labelColumn",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "stringLike"
            }
          },
          required: !0
        },
        {
          type: "field",
          label: "Data column",
          key: "valueColumn",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "numberLike"
            }
          },
          required: !0
        }
      ]
    },
    {
      section: !0,
      name: "Bar Chart",
      icon: "chart-bar",
      dependsOn: {
        setting: "chartType",
        value: "bar"
      },
      settings: [
        {
          type: "field",
          label: "Label column",
          key: "labelColumn",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "stringLike"
            }
          },
          required: !0
        },
        {
          type: "multifield",
          label: "Data columns",
          key: "valueColumns",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "numberLike"
            }
          },
          required: !0
        },
        {
          type: "select",
          label: "Format",
          key: "yAxisUnits",
          options: [
            "Default",
            "Thousands",
            "Millions"
          ],
          defaultValue: "Default"
        },
        {
          type: "text",
          label: "Y axis label",
          key: "yAxisLabel"
        },
        {
          type: "text",
          label: "X axis label",
          key: "xAxisLabel"
        },
        {
          type: "boolean",
          label: "Stacked",
          key: "stacked",
          defaultValue: !1
        },
        {
          type: "boolean",
          label: "Horizontal",
          key: "horizontal",
          defaultValue: !1
        }
      ]
    },
    {
      section: !0,
      name: "Histogram Chart",
      icon: "chart-bar",
      dependsOn: {
        setting: "chartType",
        value: "histogram"
      },
      settings: [
        {
          type: "field",
          label: "Value column",
          key: "valueColumn",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "numberLike"
            }
          },
          required: !0
        },
        {
          type: "text",
          label: "Y axis label",
          key: "yAxisLabel"
        },
        {
          type: "text",
          label: "X axis label",
          key: "xAxisLabel"
        },
        {
          type: "boolean",
          label: "Horizontal",
          key: "horizontal",
          defaultValue: !1
        },
        {
          type: "number",
          label: "Bucket count",
          key: "bucketCount",
          defaultValue: 10,
          min: 2
        }
      ]
    },
    {
      section: !0,
      name: "Line Chart",
      icon: "chart-line",
      dependsOn: {
        setting: "chartType",
        value: "line"
      },
      settings: [
        {
          type: "field",
          label: "Label column",
          key: "labelColumn",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "stringLike"
            }
          },
          required: !0
        },
        {
          type: "multifield",
          label: "Data columns",
          key: "valueColumns",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "numberLike"
            }
          },
          required: !0
        },
        {
          type: "select",
          label: "Format",
          key: "yAxisUnits",
          options: [
            "Default",
            "Thousands",
            "Millions"
          ],
          defaultValue: "Default"
        },
        {
          type: "text",
          label: "Y axis label",
          key: "yAxisLabel"
        },
        {
          type: "text",
          label: "X axis label",
          key: "xAxisLabel"
        },
        {
          type: "select",
          label: "Curve",
          key: "curve",
          options: [
            "Smooth",
            "Straight",
            "Stepline"
          ],
          defaultValue: "Smooth"
        }
      ]
    },
    {
      section: !0,
      name: "Area Chart",
      icon: "chart-line-up",
      dependsOn: {
        setting: "chartType",
        value: "area"
      },
      settings: [
        {
          type: "field",
          label: "Label columns",
          key: "labelColumn",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "stringLike"
            }
          },
          required: !0
        },
        {
          type: "multifield",
          label: "Data columns",
          key: "valueColumns",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "numberLike"
            }
          },
          required: !0
        },
        {
          type: "select",
          label: "Format",
          key: "yAxisUnits",
          options: [
            "Default",
            "Thousands",
            "Millions"
          ],
          defaultValue: "Default"
        },
        {
          type: "text",
          label: "Y axis label",
          key: "yAxisLabel"
        },
        {
          type: "text",
          label: "X axis label",
          key: "xAxisLabel"
        },
        {
          type: "select",
          label: "Curve",
          key: "curve",
          options: [
            "Smooth",
            "Straight",
            "Stepline"
          ],
          defaultValue: "Smooth"
        },
        {
          type: "boolean",
          label: "Stacked",
          key: "stacked",
          defaultValue: !0
        },
        {
          type: "boolean",
          label: "Gradient",
          key: "gradient",
          defaultValue: !1
        }
      ]
    },
    {
      section: !0,
      name: "Candlestick Chart",
      icon: "chart-bar",
      dependsOn: {
        setting: "chartType",
        value: "candlestick"
      },
      settings: [
        {
          type: "field",
          label: "Date column",
          key: "dateColumn",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "datetimeLike"
            }
          },
          required: !0
        },
        {
          type: "field",
          label: "Open column",
          key: "openColumn",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "numberLike"
            }
          },
          required: !0
        },
        {
          type: "field",
          label: "Close column",
          key: "closeColumn",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "numberLike"
            }
          },
          required: !0
        },
        {
          type: "field",
          label: "High column",
          key: "highColumn",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "numberLike"
            }
          },
          required: !0
        },
        {
          type: "field",
          label: "Low column",
          key: "lowColumn",
          dependsOn: "dataSource",
          explanation: {
            typeSupport: {
              preset: "numberLike"
            }
          },
          required: !0
        },
        {
          type: "select",
          label: "Format",
          key: "yAxisUnits",
          options: [
            "Default",
            "Thousands",
            "Millions"
          ],
          defaultValue: "Default"
        },
        {
          type: "text",
          label: "Y axis label",
          key: "yAxisLabel"
        },
        {
          type: "text",
          label: "X axis label",
          key: "xAxisLabel"
        }
      ]
    }
  ]
}, tableblock$1 = {
  deprecated: !0,
  block: !0,
  name: "Table Block",
  icon: "table",
  styles: [
    "size"
  ],
  size: {
    width: 600,
    height: 400
  },
  settings: [
    {
      type: "text",
      label: "Title",
      key: "title"
    },
    {
      section: !0,
      name: "Table",
      settings: [
        {
          type: "dataSource",
          label: "Data",
          key: "dataSource",
          required: !0
        },
        {
          type: "select",
          label: "Auto-refresh",
          key: "autoRefresh",
          license: "premium",
          placeholder: "Never",
          options: [
            {
              label: "10 seconds",
              value: 10
            },
            {
              label: "30 seconds",
              value: 30
            },
            {
              label: "1 minute",
              value: 60
            },
            {
              label: "5 minutes",
              value: 300
            },
            {
              label: "10 minutes",
              value: 600
            }
          ]
        },
        {
          type: "columns",
          label: "Columns",
          key: "tableColumns",
          dependsOn: "dataSource",
          placeholder: "All columns",
          nested: !0
        },
        {
          type: "field/sortable",
          label: "Sort by",
          key: "sortColumn",
          placeholder: "Default"
        },
        {
          type: "select",
          label: "Sort order",
          key: "sortOrder",
          options: [
            "Ascending",
            "Descending"
          ],
          defaultValue: "Ascending",
          dependsOn: "sortColumn"
        },
        {
          type: "select",
          label: "Size",
          key: "size",
          defaultValue: "spectrum--medium",
          options: [
            {
              label: "Medium",
              value: "spectrum--medium"
            },
            {
              label: "Large",
              value: "spectrum--large"
            }
          ]
        },
        {
          type: "number",
          label: "Scroll limit",
          key: "rowCount",
          defaultValue: 8
        },
        {
          type: "boolean",
          label: "Paginate",
          key: "paginate",
          defaultValue: !0
        },
        {
          type: "boolean",
          label: "Quiet",
          key: "quiet"
        },
        {
          type: "boolean",
          label: "Compact",
          key: "compact"
        },
        {
          type: "boolean",
          label: "Row selection",
          key: "allowSelectRows",
          info: "Row selection is only compatible with internal or SQL tables"
        },
        {
          type: "filter",
          label: "Filtering",
          key: "filter",
          nested: !0
        },
        {
          type: "text",
          label: "Empty text",
          key: "noRowsMessage",
          defaultValue: "No rows found"
        },
        {
          type: "searchfield",
          label: "Search fields",
          key: "searchColumns",
          placeholder: "Choose search fields",
          info: "Only the first 5 fields will be used"
        }
      ]
    },
    {
      section: !0,
      name: "On row click",
      settings: [
        {
          label: "Behaviour",
          labelHidden: !0,
          type: "radio",
          key: "clickBehaviour",
          sendEvents: !0,
          defaultValue: "actions",
          info: "Details side panel is only compatible with internal or SQL tables",
          options: [
            {
              label: "Run actions",
              value: "actions"
            },
            {
              label: "Show details side panel",
              value: "details"
            }
          ]
        },
        {
          label: "Actions",
          labelHidden: !0,
          type: "event",
          key: "onClick",
          nested: !0,
          dependsOn: {
            setting: "clickBehaviour",
            value: "actions"
          },
          context: [
            {
              label: "Clicked row",
              key: "row"
            }
          ]
        },
        {
          label: "",
          type: "fieldConfiguration",
          key: "sidePanelFields",
          nested: !0,
          dependsOn: {
            setting: "clickBehaviour",
            value: "details"
          },
          resetOn: "dataSource"
        },
        {
          label: "Save button",
          type: "text",
          key: "sidePanelSaveLabel",
          defaultValue: "Save",
          nested: !0,
          dependsOn: {
            setting: "clickBehaviour",
            value: "details"
          }
        },
        {
          label: "Delete button",
          type: "text",
          key: "sidePanelDeleteLabel",
          defaultValue: "Delete",
          nested: !0,
          dependsOn: {
            setting: "clickBehaviour",
            value: "details"
          }
        },
        {
          type: "boolean",
          label: "Hide notifications",
          key: "notificationOverride",
          defaultValue: !1,
          dependsOn: {
            setting: "clickBehaviour",
            value: "details"
          }
        }
      ]
    },
    {
      section: !0,
      name: "Button",
      settings: [
        {
          type: "boolean",
          key: "showTitleButton",
          label: "Show button",
          defaultValue: !1
        },
        {
          type: "text",
          key: "titleButtonText",
          label: "Text",
          defaultValue: "Create row",
          dependsOn: "showTitleButton"
        },
        {
          type: "radio",
          key: "titleButtonClickBehaviour",
          label: "Behaviour",
          dependsOn: "showTitleButton",
          defaultValue: "actions",
          info: "New row side panel is only compatible with internal or SQL tables",
          options: [
            {
              label: "Run actions",
              value: "actions"
            },
            {
              label: "Show new row side panel",
              value: "new"
            }
          ]
        },
        {
          type: "event",
          label: "On click",
          key: "onClickTitleButton",
          nested: !0,
          dependsOn: {
            setting: "titleButtonClickBehaviour",
            value: "actions"
          }
        }
      ]
    }
  ],
  context: [
    {
      type: "static",
      suffix: "provider",
      values: [
        {
          label: "Rows",
          key: "rows",
          type: "array"
        },
        {
          label: "Extra Info",
          key: "info",
          type: "string"
        },
        {
          label: "Rows Length",
          key: "rowsLength",
          type: "number"
        },
        {
          label: "Schema",
          key: "schema",
          type: "object"
        },
        {
          label: "Page Number",
          key: "pageNumber",
          type: "number"
        }
      ]
    },
    {
      type: "static",
      suffix: "table",
      values: [
        {
          label: "Selected Rows",
          key: "selectedRows",
          type: "array"
        }
      ]
    }
  ]
}, cardsblock$1 = {
  block: !0,
  name: "Cards Block",
  icon: "cards",
  styles: [
    "size"
  ],
  size: {
    width: 600,
    height: 400
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      type: "text",
      label: "Title",
      key: "title"
    },
    {
      type: "dataSource",
      label: "Data",
      key: "dataSource",
      required: !0
    },
    {
      type: "select",
      label: "Auto-refresh",
      key: "autoRefresh",
      license: "premium",
      placeholder: "Never",
      options: [
        {
          label: "10 seconds",
          value: 10
        },
        {
          label: "30 seconds",
          value: 30
        },
        {
          label: "1 minute",
          value: 60
        },
        {
          label: "5 minutes",
          value: 300
        },
        {
          label: "10 minutes",
          value: 600
        }
      ]
    },
    {
      type: "searchfield",
      label: "Search columns",
      key: "searchColumns",
      placeholder: "Choose search columns",
      info: "Max 5 columns will be used"
    },
    {
      type: "filter",
      label: "Filtering",
      key: "filter",
      nested: !0
    },
    {
      type: "field/sortable",
      label: "Sort column",
      key: "sortColumn",
      placeholder: "None"
    },
    {
      type: "select",
      label: "Sort order",
      key: "sortOrder",
      options: [
        "Ascending",
        "Descending"
      ],
      defaultValue: "Descending"
    },
    {
      type: "number",
      label: "Limit",
      key: "limit",
      defaultValue: 8
    },
    {
      type: "boolean",
      label: "Paginate",
      key: "paginate"
    },
    {
      type: "text",
      label: "Empty text",
      key: "noRowsMessage",
      defaultValue: "No rows found"
    },
    {
      section: !0,
      name: "Cards",
      settings: [
        {
          type: "text",
          key: "cardTitle",
          label: "Title",
          nested: !0,
          resetOn: "dataSource"
        },
        {
          type: "text",
          key: "cardSubtitle",
          label: "Subtitle",
          nested: !0,
          resetOn: "dataSource"
        },
        {
          type: "text",
          key: "cardDescription",
          label: "Description",
          nested: !0,
          resetOn: "dataSource"
        },
        {
          type: "text",
          key: "cardImageURL",
          label: "Image URL",
          nested: !0,
          resetOn: "dataSource"
        },
        {
          type: "boolean",
          key: "linkCardTitle",
          label: "Link card title"
        },
        {
          type: "boolean",
          key: "cardPeek",
          label: "Open in modal"
        },
        {
          type: "url",
          label: "Link screen",
          key: "cardURL",
          nested: !0
        },
        {
          type: "boolean",
          key: "cardHorizontal",
          label: "Horizontal"
        },
        {
          type: "boolean",
          label: "Add button",
          key: "showCardButton"
        },
        {
          type: "text",
          key: "cardButtonText",
          label: "Button text",
          nested: !0,
          dependsOn: "showCardButton"
        },
        {
          type: "event",
          label: "Click action",
          key: "cardButtonOnClick",
          nested: !0
        }
      ]
    },
    {
      section: !0,
      name: "Title button",
      settings: [
        {
          type: "boolean",
          key: "showTitleButton",
          label: "Show button"
        },
        {
          type: "boolean",
          label: "Open in modal",
          key: "titleButtonPeek"
        },
        {
          type: "text",
          key: "titleButtonText",
          label: "Button text"
        },
        {
          type: "url",
          label: "Button link",
          key: "titleButtonURL"
        }
      ]
    },
    {
      section: !0,
      name: "Advanced",
      settings: [
        {
          type: "field",
          label: "ID column",
          key: "linkColumn",
          placeholder: "Default"
        }
      ]
    }
  ],
  context: {
    type: "schema",
    suffix: "repeater",
    scope: "local"
  }
}, repeaterblock$1 = {
  block: !0,
  name: "Repeater Block",
  icon: "list-dashes",
  illegalChildren: [
    "section",
    "rowexplorer"
  ],
  hasChildren: !0,
  size: {
    width: 500,
    height: 200
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      type: "dataSource",
      label: "Data",
      key: "dataSource",
      required: !0
    },
    {
      type: "select",
      label: "Auto-refresh",
      key: "autoRefresh",
      license: "premium",
      placeholder: "Never",
      options: [
        {
          label: "10 seconds",
          value: 10
        },
        {
          label: "30 seconds",
          value: 30
        },
        {
          label: "1 minute",
          value: 60
        },
        {
          label: "5 minutes",
          value: 300
        },
        {
          label: "10 minutes",
          value: 600
        }
      ]
    },
    {
      type: "filter",
      label: "Filtering",
      key: "filter",
      nested: !0
    },
    {
      type: "field/sortable",
      label: "Sort column",
      key: "sortColumn",
      placeholder: "None"
    },
    {
      type: "select",
      label: "Sort order",
      key: "sortOrder",
      options: [
        "Ascending",
        "Descending"
      ],
      defaultValue: "Descending"
    },
    {
      type: "number",
      label: "Limit",
      key: "limit",
      defaultValue: 10
    },
    {
      type: "boolean",
      label: "Paginate",
      key: "paginate"
    },
    {
      section: !0,
      name: "Layout settings",
      settings: [
        {
          type: "text",
          label: "Empty text",
          key: "noRowsMessage",
          defaultValue: "No rows found"
        },
        {
          type: "select",
          label: "Direction",
          key: "direction",
          showInBar: !0,
          barStyle: "buttons",
          options: [
            {
              label: "Column",
              value: "column",
              barIcon: "TableSelectColumn",
              barTitle: "Column layout"
            },
            {
              label: "Row",
              value: "row",
              barIcon: "TableSelectRow",
              barTitle: "Row layout"
            }
          ],
          defaultValue: "column"
        },
        {
          type: "select",
          label: "Horiz. align",
          key: "hAlign",
          showInBar: !0,
          barStyle: "buttons",
          options: [
            {
              label: "Left",
              value: "left",
              barIcon: "AlignLeft",
              barTitle: "Align left"
            },
            {
              label: "Center",
              value: "center",
              barIcon: "AlignCenter",
              barTitle: "Align center"
            },
            {
              label: "Right",
              value: "right",
              barIcon: "AlignRight",
              barTitle: "Align right"
            },
            {
              label: "Stretch",
              value: "stretch",
              barIcon: "MoveLeftRight",
              barTitle: "Align stretched horizontally"
            }
          ],
          defaultValue: "stretch"
        },
        {
          type: "select",
          label: "Vert. align",
          key: "vAlign",
          showInBar: !0,
          barStyle: "buttons",
          options: [
            {
              label: "Top",
              value: "top",
              barIcon: "AlignTop",
              barTitle: "Align top"
            },
            {
              label: "Middle",
              value: "middle",
              barIcon: "AlignMiddle",
              barTitle: "Align middle"
            },
            {
              label: "Bottom",
              value: "bottom",
              barIcon: "AlignBottom",
              barTitle: "Align bottom"
            },
            {
              label: "Stretch",
              value: "stretch",
              barIcon: "MoveUpDown",
              barTitle: "Align stretched vertically"
            }
          ],
          defaultValue: "top"
        },
        {
          type: "select",
          label: "Gap",
          key: "gap",
          showInBar: !0,
          barStyle: "picker",
          options: [
            {
              label: "None",
              value: "N"
            },
            {
              label: "Small",
              value: "S"
            },
            {
              label: "Medium",
              value: "M"
            },
            {
              label: "Large",
              value: "L"
            }
          ],
          defaultValue: "M"
        }
      ]
    }
  ],
  context: [
    {
      type: "static",
      suffix: "provider",
      values: [
        {
          label: "Rows",
          key: "rows",
          type: "array"
        },
        {
          label: "Extra Info",
          key: "info",
          type: "string"
        },
        {
          label: "Rows Length",
          key: "rowsLength",
          type: "number"
        },
        {
          label: "Schema",
          key: "schema",
          type: "object"
        },
        {
          label: "Page Number",
          key: "pageNumber",
          type: "number"
        }
      ]
    },
    {
      type: "static",
      suffix: "repeater",
      values: [
        {
          label: "Row Index",
          key: "index",
          type: "number"
        }
      ]
    },
    {
      type: "schema",
      suffix: "repeater",
      scope: "local"
    }
  ]
}, markdownviewer$1 = {
  deprecated: !0,
  name: "Markdown Viewer",
  icon: "article",
  styles: [
    "size"
  ],
  size: {
    width: 400,
    height: 100
  },
  grid: {
    hAlign: "stretch",
    vAlign: "start"
  },
  settings: [
    {
      type: "text",
      label: "Markdown",
      key: "value",
      required: !0
    }
  ]
}, multistepformblock$1 = {
  name: "Multi-step Form Block",
  icon: "steps",
  block: !0,
  hasChildren: !1,
  ejectable: !1,
  size: {
    width: 600,
    height: 400
  },
  grid: {
    hAlign: "stretch",
    vAlign: "start"
  },
  styles: [
    "padding",
    "size",
    "background",
    "border",
    "shadow"
  ],
  settings: [
    {
      type: "table",
      label: "Data",
      key: "dataSource"
    },
    {
      type: "radio",
      label: "Type",
      key: "actionType",
      options: [
        "Create",
        "Update",
        "View"
      ],
      defaultValue: "Create"
    },
    {
      section: !0,
      dependsOn: {
        setting: "actionType",
        value: "Create",
        invert: !0
      },
      name: "Row ID",
      info: "<a href='https://docs.budibase.com/docs/form-block' target='_blank'>How to pass a row ID using bindings</a>",
      settings: [
        {
          type: "text",
          label: "Row ID",
          key: "rowId",
          nested: !0
        },
        {
          type: "text",
          label: "No rows found",
          key: "noRowsMessage",
          defaultValue: "We couldn't find a row to display",
          nested: !0
        }
      ]
    },
    {
      section: !0,
      name: "Details",
      settings: [
        {
          type: "stepConfiguration",
          key: "steps",
          nested: !0,
          labelHidden: !0,
          resetOn: [
            "dataSource",
            "actionType"
          ],
          defaultValue: [
            {}
          ]
        }
      ]
    },
    {
      tag: "style",
      type: "select",
      label: "Button position",
      key: "buttonPosition",
      options: [
        {
          label: "Bottom",
          value: "bottom"
        },
        {
          label: "Top",
          value: "top"
        }
      ],
      defaultValue: "bottom"
    },
    {
      tag: "style",
      type: "select",
      label: "Size",
      key: "size",
      options: [
        {
          label: "Medium",
          value: "spectrum--medium"
        },
        {
          label: "Large",
          value: "spectrum--large"
        }
      ],
      defaultValue: "spectrum--medium"
    }
  ],
  actions: [
    {
      type: "ValidateForm",
      suffix: "form"
    },
    {
      type: "ClearForm",
      suffix: "form"
    },
    {
      type: "UpdateFieldValue",
      suffix: "form"
    },
    {
      type: "ScrollTo",
      suffix: "form"
    },
    {
      type: "ChangeFormStep",
      suffix: "form"
    },
    {
      type: "RefreshDatasource",
      suffix: "provider"
    }
  ],
  context: [
    {
      type: "form",
      suffix: "form"
    },
    {
      type: "schema",
      suffix: "repeater"
    },
    {
      type: "static",
      suffix: "form",
      values: [
        {
          label: "Value",
          key: "__value",
          type: "object"
        },
        {
          label: "Valid",
          key: "__valid",
          type: "boolean"
        },
        {
          label: "Current Step",
          key: "__currentStep",
          type: "number"
        },
        {
          label: "Current Step Valid",
          key: "__currentStepValid",
          type: "boolean"
        }
      ]
    }
  ]
}, multistepformblockstep = {
  name: "Multi-step Form Block Step",
  settings: [
    {
      type: "formStepControls",
      label: "Steps",
      key: "steps"
    },
    {
      type: "text",
      label: "Title",
      key: "title",
      nested: !0
    },
    {
      type: "text",
      label: "Description",
      key: "desc",
      nested: !0
    },
    {
      type: "fieldConfiguration",
      key: "fields",
      nested: !0
    },
    {
      type: "buttonConfiguration",
      label: "Buttons",
      key: "buttons",
      wide: !0,
      nested: !0
    },
    {
      type: "boolean",
      label: "Collapse",
      key: "buttonsCollapsed"
    },
    {
      type: "text",
      label: "Collapsed text",
      key: "buttonsCollapsedText",
      dependsOn: "buttonsCollapsed",
      placeholder: "Action"
    }
  ]
}, formblock$1 = {
  name: "Form Block",
  icon: "list",
  styles: [
    "padding",
    "size",
    "background",
    "border",
    "shadow"
  ],
  block: !0,
  info: "Form blocks are only compatible with internal or SQL tables",
  size: {
    width: 600,
    height: 400
  },
  grid: {
    hAlign: "stretch",
    vAlign: "start"
  },
  settings: [
    {
      type: "table",
      label: "Data",
      key: "dataSource"
    },
    {
      type: "radio",
      label: "Type",
      key: "actionType",
      options: [
        "Create",
        "Update",
        "View"
      ],
      defaultValue: "Create"
    },
    {
      section: !0,
      dependsOn: {
        setting: "actionType",
        value: "Create",
        invert: !0
      },
      name: "Row ID",
      info: "<a href='https://docs.budibase.com/docs/form-block' target='_blank'>How to pass a row ID using bindings</a>",
      settings: [
        {
          type: "text",
          label: "Row ID",
          key: "rowId",
          nested: !0
        },
        {
          type: "text",
          label: "No rows found",
          key: "noRowsMessage",
          defaultValue: "We couldn't find a row to display",
          nested: !0
        }
      ]
    },
    {
      section: !0,
      name: "Details",
      settings: [
        {
          type: "text",
          label: "Title",
          key: "title",
          nested: !0
        },
        {
          type: "text",
          label: "Description",
          key: "description",
          nested: !0
        },
        {
          type: "fieldConfiguration",
          key: "fields",
          nested: !0,
          resetOn: "dataSource",
          selectAllFields: !0
        },
        {
          type: "boolean",
          label: "Disabled",
          key: "disabled",
          defaultValue: !1
        }
      ]
    },
    {
      tag: "style",
      type: "select",
      label: "Button position",
      key: "buttonPosition",
      options: [
        {
          label: "Bottom",
          value: "bottom"
        },
        {
          label: "Top",
          value: "top"
        }
      ],
      defaultValue: "bottom"
    },
    {
      section: !0,
      name: "Buttons",
      settings: [
        {
          type: "buttonConfiguration",
          key: "buttons",
          nested: !0,
          resetOn: [
            "actionType",
            "dataSource"
          ]
        },
        {
          type: "boolean",
          label: "Collapse",
          key: "buttonsCollapsed"
        },
        {
          type: "text",
          label: "Collapsed text",
          key: "buttonsCollapsedText",
          dependsOn: "buttonsCollapsed",
          placeholder: "Action"
        }
      ]
    },
    {
      tag: "style",
      type: "select",
      label: "Size",
      key: "size",
      options: [
        {
          label: "Medium",
          value: "spectrum--medium"
        },
        {
          label: "Large",
          value: "spectrum--large"
        }
      ],
      defaultValue: "spectrum--medium"
    }
  ],
  actions: [
    {
      type: "ValidateForm",
      suffix: "form"
    },
    {
      type: "ClearForm",
      suffix: "form"
    },
    {
      type: "UpdateFieldValue",
      suffix: "form"
    },
    {
      type: "ScrollTo",
      suffix: "form"
    },
    {
      type: "RefreshDatasource",
      suffix: "provider"
    }
  ],
  context: [
    {
      type: "form",
      suffix: "form"
    },
    {
      type: "schema",
      suffix: "repeater"
    }
  ]
}, sidepanel$1 = {
  name: "Side Panel",
  icon: "sidebar",
  hasChildren: !0,
  ignoresLayout: !0,
  illegalChildren: [
    "section",
    "sidepanel",
    "modal"
  ],
  showEmptyState: !1,
  draggable: !1,
  info: "Side panels are hidden by default. They will only be revealed when triggered by the 'Open Side Panel' action.",
  settings: [
    {
      type: "boolean",
      key: "ignoreClicksOutside",
      label: "Ignore clicks outside",
      defaultValue: !1
    },
    {
      type: "event",
      key: "onClose",
      label: "On close"
    }
  ]
}, modal$1 = {
  name: "Modal",
  icon: "square",
  hasChildren: !0,
  illegalChildren: [
    "section",
    "modal",
    "sidepanel"
  ],
  ignoresLayout: !0,
  showEmptyState: !1,
  draggable: !1,
  info: "Modals are hidden by default. They will only be revealed when triggered by the 'Open Modal' action.",
  settings: [
    {
      type: "boolean",
      key: "ignoreClicksOutside",
      label: "Ignore clicks outside",
      defaultValue: !1
    },
    {
      type: "event",
      key: "onClose",
      label: "On close"
    },
    {
      type: "select",
      label: "Size",
      key: "size",
      defaultValue: "small",
      options: [
        {
          label: "Small",
          value: "small"
        },
        {
          label: "Medium",
          value: "medium"
        },
        {
          label: "Large",
          value: "large"
        },
        {
          label: "Fullscreen",
          value: "fullscreen"
        }
      ]
    }
  ]
}, accordion$1 = {
  name: "Accordion",
  icon: "caret-down",
  friendlyName: "Accordion",
  description: "A collapsible Budibase container component",
  hasChildren: !0,
  illegalChildren: [
    "modal",
    "sidepanel"
  ],
  showSettingsBar: !0,
  new: !0,
  size: {
    width: 500,
    height: 200
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      type: "text",
      label: "Label",
      placeholder: "Label",
      key: "label"
    },
    {
      type: "boolean",
      label: "Bold",
      key: "bold",
      showInBar: !0,
      barIcon: "TagBold",
      barTitle: "Bold text",
      barSeparator: !1
    },
    {
      type: "select",
      label: "Default State",
      key: "initialOpen",
      defaultValue: !0,
      options: [
        {
          label: "Open",
          value: !0
        },
        {
          label: "Closed",
          value: !1
        }
      ]
    }
  ]
}, rowexplorer$1 = {
  block: !0,
  name: "Row Explorer Block",
  icon: "rows",
  size: {
    width: 800,
    height: 426
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      type: "table",
      label: "Data",
      key: "dataSource",
      required: !0
    },
    {
      type: "select",
      label: "Auto-refresh",
      key: "autoRefresh",
      license: "premium",
      placeholder: "Never",
      options: [
        {
          label: "10 seconds",
          value: 10
        },
        {
          label: "30 seconds",
          value: 30
        },
        {
          label: "1 minute",
          value: 60
        },
        {
          label: "5 minutes",
          value: 300
        },
        {
          label: "10 minutes",
          value: 600
        }
      ]
    },
    {
      type: "text",
      label: "Height",
      key: "height",
      defaultValue: "426px"
    },
    {
      type: "text",
      label: "Empty text",
      key: "noRowsMessage",
      defaultValue: "No data"
    },
    {
      section: !0,
      name: "Cards",
      settings: [
        {
          type: "field",
          label: "Search field",
          key: "cardSearchField",
          nested: !0
        },
        {
          type: "text",
          key: "cardTitle",
          label: "Title",
          nested: !0,
          defaultValue: "Title"
        },
        {
          type: "text",
          key: "cardSubtitle",
          label: "Subtitle",
          nested: !0,
          defaultValue: "Subtitle"
        },
        {
          type: "text",
          key: "cardDescription",
          label: "Description",
          nested: !0,
          defaultValue: "Description"
        },
        {
          type: "text",
          key: "cardImageURL",
          label: "Image URL",
          nested: !0
        }
      ]
    },
    {
      section: !0,
      name: "Details",
      settings: [
        {
          type: "text",
          key: "detailTitle",
          label: "Title"
        },
        {
          type: "multifield",
          label: "Fields",
          key: "detailFields",
          nested: !0,
          selectAllFields: !0
        }
      ]
    }
  ],
  context: {
    type: "schema",
    suffix: "repeater",
    scope: "local"
  }
}, gridblock$1 = {
  name: "Table",
  icon: "table",
  styles: [
    "size"
  ],
  cssVariables: [
    {
      label: "Header color",
      variable: "--custom-header-cell-background",
      type: "color"
    },
    {
      label: "Stripe color",
      variable: "--custom-stripe-cell-background",
      type: "color"
    }
  ],
  size: {
    width: 600,
    height: 400
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      type: "dataSource",
      label: "Data",
      key: "table",
      required: !0
    },
    {
      type: "filter",
      label: "Filtering",
      key: "initialFilter",
      dependsOn: {
        setting: "table.type",
        value: "custom",
        invert: !0
      },
      resetOn: "table"
    },
    {
      type: "field/sortable",
      label: "Sort column",
      key: "initialSortColumn",
      placeholder: "Default",
      dependsOn: {
        setting: "table.type",
        value: "custom",
        invert: !0
      }
    },
    {
      type: "select",
      label: "Sort order",
      key: "initialSortOrder",
      options: [
        "Ascending",
        "Descending"
      ],
      defaultValue: "Ascending",
      dependsOn: "initialSortColumn"
    },
    {
      type: "select",
      label: "Row height",
      key: "fixedRowHeight",
      placeholder: "Default",
      options: [
        {
          label: "Small",
          value: 36
        },
        {
          label: "Medium",
          value: 64
        },
        {
          label: "Large",
          value: 92
        }
      ]
    },
    {
      type: "event",
      label: "On row click",
      key: "onRowClick",
      context: [
        {
          label: "Clicked row",
          key: "row"
        }
      ]
    },
    {
      type: "boolean",
      label: "Add rows",
      key: "allowAddRows",
      defaultValue: !0,
      dependsOn: {
        setting: "table.type",
        value: [
          "table",
          "viewV2"
        ]
      }
    },
    {
      type: "boolean",
      label: "Edit rows",
      key: "allowEditRows",
      defaultValue: !0,
      dependsOn: {
        setting: "table.type",
        value: [
          "table",
          "viewV2"
        ]
      }
    },
    {
      type: "boolean",
      label: "Delete rows",
      key: "allowDeleteRows",
      defaultValue: !0,
      dependsOn: {
        setting: "table.type",
        value: [
          "table",
          "viewV2"
        ]
      }
    },
    {
      type: "boolean",
      label: "Striped rows",
      key: "stripeRows",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Quiet",
      key: "quiet",
      defaultValue: !1
    },
    {
      section: !0,
      name: "Columns",
      settings: [
        {
          type: "columns/grid",
          key: "columns",
          resetOn: "table",
          nested: !0
        }
      ]
    },
    {
      section: !0,
      name: "Buttons",
      settings: [
        {
          type: "buttonConfiguration",
          key: "buttons",
          nested: !0,
          context: [
            {
              label: "Clicked row",
              key: "row"
            }
          ]
        },
        {
          type: "boolean",
          label: "Collapse",
          key: "buttonsCollapsed"
        },
        {
          type: "text",
          label: "Collapsed text",
          key: "buttonsCollapsedText",
          dependsOn: "buttonsCollapsed",
          placeholder: "Action"
        }
      ]
    }
  ],
  context: [
    {
      type: "schema",
      scope: "local"
    },
    {
      type: "static",
      values: [
        {
          label: "Selected rows",
          key: "selectedRows",
          type: "array"
        }
      ]
    }
  ],
  actions: [
    "AddDataProviderFilterExtension",
    "ClearRowSelection",
    "RefreshDatasource"
  ]
}, bbreferencefield$1 = {
  devComment: "As bb reference is only used for user subtype for now, we are using user for icon and labels",
  name: "User List Field",
  icon: "users",
  styles: [
    "size"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 50
  },
  settings: [
    {
      type: "field/bb_reference",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Placeholder",
      key: "placeholder"
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue"
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "validation/link",
      label: "Validation",
      key: "validation"
    },
    {
      type: "boolean",
      label: "Search",
      key: "autocomplete",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Workspace users",
      key: "workspaceUsersOnly",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "readonly",
      defaultValue: !1,
      dependsOn: {
        setting: "disabled",
        value: !0,
        invert: !0
      }
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "array"
      }
    ]
  }
}, bbreferencesinglefield$1 = {
  devComment: "As bb reference is only used for user subtype for now, we are using user for icon and labels",
  name: "User Field",
  icon: "user",
  styles: [
    "size"
  ],
  editable: !0,
  size: {
    width: 400,
    height: 50
  },
  settings: [
    {
      type: "field/bb_reference_single",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "text",
      label: "Placeholder",
      key: "placeholder"
    },
    {
      type: "text",
      label: "Default value",
      key: "defaultValue"
    },
    {
      type: "text",
      label: "Help text",
      key: "helpText"
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "validation/link",
      label: "Validation",
      key: "validation"
    },
    {
      type: "boolean",
      label: "Search",
      key: "autocomplete",
      defaultValue: !0
    },
    {
      type: "boolean",
      label: "Workspace users",
      key: "workspaceUsersOnly",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "readonly",
      defaultValue: !1,
      dependsOn: {
        setting: "disabled",
        value: !0,
        invert: !0
      }
    },
    {
      type: "select",
      label: "Columns",
      key: "span",
      defaultValue: 6,
      hidden: !0,
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "1 column",
          value: 6,
          barIcon: "number-square-one",
          barTitle: "1 column"
        },
        {
          label: "2 columns",
          value: 3,
          barIcon: "number-square-two",
          barTitle: "2 columns"
        },
        {
          label: "3 columns",
          value: 2,
          barIcon: "number-square-three",
          barTitle: "3 columns"
        }
      ]
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "string"
      }
    ]
  }
}, textv2$1 = {
  new: !0,
  name: "Text",
  description: "A component for displaying text",
  icon: "text-t",
  size: {
    width: 400,
    height: 24
  },
  settings: [
    {
      type: "text/multiline",
      label: "Text (Markdown supported)",
      key: "text",
      wide: !0
    },
    {
      type: "select",
      label: "Size",
      key: "size",
      defaultValue: "14px",
      showInBar: !0,
      placeholder: "Default",
      options: [
        {
          label: "Small",
          value: "12px"
        },
        {
          label: "Medium",
          value: "14px"
        },
        {
          label: "Large",
          value: "18px"
        },
        {
          label: "Extra large",
          value: "24px"
        }
      ]
    },
    {
      type: "select",
      label: "Alignment",
      key: "align",
      defaultValue: "left",
      showInBar: !0,
      barStyle: "buttons",
      options: [
        {
          label: "Left",
          value: "left",
          barIcon: "TextAlignLeft",
          barTitle: "Align left"
        },
        {
          label: "Center",
          value: "center",
          barIcon: "TextAlignCenter",
          barTitle: "Align center"
        },
        {
          label: "Right",
          value: "right",
          barIcon: "TextAlignRight",
          barTitle: "Align right"
        },
        {
          label: "Justify",
          value: "justify",
          barIcon: "TextAlignJustify",
          barTitle: "Justify text"
        }
      ]
    },
    {
      type: "color",
      label: "Color",
      key: "color",
      showInBar: !0
    }
  ]
}, pdf$1 = {
  name: "PDF Generator",
  icon: "file-pdf",
  hasChildren: !0,
  showEmptyState: !1,
  illegalChildren: [
    "sidepanel",
    "modal",
    "gridblock"
  ],
  grid: {
    hAlign: "center",
    vAlign: "start"
  },
  size: {
    width: 800,
    height: 1200
  },
  description: "A component to render PDFs from other Budibase components",
  settings: [
    {
      type: "text",
      label: "PDF title",
      key: "fileName",
      defaultValue: "Report"
    },
    {
      type: "text",
      label: "Button text",
      key: "buttonText",
      defaultValue: "Download PDF"
    }
  ]
}, pdftable$1 = {
  name: "PDF Table",
  icon: "table",
  styles: [
    "size"
  ],
  size: {
    width: 600,
    height: 304
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      type: "dataSource",
      label: "Data",
      key: "datasource",
      required: !0
    },
    {
      type: "filter",
      label: "Filtering",
      key: "filter",
      resetOn: "datasource",
      dependsOn: {
        setting: "datasource.type",
        value: "custom",
        invert: !0
      }
    },
    {
      type: "field/sortable",
      label: "Sort column",
      key: "sortColumn",
      placeholder: "Default",
      resetOn: "datasource",
      dependsOn: {
        setting: "datasource.type",
        value: "custom",
        invert: !0
      }
    },
    {
      type: "select",
      label: "Sort order",
      key: "sortOrder",
      resetOn: "datasource",
      options: [
        "Ascending",
        "Descending"
      ],
      defaultValue: "Ascending",
      dependsOn: "sortColumn"
    },
    {
      type: "columns/toplevel",
      label: "Columns",
      key: "columns",
      resetOn: "datasource",
      placeholder: "First 3 columns"
    },
    {
      type: "number",
      label: "Limit",
      key: "limit",
      defaultValue: 10
    }
  ]
}, singlerowprovider$1 = {
  name: "Single Row Provider",
  icon: "database",
  hasChildren: !0,
  actions: [
    "RefreshDatasource"
  ],
  size: {
    width: 500,
    height: 200
  },
  grid: {
    hAlign: "stretch",
    vAlign: "stretch"
  },
  settings: [
    {
      type: "table",
      label: "Datasource",
      key: "datasource",
      required: !0
    },
    {
      type: "text",
      label: "Row ID",
      key: "rowId",
      required: !0,
      resetOn: "datasource"
    }
  ],
  context: {
    type: "schema"
  }
}, ratingfield$1 = {
  name: "Rating Field",
  icon: "star",
  styles: [
    "size"
  ],
  editable: !0,
  new: !0,
  size: {
    width: 400,
    height: 60
  },
  settings: [
    {
      type: "field/number",
      label: "Field",
      key: "field"
    },
    {
      type: "text",
      label: "Label",
      key: "label"
    },
    {
      type: "number",
      label: "Number of stars",
      key: "numberOfStars",
      min: 1,
      max: 25,
      defaultValue: 5
    },
    {
      type: "select",
      label: "Size",
      key: "size",
      options: [
        "XS",
        "S",
        "M",
        "L",
        "XL"
      ],
      defaultValue: "L"
    },
    {
      type: "select",
      label: "Icon type",
      key: "type",
      options: [
        "Star",
        "Heart"
      ],
      defaultValue: "Star"
    },
    {
      type: "select",
      label: "Colour variant",
      key: "variant",
      options: [
        "Primary",
        "Secondary",
        "Mono",
        "Gold",
        "Red",
        "Custom"
      ],
      defaultValue: "Primary"
    },
    {
      type: "color",
      label: "Custom colour",
      key: "colour",
      dependsOn: {
        setting: "variant",
        value: "Custom"
      }
    },
    {
      type: "boolean",
      label: "Disabled",
      key: "disabled",
      defaultValue: !1
    },
    {
      type: "boolean",
      label: "Read only",
      key: "readonly",
      defaultValue: !1,
      dependsOn: {
        setting: "disabled",
        value: !0,
        invert: !0
      }
    },
    {
      type: "event",
      label: "On change",
      key: "onChange",
      context: [
        {
          label: "Field Value",
          key: "value"
        }
      ]
    },
    {
      type: "validation/number",
      label: "Validation",
      key: "validation"
    }
  ],
  context: {
    type: "static",
    values: [
      {
        label: "Value",
        key: "value",
        type: "number"
      }
    ]
  }
}, Manifest = {
  features,
  typeSupportPresets,
  layout: layout$1,
  container: container$1,
  section: section$1,
  screenslot: screenslot$1,
  buttongroup: buttongroup$1,
  button: button$1,
  divider: divider$1,
  repeater: repeater$1,
  stackedlist: stackedlist$1,
  card: card$1,
  text: text$1,
  heading: heading$1,
  tag: tag$1,
  image: image$1,
  backgroundimage: backgroundimage$1,
  icon: icon$1,
  iconphosphor: iconphosphor$1,
  navigation: navigation$1,
  link: link$1,
  cardhorizontal: cardhorizontal$1,
  cardstat: cardstat$1,
  embed: embed$1,
  bar: bar$1,
  line: line$1,
  area: area$1,
  pie: pie$1,
  donut: donut$1,
  candlestick: candlestick$1,
  histogram: histogram$1,
  form: form$1,
  formstep: formstep$1,
  fieldgroup: fieldgroup$1,
  labelfield,
  stringfield: stringfield$1,
  numberfield: numberfield$1,
  bigintfield: bigintfield$1,
  passwordfield: passwordfield$1,
  optionsfield: optionsfield$1,
  multifieldselect: multifieldselect$1,
  booleanfield: booleanfield$1,
  longformfield: longformfield$1,
  datetimefield: datetimefield$1,
  codescanner: codescanner$1,
  codegenerator: codegenerator$1,
  signaturesinglefield: signaturesinglefield$1,
  embeddedmap: embeddedmap$1,
  attachmentfield: attachmentfield$1,
  attachmentsinglefield: attachmentsinglefield$1,
  relationshipfield: relationshipfield$1,
  jsonfield: jsonfield$1,
  s3upload: s3upload$1,
  dataprovider: dataprovider$1,
  table: table$1,
  daterangepicker: daterangepicker$1,
  spectrumcard: spectrumcard$1,
  filter: filter$1,
  filterconfig,
  dynamicfilter: dynamicfilter$1,
  chartblock: chartblock$1,
  tableblock: tableblock$1,
  cardsblock: cardsblock$1,
  repeaterblock: repeaterblock$1,
  markdownviewer: markdownviewer$1,
  multistepformblock: multistepformblock$1,
  multistepformblockstep,
  formblock: formblock$1,
  sidepanel: sidepanel$1,
  modal: modal$1,
  accordion: accordion$1,
  rowexplorer: rowexplorer$1,
  gridblock: gridblock$1,
  bbreferencefield: bbreferencefield$1,
  bbreferencesinglefield: bbreferencesinglefield$1,
  textv2: textv2$1,
  pdf: pdf$1,
  pdftable: pdftable$1,
  singlerowprovider: singlerowprovider$1,
  ratingfield: ratingfield$1
};
var lib = { exports: {} }, seed = 1;
function getNextValue() {
  return seed = (seed * 9301 + 49297) % 233280, seed / 233280;
}
function setSeed$1(u) {
  seed = u;
}
var randomFromSeed$1 = {
  nextValue: getNextValue,
  seed: setSeed$1
}, randomFromSeed = randomFromSeed$1, ORIGINAL = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-", alphabet$2, previousSeed, shuffled;
function reset() {
  shuffled = !1;
}
function setCharacters(u) {
  if (!u) {
    alphabet$2 !== ORIGINAL && (alphabet$2 = ORIGINAL, reset());
    return;
  }
  if (u !== alphabet$2) {
    if (u.length !== ORIGINAL.length)
      throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. You submitted " + u.length + " characters: " + u);
    var l = u.split("").filter(function(f, p, m) {
      return p !== m.lastIndexOf(f);
    });
    if (l.length)
      throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. These characters were not unique: " + l.join(", "));
    alphabet$2 = u, reset();
  }
}
function characters(u) {
  return setCharacters(u), alphabet$2;
}
function setSeed(u) {
  randomFromSeed.seed(u), previousSeed !== u && (reset(), previousSeed = u);
}
function shuffle() {
  alphabet$2 || setCharacters(ORIGINAL);
  for (var u = alphabet$2.split(""), l = [], f = randomFromSeed.nextValue(), p; u.length > 0; )
    f = randomFromSeed.nextValue(), p = Math.floor(f * u.length), l.push(u.splice(p, 1)[0]);
  return l.join("");
}
function getShuffled() {
  return shuffled || (shuffled = shuffle(), shuffled);
}
function lookup(u) {
  var l = getShuffled();
  return l[u];
}
function get() {
  return alphabet$2 || ORIGINAL;
}
var alphabet_1 = {
  get,
  characters,
  seed: setSeed,
  lookup,
  shuffled: getShuffled
}, crypto$1 = typeof window == "object" && (window.crypto || window.msCrypto), randomByte;
!crypto$1 || !crypto$1.getRandomValues ? randomByte = function(u) {
  for (var l = [], f = 0; f < u; f++)
    l.push(Math.floor(Math.random() * 256));
  return l;
} : randomByte = function(u) {
  return crypto$1.getRandomValues(new Uint8Array(u));
};
var randomByteBrowser = randomByte;
let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", random$1 = (u) => crypto.getRandomValues(new Uint8Array(u)), customRandom$1 = (u, l, f) => {
  let p = (2 << Math.log(u.length - 1) / Math.LN2) - 1, m = -~(1.6 * p * l / u.length);
  return (b = l) => {
    let y = "";
    for (; ; ) {
      let v = f(m), k = m | 0;
      for (; k--; )
        if (y += u[v[k] & p] || "", y.length === b)
          return y;
    }
  };
}, customAlphabet = (u, l = 21) => customRandom$1(u, l, random$1), nanoid = (u = 21) => crypto.getRandomValues(new Uint8Array(u)).reduce((l, f) => (f &= 63, f < 36 ? l += f.toString(36) : f < 62 ? l += (f - 26).toString(36).toUpperCase() : f > 62 ? l += "-" : l += "_", l), "");
const index_browser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  customAlphabet,
  customRandom: customRandom$1,
  nanoid,
  random: random$1,
  urlAlphabet
}, Symbol.toStringTag, { value: "Module" })), require$$2 = /* @__PURE__ */ getAugmentedNamespace(index_browser);
var alphabet$1 = alphabet_1, random = randomByteBrowser, customRandom = require$$2.customRandom;
function generate$1(u) {
  for (var l = 0, f, p = ""; !f; )
    p = p + customRandom(alphabet$1.get(), 1, random)(), f = u < Math.pow(16, l + 1), l++;
  return p;
}
var generate_1 = generate$1, generate = generate_1, REDUCE_TIME = 1567752802062, version = 7, counter, previousSeconds;
function build(u) {
  var l = "", f = Math.floor((Date.now() - REDUCE_TIME) * 1e-3);
  return f === previousSeconds ? counter++ : (counter = 0, previousSeconds = f), l = l + generate(version), l = l + generate(u), counter > 0 && (l = l + generate(counter)), l = l + generate(f), l;
}
var build_1 = build, alphabet = alphabet_1;
function isShortId(u) {
  if (!u || typeof u != "string" || u.length < 6)
    return !1;
  var l = new RegExp("[^" + alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]");
  return !l.test(u);
}
var isValid = isShortId;
(function(u) {
  var l = alphabet_1, f = build_1, p = isValid, m = 0;
  function b(S) {
    return l.seed(S), u.exports;
  }
  function y(S) {
    return m = S, u.exports;
  }
  function v(S) {
    return S !== void 0 && l.characters(S), l.shuffled();
  }
  function k() {
    return f(m);
  }
  u.exports = k, u.exports.generate = k, u.exports.seed = b, u.exports.worker = y, u.exports.characters = v, u.exports.isValid = p;
})(lib);
var libExports = lib.exports, shortid = libExports;
function create_fragment$I(u) {
  let l;
  const f = (
    /*#slots*/
    u[6].default
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[5],
    null
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, [b]) {
      p && p.p && (!l || b & /*$$scope*/
      32) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[5],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[5],
          b,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[5]
        ),
        null
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function instance$G(u, l, f) {
  let p, { $$slots: m = {}, $$scope: b } = l;
  const { ContextScopes: y } = getContext$1("sdk");
  let { data: v } = l, { actions: k } = l, { key: S } = l, { scope: $ = y.Global } = l, w = getContext$1("context");
  const T = getContext$1("component");
  component_subscribe(u, T, (B) => f(10, p = B));
  const E = S || p.id;
  $ === y.Local && (w = createContextStore(w), setContext("context", w));
  const R = shortid.generate();
  let O, P;
  const L = (B) => {
    const j = JSON.stringify(B);
    j !== O && (w.actions.provideData(E, B), O = j);
  }, M = (B) => {
    const j = JSON.stringify(B);
    j !== P && (P = j, B == null || B.forEach(({ type: x, callback: N, metadata: D }) => {
      w.actions.provideAction(E, x, N), x === ActionTypes.RefreshDatasource && D != null && D.dataSource && dataSourceStore.actions.registerDataSource(D.dataSource, R, N);
    }));
  };
  return onDestroy(() => {
    dataSourceStore.actions.unregisterInstance(R);
  }), u.$$set = (B) => {
    "data" in B && f(1, v = B.data), "actions" in B && f(2, k = B.actions), "key" in B && f(3, S = B.key), "scope" in B && f(4, $ = B.scope), "$$scope" in B && f(5, b = B.$$scope);
  }, u.$$.update = () => {
    u.$$.dirty & /*data*/
    2 && L(v), u.$$.dirty & /*actions*/
    4 && M(k);
  }, [T, v, k, S, $, b, m];
}
class Provider extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$G, create_fragment$I, safe_not_equal, { data: 1, actions: 2, key: 3, scope: 4 });
  }
}
function create_if_block$l(u) {
  let l = (
    /*screen*/
    u[1].props._id
  ), f, p, m = create_key_block$2(u);
  return {
    c() {
      m.c(), f = empty$1();
    },
    m(b, y) {
      m.m(b, y), insert(b, f, y), p = !0;
    },
    p(b, y) {
      y & /*screen*/
      2 && safe_not_equal(l, l = /*screen*/
      b[1].props._id) ? (group_outros(), transition_out(m, 1, 1, noop$4), check_outros(), m = create_key_block$2(b), m.c(), transition_in(m, 1), m.m(f.parentNode, f)) : m.p(b, y);
    },
    i(b) {
      p || (transition_in(m), p = !0);
    },
    o(b) {
      transition_out(m), p = !1;
    },
    d(b) {
      b && detach(f), m.d(b);
    }
  };
}
function create_default_slot$n(u) {
  let l, f;
  return l = new Component({
    props: {
      isRoot: !0,
      instance: (
        /*screen*/
        u[1].props
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*screen*/
      2 && (b.instance = /*screen*/
      p[1].props), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_key_block$2(u) {
  let l, f;
  return l = new Provider({
    props: {
      key: "url",
      data: (
        /*params*/
        u[0]
      ),
      $$slots: { default: [create_default_slot$n] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*params*/
      1 && (b.data = /*params*/
      p[0]), m & /*$$scope, screen*/
      258 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$H(u) {
  var m;
  let l, f, p = (
    /*$routeStore*/
    u[2].routerLoaded && /*screen*/
    ((m = u[1]) == null ? void 0 : m.props) && create_if_block$l(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(b, y) {
      p && p.m(b, y), insert(b, l, y), f = !0;
    },
    p(b, [y]) {
      var v;
      /*$routeStore*/
      b[2].routerLoaded && /*screen*/
      ((v = b[1]) != null && v.props) ? p ? (p.p(b, y), y & /*$routeStore, screen*/
      6 && transition_in(p, 1)) : (p = create_if_block$l(b), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(b) {
      f || (transition_in(p), f = !0);
    },
    o(b) {
      transition_out(p), f = !1;
    },
    d(b) {
      b && detach(l), p && p.d(b);
    }
  };
}
function instance$F(u, l, f) {
  let p, m, b, y;
  component_subscribe(u, routeStore, (w) => f(2, m = w)), component_subscribe(u, screenStore, (w) => f(5, y = w));
  let { params: v = {} } = l;
  const k = getContext$1("context"), S = memo();
  component_subscribe(u, S, (w) => f(4, b = w));
  const $ = (w, T) => {
    if (w != null && w.length && !get_store_value(builderStore).inBuilder) {
      const E = enrichButtonActions(w, { ...get_store_value(k), url: T });
      E != null && E();
    }
  };
  return onMount(() => {
    m.routerLoaded || routeStore.actions.setRouterLoaded();
  }), u.$$set = (w) => {
    "params" in w && f(0, v = w.params);
  }, u.$$.update = () => {
    u.$$.dirty & /*$screenStore*/
    32 && f(1, p = y.activeScreen), u.$$.dirty & /*screen*/
    2 && S.set(p == null ? void 0 : p.onLoad), u.$$.dirty & /*$onLoadActions, params*/
    17 && $(b, v);
  }, [v, p, m, S, b, y];
}
class Screen extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$F, create_fragment$H, safe_not_equal, { params: 0 });
  }
}
const Router_svelte_svelte_type_style_lang = "";
function create_key_block$1(u) {
  let l, f, p, m, b, y;
  return f = new Router({
    props: { routes: (
      /*config*/
      u[0].routes
    ) }
  }), f.$on(
    "routeLoading",
    /*onRouteLoading*/
    u[4]
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "svelte-u3ivhz");
    },
    m(v, k) {
      insert(v, l, k), mount_component(f, l, null), m = !0, b || (y = action_destroyer(p = /*styleable*/
      u[2].call(
        null,
        l,
        /*$component*/
        u[1].styles
      )), b = !0);
    },
    p(v, k) {
      const S = {};
      k & /*config*/
      1 && (S.routes = /*config*/
      v[0].routes), f.$set(S), p && is_function(p.update) && k & /*$component*/
      2 && p.update.call(
        null,
        /*$component*/
        v[1].styles
      );
    },
    i(v) {
      m || (transition_in(f.$$.fragment, v), m = !0);
    },
    o(v) {
      transition_out(f.$$.fragment, v), m = !1;
    },
    d(v) {
      v && detach(l), destroy_component(f), b = !1, y();
    }
  };
}
function create_fragment$G(u) {
  let l = (
    /*config*/
    u[0].id
  ), f, p, m = create_key_block$1(u);
  return {
    c() {
      m.c(), f = empty$1();
    },
    m(b, y) {
      m.m(b, y), insert(b, f, y), p = !0;
    },
    p(b, [y]) {
      y & /*config*/
      1 && safe_not_equal(l, l = /*config*/
      b[0].id) ? (group_outros(), transition_out(m, 1, 1, noop$4), check_outros(), m = create_key_block$1(b), m.c(), transition_in(m, 1), m.m(f.parentNode, f)) : m.p(b, y);
    },
    i(b) {
      p || (transition_in(m), p = !0);
    },
    o(b) {
      transition_out(m), p = !1;
    },
    d(b) {
      b && detach(f), m.d(b);
    }
  };
}
function instance$E(u, l, f) {
  let p, m, b, y;
  component_subscribe(u, querystring, (T) => f(5, m = T)), component_subscribe(u, routeStore, (T) => f(6, b = T));
  const { styleable: v } = getContext$1("sdk"), k = getContext$1("component");
  component_subscribe(u, k, (T) => f(1, y = T)), setContext("screenslot", !0);
  const S = (T) => {
    let E = {};
    if (T) {
      const R = new URLSearchParams(T);
      for (const [O, P] of R)
        E[O] = P;
    }
    return E;
  }, $ = (T) => {
    let E = {};
    return T.forEach((R) => {
      E[R.path] = Screen;
    }), E["*"] = Screen, E;
  }, w = ({ detail: T }) => {
    routeStore.actions.setRouteParams(T.params || {}), routeStore.actions.setActiveRoute(T.route);
  };
  return onMount(() => {
    const T = S(get_store_value(querystring));
    if (T.state)
      try {
        const E = JSON.parse(atob(T.state));
        stateStore.actions.initialise(E);
      } catch {
      }
  }), u.$$.update = () => {
    u.$$.dirty & /*$routeStore*/
    64 && f(0, p = {
      routes: $(b.routes),
      id: b.routeSessionId
    }), u.$$.dirty & /*$querystring*/
    32 && routeStore.actions.setQueryParams(S(m));
  }, [
    p,
    y,
    v,
    k,
    w,
    m,
    b
  ];
}
class Router_1 extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$E, create_fragment$G, safe_not_equal, {});
  }
}
const cardsblock = () => import("./CardsBlock-a468a54a.js"), repeaterblock = () => import("./RepeaterBlock-18c134e0.js"), formblock = () => import("./FormBlock-95d3caaa.js"), chartblock = () => import("./ChartBlock-68540354.js"), rowexplorer = () => import("./RowExplorer-967fe7ca.js"), multistepformblock = () => import("./MultiStepFormblock-41d1fc65.js"), bar = () => import("./BarChart-a9d4b3a0.js"), line = () => import("./LineChart-aa1d7158.js"), pie = () => import("./PieChart-bfeb99c8.js"), donut = () => import("./DonutChart-76b25eb0.js"), area = () => import("./AreaChart-2a1a1eb9.js"), candlestick = () => import("./CandleStickChart-00c19f06.js"), histogram = () => import("./HistogramChart-2b342fa8.js"), dynamicfilter = () => import("./DynamicFilter-1d5cfb2d.js"), form = () => import("./Form-66cb891d.js"), fieldgroup = () => import("./FieldGroup-6620a044.js"), stringfield = () => import("./StringField-91e4b09c.js"), numberfield = () => import("./NumberField-8a2668ee.js"), bigintfield = () => import("./BigIntField-a72dc0d5.js"), optionsfield = () => import("./OptionsField-bec69c17.js"), multifieldselect = () => import("./MultiFieldSelect-fdc6b178.js"), booleanfield = () => import("./BooleanField-21d41359.js"), longformfield = () => import("./LongFormField-c6b9b4d4.js"), datetimefield = () => import("./DateTimeField-553dec7d.js"), attachmentfield = () => import("./AttachmentField-9fdefd52.js"), attachmentsinglefield = () => import("./AttachmentSingleField-adfcd307.js"), relationshipfield = () => import("./RelationshipField-11fde1bc.js"), passwordfield = () => import("./PasswordField-9fb2d5fa.js"), formstep = () => import("./FormStep-d3421924.js"), jsonfield = () => import("./JSONField-8a8f54d1.js"), s3upload = () => import("./S3Upload-fd8d236d.js"), codescanner = () => import("./CodeScannerField-888bbbda.js"), signaturesinglefield = () => import("./SignatureField-cc81fb06.js"), bbreferencefield = () => import("./BBReferenceField-be3a365f.js"), bbreferencesinglefield = () => import("./BBReferenceSingleField-ca75a590.js"), ratingfield = () => import("./RatingField-6a49bd91.js"), pdf = () => import("./PDF-c61809e5.js"), pdftable = () => import("./PDFTable-64cd79d6.js"), table = () => import("./Table-e0b2a117.js"), Placeholder = () => import("./Placeholder-f6d4d740.js"), container = () => import("./Container-5c9526ad.js"), dataprovider = () => import("./DataProvider-2933d65b.js"), divider = () => import("./Divider-29c4e90d.js"), screenslot = () => import("./ScreenSlot-0cf0cb2e.js"), button = () => import("./Button-13f4890c.js"), buttongroup = () => import("./ButtonGroup-5ad8ded2.js"), repeater = () => import("./Repeater-1dc3de83.js"), layout = () => import("./Layout-6d1f2954.js"), link = () => import("./Link-d220c181.js"), image = () => import("./Image-97c90c3b.js"), embed = () => import("./Embed-5fa2b598.js"), icon = () => import("./Icon-92dab964.js"), iconphosphor = () => import("./IconV2-d80b6b3d.js"), backgroundimage = () => import("./BackgroundImage-53f318ad.js"), daterangepicker = () => import("./DateRangePicker-0bfcd8ca.js"), cardstat = () => import("./CardStat-1d5f7fe4.js"), spectrumcard = () => import("./SpectrumCard-45150511.js"), tag = () => import("./Tag-6cc284b2.js"), embeddedmap = () => import("./EmbeddedMap-b56fb847.js"), sidepanel = () => import("./SidePanel-ad0d75e1.js"), modal = () => import("./Modal-55d95b41.js"), gridblock = () => import("./GridBlock-ec8e4a8f.js"), textv2 = () => import("./Text-8f27605e.js"), filter = () => import("./Filter-703931c2.js"), accordion = () => import("./Accordion-07c6b212.js"), singlerowprovider = () => import("./SingleRowProvider-9de6ed7d.js"), codegenerator = () => import("./CodeGenerator-09e93215.js"), tableblock = () => import("./TableBlock-5de833cc.js"), navigation = () => import("./Navigation-08101446.js"), cardhorizontal = () => import("./CardHorizontal-fae0c3f1.js"), stackedlist = () => import("./StackedList-03464e69.js"), card = () => import("./Card-c4446a8a.js"), section = () => import("./Section-df822158.js"), text = () => import("./Text-be701bfc.js"), heading = () => import("./Heading-3f4dd21b.js"), markdownviewer = () => import("./MarkdownViewer-2e669b93.js"), AppComponents = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Placeholder,
  accordion,
  area,
  attachmentfield,
  attachmentsinglefield,
  backgroundimage,
  bar,
  bbreferencefield,
  bbreferencesinglefield,
  bigintfield,
  booleanfield,
  button,
  buttongroup,
  candlestick,
  card,
  cardhorizontal,
  cardsblock,
  cardstat,
  chartblock,
  codegenerator,
  codescanner,
  container,
  dataprovider,
  daterangepicker,
  datetimefield,
  divider,
  donut,
  dynamicfilter,
  embed,
  embeddedmap,
  fieldgroup,
  filter,
  form,
  formblock,
  formstep,
  gridblock,
  heading,
  histogram,
  icon,
  iconphosphor,
  image,
  jsonfield,
  layout,
  line,
  link,
  longformfield,
  markdownviewer,
  modal,
  multifieldselect,
  multistepformblock,
  navigation,
  numberfield,
  optionsfield,
  passwordfield,
  pdf,
  pdftable,
  pie,
  ratingfield,
  relationshipfield,
  repeater,
  repeaterblock,
  rowexplorer,
  s3upload,
  screenslot,
  section,
  sidepanel,
  signaturesinglefield,
  singlerowprovider,
  spectrumcard,
  stackedlist,
  stringfield,
  table,
  tableblock,
  tag,
  text,
  textv2
}, Symbol.toStringTag, { value: "Module" })), BudibasePrefix = "@budibase/standard-components/", builtInComponentCache = /* @__PURE__ */ new Map(), builtInComponentPromises = /* @__PURE__ */ new Map(), createComponentStore = () => {
  const u = writable({
    customComponentManifest: {},
    customComponentMap: {},
    mountedComponents: {}
  }), l = derived(
    [u, builderStore, devToolsStore, screenStore],
    ([$, w, T, E]) => {
      var j;
      const { inBuilder: R, selectedComponentId: O } = w;
      if (!R && !T.visible)
        return {};
      const P = (j = E.activeScreen) == null ? void 0 : j.props, L = findComponentById(P, O), M = y(L == null ? void 0 : L._component), B = findComponentPathById(P, O) || [];
      return {
        customComponentManifest: $.customComponentManifest,
        selectedComponentInstance: $.mountedComponents[O],
        selectedComponent: L,
        selectedComponentDefinition: M,
        selectedComponentPath: B == null ? void 0 : B.map((x) => x._id),
        mountedComponentCount: Object.keys($.mountedComponents).length,
        screenslotInstance: $.mountedComponents[ScreenslotID]
      };
    }
  ), f = ($, w) => {
    $ && u.update((T) => {
      const E = w.component;
      return E != null && E.startsWith("plugin") && (T.customComponentMap[E] ? T.customComponentMap[E].push($) : T.customComponentMap[E] = [$]), T.mountedComponents[$] = w, T;
    });
  }, p = ($) => {
    $ && u.update((w) => {
      var R, O;
      const T = (O = (R = w.mountedComponents[$]) == null ? void 0 : R.instance) == null ? void 0 : O.component;
      let E = w.customComponentMap;
      return T != null && T.startsWith("plugin") && (E[T] = E[T].filter(
        (P) => P !== $
      )), delete w.mountedComponents[$], w;
    });
  }, m = ($) => get_store_value(u).mountedComponents[$] != null, b = ($) => {
    var T;
    const w = (T = get_store_value(screenStore).activeScreen) == null ? void 0 : T.props;
    return findComponentById(w, $);
  }, y = ($) => {
    var T, E;
    if (!$)
      return null;
    if ($ === ScreenslotType && ($ = `${BudibasePrefix}${$}`), $.startsWith(BudibasePrefix))
      return $ = $.replace(BudibasePrefix, ""), $ ? Manifest[$] : null;
    const { customComponentManifest: w } = get_store_value(u);
    return (E = (T = w == null ? void 0 : w[$]) == null ? void 0 : T.schema) == null ? void 0 : E.schema;
  };
  return {
    ...l,
    actions: {
      registerInstance: f,
      unregisterInstance: p,
      isComponentRegistered: m,
      getComponentById: b,
      getComponentDefinition: y,
      getComponentConstructor: ($) => {
        var T;
        if (!$)
          return null;
        if ($ === ScreenslotType)
          return Router_1;
        if ($.startsWith(BudibasePrefix)) {
          const E = $.split("/"), R = E[E.length - 1];
          if (builtInComponentCache.has(R))
            return builtInComponentCache.get(R);
          if (builtInComponentPromises.has(R))
            return builtInComponentPromises.get(R);
          const O = AppComponents[R];
          if (!O)
            return console.warn(`Component loader missing for ${R}`), null;
          const P = O().then((L) => {
            const M = (L == null ? void 0 : L.default) ?? null;
            return M && builtInComponentCache.set(R, M), builtInComponentPromises.delete(R), M;
          }).catch((L) => (builtInComponentPromises.delete(R), console.error(`Failed to load component ${R}`, L), null));
          return builtInComponentPromises.set(R, P), P;
        }
        const { customComponentManifest: w } = get_store_value(u);
        return (T = w == null ? void 0 : w[$]) == null ? void 0 : T.Component;
      },
      getComponentInstance: ($) => derived(u, (w) => w.mountedComponents[$]),
      registerCustomComponent: ({ Component: $, schema: w, version: T }) => {
        var O, P;
        if (!$ || !((O = w == null ? void 0 : w.schema) != null && O.name) || !T)
          return;
        const E = `plugin/${w.schema.name}`;
        u.update((L) => (L.customComponentManifest[E] = {
          Component: $,
          schema: w
        }, L));
        const R = get_store_value(u);
        (P = R.customComponentMap[E]) != null && P.length && R.customComponentMap[E].forEach((L) => {
          var M;
          (M = R.mountedComponents[L]) == null || M.reload();
        });
      }
    }
  };
}, componentStore = createComponentStore(), createUploadStore = () => {
  const u = writable([]), l = (m, b) => {
    !m || !b || u.update((y) => (y.push({
      componentId: m,
      callback: b
    }), y));
  }, f = (m) => {
    u.update((b) => b.filter((y) => y.componentId !== m));
  }, p = async (m) => {
    if (!m)
      return;
    const b = get_store_value(u).find((y) => y.componentId === m);
    return await (b == null ? void 0 : b.callback());
  };
  return {
    subscribe: u.subscribe,
    actions: { registerFileUpload: l, unregisterFileUpload: f, processFileUpload: p }
  };
}, uploadStore = createUploadStore(), createRowSelectionStore = () => {
  const u = writable({});
  function l(p, m, b) {
    u.update((y) => (y[p] = { tableId: m, selectedRows: b }, y));
  }
  function f(p) {
    const m = get_store_value(u), b = Object.keys(m).find(
      (y) => y === p
    );
    return m[b];
  }
  return {
    subscribe: u.subscribe,
    set: u.set,
    actions: {
      updateSelection: l,
      getSelection: f
    }
  };
}, rowSelectionStore = createRowSelectionStore(), createBlockStore = () => {
  const u = writable({}), l = (m, b) => {
    u.update((y) => ({
      ...y,
      [m]: b
    }));
  }, f = (m) => {
    u.update((b) => (delete b[m], b));
  }, p = (m) => get_store_value(u)[m];
  return {
    subscribe: u.subscribe,
    actions: {
      registerBlock: l,
      unregisterBlock: f,
      getBlock: p
    }
  };
}, blockStore = createBlockStore(), initialState = {
  multiTenancy: !1,
  offlineMode: !1,
  cloud: !1,
  disableAccountPortal: !1,
  isDev: !1,
  maintenance: [],
  loaded: !1
}, createEnvironmentStore = () => {
  const u = writable(initialState), l = {
    fetchEnvironment: async () => {
      try {
        const f = await API.getEnvironment();
        u.set({
          ...initialState,
          ...f,
          loaded: !0
        });
      } catch {
        u.set(initialState);
      }
    }
  };
  return {
    subscribe: u.subscribe,
    actions: l
  };
}, environmentStore = createEnvironmentStore(), devToolsEnabled = derived(
  [appStore, builderStore],
  ([u, l]) => !l.inBuilder && u.isDevApp
), currentRole = derived(
  [devToolsEnabled, devToolsStore, authStore],
  ([u, l, f]) => u && l.role || (f == null ? void 0 : f.roleId) || Roles.PUBLIC
), dndComponentPath = derived(
  [dndParent, screenStore],
  ([u, l]) => {
    var m;
    const f = (m = l.activeScreen) == null ? void 0 : m.props, p = findComponentPathById(f, u) || [];
    return p == null ? void 0 : p.map((b) => b._id);
  }
), snippets = derivedMemo(
  [appStore, builderStore],
  ([u, l]) => {
    var f;
    return (l == null ? void 0 : l.snippets) || ((f = u == null ? void 0 : u.application) == null ? void 0 : f.snippets) || [];
  }
), createRoleStore = () => {
  const u = writable([]), l = async () => {
    const f = await API.getAccessibleRoles();
    return u.set(f || []), f;
  };
  return {
    subscribe: u.subscribe,
    actions: { fetchAccessibleRoles: l }
  };
}, roleStore = createRoleStore();
currentRole.subscribe(roleStore.actions.fetchAccessibleRoles);
const createSidePanelStore = () => {
  const l = writable({
    contentId: null,
    ignoreClicksOutside: !0
  }), f = derived(l, (v) => ({
    ...v,
    open: v.contentId != null
  }));
  let p;
  const m = (v) => {
    clearTimeout(p), l.update((k) => (k.contentId = v, k));
  }, b = () => {
    p = setTimeout(() => {
      l.update((v) => (v.contentId = null, v));
    }, 50);
  }, y = (v) => {
    l.update((k) => (k.ignoreClicksOutside = v, k));
  };
  return {
    subscribe: f.subscribe,
    actions: {
      open: m,
      close: b,
      setIgnoreClicksOutside: y
    }
  };
}, sidePanelStore = createSidePanelStore(), createModalStore = () => {
  const l = writable({
    contentId: null
  }), f = (m) => {
    l.update((b) => (b.contentId = m, b));
  }, p = () => {
    l.update((m) => (m.contentId = null, m));
  };
  return {
    subscribe: l.subscribe,
    actions: {
      open: f,
      close: p
    }
  };
}, modalStore = createModalStore(), createHoverStore = () => {
  const u = writable({
    hoveredComponentId: null
  });
  let l;
  const f = (m, b = !0) => {
    clearTimeout(l), m ? p(m, b) : l = setTimeout(() => {
      p(m, b);
    }, 10);
  }, p = (m, b = !0) => {
    m !== get_store_value(u).hoveredComponentId && (u.set({ hoveredComponentId: m }), b && eventStore.actions.dispatchEvent("hover-component", { id: m }));
  };
  return {
    ...u,
    actions: {
      hoverComponent: f
    }
  };
}, hoverStore = createHoverStore(), createContextStore = (u) => {
  const l = writable({});
  let f = [];
  const m = derived(u ? [u, l] : [l], (S) => S.reduce(($, w) => ({ ...$, ...w }), {}));
  u && u.actions.observeChanges((S) => {
    k(S);
  });
  const b = (S, $) => {
    !S || $ === void 0 || (l.update((w) => (w[S] = $, w)), k(S));
  }, y = (S, $, w) => {
    if (!S || !$)
      return;
    const T = `${S}_${$}`;
    l.update((E) => (E[T] = w, E)), k(T);
  }, v = (S) => (f.push(S), () => {
    f = f.filter(($) => $ !== S);
  }), k = (S) => {
    f.forEach(($) => $(S));
  };
  return {
    subscribe: m.subscribe,
    actions: {
      provideData: b,
      provideAction: y,
      observeChanges: v
    }
  };
}, createFeaturesStore = () => derived([authStore, appStore], ([u, l]) => {
  var y, v, k;
  const f = () => {
    const S = u;
    if (S)
      return S.license;
  }, p = () => {
    const S = l;
    if (S != null && S.licenseType)
      return S.licenseType;
  }, m = () => {
    var $;
    let S = p();
    if (!S) {
      const w = f();
      S = ($ = w == null ? void 0 : w.plan) == null ? void 0 : $.type;
    }
    return S ? S === PlanType.FREE : !0;
  }, b = f();
  return {
    logoEnabled: m(),
    aiEnabled: ((y = b == null ? void 0 : b.features) == null ? void 0 : y.includes(Feature.AI_CUSTOM_CONFIGS)) || ((v = b == null ? void 0 : b.features) == null ? void 0 : v.includes(Feature.BUDIBASE_AI)),
    pwaEnabled: (k = b == null ? void 0 : b.features) == null ? void 0 : k.includes(Feature.PWA),
    recaptchaEnabled: b == null ? void 0 : b.features.includes(Feature.RECAPTCHA)
  };
}), featuresStore = createFeaturesStore(), contextActionHandler = async (u, l) => {
  const f = getActionContextKey(u), p = l[f];
  if (p)
    return await p(u.parameters);
}, getActionContextKey = (u) => {
  const l = u == null ? void 0 : u["##eventHandlerType"], f = (p, m) => `${p}_${m}`;
  switch (l) {
    case "Scroll To Field":
      return f(u.parameters.componentId, ActionTypes.ScrollTo);
    case "Update Field Value":
      return f(u.parameters.componentId, ActionTypes.UpdateFieldValue);
    case "Validate Form":
      return f(u.parameters.componentId, ActionTypes.ValidateForm);
    case "Refresh Data Provider":
      return f(u.parameters.componentId, ActionTypes.RefreshDatasource);
    case "Clear Form":
      return f(u.parameters.componentId, ActionTypes.ClearForm);
    case "Change Form Step":
      return f(u.parameters.componentId, ActionTypes.ChangeFormStep);
    case "Clear Row Selection":
      return f(u.parameters.componentId, ActionTypes.ClearRowSelection);
    default:
      return null;
  }
}, getActionDependentContextKeys = (u) => {
  var f;
  switch (u == null ? void 0 : u["##eventHandlerType"]) {
    case "Save Row":
    case "Duplicate Row":
      if ((f = u.parameters) != null && f.providerId)
        return [u.parameters.providerId];
  }
  return [];
}, saveRowHandler = async (u, l) => {
  const { fields: f, providerId: p, tableId: m, notificationOverride: b } = u.parameters;
  let y;
  if (p ? y = { ...l[p] } : y = {}, f)
    for (let [v, k] of Object.entries(f))
      deepSet(y, v, k);
  m && (m.startsWith("view") ? y._viewId = m : y.tableId = m);
  try {
    const v = await API.saveRow(y);
    return b || notificationStore.actions.success("Row saved"), await dataSourceStore.actions.invalidateDataSource(m, {
      invalidateRelationships: !0
    }), { row: v };
  } catch {
    return !1;
  }
}, duplicateRowHandler = async (u, l) => {
  const { fields: f, providerId: p, tableId: m, notificationOverride: b } = u.parameters;
  if (p) {
    let y = { ...l[p] };
    if (f)
      for (let [v, k] of Object.entries(f))
        deepSet(y, v, k);
    m && (m.startsWith("view") ? y._viewId = m : y.tableId = m), delete y._id, delete y._rev;
    try {
      const v = await API.saveRow(y);
      return b || notificationStore.actions.success("Row saved"), await dataSourceStore.actions.invalidateDataSource(m, {
        invalidateRelationships: !0
      }), { row: v };
    } catch {
      return !1;
    }
  }
}, fetchRowHandler = async (u) => {
  const { tableId: l, rowId: f } = u.parameters;
  if (l && f)
    try {
      return { row: await API.fetchRow(l, f) };
    } catch {
      return !1;
    }
}, deleteRowHandler = async (u) => {
  const { tableId: l, rowId: f, notificationOverride: p } = u.parameters;
  if (l && f)
    try {
      let m, b = [];
      if (typeof f == "string")
        try {
          b = JSON.parse(f);
        } catch {
          b = f.split(",").map((k) => k.trim()).filter((k) => k);
        }
      else
        b = f;
      if (typeof b == "object" && b.constructor === Object ? m = [b] : Array.isArray(b) ? m = b : Number.isInteger(b) && (m = [String(b)]), !m && !b)
        return notificationStore.actions.warning("No valid rows were supplied"), !1;
      const y = await API.deleteRows(l, m);
      p || notificationStore.actions.success(
        (y == null ? void 0 : y.length) == 1 ? "Row deleted" : `${y.length} Rows deleted`
      ), await dataSourceStore.actions.invalidateDataSource(l, {
        invalidateRelationships: !0
      });
    } catch (m) {
      console.error(m), notificationStore.actions.error(
        "An error occurred while executing the query"
      );
    }
}, triggerAutomationHandler = async (u) => {
  const { fields: l, notificationOverride: f, timeout: p } = u.parameters;
  try {
    const m = await API.triggerAutomation(
      u.parameters.automationId,
      l,
      p
    );
    if (m.value)
      return f || notificationStore.actions.success("Automation ran successfully"), { result: m };
    f || notificationStore.actions.success("Automation triggered");
  } catch {
    return !1;
  }
}, navigationHandler = (u) => {
  let { url: l, peek: f, externalNewTab: p, type: m } = u.parameters;
  m === "screen" && l && !l.startsWith("/") && (l = `/${l}`), routeStore.actions.navigate(l, f, p), closeSidePanelHandler();
}, queryExecutionHandler = async (u) => {
  const { queryId: l, queryParams: f, notificationOverride: p } = u.parameters;
  try {
    const m = await API.fetchQueryDefinition(l);
    if ((m == null ? void 0 : m.datasourceId) == null)
      return notificationStore.actions.error("That query couldn't be found"), !1;
    const b = await API.executeQuery(l, {
      parameters: f
    });
    return m.readable || (p || notificationStore.actions.success("Query executed successfully"), await dataSourceStore.actions.invalidateDataSource(m.datasourceId)), { result: b };
  } catch {
    return notificationStore.actions.error(
      "An error occurred while executing the query"
    ), !1;
  }
}, logoutHandler = async (u) => {
  var p;
  await authStore.actions.logOut();
  let l = "/builder/auth/login", f = !1;
  u.parameters.redirectUrl && (f = (p = u.parameters.redirectUrl) == null ? void 0 : p.startsWith("/"), l = routeStore.actions.createFullURL(
    u.parameters.redirectUrl
  )), window.location.href = l, f && window.location.reload();
}, closeScreenModalHandler = (u) => {
  let l;
  u != null && u.parameters && (l = u.parameters.url), window.parent.postMessage({ type: PeekMessages.CLOSE_SCREEN_MODAL, url: l });
}, updateStateHandler = (u) => {
  var b;
  const { type: l, key: f, value: p, persist: m } = u.parameters;
  l === "set" ? stateStore.actions.setValue(f, p, m) : l === "delete" && stateStore.actions.deleteValue(f), (b = get_store_value(routeStore).queryParams) != null && b.peek && window.parent.postMessage({
    type: PeekMessages.UPDATE_STATE,
    detail: { type: l, key: f, value: p, persist: m }
  });
}, s3UploadHandler = async (u) => {
  const { componentId: l } = u.parameters;
  if (!l)
    return;
  const f = await uploadStore.actions.processFileUpload(l);
  return {
    publicUrl: f == null ? void 0 : f.publicUrl
  };
}, exportDataHandler = async (u) => {
  var S, $;
  let { tableComponentId: l, rows: f, type: p, columns: m, delimiter: b, customHeaders: y } = u.parameters, v;
  if (!(f != null && f.length)) {
    notificationStore.actions.error("Please select at least one row");
    return;
  }
  const k = rowSelectionStore.actions.getSelection(l);
  if ((S = k == null ? void 0 : k.selectedRows) != null && S.length && (f = k.selectedRows, v = k.tableId), v || (v = ($ = f == null ? void 0 : f[0]) == null ? void 0 : $.tableId), !v) {
    try {
      const w = convertDataToExportFormat(
        f,
        p,
        m,
        b
      );
      download(
        new Blob([w], { type: "text/plain" }),
        `${l}.${p}`
      );
    } catch (w) {
      notificationStore.actions.error(
        `Error exporting data: ${w.message || w}`
      );
    }
    return;
  }
  try {
    typeof f[0] != "string" && (f = f.map((T) => T._id));
    const w = await API.exportRows(v, p, {
      rows: f,
      columns: m == null ? void 0 : m.map((T) => T.name || T),
      delimiter: b,
      customHeaders: y
    });
    download(new Blob([w], { type: "text/plain" }), `${v}.${p}`);
  } catch {
    notificationStore.actions.error("There was an error exporting the data");
  }
}, continueIfHandler = (u) => {
  const { type: l, value: f, operator: p, referenceValue: m } = u.parameters;
  if (!l || !p)
    return;
  let b = !1;
  return f == null && m == null || f === m ? b = !0 : b = JSON.stringify(f) === JSON.stringify(m), l === "continue" ? p === "equal" ? b : !b : p === "equal" ? !b : b;
}, showNotificationHandler = (u) => {
  var b, y;
  const { message: l, type: f, autoDismiss: p, duration: m } = u.parameters;
  !l || !f || (y = (b = notificationStore.actions)[f]) == null || y.call(b, l, p, m);
}, promptUserHandler = () => {
}, copyToClipboardHandler = async (u) => {
  const { textToCopy: l, showNotification: f, notificationMessage: p } = u.parameters;
  if (l) {
    try {
      if (await navigator.clipboard.writeText(l), f) {
        const m = p || "Copied to clipboard";
        notificationStore.actions.success(m, !0, 3e3);
      }
    } catch (m) {
      console.error("Failed to copy text: ", m), notificationStore.actions.error("Failed to copy to clipboard");
    }
    return { copied: l };
  }
}, openSidePanelHandler = (u) => {
  const { id: l } = u.parameters;
  l && sidePanelStore.actions.open(l);
}, closeSidePanelHandler = () => {
  sidePanelStore.actions.close();
}, openModalHandler = (u) => {
  const { id: l } = u.parameters;
  l && modalStore.actions.open(l);
}, closeModalHandler = () => {
  modalStore.actions.close();
}, downloadFileHandler = async (u) => {
  const { url: l, fileName: f } = u.parameters;
  try {
    const { type: p } = u.parameters;
    if (p === "attachment") {
      const { tableId: v, rowId: k, attachmentColumn: S } = u.parameters, $ = await API.downloadAttachment(v, k, S);
      await downloadStream($);
      return;
    }
    const m = await fetch(l);
    if (!m.ok) {
      notificationStore.actions.error(
        `Failed to download from '${l}'. Server returned status code: ${m.status}`
      );
      return;
    }
    const b = URL.createObjectURL(await m.blob()), y = document.createElement("a");
    y.href = b, y.download = f, y.click(), URL.revokeObjectURL(b);
  } catch (p) {
    console.error(p), p.status ? notificationStore.actions.error(
      `Failed to download from '${l}'. Server returned status code: ${p.status}`
    ) : notificationStore.actions.error(`Failed to download from '${l}'.`);
  }
}, rowActionHandler = async (u) => {
  const { resourceId: l, rowId: f, rowActionId: p } = u.parameters;
  await API.rowActions.trigger(l, p, f), await dataSourceStore.actions.invalidateDataSource(l, {
    invalidateRelationships: !0
  });
}, handlerMap$1 = {
  "Fetch Row": fetchRowHandler,
  "Save Row": saveRowHandler,
  "Duplicate Row": duplicateRowHandler,
  "Delete Row": deleteRowHandler,
  "Navigate To": navigationHandler,
  "Execute Query": queryExecutionHandler,
  "Trigger Automation": triggerAutomationHandler,
  "Log Out": logoutHandler,
  "Close Screen Modal": closeScreenModalHandler,
  "Update State": updateStateHandler,
  "Upload File to S3": s3UploadHandler,
  "Export Data": exportDataHandler,
  "Continue if / Stop if": continueIfHandler,
  "Show Notification": showNotificationHandler,
  "Prompt User": promptUserHandler,
  "Open Side Panel": openSidePanelHandler,
  "Close Side Panel": closeSidePanelHandler,
  "Open Modal": openModalHandler,
  "Close Modal": closeModalHandler,
  "Download File": downloadFileHandler,
  "Row Action": rowActionHandler,
  "Copy To Clipboard": copyToClipboardHandler
}, confirmTextMap = {
  "Delete Row": "Are you sure you want to delete this row?",
  "Save Row": "Are you sure you want to save this row?",
  "Execute Query": "Are you sure you want to execute this query?",
  "Trigger Automation": "Are you sure you want to trigger this automation?",
  "Prompt User": "Are you sure you want to continue?",
  "Duplicate Row": "Are you sure you want to duplicate this row?"
}, enrichButtonActions = (u, l) => {
  if (!(u != null && u.length) || get_store_value(builderStore).inBuilder)
    return null;
  if (typeof u == "function")
    return u;
  const f = u.map((p) => handlerMap$1[p["##eventHandlerType"]] || contextActionHandler);
  return async (p) => {
    var b;
    let m = l.actions || [];
    for (let y = 0; y < f.length; y++)
      try {
        if (!f[y])
          continue;
        const v = {
          ...l,
          state: get_store_value(stateStore),
          actions: m,
          eventContext: p
        };
        let k = u[y];
        k = enrichDataBindings(k, v);
        const S = async () => f[y](k, v);
        if ((b = k.parameters) != null && b.confirm)
          return new Promise(($) => {
            var L, M, B, j;
            const w = confirmTextMap[k["##eventHandlerType"]], T = ((L = k.parameters) == null ? void 0 : L.confirmText) || w, E = k["##eventHandlerType"], R = ((M = k.parameters) == null ? void 0 : M.customTitleText) || E, O = ((B = k.parameters) == null ? void 0 : B.cancelButtonText) || "Cancel", P = ((j = k.parameters) == null ? void 0 : j.confirmButtonText) || "Confirm";
            confirmationStore.actions.showConfirmation(
              R,
              T,
              async () => {
                const x = await S();
                if (x !== !1) {
                  m.push(x);
                  const N = { ...l, actions: m }, D = enrichButtonActions(
                    u.slice(y + 1),
                    N
                  );
                  $(typeof D == "function" ? await D(p) : !0);
                } else
                  $(!1);
              },
              () => {
                $(!1);
              },
              P,
              O
            );
          });
        {
          const $ = await S();
          if ($ === !1)
            return;
          m.push($);
        }
      } catch (v) {
        console.error("Error while executing button handler"), console.error(v);
        return;
      }
  };
}, propsAreSame = (u, l) => u === l ? !0 : typeof u == "function" || typeof l == "function" ? !1 : JSON.stringify(u) === JSON.stringify(l), enrichProps = (u, l, f) => {
  var v;
  let p = { ...u }, m = {};
  Object.keys(p).forEach((k) => {
    var S;
    ((S = f == null ? void 0 : f[k]) == null ? void 0 : S.type) === "event" && (m[k] = p[k], delete p[k]);
  });
  let b = p._conditions, y = enrichDataBindings(p, l);
  return Object.keys(m).forEach((k) => {
    y[k] = enrichButtonActions(m[k], l);
  }), (v = y._conditions) != null && v.length && y._conditions.forEach((k, S) => {
    var $;
    (($ = f == null ? void 0 : f[k.setting]) == null ? void 0 : $.type) === "event" && (k.settingValue = enrichButtonActions(
      b[S].settingValue,
      l
    ), k.rand = Math.random());
  }), y;
}, getActiveConditions = (u) => u != null && u.length ? u.filter((l) => {
  l.valueType === "number" ? (l.referenceValue = parseFloat(l.referenceValue), l.newValue = parseFloat(l.newValue)) : l.valueType === "datetime" ? (l.referenceValue && (l.referenceValue = new Date(
    l.referenceValue
  ).toISOString()), l.newValue && (l.newValue = new Date(l.newValue).toISOString())) : l.valueType === "boolean" && (l.referenceValue = `${l.referenceValue}`.toLowerCase() === "true", l.newValue = `${l.newValue}`.toLowerCase() === "true");
  const f = {
    ...l,
    type: l.valueType,
    field: "newValue",
    value: l.referenceValue
  };
  let p = buildQuery$1([f]);
  return p.onEmptyFilter = EmptyFilterOption.RETURN_NONE, runQuery$1([f], p).length > 0;
}) : [], reduceConditionActions = (u) => {
  let l = {}, f = null;
  return u == null || u.forEach((p) => {
    p.action === "show" ? f = !0 : p.action === "hide" ? f = !1 : p.setting && (l[p.setting] = p.settingValue);
  }), { settingUpdates: l, visible: f };
}, EmptyPlaceholder_svelte_svelte_type_style_lang = "";
function create_if_block$k(u) {
  var m;
  let l, f = (
    /*$component*/
    (u[0].name || /*definition*/
    ((m = u[1]) == null ? void 0 : m.name) || "Component") + ""
  ), p;
  return {
    c() {
      l = element("div"), p = text$2(f), attr(l, "class", "component-placeholder svelte-1uv9ndz");
    },
    m(b, y) {
      insert(b, l, y), append$1(l, p);
    },
    p(b, y) {
      var v;
      y & /*$component, definition*/
      3 && f !== (f = /*$component*/
      (b[0].name || /*definition*/
      ((v = b[1]) == null ? void 0 : v.name) || "Component") + "") && set_data(p, f);
    },
    d(b) {
      b && detach(l);
    }
  };
}
function create_fragment$F(u) {
  let l, f = (
    /*$builderStore*/
    u[2].inBuilder && create_if_block$k(u)
  );
  return {
    c() {
      f && f.c(), l = empty$1();
    },
    m(p, m) {
      f && f.m(p, m), insert(p, l, m);
    },
    p(p, [m]) {
      /*$builderStore*/
      p[2].inBuilder ? f ? f.p(p, m) : (f = create_if_block$k(p), f.c(), f.m(l.parentNode, l)) : f && (f.d(1), f = null);
    },
    i: noop$4,
    o: noop$4,
    d(p) {
      p && detach(l), f && f.d(p);
    }
  };
}
function instance$D(u, l, f) {
  let p, m, b;
  const y = getContext$1("component");
  component_subscribe(u, y, (S) => f(0, m = S));
  const { builderStore: v, componentStore: k } = getContext$1("sdk");
  return component_subscribe(u, v, (S) => f(2, b = S)), u.$$.update = () => {
    u.$$.dirty & /*$component*/
    1 && f(1, p = k.actions.getComponentDefinition(m.type));
  }, [m, p, b, y, v];
}
class EmptyPlaceholder extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$D, create_fragment$F, safe_not_equal, {});
  }
}
const ScreenPlaceholder_svelte_svelte_type_style_lang = "";
function create_if_block$j(u) {
  let l, f, p, m, b, y, v;
  return f = new Heading({
    props: {
      size: "L",
      $$slots: { default: [create_default_slot_2$7] },
      $$scope: { ctx: u }
    }
  }), m = new Body({
    props: {
      $$slots: { default: [create_default_slot_1$a] },
      $$scope: { ctx: u }
    }
  }), y = new Button({
    props: {
      cta: !0,
      icon: "plus",
      $$slots: { default: [create_default_slot$m] },
      $$scope: { ctx: u }
    }
  }), y.$on(
    "click",
    /*builderStore*/
    u[1].actions.requestAddComponent
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), p = space(), create_component(m.$$.fragment), b = space(), create_component(y.$$.fragment), attr(l, "class", "placeholder svelte-1bc7j1u");
    },
    m(k, S) {
      insert(k, l, S), mount_component(f, l, null), append$1(l, p), mount_component(m, l, null), append$1(l, b), mount_component(y, l, null), v = !0;
    },
    p(k, S) {
      const $ = {};
      S & /*$$scope*/
      4 && ($.$$scope = { dirty: S, ctx: k }), f.$set($);
      const w = {};
      S & /*$$scope*/
      4 && (w.$$scope = { dirty: S, ctx: k }), m.$set(w);
      const T = {};
      S & /*$$scope*/
      4 && (T.$$scope = { dirty: S, ctx: k }), y.$set(T);
    },
    i(k) {
      v || (transition_in(f.$$.fragment, k), transition_in(m.$$.fragment, k), transition_in(y.$$.fragment, k), v = !0);
    },
    o(k) {
      transition_out(f.$$.fragment, k), transition_out(m.$$.fragment, k), transition_out(y.$$.fragment, k), v = !1;
    },
    d(k) {
      k && detach(l), destroy_component(f), destroy_component(m), destroy_component(y);
    }
  };
}
function create_default_slot_2$7(u) {
  let l;
  return {
    c() {
      l = text$2("Your screen is empty");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot_1$a(u) {
  let l;
  return {
    c() {
      l = text$2("Bring your app to life by adding some components!");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot$m(u) {
  let l;
  return {
    c() {
      l = text$2("Add component");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_fragment$E(u) {
  let l, f, p = (
    /*$builderStore*/
    u[0].inBuilder && create_if_block$j(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, [b]) {
      /*$builderStore*/
      m[0].inBuilder ? p ? (p.p(m, b), b & /*$builderStore*/
      1 && transition_in(p, 1)) : (p = create_if_block$j(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
function instance$C(u, l, f) {
  let p;
  const { builderStore: m } = getContext$1("sdk");
  return component_subscribe(u, m, (b) => f(0, p = b)), [p, m];
}
class ScreenPlaceholder extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$C, create_fragment$E, safe_not_equal, {});
  }
}
function create_if_block$i(u) {
  let l;
  function f(b, y) {
    if (
      /*error*/
      b[0].errorType === "setting"
    )
      return create_if_block_1$8;
    if (
      /*error*/
      b[0].errorType === "ancestor-setting"
    )
      return create_if_block_2$6;
  }
  let p = f(u), m = p && p(u);
  return {
    c() {
      m && m.c(), l = empty$1();
    },
    m(b, y) {
      m && m.m(b, y), insert(b, l, y);
    },
    p(b, y) {
      p === (p = f(b)) && m ? m.p(b, y) : (m && m.d(1), m = p && p(b), m && (m.c(), m.m(l.parentNode, l)));
    },
    d(b) {
      b && detach(l), m && m.d(b);
    }
  };
}
function create_if_block_2$6(u) {
  let l, f, p, m, b = (
    /*error*/
    u[0].ancestor.name + ""
  ), y, v, k;
  return {
    c() {
      l = element("span"), l.textContent = "-", f = space(), p = element("span"), m = text$2("Add "), y = text$2(b), attr(p, "class", "spectrum-Link");
    },
    m(S, $) {
      insert(S, l, $), insert(S, f, $), insert(S, p, $), append$1(p, m), append$1(p, y), v || (k = listen(
        p,
        "click",
        /*click_handler_1*/
        u[5]
      ), v = !0);
    },
    p(S, $) {
      $ & /*error*/
      1 && b !== (b = /*error*/
      S[0].ancestor.name + "") && set_data(y, b);
    },
    d(S) {
      S && (detach(l), detach(f), detach(p)), v = !1, k();
    }
  };
}
function create_if_block_1$8(u) {
  let l, f, p, m, b;
  return {
    c() {
      l = element("span"), l.textContent = "-", f = space(), p = element("span"), p.textContent = "Show me", attr(p, "class", "spectrum-Link");
    },
    m(y, v) {
      insert(y, l, v), insert(y, f, v), insert(y, p, v), m || (b = listen(
        p,
        "click",
        /*click_handler*/
        u[4]
      ), m = !0);
    },
    p: noop$4,
    d(y) {
      y && (detach(l), detach(f), detach(p)), m = !1, b();
    }
  };
}
function create_fragment$D(u) {
  let l, f = (
    /*error*/
    u[0] && create_if_block$i(u)
  );
  return {
    c() {
      f && f.c(), l = empty$1();
    },
    m(p, m) {
      f && f.m(p, m), insert(p, l, m);
    },
    p(p, [m]) {
      /*error*/
      p[0] ? f ? f.p(p, m) : (f = create_if_block$i(p), f.c(), f.m(l.parentNode, l)) : f && (f.d(1), f = null);
    },
    i: noop$4,
    o: noop$4,
    d(p) {
      p && detach(l), f && f.d(p);
    }
  };
}
function instance$B(u, l, f) {
  let p, { error: m } = l;
  const b = getContext$1("component");
  component_subscribe(u, b, (S) => f(1, p = S));
  const { builderStore: y } = getContext$1("sdk"), v = () => {
    y.actions.highlightSetting(m.key);
  }, k = () => {
    y.actions.addParentComponent(p.id, m.ancestor.fullType);
  };
  return u.$$set = (S) => {
    "error" in S && f(0, m = S.error);
  }, [m, p, b, y, v, k];
}
class ComponentErrorStateCTA extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$B, create_fragment$D, safe_not_equal, { error: 0 });
  }
}
const ComponentErrorState_svelte_svelte_type_style_lang = "";
function create_if_block$h(u) {
  let l, f, p = (
    /*$component*/
    u[0].errorState && create_if_block_1$7(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, b) {
      /*$component*/
      m[0].errorState ? p ? (p.p(m, b), b & /*$component*/
      1 && transition_in(p, 1)) : (p = create_if_block_1$7(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
function create_if_block_1$7(u) {
  let l, f, p, m, b, y, v;
  f = new Icon({
    props: {
      name: "warning",
      color: "var(--spectrum-global-color-static-red-600)"
    }
  });
  let k = (
    /*errorMessage*/
    u[1] && create_if_block_2$5(u)
  );
  return {
    c() {
      l = element("div"), create_component(f.$$.fragment), p = space(), k && k.c(), attr(l, "class", "component-placeholder svelte-129t83p");
    },
    m(S, $) {
      insert(S, l, $), mount_component(f, l, null), append$1(l, p), k && k.m(l, null), b = !0, y || (v = action_destroyer(m = /*styleable*/
      u[5].call(
        null,
        l,
        /*styles*/
        u[2]
      )), y = !0);
    },
    p(S, $) {
      /*errorMessage*/
      S[1] ? k ? (k.p(S, $), $ & /*errorMessage*/
      2 && transition_in(k, 1)) : (k = create_if_block_2$5(S), k.c(), transition_in(k, 1), k.m(l, null)) : k && (group_outros(), transition_out(k, 1, 1, () => {
        k = null;
      }), check_outros()), m && is_function(m.update) && $ & /*styles*/
      4 && m.update.call(
        null,
        /*styles*/
        S[2]
      );
    },
    i(S) {
      b || (transition_in(f.$$.fragment, S), transition_in(k), b = !0);
    },
    o(S) {
      transition_out(f.$$.fragment, S), transition_out(k), b = !1;
    },
    d(S) {
      S && detach(l), destroy_component(f), k && k.d(), y = !1, v();
    }
  };
}
function create_if_block_2$5(u) {
  let l, f = (
    /*errorMessage*/
    u[1].message + ""
  ), p, m, b;
  return m = new ComponentErrorStateCTA({
    props: { error: (
      /*errorMessage*/
      u[1]
    ) }
  }), {
    c() {
      l = new HtmlTag(!1), p = space(), create_component(m.$$.fragment), l.a = p;
    },
    m(y, v) {
      l.m(f, y, v), insert(y, p, v), mount_component(m, y, v), b = !0;
    },
    p(y, v) {
      (!b || v & /*errorMessage*/
      2) && f !== (f = /*errorMessage*/
      y[1].message + "") && l.p(f);
      const k = {};
      v & /*errorMessage*/
      2 && (k.error = /*errorMessage*/
      y[1]), m.$set(k);
    },
    i(y) {
      b || (transition_in(m.$$.fragment, y), b = !0);
    },
    o(y) {
      transition_out(m.$$.fragment, y), b = !1;
    },
    d(y) {
      y && (l.d(), detach(p)), destroy_component(m, y);
    }
  };
}
function create_fragment$C(u) {
  let l, f, p = (
    /*$builderStore*/
    u[3].inBuilder && create_if_block$h(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, [b]) {
      /*$builderStore*/
      m[3].inBuilder ? p ? (p.p(m, b), b & /*$builderStore*/
      8 && transition_in(p, 1)) : (p = create_if_block$h(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
function instance$A(u, l, f) {
  let p, m, b, y, { componentErrors: v } = l;
  const k = getContext$1("component");
  component_subscribe(u, k, (w) => f(0, b = w));
  const { styleable: S, builderStore: $ } = getContext$1("sdk");
  return component_subscribe(u, $, (w) => f(3, y = w)), u.$$set = (w) => {
    "componentErrors" in w && f(7, v = w.componentErrors);
  }, u.$$.update = () => {
    u.$$.dirty & /*$component*/
    1 && f(2, p = {
      ...b.styles,
      normal: {},
      custom: null,
      empty: !0
    }), u.$$.dirty & /*componentErrors*/
    128 && f(1, m = v == null ? void 0 : v[0]);
  }, [
    b,
    m,
    p,
    y,
    k,
    S,
    $,
    v
  ];
}
class ComponentErrorState extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$A, create_fragment$C, safe_not_equal, { componentErrors: 7 });
  }
}
const buildStyleString = (u, l) => {
  let f = "";
  for (let p of Object.keys(u || {}))
    u[p] != null && (f += `${p}:${u[p]};`);
  return f + (l || "");
}, styleable = (u, l = {}) => {
  let f, p, m, b;
  const y = (k = {}) => {
    u.classList.add(`${k.id}-dom`);
    let S = {};
    k.empty && (S.padding = "var(--spacing-l)", S.overflow = "hidden", k.selected ? S.border = "2px solid transparent" : S.border = "2px dashed var(--spectrum-global-color-gray-400)");
    const $ = k.id, w = k.custom || "", { isBlock: T } = k, E = { ...S, ...k.normal }, R = {
      ...E,
      ...k.hover || {}
    };
    u.setAttribute("draggable", !!k.draggable);
    const O = (P) => {
      u.style = P;
    };
    f = () => {
      O(buildStyleString(E, w));
    }, p = () => {
      O(buildStyleString(R, w));
    }, m = (P) => (builderStore.actions.selectComponent($), P.preventDefault(), P.stopPropagation(), !1), b = (P) => {
      if (!T)
        return k.interactive && k.editable && builderStore.actions.setEditMode(!0), P.preventDefault(), P.stopPropagation(), !1;
    }, u.addEventListener("mouseover", p), u.addEventListener("mouseout", f), k.interactive && !k.isRoot && (u.addEventListener("click", m, !1), u.addEventListener("dblclick", b, !1)), f();
  }, v = () => {
    u.removeEventListener("mouseover", p), u.removeEventListener("mouseout", f), u.removeEventListener("click", m), u.removeEventListener("dblclick", b);
  };
  return y(l), {
    // Clean up old listeners and apply new ones on update
    update: (k) => {
      v(), y(k);
    },
    // Clean up listeners when component is destroyed
    destroy: () => {
      v();
    }
  };
};
var GridParams = /* @__PURE__ */ ((u) => (u.HAlign = "h-align", u.VAlign = "v-align", u.ColStart = "col-start", u.ColEnd = "col-end", u.RowStart = "row-start", u.RowEnd = "row-end", u))(GridParams || {}), Devices = /* @__PURE__ */ ((u) => (u.Desktop = "desktop", u.Mobile = "mobile", u))(Devices || {}), GridDragMode = /* @__PURE__ */ ((u) => (u.Resize = "resize", u.Move = "move", u))(GridDragMode || {});
const getGridVar = (u, l) => `--grid-${u}-${l}`, isGridEvent = (u) => {
  var p, m, b, y, v, k;
  if (!(u.target instanceof HTMLElement))
    return !1;
  const l = (b = (m = (p = u.target).closest) == null ? void 0 : m.call(p, ".component")) == null ? void 0 : b.parentNode, f = (y = l == null ? void 0 : l.closest(".component")) == null ? void 0 : y.childNodes[0];
  return ((v = u.target.dataset) == null ? void 0 : v.indicator) === "true" || !!((k = f == null ? void 0 : f.classList) != null && k.contains("grid"));
}, gridLayout = (u, l) => {
  let f;
  const p = (b) => {
    var B, j, x, N;
    const {
      id: y,
      styles: v,
      interactive: k,
      errored: S,
      definition: $,
      draggable: w,
      insideGrid: T,
      ignoresLayout: E
    } = b;
    if (!T)
      return;
    if (E) {
      u.classList.add("ignores-layout");
      return;
    }
    u.classList.add("grid-child"), f = (D) => {
      D.stopPropagation(), builderStore.actions.selectComponent(y);
    };
    let R = v["--default-width"] ?? ((B = $ == null ? void 0 : $.size) == null ? void 0 : B.width) ?? 200, O = v["--default-height"] ?? ((j = $ == null ? void 0 : $.size) == null ? void 0 : j.height) ?? 200;
    S && (R = 500, O = 60), R += 2 * GridSpacing, O += 2 * GridSpacing;
    const P = {
      "--default-width": R,
      "--default-height": O
    }, L = {
      "h-align": ((x = $ == null ? void 0 : $.grid) == null ? void 0 : x.hAlign) || "stretch",
      "v-align": ((N = $ == null ? void 0 : $.grid) == null ? void 0 : N.vAlign) || "center",
      "col-start": 1,
      "col-end": "round(up, calc((var(--grid-spacing) * 2 + var(--default-width)) / var(--col-size) + 1))",
      "row-start": 1,
      "row-end": Math.max(2, Math.ceil(O / GridRowHeight) + 1)
    };
    for (let D of Object.values(GridParams)) {
      let V = getGridVar("desktop", D), W = getGridVar("mobile", D);
      P[V] = v[V] ?? v[W] ?? L[D], P[W] = v[W] ?? v[V] ?? L[D];
    }
    S && (P[getGridVar(
      "desktop",
      "h-align"
      /* HAlign */
    )] = "stretch", P[getGridVar(
      "mobile",
      "h-align"
      /* HAlign */
    )] = "stretch", P[getGridVar(
      "desktop",
      "v-align"
      /* VAlign */
    )] = "stretch", P[getGridVar(
      "mobile",
      "v-align"
      /* VAlign */
    )] = "stretch");
    const M = (D, V, W) => {
      const F = `${P[getGridVar(V, W)]}`;
      u.dataset[D] !== F && (u.dataset[D] = F);
    };
    M(
      "gridDesktopRowEnd",
      "desktop",
      "row-end"
      /* RowEnd */
    ), M(
      "gridMobileRowEnd",
      "mobile",
      "row-end"
      /* RowEnd */
    ), M(
      "gridDesktopHAlign",
      "desktop",
      "h-align"
      /* HAlign */
    ), M(
      "gridMobileHAlign",
      "mobile",
      "h-align"
      /* HAlign */
    ), M(
      "gridDesktopVAlign",
      "desktop",
      "v-align"
      /* VAlign */
    ), M(
      "gridMobileVAlign",
      "mobile",
      "v-align"
      /* VAlign */
    ), u.dataset.insideGrid !== "true" && (u.dataset.insideGrid = "true"), u.style = buildStyleString(P), k && u.addEventListener("click", f, !1), u.setAttribute("draggable", (!!w).toString());
  }, m = () => {
    f && (u.removeEventListener("click", f, !1), f = null);
  };
  return p(l), {
    update(b) {
      m(), p(b);
    },
    destroy() {
      m();
    }
  };
}, Component_svelte_svelte_type_style_lang = "";
function get_each_context$8(u, l, f) {
  const p = u.slice();
  return p[83] = l[f], p;
}
function create_if_block$g(u) {
  let l, f, p, m, b, y, v, k, S;
  const $ = [create_if_block_1$6, create_else_block$3], w = [];
  function T(E, R) {
    return (
      /*hasComponentErrors*/
      E[5] ? 0 : 1
    );
  }
  return f = T(u), p = w[f] = $[f](u), {
    c() {
      l = element("div"), p.c(), attr(l, "class", m = null_to_empty(`component ${/*id*/
      u[4]}`) + " svelte-d44q0m"), attr(
        l,
        "data-id",
        /*id*/
        u[4]
      ), attr(
        l,
        "data-name",
        /*name*/
        u[7]
      ), attr(
        l,
        "data-icon",
        /*icon*/
        u[24]
      ), attr(l, "data-parent", b = /*$component*/
      u[16].id), toggle_class(
        l,
        "draggable",
        /*draggable*/
        u[10]
      ), toggle_class(
        l,
        "droppable",
        /*droppable*/
        u[23]
      ), toggle_class(
        l,
        "empty",
        /*empty*/
        u[14]
      ), toggle_class(
        l,
        "interactive",
        /*interactive*/
        u[11]
      ), toggle_class(
        l,
        "editing",
        /*editing*/
        u[6]
      ), toggle_class(
        l,
        "pad",
        /*pad*/
        u[3]
      ), toggle_class(
        l,
        "parent",
        /*hasChildren*/
        u[13]
      ), toggle_class(
        l,
        "block",
        /*isBlock*/
        u[2]
      ), toggle_class(
        l,
        "error",
        /*hasComponentErrors*/
        u[5]
      ), toggle_class(
        l,
        "root",
        /*isRoot*/
        u[1]
      );
    },
    m(E, R) {
      insert(E, l, R), w[f].m(l, null), v = !0, k || (S = action_destroyer(y = gridLayout.call(
        null,
        l,
        /*gridMetadata*/
        u[21]
      )), k = !0);
    },
    p(E, R) {
      let O = f;
      f = T(E), f === O ? w[f].p(E, R) : (group_outros(), transition_out(w[O], 1, 1, () => {
        w[O] = null;
      }), check_outros(), p = w[f], p ? p.p(E, R) : (p = w[f] = $[f](E), p.c()), transition_in(p, 1), p.m(l, null)), (!v || R[0] & /*id*/
      16 && m !== (m = null_to_empty(`component ${/*id*/
      E[4]}`) + " svelte-d44q0m")) && attr(l, "class", m), (!v || R[0] & /*id*/
      16) && attr(
        l,
        "data-id",
        /*id*/
        E[4]
      ), (!v || R[0] & /*name*/
      128) && attr(
        l,
        "data-name",
        /*name*/
        E[7]
      ), (!v || R[0] & /*icon*/
      16777216) && attr(
        l,
        "data-icon",
        /*icon*/
        E[24]
      ), (!v || R[0] & /*$component*/
      65536 && b !== (b = /*$component*/
      E[16].id)) && attr(l, "data-parent", b), y && is_function(y.update) && R[0] & /*gridMetadata*/
      2097152 && y.update.call(
        null,
        /*gridMetadata*/
        E[21]
      ), (!v || R[0] & /*id, draggable*/
      1040) && toggle_class(
        l,
        "draggable",
        /*draggable*/
        E[10]
      ), (!v || R[0] & /*id, droppable*/
      8388624) && toggle_class(
        l,
        "droppable",
        /*droppable*/
        E[23]
      ), (!v || R[0] & /*id, empty*/
      16400) && toggle_class(
        l,
        "empty",
        /*empty*/
        E[14]
      ), (!v || R[0] & /*id, interactive*/
      2064) && toggle_class(
        l,
        "interactive",
        /*interactive*/
        E[11]
      ), (!v || R[0] & /*id, editing*/
      80) && toggle_class(
        l,
        "editing",
        /*editing*/
        E[6]
      ), (!v || R[0] & /*id, pad*/
      24) && toggle_class(
        l,
        "pad",
        /*pad*/
        E[3]
      ), (!v || R[0] & /*id, hasChildren*/
      8208) && toggle_class(
        l,
        "parent",
        /*hasChildren*/
        E[13]
      ), (!v || R[0] & /*id, isBlock*/
      20) && toggle_class(
        l,
        "block",
        /*isBlock*/
        E[2]
      ), (!v || R[0] & /*id, hasComponentErrors*/
      48) && toggle_class(
        l,
        "error",
        /*hasComponentErrors*/
        E[5]
      ), (!v || R[0] & /*id, isRoot*/
      18) && toggle_class(
        l,
        "root",
        /*isRoot*/
        E[1]
      );
    },
    i(E) {
      v || (transition_in(p), v = !0);
    },
    o(E) {
      transition_out(p), v = !1;
    },
    d(E) {
      E && detach(l), w[f].d(), k = !1, S();
    }
  };
}
function create_else_block$3(u) {
  let l, f, p;
  const m = [
    /*initialSettings*/
    u[18]
  ];
  var b = (
    /*constructor*/
    u[20]
  );
  function y(v, k) {
    let S = {
      $$slots: { default: [create_default_slot$l] },
      $$scope: { ctx: v }
    };
    for (let $ = 0; $ < m.length; $ += 1)
      S = assign(S, m[$]);
    return k !== void 0 && k[0] & /*initialSettings*/
    262144 && (S = assign(S, get_spread_update(m, [get_spread_object(
      /*initialSettings*/
      v[18]
    )]))), { props: S };
  }
  return b && (l = construct_svelte_component(b, y(u)), u[57](l)), {
    c() {
      l && create_component(l.$$.fragment), f = empty$1();
    },
    m(v, k) {
      l && mount_component(l, v, k), insert(v, f, k), p = !0;
    },
    p(v, k) {
      if (k[0] & /*constructor*/
      1048576 && b !== (b = /*constructor*/
      v[20])) {
        if (l) {
          group_outros();
          const S = l;
          transition_out(S.$$.fragment, 1, 0, () => {
            destroy_component(S, 1);
          }), check_outros();
        }
        b ? (l = construct_svelte_component(b, y(v, k)), v[57](l), create_component(l.$$.fragment), transition_in(l.$$.fragment, 1), mount_component(l, f.parentNode, f)) : l = null;
      } else if (b) {
        const S = k[0] & /*initialSettings*/
        262144 ? get_spread_update(m, [get_spread_object(
          /*initialSettings*/
          v[18]
        )]) : {};
        k[0] & /*children, instance, isRoot, emptyState, isBlock*/
        4615 | k[1] & /*$$scope*/
        134217728 && (S.$$scope = { dirty: k, ctx: v }), l.$set(S);
      }
    },
    i(v) {
      p || (l && transition_in(l.$$.fragment, v), p = !0);
    },
    o(v) {
      l && transition_out(l.$$.fragment, v), p = !1;
    },
    d(v) {
      v && detach(f), u[57](null), l && destroy_component(l, v);
    }
  };
}
function create_if_block_1$6(u) {
  let l, f;
  return l = new ComponentErrorState({
    props: {
      componentErrors: (
        /*componentErrors*/
        u[15]
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*componentErrors*/
      32768 && (b.componentErrors = /*componentErrors*/
      p[15]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_5$2(u) {
  let l;
  const f = (
    /*#slots*/
    u[56].default
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[58],
    null
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, b) {
      p && p.p && (!l || b[1] & /*$$scope*/
      134217728) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[58],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[58],
          b,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[58]
        ),
        null
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function create_if_block_3$3(u) {
  let l, f, p, m;
  const b = [create_if_block_4$2, create_else_block_1$1], y = [];
  function v(k, S) {
    return (
      /*isRoot*/
      k[1] ? 0 : 1
    );
  }
  return l = v(u), f = y[l] = b[l](u), {
    c() {
      f.c(), p = empty$1();
    },
    m(k, S) {
      y[l].m(k, S), insert(k, p, S), m = !0;
    },
    p(k, S) {
      let $ = l;
      l = v(k), l !== $ && (group_outros(), transition_out(y[$], 1, 1, () => {
        y[$] = null;
      }), check_outros(), f = y[l], f || (f = y[l] = b[l](k), f.c()), transition_in(f, 1), f.m(p.parentNode, p));
    },
    i(k) {
      m || (transition_in(f), m = !0);
    },
    o(k) {
      transition_out(f), m = !1;
    },
    d(k) {
      k && detach(p), y[l].d(k);
    }
  };
}
function create_if_block_2$4(u) {
  let l = [], f = /* @__PURE__ */ new Map(), p, m, b = ensure_array_like(
    /*children*/
    u[12]
  );
  const y = (v) => (
    /*child*/
    v[83]._id
  );
  for (let v = 0; v < b.length; v += 1) {
    let k = get_each_context$8(u, b, v), S = y(k);
    f.set(S, l[v] = create_each_block$8(S, k));
  }
  return {
    c() {
      for (let v = 0; v < l.length; v += 1)
        l[v].c();
      p = empty$1();
    },
    m(v, k) {
      for (let S = 0; S < l.length; S += 1)
        l[S] && l[S].m(v, k);
      insert(v, p, k), m = !0;
    },
    p(v, k) {
      k[0] & /*children, instance*/
      4097 && (b = ensure_array_like(
        /*children*/
        v[12]
      ), group_outros(), l = update_keyed_each(l, k, y, 1, v, b, f, p.parentNode, outro_and_destroy_block, create_each_block$8, p, get_each_context$8), check_outros());
    },
    i(v) {
      if (!m) {
        for (let k = 0; k < b.length; k += 1)
          transition_in(l[k]);
        m = !0;
      }
    },
    o(v) {
      for (let k = 0; k < l.length; k += 1)
        transition_out(l[k]);
      m = !1;
    },
    d(v) {
      v && detach(p);
      for (let k = 0; k < l.length; k += 1)
        l[k].d(v);
    }
  };
}
function create_else_block_1$1(u) {
  let l, f;
  return l = new EmptyPlaceholder({}), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_4$2(u) {
  let l, f;
  return l = new ScreenPlaceholder({}), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_each_block$8(u, l) {
  let f, p, m;
  return p = new Component({
    props: {
      instance: (
        /*child*/
        l[83]
      ),
      parent: (
        /*instance*/
        l[0]
      )
    }
  }), {
    key: u,
    first: null,
    c() {
      f = empty$1(), create_component(p.$$.fragment), this.first = f;
    },
    m(b, y) {
      insert(b, f, y), mount_component(p, b, y), m = !0;
    },
    p(b, y) {
      l = b;
      const v = {};
      y[0] & /*children*/
      4096 && (v.instance = /*child*/
      l[83]), y[0] & /*instance*/
      1 && (v.parent = /*instance*/
      l[0]), p.$set(v);
    },
    i(b) {
      m || (transition_in(p.$$.fragment, b), m = !0);
    },
    o(b) {
      transition_out(p.$$.fragment, b), m = !1;
    },
    d(b) {
      b && detach(f), destroy_component(p, b);
    }
  };
}
function create_default_slot$l(u) {
  let l, f, p, m;
  const b = [create_if_block_2$4, create_if_block_3$3, create_if_block_5$2], y = [];
  function v(k, S) {
    return (
      /*children*/
      k[12].length ? 0 : (
        /*emptyState*/
        k[9] ? 1 : (
          /*isBlock*/
          k[2] ? 2 : -1
        )
      )
    );
  }
  return ~(l = v(u)) && (f = y[l] = b[l](u)), {
    c() {
      f && f.c(), p = empty$1();
    },
    m(k, S) {
      ~l && y[l].m(k, S), insert(k, p, S), m = !0;
    },
    p(k, S) {
      let $ = l;
      l = v(k), l === $ ? ~l && y[l].p(k, S) : (f && (group_outros(), transition_out(y[$], 1, 1, () => {
        y[$] = null;
      }), check_outros()), ~l ? (f = y[l], f ? f.p(k, S) : (f = y[l] = b[l](k), f.c()), transition_in(f, 1), f.m(p.parentNode, p)) : f = null);
    },
    i(k) {
      m || (transition_in(f), m = !0);
    },
    o(k) {
      transition_out(f), m = !1;
    },
    d(k) {
      k && detach(p), ~l && y[l].d(k);
    }
  };
}
function create_fragment$B(u) {
  let l, f, p = (
    /*constructor*/
    u[20] && /*initialSettings*/
    u[18] && /*visible*/
    (u[19] || /*inSelectedPath*/
    u[8]) && !/*builderHidden*/
    u[22] && create_if_block$g(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, b) {
      /*constructor*/
      m[20] && /*initialSettings*/
      m[18] && /*visible*/
      (m[19] || /*inSelectedPath*/
      m[8]) && !/*builderHidden*/
      m[22] ? p ? (p.p(m, b), b[0] & /*constructor, initialSettings, visible, inSelectedPath, builderHidden*/
      6029568 && transition_in(p, 1)) : (p = create_if_block$g(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
let SettingsDefinitionCache = {}, SettingsDefinitionMapCache = {}, InstanceSettingsCache = {};
function instance_1$3(u, l, f) {
  let p, m, b, y, v, k, S, $, w, T, E, R, O, P, L, M, B, j, x, N, D, V, W, F, U, Y, q, Q, z, H, X, Z, oe, ee, ie, de, pe, le;
  component_subscribe(u, appStore, (he) => f(67, X = he)), component_subscribe(u, dndIsDragging, (he) => f(51, ee = he)), component_subscribe(u, builderStore, (he) => f(52, ie = he)), component_subscribe(u, devToolsStore, (he) => f(53, de = he)), component_subscribe(u, dndComponentPath, (he) => f(54, pe = he)), component_subscribe(u, componentStore, (he) => f(55, le = he));
  let { $$slots: ae = {}, $$scope: ne } = l, { instance: K = {} } = l, { parent: ce = null } = l, { isLayout: te = !1 } = l, { isRoot: ue = !1 } = l, { isBlock: J = !1 } = l;
  const fe = getContext$1("context");
  component_subscribe(u, fe, (he) => f(50, Z = he));
  const _e = !!getContext$1("screenslot"), ye = getContext$1("component");
  component_subscribe(u, ye, (he) => f(16, oe = he));
  const ke = writable({});
  setContext("component", ke);
  let we, se, $e, Pe, De, He, Ce, Ue, gt, it, wt = !0, Je, Ae, Ve, Ke, st, At = "", mt = {}, et, lt = !1;
  const Ct = (he, ve = !1) => {
    if (he == null)
      return;
    const Se = JSON.stringify(he), be = hashString(Se);
    if (be === it && !ve)
      return;
    it = be, f(35, st = null);
    const Ie = he._component, Re = componentStore.actions.getComponentConstructor(Ie);
    if (((We) => typeof (We == null ? void 0 : We.then) == "function")(Re)) {
      f(20, Je = null);
      const We = be;
      Re.then((ze) => {
        We === it && f(20, Je = ze);
      }).catch((ze) => {
        We === it && (console.error("Failed to resolve component constructor", ze), f(20, Je = null));
      });
    } else
      f(20, Je = Re);
    if (f(34, Ae = componentStore.actions.getComponentDefinition(Ie)), !Ae)
      return;
    const Me = `${Ae.name}${(Ae == null ? void 0 : Ae.deprecated) === !0 ? "_deprecated" : ""}`;
    SettingsDefinitionCache[Me] ? (Ve = SettingsDefinitionCache[Me], Ke = SettingsDefinitionMapCache[Me]) : (Ve = getSettingsDefinition(Ae), Ke = Ft(Ve), SettingsDefinitionCache[Me] = Ve, SettingsDefinitionMapCache[Me] = Ke);
    let Ge;
    InstanceSettingsCache[be] ? Ge = InstanceSettingsCache[be] : (Ge = xt(he, Ve), InstanceSettingsCache[be] = Ge), f(29, Pe = Ge.staticSettings), $e = Ge.dynamicSettings;
    const qt = JSON.stringify({ ...he, _children: null }), Kt = findHBSBlocks(qt).map((We) => {
      let ze = We.replace(/\\"/g, '"');
      return isJSBinding(ze) ? decodeJSBinding(ze) : ze;
    });
    mt = Dt(he, Ve), At = Kt.join(" "), Nt(he, Ve), Tt(get_store_value(fe), Ke), et || (et = fe.actions.observeChanges(Wt));
  }, Dt = (he, ve) => {
    let Se = {};
    return ve.forEach((be) => {
      var Ie;
      be.type === "event" && ((Ie = he[be.key]) == null || Ie.forEach((Re) => {
        var Me;
        const Le = getActionContextKey(Re);
        Le && (Se[Le] = !0), (Me = getActionDependentContextKeys(Re)) == null || Me.forEach((Ge) => {
          Se[Ge] = !0;
        });
      }));
    }), Se;
  }, Nt = (he, ve) => {
    ve.forEach((Se) => {
      if (Se.type === "table") {
        const be = he[Se.key];
        be && (be.type || (be.type = "table"), be.resourceId || (be.type === "viewV2" ? be.resourceId = be.id : be.resourceId = be.tableId));
      }
    });
  }, Ft = (he) => {
    let ve = {};
    return he == null || he.forEach((Se) => {
      ve[Se.key] = Se;
    }), ve;
  }, xt = (he, ve) => {
    var Re;
    let Se = {};
    Object.entries(he).filter(([Le]) => !Le.startsWith("_")).forEach(([Le, Me]) => {
      Se[Le] = Me;
    });
    let be = { ...Se }, Ie = { ...Se };
    return Ie._conditions = he._conditions, Ie._css = (Re = he._styles) == null ? void 0 : Re.custom, ve == null || ve.forEach((Le) => {
      if (Le.nested)
        delete Ie[Le.key];
      else {
        const Me = Se[Le.key];
        Me == null ? delete Ie[Le.key] : typeof Me == "string" && Me.includes("{{") || Le.type === "event" || typeof Me == "object" && JSON.stringify(Me).includes("{{") ? delete be[Le.key] : delete Ie[Le.key];
      }
    }), {
      staticSettings: be,
      dynamicSettings: Ie
    };
  }, jt = () => {
    if (!(De != null && De._conditions)) {
      f(33, Ue = []);
      return;
    }
    f(33, Ue = De._conditions.map((he) => {
      var Se, be;
      const ve = (Se = K._conditions) == null ? void 0 : Se.find((Ie) => Ie.id === he.id);
      return (be = Ke[he.setting]) != null && be.nested && ve ? {
        ...he,
        settingValue: ve.settingValue
      } : he;
    }));
  }, Tt = (he, ve) => {
    gt = Date.now();
    const Se = gt, be = enrichProps($e, he, ve);
    Se === gt && (f(30, De = be), jt());
  }, Ut = (he) => {
    if (!(he != null && he.length))
      return;
    let ve = !he.find((Ie) => Ie.action === "show");
    const Se = getActiveConditions(he), be = reduceConditionActions(Se);
    be.visible != null && (ve = be.visible), f(31, He = be.settingUpdates), f(19, wt = ve);
  }, Ht = (he, ve, Se) => {
    const be = {
      ...he,
      ...ve,
      ...Se
    };
    if (!Ce)
      f(32, Ce = { ...be }), f(18, se = Ce);
    else {
      const Ie = new Set(Object.keys(be));
      Object.keys(Ce).forEach((Re) => Ie.add(Re)), Ie.forEach((Re) => {
        if (!propsAreSame(be[Re], Ce[Re])) {
          if (f(32, Ce[Re] = be[Re], Ce), Re.startsWith("_"))
            return;
          we != null && we.$$set ? we.$$set({ [Re]: be[Re] }) : f(18, se[Re] = be[Re], se);
        }
      });
    }
  }, Gt = async () => {
    const he = Q ? m : `${m}-dom`, ve = document.getElementsByClassName(he)[0];
    ve && (get_store_value(dndIsDragging) || Q && ve.classList.contains("dragging") || ve.scrollIntoView({
      behavior: "instant",
      block: "nearest",
      inline: "start"
    }));
  }, Wt = (he) => {
    let ve = mt[he];
    if (ve == null) {
      const Se = he === "snippets" ? he : `[${he}]`;
      ve = At.indexOf(Se) !== -1, mt[he] = ve;
    }
    ve && Tt(Z, Ke);
  }, Vt = () => {
    var Se;
    const he = get_store_value(fe), ve = (Se = we == null ? void 0 : we.getAdditionalDataContext) == null ? void 0 : Se.call(we);
    return { ...he, ...ve };
  }, Et = (he) => {
    var ve, Se;
    return !!((ve = he == null ? void 0 : he._component) != null && ve.endsWith("/container") && (he == null ? void 0 : he.layout) === "grid" || (Se = he == null ? void 0 : he._component) != null && Se.endsWith("/pdf"));
  };
  onMount(() => (X.isDevApp && (componentStore.actions.isComponentRegistered(m) || componentStore.actions.registerInstance(m, {
    component: K._component,
    getSettings: () => Ce,
    getRawSettings: () => ({ ...Pe, ...$e }),
    getDataContext: Vt,
    reload: () => Ct(K, !0),
    setEphemeralStyles: (he) => f(35, st = he),
    state: ke
  })), () => {
    componentStore.actions.isComponentRegistered(m) && componentStore.actions.unregisterInstance(m), et == null || et();
  }));
  function zt(he) {
    binding_callbacks[he ? "unshift" : "push"](() => {
      we = he, f(17, we);
    });
  }
  return u.$$set = (he) => {
    "instance" in he && f(0, K = he.instance), "parent" in he && f(27, ce = he.parent), "isLayout" in he && f(28, te = he.isLayout), "isRoot" in he && f(1, ue = he.isRoot), "isBlock" in he && f(2, J = he.isBlock), "$$scope" in he && f(58, ne = he.$$scope);
  }, u.$$.update = () => {
    var he, ve, Se, be, Ie;
    u.$$.dirty[0] & /*instance*/
    1 && Ct(K), u.$$.dirty[0] & /*instance*/
    1 && f(12, p = K._children || []), u.$$.dirty[0] & /*instance*/
    1 && f(4, m = K._id), u.$$.dirty[0] & /*isRoot, instance*/
    3 && f(7, b = ue ? "Screen" : K._instanceName), u.$$.dirty[0] & /*instance*/
    1 | u.$$.dirty[1] & /*definition*/
    8 && f(24, y = K._icon || (Ae == null ? void 0 : Ae.icon)), u.$$.dirty[0] & /*id*/
    16 | u.$$.dirty[1] & /*$builderStore*/
    2097152 && f(38, v = ie.inBuilder && ie.selectedComponentId === m), u.$$.dirty[0] & /*id*/
    16 | u.$$.dirty[1] & /*$componentStore*/
    16777216 && f(8, k = (he = le.selectedComponentPath) == null ? void 0 : he.includes(m)), u.$$.dirty[0] & /*inSelectedPath*/
    256 | u.$$.dirty[1] & /*$builderStore*/
    2097152 && f(47, S = k && ie.editMode), u.$$.dirty[0] & /*id*/
    16 | u.$$.dirty[1] & /*$dndComponentPath*/
    8388608 && f(42, $ = pe == null ? void 0 : pe.includes(m)), u.$$.dirty[0] & /*instance*/
    1 && f(15, w = (ve = K == null ? void 0 : K._meta) == null ? void 0 : ve.errors), u.$$.dirty[1] & /*definition*/
    8 && f(13, T = !!(Ae != null && Ae.hasChildren)), u.$$.dirty[1] & /*definition*/
    8 && f(45, E = (Ae == null ? void 0 : Ae.showEmptyState) !== !1), u.$$.dirty[0] & /*componentErrors*/
    32768 && f(46, R = !!(w != null && w.find((Re) => Re.errorType === "setting"))), u.$$.dirty[1] & /*definition, hasMissingRequiredSettings*/
    32776 && f(39, O = !!(Ae != null && Ae.editable) && !R), u.$$.dirty[0] & /*componentErrors*/
    32768 && f(5, P = (w == null ? void 0 : w.length) > 0), u.$$.dirty[0] & /*isBlock, instance*/
    5 | u.$$.dirty[1] & /*$builderStore*/
    2097152 && f(49, L = ie.inBuilder && _e && !J && !K.static), u.$$.dirty[0] & /*isBlock*/
    4 | u.$$.dirty[1] & /*$devToolsStore*/
    4194304 && f(48, M = de.allowSelection && !J), u.$$.dirty[1] & /*builderInteractive, devToolsInteractive*/
    393216 && f(11, B = L || M), u.$$.dirty[1] & /*editable, selected, $builderStore*/
    2097536 && f(6, j = O && v && ie.editMode), u.$$.dirty[0] & /*interactive, isLayout, isRoot, isBlock*/
    268437510 | u.$$.dirty[1] & /*inDragPath, definition*/
    65544 && f(10, x = !S && B && !te && !ue && !J && (Ae == null ? void 0 : Ae.draggable) !== !1), u.$$.dirty[0] & /*interactive*/
    2048 && f(23, N = B), u.$$.dirty[0] & /*id*/
    16 | u.$$.dirty[1] & /*$builderStore*/
    2097152 && f(22, D = ie.inBuilder && ((Se = ie.hiddenComponentIds) == null ? void 0 : Se.includes(m))), u.$$.dirty[0] & /*isBlock, interactive, children, hasChildren*/
    14340 | u.$$.dirty[1] & /*hasMissingRequiredSettings*/
    32768 && f(14, V = !J && (B && !p.length && T || R)), u.$$.dirty[0] & /*empty*/
    16384 | u.$$.dirty[1] & /*showEmptyState*/
    16384 && f(9, W = V && E), u.$$.dirty[1] & /*conditions*/
    4 && Ut(Ue), u.$$.dirty[0] & /*staticSettings, enrichedSettings*/
    1610612736 | u.$$.dirty[1] & /*conditionalSettings*/
    1 && Ht(Pe, De, He), u.$$.dirty[1] & /*cachedSettings*/
    2 && f(40, F = Ce == null ? void 0 : Ce._css), u.$$.dirty[1] & /*selected*/
    128 && v && Gt(), u.$$.dirty[1] & /*$context*/
    524288 && f(44, U = (be = Z == null ? void 0 : Z.device) == null ? void 0 : be.theme), u.$$.dirty[1] & /*currentTheme*/
    8192 && f(37, Y = !(U != null && U.includes("light"))), u.$$.dirty[0] & /*instance*/
    1 | u.$$.dirty[1] & /*ephemeralStyles*/
    16 && f(41, q = {
      ...(Ie = K._styles) == null ? void 0 : Ie.normal,
      ...st
    }), u.$$.dirty[0] & /*parent*/
    134217728 && f(36, Q = Et(ce)), u.$$.dirty[0] & /*instance*/
    1 && f(43, z = Et(K)), u.$$.dirty[0] & /*id, interactive, draggable, hasComponentErrors*/
    3120 | u.$$.dirty[1] & /*insideGrid, definition, normalStyles*/
    1064 && f(21, H = {
      insideGrid: Q,
      ignoresLayout: (Ae == null ? void 0 : Ae.ignoresLayout) === !0,
      id: m,
      interactive: B,
      styles: q,
      draggable: x,
      definition: Ae,
      errored: P
    }), u.$$.dirty[0] & /*pad, interactive, hasChildren*/
    10248 | u.$$.dirty[1] & /*isGrid, inDndPath*/
    6144 && f(3, lt = lt || !z && B && T && $), u.$$.dirty[1] & /*$dndIsDragging*/
    1048576 && f(3, lt = !1), u.$$.dirty[0] & /*id, children, instance, emptyState, interactive, isRoot, draggable, isBlock, inSelectedPath, name, editing, hasComponentErrors, $component*/
    73719 | u.$$.dirty[1] & /*normalStyles, customCSS, selected, editable, darkMode*/
    1984 && ke.set({
      id: m,
      children: p.length,
      styles: {
        ...K._styles,
        normal: q,
        custom: F,
        id: m,
        empty: W,
        selected: v,
        interactive: B,
        isRoot: ue,
        draggable: x,
        editable: O,
        isBlock: J
      },
      empty: W,
      selected: v,
      isRoot: ue,
      inSelectedPath: k,
      name: b,
      editing: j,
      type: K._component,
      errorState: P,
      parent: m,
      path: [...(oe == null ? void 0 : oe.path) ?? [], m],
      darkMode: Y
    });
  }, [
    K,
    ue,
    J,
    lt,
    m,
    P,
    j,
    b,
    k,
    W,
    x,
    B,
    p,
    T,
    V,
    w,
    oe,
    we,
    se,
    wt,
    Je,
    H,
    D,
    N,
    y,
    fe,
    ye,
    ce,
    te,
    Pe,
    De,
    He,
    Ce,
    Ue,
    Ae,
    st,
    Q,
    Y,
    v,
    O,
    F,
    q,
    $,
    z,
    U,
    E,
    R,
    S,
    M,
    L,
    Z,
    ee,
    ie,
    de,
    pe,
    le,
    ae,
    zt,
    ne
  ];
}
class Component extends SvelteComponent {
  constructor(l) {
    super(), init$1(
      this,
      l,
      instance_1$3,
      create_fragment$B,
      safe_not_equal,
      {
        instance: 0,
        parent: 27,
        isLayout: 28,
        isRoot: 1,
        isBlock: 2
      },
      null,
      [-1, -1, -1]
    );
  }
}
const linkable = (u, l) => {
  if (get_store_value(builderStore).inBuilder) {
    u.onclick = (f) => {
      f.preventDefault();
    };
    return;
  }
  link$2(u, l);
}, getAction = (u, l) => {
  var p;
  if (!u || !l)
    return null;
  const f = getContext$1("context");
  return f ? (p = get_store_value(f)) == null ? void 0 : p[`${u}_${l}`] : null;
};
function create_fragment$A(u) {
  let l, f, p, m, b;
  const y = (
    /*#slots*/
    u[4].default
  ), v = create_slot(
    y,
    u,
    /*$$scope*/
    u[3],
    null
  );
  return {
    c() {
      l = element("div"), v && v.c();
    },
    m(k, S) {
      insert(k, l, S), v && v.m(l, null), p = !0, m || (b = action_destroyer(f = /*styleable*/
      u[2].call(
        null,
        l,
        /*$component*/
        u[0].styles
      )), m = !0);
    },
    p(k, [S]) {
      v && v.p && (!p || S & /*$$scope*/
      8) && update_slot_base(
        v,
        y,
        k,
        /*$$scope*/
        k[3],
        p ? get_slot_changes(
          y,
          /*$$scope*/
          k[3],
          S,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          k[3]
        ),
        null
      ), f && is_function(f.update) && S & /*$component*/
      1 && f.update.call(
        null,
        /*$component*/
        k[0].styles
      );
    },
    i(k) {
      p || (transition_in(v, k), p = !0);
    },
    o(k) {
      transition_out(v, k), p = !1;
    },
    d(k) {
      k && detach(l), v && v.d(k), m = !1, b();
    }
  };
}
function instance$z(u, l, f) {
  let p, m;
  component_subscribe(u, builderStore, (R) => f(6, m = R));
  let { $$slots: b = {}, $$scope: y } = l;
  const v = getContext$1("component");
  component_subscribe(u, v, (R) => f(0, p = R));
  const { styleable: k } = getContext$1("sdk");
  let S = {};
  const $ = (R, O, P, L) => {
    S[O] || (S[O] = {}), S[O][R] = { order: P, instance: L };
  }, w = (R, O) => {
    S[O] && delete S[O][R];
  }, T = () => {
    var P, L, M, B, j;
    const R = S[p.id] || {};
    let O = (P = Object.values(R)[0]) == null ? void 0 : P.instance;
    O && (O._styles = {
      ...O._styles,
      normal: {
        ...(L = O._styles) == null ? void 0 : L.normal,
        ...(M = p.styles) == null ? void 0 : M.normal
      },
      custom: (((B = O._styles) == null ? void 0 : B.custom) || "") + (((j = p.styles) == null ? void 0 : j.custom) || "")
    }, E(O, S), builderStore.actions.ejectBlock(p.id, O));
  }, E = (R, O) => {
    let P = R._id;
    const L = Object.values(O[P] || {});
    L.length && (L.sort((M, B) => M.order < B.order ? -1 : 1), R._children = L.map((M) => M.instance), R._children.forEach((M) => {
      E(M, O);
    }));
  };
  return setContext("block", {
    // We need to set a block context to know we're inside a block, but also
    // to be able to reference the actual component ID of the block from
    // any depth
    id: p.id,
    // Name can be used down the tree in placeholders
    name: p.name,
    // We register block components with their raw props so that we can eject
    // blocks later on
    registerComponent: $,
    unregisterComponent: w
  }), onMount(() => {
    m.inBuilder && blockStore.actions.registerBlock(p.id, { eject: T });
  }), onDestroy(() => {
    m.inBuilder && blockStore.actions.unregisterBlock(p.id);
  }), u.$$set = (R) => {
    "$$scope" in R && f(3, y = R.$$scope);
  }, [p, v, k, y, b];
}
class Block extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$z, create_fragment$A, safe_not_equal, {});
  }
}
function create_default_slot$k(u) {
  let l;
  const f = (
    /*#slots*/
    u[14].default
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[15],
    null
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, b) {
      p && p.p && (!l || b & /*$$scope*/
      32768) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[15],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[15],
          b,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[15]
        ),
        null
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function create_fragment$z(u) {
  let l, f;
  return l = new Component({
    props: {
      instance: (
        /*instance*/
        u[0]
      ),
      isBlock: !0,
      $$slots: { default: [create_default_slot$k] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*instance*/
      1 && (b.instance = /*instance*/
      p[0]), m & /*$$scope*/
      32768 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance_1$2(u, l, f) {
  let p, m, b, y, v;
  component_subscribe(u, builderStore, (D) => f(12, y = D));
  let { $$slots: k = {}, $$scope: S } = l, { type: $ } = l, { props: w = void 0 } = l, { styles: T = void 0 } = l, { context: E = void 0 } = l, { name: R = void 0 } = l, { order: O = 0 } = l, { containsSlot: P = !1 } = l, { id: L = void 0 } = l;
  const M = getContext$1("component");
  component_subscribe(u, M, (D) => f(13, v = D));
  const B = getContext$1("block"), j = shortid.generate(), x = (D) => D ? D.startsWith("plugin/") ? D : `@budibase/standard-components/${D}` : null, N = (D, V) => D || (V ? (V.startsWith("plugin/") && (V = V.split("plugin/")[1]), V[0].toUpperCase() + V.slice(1)) : "New component");
  return onDestroy(() => {
    m && B.unregisterComponent(L, p);
  }), u.$$set = (D) => {
    "type" in D && f(3, $ = D.type), "props" in D && f(4, w = D.props), "styles" in D && f(5, T = D.styles), "context" in D && f(6, E = D.context), "name" in D && f(7, R = D.name), "order" in D && f(8, O = D.order), "containsSlot" in D && f(9, P = D.containsSlot), "id" in D && f(2, L = D.id), "$$scope" in D && f(15, S = D.$$scope);
  }, u.$$.update = () => {
    u.$$.dirty & /*context*/
    64 && f(2, L = `${B.id}-${E ?? j}`), u.$$.dirty & /*$component*/
    8192 && f(10, p = v == null ? void 0 : v.id), u.$$.dirty & /*$builderStore*/
    4096 && f(11, m = y.inBuilder), u.$$.dirty & /*props, type, id, name, containsSlot, styles*/
    700 && f(0, b = {
      ...w,
      _component: x($),
      _id: L,
      _instanceName: N(R, $),
      _containsSlot: P,
      _styles: { ...T, normal: (T == null ? void 0 : T.normal) || {} }
    }), u.$$.dirty & /*inBuilder, id, parentId, order, instance*/
    3333 && m && B.registerComponent(L, p, O ?? 0, b);
  }, [
    b,
    M,
    L,
    $,
    w,
    T,
    E,
    R,
    O,
    P,
    p,
    m,
    y,
    v,
    k,
    S
  ];
}
class BlockComponent extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance_1$2, create_fragment$z, safe_not_equal, {
      type: 3,
      props: 4,
      styles: 5,
      context: 6,
      name: 7,
      order: 8,
      containsSlot: 9,
      id: 2
    });
  }
}
const getDatasourceFetchInstance = (u) => {
  const l = DataFetchMap[u == null ? void 0 : u.type];
  return l ? new l({
    API,
    datasource: u,
    query: null
  }) : null;
}, fetchDatasourceSchema = async (u, l = { enrichRelationships: !1, formSchema: !1 }) => {
  var b;
  const f = getDatasourceFetchInstance(u), p = await (f == null ? void 0 : f.getDefinition());
  if (!f || !p)
    return null;
  let m;
  if ((u == null ? void 0 : u.type) !== "query" || !(l != null && l.formSchema))
    m = f.getSchema(p);
  else if ("parameters" in p && ((b = p.parameters) != null && b.length)) {
    m = {};
    for (const y of p.parameters)
      m[y.name] = { ...y, type: FieldType.STRING };
  }
  if (!m)
    return null;
  if (u.type === "viewV2")
    for (const y of Object.keys(m))
      m[y].visible || delete m[y];
  if (p && "sql" in p && p.sql && (l != null && l.enrichRelationships)) {
    const y = await getRelationshipSchemaAdditions(m);
    m = {
      ...m,
      ...y
    };
  }
  return f.enrichSchema(m);
}, fetchDatasourceDefinition = async (u) => {
  const l = getDatasourceFetchInstance(u);
  return await (l == null ? void 0 : l.getDefinition());
}, getRelationshipSchemaAdditions = async (u) => {
  if (!u)
    return null;
  let l = {};
  for (let f of Object.keys(u)) {
    const p = u[f];
    if ((p == null ? void 0 : p.type) === "link") {
      const m = await fetchDatasourceSchema({
        type: "table",
        tableId: p == null ? void 0 : p.tableId
      });
      if (!m)
        continue;
      Object.keys(m).forEach((b) => {
        l[`${f}.${b}`] = {
          type: m[b].type,
          externalType: m[b].externalType,
          constraints: m[b].constraints
        };
      });
    }
  }
  return l;
}, getAPIKey = async () => {
  const { apiKey: u } = await API.fetchDeveloperInfo();
  return u;
}, createValidatorFromConstraints = (u, l, f, p) => {
  var b, y, v, k, S, $;
  let m = [];
  if (u) {
    if ((f === (p == null ? void 0 : p.primaryDisplay) || ((b = u.presence) == null ? void 0 : b.allowEmpty) === !1 || u.presence === !0) && m.push({
      type: u.type == FieldType.ARRAY ? FieldType.ARRAY : FieldType.STRING,
      constraint: "required",
      error: "Required"
    }), exists((y = u.length) == null ? void 0 : y.maximum)) {
      const w = u.length.maximum;
      m.push({
        type: FieldType.STRING,
        constraint: "maxLength",
        value: w,
        error: `Maximum length is ${w}`
      });
    }
    if (exists((v = u.numericality) == null ? void 0 : v.greaterThanOrEqualTo)) {
      const w = u.numericality.greaterThanOrEqualTo;
      m.push({
        type: FieldType.NUMBER,
        constraint: "minValue",
        value: w,
        error: `Minimum value is ${w}`
      });
    }
    if (exists((k = u.numericality) == null ? void 0 : k.lessThanOrEqualTo)) {
      const w = u.numericality.lessThanOrEqualTo;
      m.push({
        type: FieldType.NUMBER,
        constraint: "maxValue",
        value: w,
        error: `Maximum value is ${w}`
      });
    }
    if (exists(u.inclusion) && u.type !== "array") {
      const w = u.inclusion || [];
      m.push({
        type: FieldType.STRING,
        constraint: "inclusion",
        value: w,
        error: "Invalid value"
      });
    }
    if (exists((S = u.datetime) == null ? void 0 : S.earliest)) {
      const w = u.datetime.earliest, T = getDateDisplayValue(dayjs(w));
      m.push({
        type: FieldType.DATETIME,
        constraint: "minValue",
        value: w,
        error: `Earliest date is ${T}`
      });
    }
    if (exists(($ = u.datetime) == null ? void 0 : $.latest)) {
      const w = u.datetime.latest, T = getDateDisplayValue(dayjs(w));
      m.push({
        type: FieldType.DATETIME,
        constraint: "maxValue",
        value: w,
        error: `Latest date is ${T}`
      });
    }
  }
  return m = m.concat(l || []), (w) => {
    for (let T of m) {
      const E = evaluateRule(T, w);
      if (E)
        return E;
    }
    return null;
  };
}, evaluateRule = (u, l) => {
  if (!u)
    return null;
  const f = handlerMap[u.constraint];
  return f ? (l = parseType(l, u.type), f(l, u) ? null : u.error || "Error") : null;
}, parseType = (u, l) => {
  if (!exists(u) || !l)
    return null;
  if (l === FieldType.STRING)
    return typeof u == "string" || Array.isArray(u) ? u : u.length === 0 ? null : `${u}`;
  if (l === FieldType.NUMBER)
    return isNaN(u) ? null : parseFloat(u);
  if (l === FieldType.DATETIME) {
    if (u instanceof Date)
      return u.getTime();
    const f = isNaN(u) ? Date.parse(u) : new Date(u).getTime();
    return isNaN(f) ? null : f;
  }
  return l === FieldType.BOOLEAN ? typeof u == "string" ? u.toLowerCase() === "true" : u === !0 : l === FieldType.ATTACHMENTS ? !Array.isArray(u) || !u.length ? null : u : l === FieldType.ATTACHMENT_SINGLE || l === FieldType.SIGNATURE_SINGLE ? u != null && u.key ? u : null : l === FieldType.LINK || l === FieldType.ARRAY ? !Array.isArray(u) || !u.length ? null : u : l === FieldType.JSON ? u : null;
}, requiredHandler = (u) => u != null, minLengthHandler = (u, l) => {
  const f = parseType(l.value, "number");
  return u == null || u.length >= f;
}, maxLengthHandler = (u, l) => {
  const f = parseType(l.value, "number");
  return u == null || u.length <= f;
}, maxFileSizeHandler = (u, l) => {
  const f = parseType(l.value, "number"), p = (m) => m.size / 1e6 > f;
  return u == null || !(u != null && u.key ? p(u) : u.some(p));
}, maxUploadSizeHandler = (u, l) => {
  const f = parseType(l.value, "number");
  return u == null || (u != null && u.key ? u.size / 1e6 <= f : u.reduce(
    (p, m) => p + m.size,
    0
  ) / 1e6 <= f);
}, minValueHandler = (u, l) => {
  const f = parseType(l.value, l.type);
  return u == null || u >= f;
}, maxValueHandler = (u, l) => {
  const f = parseType(l.value, l.type);
  return u == null || u <= f;
}, inclusionHandler = (u, l) => u == null || l.value.includes(u), equalHandler = (u, l) => {
  const f = parseType(l.value, l.type);
  return u === f;
}, notEqualHandler = (u, l) => {
  const f = parseType(l.value, l.type);
  return u == null && f == null ? !0 : u !== f;
}, regexHandler = (u, l) => {
  const f = parseType(l.value, "string");
  return u || (u = ""), new RegExp(f).test(u);
}, notRegexHandler = (u, l) => !regexHandler(u, l), containsHandler = (u, l) => {
  const f = parseType(l.value, "string");
  return u && u.includes(f);
}, notContainsHandler = (u, l) => !containsHandler(u, l), jsonHandler = (u) => {
  if (typeof u != "object" || Array.isArray(u))
    return !1;
  try {
    return JSON.parse(JSON.stringify(u)), !0;
  } catch {
    return !1;
  }
}, handlerMap = {
  required: requiredHandler,
  minLength: minLengthHandler,
  maxLength: maxLengthHandler,
  minValue: minValueHandler,
  maxValue: maxValueHandler,
  inclusion: inclusionHandler,
  equal: equalHandler,
  notEqual: notEqualHandler,
  regex: regexHandler,
  notRegex: notRegexHandler,
  contains: containsHandler,
  notContains: notContainsHandler,
  json: jsonHandler,
  maxFileSize: maxFileSizeHandler,
  maxUploadSize: maxUploadSizeHandler
}, exists = (u) => u != null && u !== "", SDK = {
  API,
  // Stores
  authStore,
  appStore,
  notificationStore,
  routeStore,
  rowSelectionStore,
  screenStore,
  builderStore,
  uploadStore,
  componentStore,
  environmentStore,
  sidePanelStore,
  modalStore,
  dndIsDragging,
  currentRole,
  confirmationStore,
  roleStore,
  stateStore,
  // Utils
  styleable,
  linkable,
  getAction,
  fetchDatasourceSchema,
  fetchDatasourceDefinition,
  getRelationshipSchemaAdditions,
  fetchData,
  QueryUtils,
  ContextScopes: ComponentContextScopes,
  // This is not used internally but exposed to users to be used in plugins
  getAPIKey,
  enrichButtonActions,
  processStringSync,
  makePropSafe,
  createContextStore,
  generateGoldenSample,
  memo,
  derivedMemo,
  createValidatorFromConstraints,
  // Components
  Provider,
  Block,
  BlockComponent,
  // Constants
  ActionTypes
}, NotificationDisplay_svelte_svelte_type_style_lang = "";
function get_each_context$7(u, l, f) {
  const p = u.slice();
  return p[2] = l[f].type, p[3] = l[f].icon, p[4] = l[f].message, p[5] = l[f].id, p[6] = l[f].dismissable, p[7] = l[f].count, p;
}
function create_if_block$f(u) {
  let l = [], f = /* @__PURE__ */ new Map(), p, m, b = ensure_array_like(
    /*$notificationStore*/
    u[0]
  );
  const y = (v) => (
    /*id*/
    v[5]
  );
  for (let v = 0; v < b.length; v += 1) {
    let k = get_each_context$7(u, b, v), S = y(k);
    f.set(S, l[v] = create_each_block$7(S, k));
  }
  return {
    c() {
      for (let v = 0; v < l.length; v += 1)
        l[v].c();
      p = empty$1();
    },
    m(v, k) {
      for (let S = 0; S < l.length; S += 1)
        l[S] && l[S].m(v, k);
      insert(v, p, k), m = !0;
    },
    p(v, k) {
      k & /*$notificationStore*/
      1 && (b = ensure_array_like(
        /*$notificationStore*/
        v[0]
      ), group_outros(), l = update_keyed_each(l, k, y, 1, v, b, f, p.parentNode, outro_and_destroy_block, create_each_block$7, p, get_each_context$7), check_outros());
    },
    i(v) {
      if (!m) {
        for (let k = 0; k < b.length; k += 1)
          transition_in(l[k]);
        m = !0;
      }
    },
    o(v) {
      for (let k = 0; k < l.length; k += 1)
        transition_out(l[k]);
      m = !1;
    },
    d(v) {
      v && detach(p);
      for (let k = 0; k < l.length; k += 1)
        l[k].d(v);
    }
  };
}
function create_each_block$7(u, l) {
  let f, p, m, b, y, v;
  function k() {
    return (
      /*dismiss_handler*/
      l[1](
        /*id*/
        l[5]
      )
    );
  }
  return p = new Notification({
    props: {
      type: (
        /*type*/
        l[2]
      ),
      message: (
        /*count*/
        l[7] > 1 ? `(${/*count*/
        l[7]}) ${/*message*/
        l[4]}` : (
          /*message*/
          l[4]
        )
      ),
      icon: (
        /*icon*/
        l[3]
      ),
      dismissable: (
        /*dismissable*/
        l[6]
      )
    }
  }), p.$on("dismiss", k), {
    key: u,
    first: null,
    c() {
      f = element("div"), create_component(p.$$.fragment), m = space(), this.first = f;
    },
    m(S, $) {
      insert(S, f, $), mount_component(p, f, null), append$1(f, m), v = !0;
    },
    p(S, $) {
      l = S;
      const w = {};
      $ & /*$notificationStore*/
      1 && (w.type = /*type*/
      l[2]), $ & /*$notificationStore*/
      1 && (w.message = /*count*/
      l[7] > 1 ? `(${/*count*/
      l[7]}) ${/*message*/
      l[4]}` : (
        /*message*/
        l[4]
      )), $ & /*$notificationStore*/
      1 && (w.icon = /*icon*/
      l[3]), $ & /*$notificationStore*/
      1 && (w.dismissable = /*dismissable*/
      l[6]), p.$set(w);
    },
    i(S) {
      v || (transition_in(p.$$.fragment, S), S && add_render_callback(() => {
        v && (y && y.end(1), b = create_in_transition(f, fly, {
          duration: 300,
          y: -20,
          delay: (
            /*$notificationStore*/
            l[0].delay ? 300 : 0
          )
        }), b.start());
      }), v = !0);
    },
    o(S) {
      transition_out(p.$$.fragment, S), b && b.invalidate(), S && (y = create_out_transition(f, fly, { y: -20, duration: 150 })), v = !1;
    },
    d(S) {
      S && detach(f), destroy_component(p), S && y && y.end();
    }
  };
}
function create_fragment$y(u) {
  let l, f, p = (
    /*$notificationStore*/
    u[0] && create_if_block$f(u)
  );
  return {
    c() {
      l = element("div"), p && p.c(), attr(l, "class", "notifications svelte-o2yltz");
    },
    m(m, b) {
      insert(m, l, b), p && p.m(l, null), f = !0;
    },
    p(m, [b]) {
      /*$notificationStore*/
      m[0] ? p ? (p.p(m, b), b & /*$notificationStore*/
      1 && transition_in(p, 1)) : (p = create_if_block$f(m), p.c(), transition_in(p, 1), p.m(l, null)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d();
    }
  };
}
function instance$y(u, l, f) {
  let p;
  return component_subscribe(u, notificationStore, (b) => f(0, p = b)), [p, (b) => notificationStore.actions.dismiss(b)];
}
class NotificationDisplay extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$y, create_fragment$y, safe_not_equal, {});
  }
}
function create_if_block$e(u) {
  let l, f;
  return l = new Modal({
    props: {
      fixed: !0,
      $$slots: { default: [create_default_slot$j] },
      $$scope: { ctx: u }
    }
  }), l.$on("cancel", confirmationStore.actions.cancel), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, $confirmationStore*/
      3 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_1$9(u) {
  let l = (
    /*$confirmationStore*/
    u[0].text + ""
  ), f;
  return {
    c() {
      f = text$2(l);
    },
    m(p, m) {
      insert(p, f, m);
    },
    p(p, m) {
      m & /*$confirmationStore*/
      1 && l !== (l = /*$confirmationStore*/
      p[0].text + "") && set_data(f, l);
    },
    d(p) {
      p && detach(f);
    }
  };
}
function create_default_slot$j(u) {
  let l, f;
  return l = new ModalContent({
    props: {
      title: (
        /*$confirmationStore*/
        u[0].title
      ),
      onConfirm: confirmationStore.actions.confirm,
      confirmText: (
        /*$confirmationStore*/
        u[0].confirmButtonText
      ),
      cancelText: (
        /*$confirmationStore*/
        u[0].cancelButtonText
      ),
      $$slots: { default: [create_default_slot_1$9] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$confirmationStore*/
      1 && (b.title = /*$confirmationStore*/
      p[0].title), m & /*$confirmationStore*/
      1 && (b.confirmText = /*$confirmationStore*/
      p[0].confirmButtonText), m & /*$confirmationStore*/
      1 && (b.cancelText = /*$confirmationStore*/
      p[0].cancelButtonText), m & /*$$scope, $confirmationStore*/
      3 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$x(u) {
  let l, f, p = (
    /*$confirmationStore*/
    u[0].showConfirmation && create_if_block$e(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, [b]) {
      /*$confirmationStore*/
      m[0].showConfirmation ? p ? (p.p(m, b), b & /*$confirmationStore*/
      1 && transition_in(p, 1)) : (p = create_if_block$e(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
function instance$x(u, l, f) {
  let p;
  return component_subscribe(u, confirmationStore, (m) => f(0, p = m)), [p];
}
class ConfirmationDisplay extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$x, create_fragment$x, safe_not_equal, {});
  }
}
const PeekScreenDisplay_svelte_svelte_type_style_lang = "";
function create_if_block$d(u) {
  let l, f;
  return l = new Modal({
    props: {
      fixed: !0,
      $$slots: {
        outside: [create_outside_slot],
        default: [create_default_slot_2$6]
      },
      $$scope: { ctx: u }
    }
  }), l.$on(
    "cancel",
    /*handleCancel*/
    u[2]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, $peekStore, iframe*/
      4099 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_3$5(u) {
  let l, f;
  return {
    c() {
      l = element("iframe"), attr(l, "title", "Peek"), src_url_equal(l.src, f = /*$peekStore*/
      u[1].href) || attr(l, "src", f), attr(l, "class", "svelte-gbetw2");
    },
    m(p, m) {
      insert(p, l, m), u[5](l);
    },
    p(p, m) {
      m & /*$peekStore*/
      2 && !src_url_equal(l.src, f = /*$peekStore*/
      p[1].href) && attr(l, "src", f);
    },
    d(p) {
      p && detach(l), u[5](null);
    }
  };
}
function create_default_slot_2$6(u) {
  let l, f;
  return l = new ModalContent({
    props: {
      showCancelButton: !1,
      showConfirmButton: !1,
      size: "L",
      showDivider: !1,
      showCloseIcon: !1,
      $$slots: { default: [create_default_slot_3$5] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, $peekStore, iframe*/
      4099 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_1$8(u) {
  let l;
  return {
    c() {
      l = text$2("Full screen");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot$i(u) {
  let l;
  return {
    c() {
      l = text$2("Close");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_outside_slot(u) {
  let l, f, p, m, b;
  return f = new ActionButton({
    props: {
      size: "S",
      quiet: !0,
      icon: "arrow-square-out",
      $$slots: { default: [create_default_slot_1$8] },
      $$scope: { ctx: u }
    }
  }), f.$on(
    "click",
    /*handleFullscreen*/
    u[3]
  ), m = new ActionButton({
    props: {
      size: "S",
      quiet: !0,
      icon: "x",
      $$slots: { default: [create_default_slot$i] },
      $$scope: { ctx: u }
    }
  }), m.$on(
    "click",
    /*handleCancel*/
    u[2]
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), p = space(), create_component(m.$$.fragment), attr(l, "class", "actions spectrum--darkest svelte-gbetw2"), attr(l, "slot", "outside");
    },
    m(y, v) {
      insert(y, l, v), mount_component(f, l, null), append$1(l, p), mount_component(m, l, null), b = !0;
    },
    p(y, v) {
      const k = {};
      v & /*$$scope*/
      4096 && (k.$$scope = { dirty: v, ctx: y }), f.$set(k);
      const S = {};
      v & /*$$scope*/
      4096 && (S.$$scope = { dirty: v, ctx: y }), m.$set(S);
    },
    i(y) {
      b || (transition_in(f.$$.fragment, y), transition_in(m.$$.fragment, y), b = !0);
    },
    o(y) {
      transition_out(f.$$.fragment, y), transition_out(m.$$.fragment, y), b = !1;
    },
    d(y) {
      y && detach(l), destroy_component(f), destroy_component(m);
    }
  };
}
function create_fragment$w(u) {
  let l, f, p = (
    /*$peekStore*/
    u[1].showPeek && create_if_block$d(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, [b]) {
      /*$peekStore*/
      m[1].showPeek ? p ? (p.p(m, b), b & /*$peekStore*/
      2 && transition_in(p, 1)) : (p = create_if_block$d(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
function instance$w(u, l, f) {
  let p;
  component_subscribe(u, peekStore, (O) => f(1, p = O));
  let m, b = !1;
  const y = (O) => {
    const { dataSourceId: P, options: L } = O.detail;
    dataSourceStore.actions.invalidateDataSource(P, L);
  }, v = (O) => {
    const { message: P, type: L, icon: M, autoDismiss: B } = O.detail;
    notificationStore.actions.send(P, L, M, B);
  }, k = (O) => {
    const { type: P, key: L, value: M, persist: B } = O.detail;
    P === "set" ? stateStore.actions.setValue(L, M, B) : P === "delete" && stateStore.actions.deleteValue(L);
  }, S = () => {
    dataSourceStore.actions.refreshAll();
  };
  function $(O) {
    var M;
    const L = {
      [PeekMessages.NOTIFICATION]: () => {
        v(O.data);
      },
      [PeekMessages.CLOSE_SCREEN_MODAL]: () => {
        var B;
        peekStore.actions.hidePeek(), (B = O.data) != null && B.url && routeStore.actions.navigate(O.data.url);
      },
      [PeekMessages.INVALIDATE_DATASOURCE]: () => {
        y(O.data);
      },
      [PeekMessages.UPDATE_STATE]: () => {
        k(O.data);
      },
      [PeekMessages.REFRESH_ALL_DATASOURCES]: () => {
        S();
      }
    }[O.data.type];
    L ? L(O) : console.warn("Unknown event type", (M = O == null ? void 0 : O.data) == null ? void 0 : M.type);
  }
  const w = () => {
    window.addEventListener("message", $);
  }, T = () => {
    peekStore.actions.hidePeek(), window.removeEventListener("message", $);
  }, E = () => {
    p.external ? window.location = p.href : (routeStore.actions.navigate(p.url), T());
  };
  onDestroy(() => {
    m && T();
  });
  function R(O) {
    binding_callbacks[O ? "unshift" : "push"](() => {
      m = O, f(0, m);
    });
  }
  return u.$$.update = () => {
    u.$$.dirty & /*iframe, listenersAttached*/
    17 && (m && !b ? (w(), f(4, b = !0)) : m || f(4, b = !1));
  }, [
    m,
    p,
    T,
    E,
    b,
    R
  ];
}
class PeekScreenDisplay extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$w, create_fragment$w, safe_not_equal, {});
  }
}
const InstallPrompt_svelte_svelte_type_style_lang = "";
function create_if_block$c(u) {
  let l, f, p, m;
  return {
    c() {
      l = element("div"), f = element("button"), f.textContent = "Install app", attr(f, "class", "openMenu svelte-z0e6e1"), attr(l, "class", "install-prompt svelte-z0e6e1");
    },
    m(b, y) {
      insert(b, l, y), append$1(l, f), p || (m = listen(
        f,
        "click",
        /*installPWA*/
        u[1]
      ), p = !0);
    },
    p: noop$4,
    d(b) {
      b && detach(l), p = !1, m();
    }
  };
}
function create_fragment$v(u) {
  let l, f = (
    /*showButton*/
    u[0] && create_if_block$c(u)
  );
  return {
    c() {
      f && f.c(), l = empty$1();
    },
    m(p, m) {
      f && f.m(p, m), insert(p, l, m);
    },
    p(p, [m]) {
      /*showButton*/
      p[0] ? f ? f.p(p, m) : (f = create_if_block$c(p), f.c(), f.m(l.parentNode, l)) : f && (f.d(1), f = null);
    },
    i: noop$4,
    o: noop$4,
    d(p) {
      p && detach(l), f && f.d(p);
    }
  };
}
const STORAGE_KEY_PREFIX = "pwa-install-declined";
function instance$v(u, l, f) {
  let p, m, b;
  component_subscribe(u, appStore, (S) => f(4, m = S)), component_subscribe(u, featuresStore, (S) => f(2, b = S));
  let y = !1;
  function v() {
    if (!p)
      return !1;
    const S = m.appId, $ = `${STORAGE_KEY_PREFIX}-${S}`;
    return localStorage.getItem($) === "true" ? !1 : typeof window < "u" && window.deferredPwaPrompt ? (f(0, y = !0), !0) : !1;
  }
  async function k() {
    if (!window.deferredPwaPrompt)
      return;
    window.deferredPwaPrompt.prompt();
    const { outcome: S } = await window.deferredPwaPrompt.userChoice;
    if (S === "accepted")
      f(0, y = !1);
    else if (S === "dismissed") {
      const $ = m.appId, w = `${STORAGE_KEY_PREFIX}-${$}`;
      localStorage.setItem(w, "true"), f(0, y = !1);
    }
    window.deferredPwaPrompt = null;
  }
  return onMount(async () => {
    if ("serviceWorker" in navigator)
      try {
        await navigator.serviceWorker.register("/app/service-worker.js", { scope: "/app/" });
      } catch (S) {
        console.error("Service worker registration failed:", S);
      }
    v();
  }), u.$$.update = () => {
    u.$$.dirty & /*$featuresStore*/
    4 && (p = b.pwaEnabled);
  }, [y, k, b];
}
class InstallPrompt extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$v, create_fragment$v, safe_not_equal, {});
  }
}
function create_default_slot$h(u) {
  let l;
  const f = (
    /*#slots*/
    u[3].default
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[4],
    null
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, b) {
      p && p.p && (!l || b & /*$$scope*/
      16) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[4],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[4],
          b,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[4]
        ),
        null
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function create_fragment$u(u) {
  let l, f;
  return l = new Provider({
    props: {
      key: "user",
      data: {
        .../*$authStore*/
        u[1],
        roleId: (
          /*$currentRole*/
          u[2]
        )
      },
      actions: (
        /*actions*/
        u[0]
      ),
      $$slots: { default: [create_default_slot$h] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*$authStore, $currentRole*/
      6 && (b.data = {
        .../*$authStore*/
        p[1],
        roleId: (
          /*$currentRole*/
          p[2]
        )
      }), m & /*actions*/
      1 && (b.actions = /*actions*/
      p[0]), m & /*$$scope*/
      16 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$u(u, l, f) {
  let p, m, b;
  component_subscribe(u, authStore, (k) => f(1, m = k)), component_subscribe(u, currentRole, (k) => f(2, b = k));
  let { $$slots: y = {}, $$scope: v } = l;
  return u.$$set = (k) => {
    "$$scope" in k && f(4, v = k.$$scope);
  }, f(0, p = [
    {
      type: ActionTypes.RefreshDatasource,
      callback: () => authStore.actions.fetchUser(),
      metadata: {
        dataSource: {
          type: "table",
          tableId: TableNames.USERS
        }
      }
    }
  ]), [p, m, b, y, v];
}
class UserBindingsProvider extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$u, create_fragment$u, safe_not_equal, {});
  }
}
function create_default_slot$g(u) {
  let l;
  const f = (
    /*#slots*/
    u[5].default
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[6],
    null
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, b) {
      p && p.p && (!l || b & /*$$scope*/
      64) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[6],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[6],
          b,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[6]
        ),
        null
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function create_fragment$t(u) {
  let l, f;
  return l = new Provider({
    props: {
      key: "device",
      data: (
        /*data*/
        u[0]
      ),
      $$slots: { default: [create_default_slot$g] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*data*/
      1 && (b.data = /*data*/
      p[0]), m & /*$$scope*/
      64 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
const tabletBreakpoint = 720, desktopBreakpoint = 1280;
function instance$t(u, l, f) {
  let p, m, b;
  component_subscribe(u, themeStore, (w) => f(4, b = w));
  let { $$slots: y = {}, $$scope: v } = l, k = window.innerWidth, S = window.innerHeight;
  const $ = new ResizeObserver((w) => {
    var T, E;
    w != null && w[0] && (f(1, k = (T = w[0].contentRect) == null ? void 0 : T.width), f(2, S = (E = w[0].contentRect) == null ? void 0 : E.height));
  });
  return onMount(() => {
    $.observe(document.getElementById("app-body"));
  }), onDestroy(() => {
    $.unobserve(document.getElementById("app-body"));
  }), u.$$set = (w) => {
    "$$scope" in w && f(6, v = w.$$scope);
  }, u.$$.update = () => {
    u.$$.dirty & /*$themeStore*/
    16 && f(3, p = b.theme), u.$$.dirty & /*width, height, theme*/
    14 && f(0, m = {
      mobile: k && k < tabletBreakpoint,
      tablet: k && k >= tabletBreakpoint && k < desktopBreakpoint,
      width: k,
      height: S,
      theme: p
    });
  }, [m, k, S, p, b, y, v];
}
class DeviceBindingsProvider extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$t, create_fragment$t, safe_not_equal, {});
  }
}
function create_default_slot$f(u) {
  let l;
  const f = (
    /*#slots*/
    u[1].default
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[2],
    null
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, b) {
      p && p.p && (!l || b & /*$$scope*/
      4) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[2],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[2],
          b,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[2]
        ),
        null
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function create_fragment$s(u) {
  let l, f;
  return l = new Provider({
    props: {
      key: "state",
      data: (
        /*$stateStore*/
        u[0]
      ),
      $$slots: { default: [create_default_slot$f] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*$stateStore*/
      1 && (b.data = /*$stateStore*/
      p[0]), m & /*$$scope*/
      4 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$s(u, l, f) {
  let p;
  component_subscribe(u, stateStore, (y) => f(0, p = y));
  let { $$slots: m = {}, $$scope: b } = l;
  return u.$$set = (y) => {
    "$$scope" in y && f(2, b = y.$$scope);
  }, [p, m, b];
}
class StateBindingsProvider extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$s, create_fragment$s, safe_not_equal, {});
  }
}
function create_default_slot$e(u) {
  let l;
  const f = (
    /*#slots*/
    u[1].default
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[2],
    null
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, b) {
      p && p.p && (!l || b & /*$$scope*/
      4) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[2],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[2],
          b,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[2]
        ),
        null
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function create_fragment$r(u) {
  let l, f;
  return l = new Provider({
    props: {
      key: "url",
      data: (
        /*$routeStore*/
        u[0].testUrlParams
      ),
      $$slots: { default: [create_default_slot$e] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*$routeStore*/
      1 && (b.data = /*$routeStore*/
      p[0].testUrlParams), m & /*$$scope*/
      4 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$r(u, l, f) {
  let p;
  component_subscribe(u, routeStore, (y) => f(0, p = y));
  let { $$slots: m = {}, $$scope: b } = l;
  return u.$$set = (y) => {
    "$$scope" in y && f(2, b = y.$$scope);
  }, [p, m, b];
}
class TestUrlBindingsProvider extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$r, create_fragment$r, safe_not_equal, {});
  }
}
function create_default_slot$d(u) {
  let l;
  const f = (
    /*#slots*/
    u[1].default
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[2],
    null
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, b) {
      p && p.p && (!l || b & /*$$scope*/
      4) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[2],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[2],
          b,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[2]
        ),
        null
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function create_fragment$q(u) {
  let l, f;
  return l = new Provider({
    props: {
      key: "rowSelection",
      data: (
        /*$rowSelectionStore*/
        u[0]
      ),
      $$slots: { default: [create_default_slot$d] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*$rowSelectionStore*/
      1 && (b.data = /*$rowSelectionStore*/
      p[0]), m & /*$$scope*/
      4 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$q(u, l, f) {
  let p;
  component_subscribe(u, rowSelectionStore, (y) => f(0, p = y));
  let { $$slots: m = {}, $$scope: b } = l;
  return u.$$set = (y) => {
    "$$scope" in y && f(2, b = y.$$scope);
  }, [p, m, b];
}
class RowSelectionProvider extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$q, create_fragment$q, safe_not_equal, {});
  }
}
function create_default_slot$c(u) {
  let l;
  const f = (
    /*#slots*/
    u[1].default
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[2],
    null
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, b) {
      p && p.p && (!l || b & /*$$scope*/
      4) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[2],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[2],
          b,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[2]
        ),
        null
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function create_fragment$p(u) {
  let l, f;
  return l = new Provider({
    props: {
      key: "query",
      data: (
        /*$routeStore*/
        u[0].queryParams
      ),
      $$slots: { default: [create_default_slot$c] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*$routeStore*/
      1 && (b.data = /*$routeStore*/
      p[0].queryParams), m & /*$$scope*/
      4 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$p(u, l, f) {
  let p;
  component_subscribe(u, routeStore, (y) => f(0, p = y));
  let { $$slots: m = {}, $$scope: b } = l;
  return u.$$set = (y) => {
    "$$scope" in y && f(2, b = y.$$scope);
  }, [p, m, b];
}
class QueryParamsProvider extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$p, create_fragment$p, safe_not_equal, {});
  }
}
const SettingsButton_svelte_svelte_type_style_lang = "";
function create_fragment$o(u) {
  let l, f, p, m, b;
  return f = new Icon({
    props: { name: (
      /*icon*/
      u[3]
    ), size: "S" }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(
        l,
        "title",
        /*title*/
        u[4]
      ), attr(l, "class", "svelte-1p3obm1"), toggle_class(
        l,
        "active",
        /*active*/
        u[0]
      ), toggle_class(
        l,
        "disabled",
        /*disabled*/
        u[6]
      );
    },
    m(y, v) {
      insert(y, l, v), mount_component(f, l, null), p = !0, m || (b = listen(
        l,
        "click",
        /*click_handler*/
        u[10]
      ), m = !0);
    },
    p(y, [v]) {
      const k = {};
      v & /*icon*/
      8 && (k.name = /*icon*/
      y[3]), f.$set(k), (!p || v & /*title*/
      16) && attr(
        l,
        "title",
        /*title*/
        y[4]
      ), (!p || v & /*active*/
      1) && toggle_class(
        l,
        "active",
        /*active*/
        y[0]
      ), (!p || v & /*disabled*/
      64) && toggle_class(
        l,
        "disabled",
        /*disabled*/
        y[6]
      );
    },
    i(y) {
      p || (transition_in(f.$$.fragment, y), p = !0);
    },
    o(y) {
      transition_out(f.$$.fragment, y), p = !1;
    },
    d(y) {
      y && detach(l), destroy_component(f), m = !1, b();
    }
  };
}
function instance$o(u, l, f) {
  let p, { prop: m } = l, { value: b } = l, { icon: y } = l, { title: v } = l, { bool: k = !1 } = l, { active: S = !1 } = l, { component: $ } = l, { disabled: w = !1 } = l;
  const T = createEventDispatcher(), E = () => {
    if (m) {
      const R = k ? !p : b;
      builderStore.actions.updateProp(m, R);
    }
    T("click");
  };
  return u.$$set = (R) => {
    "prop" in R && f(1, m = R.prop), "value" in R && f(2, b = R.value), "icon" in R && f(3, y = R.icon), "title" in R && f(4, v = R.title), "bool" in R && f(5, k = R.bool), "active" in R && f(0, S = R.active), "component" in R && f(9, $ = R.component), "disabled" in R && f(6, w = R.disabled);
  }, u.$$.update = () => {
    u.$$.dirty & /*component, prop*/
    514 && f(7, p = $ == null ? void 0 : $[m]), u.$$.dirty & /*prop, bool, currentValue, value*/
    166 && f(0, S = m && (k ? !!p : p === b));
  }, [
    S,
    m,
    b,
    y,
    v,
    k,
    w,
    p,
    T,
    $,
    E
  ];
}
class SettingsButton extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$o, create_fragment$o, safe_not_equal, {
      prop: 1,
      value: 2,
      icon: 3,
      title: 4,
      bool: 5,
      active: 0,
      component: 9,
      disabled: 6
    });
  }
}
const GridStylesButton_svelte_svelte_type_style_lang = "";
function create_fragment$n(u) {
  let l, f, p, m, b;
  return f = new Icon({
    props: { name: (
      /*icon*/
      u[2]
    ), size: "S" }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(
        l,
        "title",
        /*title*/
        u[3]
      ), attr(l, "class", "svelte-ih88f7"), toggle_class(
        l,
        "active",
        /*active*/
        u[5]
      );
    },
    m(y, v) {
      insert(y, l, v), mount_component(f, l, null), p = !0, m || (b = listen(
        l,
        "click",
        /*click_handler*/
        u[6]
      ), m = !0);
    },
    p(y, [v]) {
      const k = {};
      v & /*icon*/
      4 && (k.name = /*icon*/
      y[2]), f.$set(k), (!p || v & /*title*/
      8) && attr(
        l,
        "title",
        /*title*/
        y[3]
      ), (!p || v & /*active*/
      32) && toggle_class(
        l,
        "active",
        /*active*/
        y[5]
      );
    },
    i(y) {
      p || (transition_in(f.$$.fragment, y), p = !0);
    },
    o(y) {
      transition_out(f.$$.fragment, y), p = !1;
    },
    d(y) {
      y && detach(l), destroy_component(f), m = !1, b();
    }
  };
}
function instance$n(u, l, f) {
  let { style: p } = l, { value: m } = l, { icon: b } = l, { title: y } = l, { componentId: v } = l, { active: k } = l;
  const S = () => {
    builderStore.actions.updateStyles({ [p]: m }, v);
  };
  return u.$$set = ($) => {
    "style" in $ && f(0, p = $.style), "value" in $ && f(1, m = $.value), "icon" in $ && f(2, b = $.icon), "title" in $ && f(3, y = $.title), "componentId" in $ && f(4, v = $.componentId), "active" in $ && f(5, k = $.active);
  }, [p, m, b, y, v, k, S];
}
class GridStylesButton extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$n, create_fragment$n, safe_not_equal, {
      style: 0,
      value: 1,
      icon: 2,
      title: 3,
      componentId: 4,
      active: 5
    });
  }
}
const SettingsColorPicker_svelte_svelte_type_style_lang = "";
function create_fragment$m(u) {
  let l, f, p;
  return f = new ColorPicker({
    props: {
      size: "S",
      value: (
        /*disabled*/
        u[1] ? null : (
          /*currentValue*/
          u[2]
        )
      )
    }
  }), f.$on(
    "change",
    /*change_handler*/
    u[4]
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "svelte-2tavi5"), toggle_class(
        l,
        "disabled",
        /*disabled*/
        u[1]
      );
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, [b]) {
      const y = {};
      b & /*disabled, currentValue*/
      6 && (y.value = /*disabled*/
      m[1] ? null : (
        /*currentValue*/
        m[2]
      )), f.$set(y), (!p || b & /*disabled*/
      2) && toggle_class(
        l,
        "disabled",
        /*disabled*/
        m[1]
      );
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function instance$m(u, l, f) {
  let p, { prop: m } = l, { component: b } = l, { disabled: y = !1 } = l;
  const v = (k) => {
    m && builderStore.actions.updateProp(m, k.detail);
  };
  return u.$$set = (k) => {
    "prop" in k && f(0, m = k.prop), "component" in k && f(3, b = k.component), "disabled" in k && f(1, y = k.disabled);
  }, u.$$.update = () => {
    u.$$.dirty & /*component, prop*/
    9 && f(2, p = b == null ? void 0 : b[m]);
  }, [m, y, p, b, v];
}
class SettingsColorPicker extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$m, create_fragment$m, safe_not_equal, { prop: 0, component: 3, disabled: 1 });
  }
}
const SettingsPicker_svelte_svelte_type_style_lang = "";
function create_fragment$l(u) {
  let l, f, p;
  return f = new Select_1({
    props: {
      quiet: !0,
      autoWidth: !0,
      placeholder: (
        /*label*/
        u[2]
      ),
      options: (
        /*options*/
        u[1]
      ),
      disabled: (
        /*disabled*/
        u[3]
      ),
      value: (
        /*currentValue*/
        u[4]
      )
    }
  }), f.$on(
    "change",
    /*change_handler*/
    u[6]
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "svelte-y2na4k");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, [b]) {
      const y = {};
      b & /*label*/
      4 && (y.placeholder = /*label*/
      m[2]), b & /*options*/
      2 && (y.options = /*options*/
      m[1]), b & /*disabled*/
      8 && (y.disabled = /*disabled*/
      m[3]), b & /*currentValue*/
      16 && (y.value = /*currentValue*/
      m[4]), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function instance$l(u, l, f) {
  let p, { prop: m } = l, { options: b } = l, { label: y } = l, { component: v } = l, { disabled: k = !1 } = l;
  const S = ($) => {
    m && builderStore.actions.updateProp(m, $.detail);
  };
  return u.$$set = ($) => {
    "prop" in $ && f(0, m = $.prop), "options" in $ && f(1, b = $.options), "label" in $ && f(2, y = $.label), "component" in $ && f(5, v = $.component), "disabled" in $ && f(3, k = $.disabled);
  }, u.$$.update = () => {
    u.$$.dirty & /*component, prop*/
    33 && f(4, p = v == null ? void 0 : v[m]);
  }, [m, b, y, k, p, v, S];
}
class SettingsPicker extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$l, create_fragment$l, safe_not_equal, {
      prop: 0,
      options: 1,
      label: 2,
      component: 5,
      disabled: 3
    });
  }
}
const SettingsBar_svelte_svelte_type_style_lang = "";
function get_each_context$6(u, l, f) {
  const p = u.slice();
  return p[38] = l[f], p[40] = f, p;
}
function get_each_context_1(u, l, f) {
  const p = u.slice();
  return p[41] = l[f], p;
}
function create_if_block$b(u) {
  let l, f, p, m, b = (
    /*showGridStyles*/
    u[12] && create_if_block_7$1(u)
  ), y = ensure_array_like(
    /*settings*/
    u[14]
  ), v = [];
  for (let $ = 0; $ < y.length; $ += 1)
    v[$] = create_each_block$6(get_each_context$6(u, y, $));
  const k = ($) => transition_out(v[$], 1, 1, () => {
    v[$] = null;
  });
  let S = !/*isRoot*/
  u[13] && create_if_block_1$5(u);
  return {
    c() {
      l = element("div"), b && b.c(), f = space();
      for (let $ = 0; $ < v.length; $ += 1)
        v[$].c();
      p = space(), S && S.c(), attr(l, "class", "bar svelte-zwufuk"), set_style(
        l,
        "top",
        /*top*/
        u[3] + "px"
      ), set_style(
        l,
        "left",
        /*left*/
        u[4] + "px"
      ), toggle_class(
        l,
        "visible",
        /*measured*/
        u[6]
      );
    },
    m($, w) {
      insert($, l, w), b && b.m(l, null), append$1(l, f);
      for (let T = 0; T < v.length; T += 1)
        v[T] && v[T].m(l, null);
      append$1(l, p), S && S.m(l, null), u[29](l), m = !0;
    },
    p($, w) {
      if (/*showGridStyles*/
      $[12] ? b ? (b.p($, w), w[0] & /*showGridStyles*/
      4096 && transition_in(b, 1)) : (b = create_if_block_7$1($), b.c(), transition_in(b, 1), b.m(l, f)) : b && (group_outros(), transition_out(b, 1, 1, () => {
        b = null;
      }), check_outros()), w[0] & /*settings, isRoot, component*/
      24578) {
        y = ensure_array_like(
          /*settings*/
          $[14]
        );
        let T;
        for (T = 0; T < y.length; T += 1) {
          const E = get_each_context$6($, y, T);
          v[T] ? (v[T].p(E, w), transition_in(v[T], 1)) : (v[T] = create_each_block$6(E), v[T].c(), transition_in(v[T], 1), v[T].m(l, p));
        }
        for (group_outros(), T = y.length; T < v.length; T += 1)
          k(T);
        check_outros();
      }
      /*isRoot*/
      $[13] ? S && (group_outros(), transition_out(S, 1, 1, () => {
        S = null;
      }), check_outros()) : S ? (S.p($, w), w[0] & /*isRoot*/
      8192 && transition_in(S, 1)) : (S = create_if_block_1$5($), S.c(), transition_in(S, 1), S.m(l, null)), (!m || w[0] & /*top*/
      8) && set_style(
        l,
        "top",
        /*top*/
        $[3] + "px"
      ), (!m || w[0] & /*left*/
      16) && set_style(
        l,
        "left",
        /*left*/
        $[4] + "px"
      ), (!m || w[0] & /*measured*/
      64) && toggle_class(
        l,
        "visible",
        /*measured*/
        $[6]
      );
    },
    i($) {
      if (!m) {
        transition_in(b);
        for (let w = 0; w < y.length; w += 1)
          transition_in(v[w]);
        transition_in(S), m = !0;
      }
    },
    o($) {
      transition_out(b), v = v.filter(Boolean);
      for (let w = 0; w < v.length; w += 1)
        transition_out(v[w]);
      transition_out(S), m = !1;
    },
    d($) {
      $ && detach(l), b && b.d(), destroy_each(v, $), S && S.d(), u[29](null);
    }
  };
}
function create_if_block_7$1(u) {
  let l, f, p, m, b, y, v, k, S, $, w, T, E, R, O, P, L, M, B, j;
  return l = new GridStylesButton({
    props: {
      style: (
        /*gridHAlignVar*/
        u[11]
      ),
      value: "start",
      icon: "align-left",
      title: "Align left",
      active: (
        /*gridHAlign*/
        u[7] === "start"
      ),
      componentId: (
        /*id*/
        u[0]
      )
    }
  }), p = new GridStylesButton({
    props: {
      style: (
        /*gridHAlignVar*/
        u[11]
      ),
      value: "center",
      icon: "align-center-horizontal",
      title: "Align center",
      active: (
        /*gridHAlign*/
        u[7] === "center"
      ),
      componentId: (
        /*id*/
        u[0]
      )
    }
  }), b = new GridStylesButton({
    props: {
      style: (
        /*gridHAlignVar*/
        u[11]
      ),
      value: "end",
      icon: "align-right",
      title: "Align right",
      active: (
        /*gridHAlign*/
        u[7] === "end"
      ),
      componentId: (
        /*id*/
        u[0]
      )
    }
  }), v = new GridStylesButton({
    props: {
      style: (
        /*gridHAlignVar*/
        u[11]
      ),
      value: "stretch",
      icon: "arrows-left-right",
      title: "Stretch horizontally",
      active: (
        /*gridHAlign*/
        u[7] === "stretch"
      ),
      componentId: (
        /*id*/
        u[0]
      )
    }
  }), w = new GridStylesButton({
    props: {
      style: (
        /*gridVAlignVar*/
        u[10]
      ),
      value: "start",
      icon: "align-top",
      title: "Align top",
      active: (
        /*gridVAlign*/
        u[8] === "start"
      ),
      componentId: (
        /*id*/
        u[0]
      )
    }
  }), E = new GridStylesButton({
    props: {
      style: (
        /*gridVAlignVar*/
        u[10]
      ),
      value: "center",
      icon: "align-center-vertical",
      title: "Align middle",
      active: (
        /*gridVAlign*/
        u[8] === "center"
      ),
      componentId: (
        /*id*/
        u[0]
      )
    }
  }), O = new GridStylesButton({
    props: {
      style: (
        /*gridVAlignVar*/
        u[10]
      ),
      value: "end",
      icon: "align-bottom",
      title: "Align bottom",
      active: (
        /*gridVAlign*/
        u[8] === "end"
      ),
      componentId: (
        /*id*/
        u[0]
      )
    }
  }), L = new GridStylesButton({
    props: {
      style: (
        /*gridVAlignVar*/
        u[10]
      ),
      value: "stretch",
      icon: "arrows-up-down",
      title: "Stretch vertically",
      active: (
        /*gridVAlign*/
        u[8] === "stretch"
      ),
      componentId: (
        /*id*/
        u[0]
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment), f = space(), create_component(p.$$.fragment), m = space(), create_component(b.$$.fragment), y = space(), create_component(v.$$.fragment), k = space(), S = element("div"), $ = space(), create_component(w.$$.fragment), T = space(), create_component(E.$$.fragment), R = space(), create_component(O.$$.fragment), P = space(), create_component(L.$$.fragment), M = space(), B = element("div"), attr(S, "class", "divider svelte-zwufuk"), attr(B, "class", "divider svelte-zwufuk");
    },
    m(x, N) {
      mount_component(l, x, N), insert(x, f, N), mount_component(p, x, N), insert(x, m, N), mount_component(b, x, N), insert(x, y, N), mount_component(v, x, N), insert(x, k, N), insert(x, S, N), insert(x, $, N), mount_component(w, x, N), insert(x, T, N), mount_component(E, x, N), insert(x, R, N), mount_component(O, x, N), insert(x, P, N), mount_component(L, x, N), insert(x, M, N), insert(x, B, N), j = !0;
    },
    p(x, N) {
      const D = {};
      N[0] & /*gridHAlignVar*/
      2048 && (D.style = /*gridHAlignVar*/
      x[11]), N[0] & /*gridHAlign*/
      128 && (D.active = /*gridHAlign*/
      x[7] === "start"), N[0] & /*id*/
      1 && (D.componentId = /*id*/
      x[0]), l.$set(D);
      const V = {};
      N[0] & /*gridHAlignVar*/
      2048 && (V.style = /*gridHAlignVar*/
      x[11]), N[0] & /*gridHAlign*/
      128 && (V.active = /*gridHAlign*/
      x[7] === "center"), N[0] & /*id*/
      1 && (V.componentId = /*id*/
      x[0]), p.$set(V);
      const W = {};
      N[0] & /*gridHAlignVar*/
      2048 && (W.style = /*gridHAlignVar*/
      x[11]), N[0] & /*gridHAlign*/
      128 && (W.active = /*gridHAlign*/
      x[7] === "end"), N[0] & /*id*/
      1 && (W.componentId = /*id*/
      x[0]), b.$set(W);
      const F = {};
      N[0] & /*gridHAlignVar*/
      2048 && (F.style = /*gridHAlignVar*/
      x[11]), N[0] & /*gridHAlign*/
      128 && (F.active = /*gridHAlign*/
      x[7] === "stretch"), N[0] & /*id*/
      1 && (F.componentId = /*id*/
      x[0]), v.$set(F);
      const U = {};
      N[0] & /*gridVAlignVar*/
      1024 && (U.style = /*gridVAlignVar*/
      x[10]), N[0] & /*gridVAlign*/
      256 && (U.active = /*gridVAlign*/
      x[8] === "start"), N[0] & /*id*/
      1 && (U.componentId = /*id*/
      x[0]), w.$set(U);
      const Y = {};
      N[0] & /*gridVAlignVar*/
      1024 && (Y.style = /*gridVAlignVar*/
      x[10]), N[0] & /*gridVAlign*/
      256 && (Y.active = /*gridVAlign*/
      x[8] === "center"), N[0] & /*id*/
      1 && (Y.componentId = /*id*/
      x[0]), E.$set(Y);
      const q = {};
      N[0] & /*gridVAlignVar*/
      1024 && (q.style = /*gridVAlignVar*/
      x[10]), N[0] & /*gridVAlign*/
      256 && (q.active = /*gridVAlign*/
      x[8] === "end"), N[0] & /*id*/
      1 && (q.componentId = /*id*/
      x[0]), O.$set(q);
      const Q = {};
      N[0] & /*gridVAlignVar*/
      1024 && (Q.style = /*gridVAlignVar*/
      x[10]), N[0] & /*gridVAlign*/
      256 && (Q.active = /*gridVAlign*/
      x[8] === "stretch"), N[0] & /*id*/
      1 && (Q.componentId = /*id*/
      x[0]), L.$set(Q);
    },
    i(x) {
      j || (transition_in(l.$$.fragment, x), transition_in(p.$$.fragment, x), transition_in(b.$$.fragment, x), transition_in(v.$$.fragment, x), transition_in(w.$$.fragment, x), transition_in(E.$$.fragment, x), transition_in(O.$$.fragment, x), transition_in(L.$$.fragment, x), j = !0);
    },
    o(x) {
      transition_out(l.$$.fragment, x), transition_out(p.$$.fragment, x), transition_out(b.$$.fragment, x), transition_out(v.$$.fragment, x), transition_out(w.$$.fragment, x), transition_out(E.$$.fragment, x), transition_out(O.$$.fragment, x), transition_out(L.$$.fragment, x), j = !1;
    },
    d(x) {
      x && (detach(f), detach(m), detach(y), detach(k), detach(S), detach($), detach(T), detach(R), detach(P), detach(M), detach(B)), destroy_component(l, x), destroy_component(p, x), destroy_component(b, x), destroy_component(v, x), destroy_component(w, x), destroy_component(E, x), destroy_component(O, x), destroy_component(L, x);
    }
  };
}
function create_if_block_6$1(u) {
  let l, f;
  return l = new SettingsColorPicker({
    props: {
      prop: (
        /*setting*/
        u[38].key
      ),
      component: (
        /*component*/
        u[1]
      ),
      disabled: !!/*setting*/
      u[38].license
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*settings*/
      16384 && (b.prop = /*setting*/
      p[38].key), m[0] & /*component*/
      2 && (b.component = /*component*/
      p[1]), m[0] & /*settings*/
      16384 && (b.disabled = !!/*setting*/
      p[38].license), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_5$1(u) {
  let l, f;
  return l = new SettingsButton({
    props: {
      prop: (
        /*setting*/
        u[38].key
      ),
      icon: (
        /*setting*/
        u[38].barIcon
      ),
      title: (
        /*setting*/
        u[38].barTitle || /*setting*/
        u[38].label
      ),
      disabled: !!/*setting*/
      u[38].license,
      bool: !0,
      component: (
        /*component*/
        u[1]
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*settings*/
      16384 && (b.prop = /*setting*/
      p[38].key), m[0] & /*settings*/
      16384 && (b.icon = /*setting*/
      p[38].barIcon), m[0] & /*settings*/
      16384 && (b.title = /*setting*/
      p[38].barTitle || /*setting*/
      p[38].label), m[0] & /*settings*/
      16384 && (b.disabled = !!/*setting*/
      p[38].license), m[0] & /*component*/
      2 && (b.component = /*component*/
      p[1]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_3$2(u) {
  let l, f, p, m;
  const b = [create_if_block_4$1, create_else_block$2], y = [];
  function v(k, S) {
    return (
      /*setting*/
      k[38].barStyle === "buttons" ? 0 : 1
    );
  }
  return l = v(u), f = y[l] = b[l](u), {
    c() {
      f.c(), p = empty$1();
    },
    m(k, S) {
      y[l].m(k, S), insert(k, p, S), m = !0;
    },
    p(k, S) {
      let $ = l;
      l = v(k), l === $ ? y[l].p(k, S) : (group_outros(), transition_out(y[$], 1, 1, () => {
        y[$] = null;
      }), check_outros(), f = y[l], f ? f.p(k, S) : (f = y[l] = b[l](k), f.c()), transition_in(f, 1), f.m(p.parentNode, p));
    },
    i(k) {
      m || (transition_in(f), m = !0);
    },
    o(k) {
      transition_out(f), m = !1;
    },
    d(k) {
      k && detach(p), y[l].d(k);
    }
  };
}
function create_else_block$2(u) {
  let l, f;
  return l = new SettingsPicker({
    props: {
      prop: (
        /*setting*/
        u[38].key
      ),
      options: (
        /*setting*/
        u[38].options
      ),
      label: (
        /*setting*/
        u[38].label
      ),
      disabled: !!/*setting*/
      u[38].license,
      component: (
        /*component*/
        u[1]
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*settings*/
      16384 && (b.prop = /*setting*/
      p[38].key), m[0] & /*settings*/
      16384 && (b.options = /*setting*/
      p[38].options), m[0] & /*settings*/
      16384 && (b.label = /*setting*/
      p[38].label), m[0] & /*settings*/
      16384 && (b.disabled = !!/*setting*/
      p[38].license), m[0] & /*component*/
      2 && (b.component = /*component*/
      p[1]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_4$1(u) {
  let l, f, p = ensure_array_like(
    /*setting*/
    u[38].options
  ), m = [];
  for (let y = 0; y < p.length; y += 1)
    m[y] = create_each_block_1(get_each_context_1(u, p, y));
  const b = (y) => transition_out(m[y], 1, 1, () => {
    m[y] = null;
  });
  return {
    c() {
      for (let y = 0; y < m.length; y += 1)
        m[y].c();
      l = empty$1();
    },
    m(y, v) {
      for (let k = 0; k < m.length; k += 1)
        m[k] && m[k].m(y, v);
      insert(y, l, v), f = !0;
    },
    p(y, v) {
      if (v[0] & /*settings, component*/
      16386) {
        p = ensure_array_like(
          /*setting*/
          y[38].options
        );
        let k;
        for (k = 0; k < p.length; k += 1) {
          const S = get_each_context_1(y, p, k);
          m[k] ? (m[k].p(S, v), transition_in(m[k], 1)) : (m[k] = create_each_block_1(S), m[k].c(), transition_in(m[k], 1), m[k].m(l.parentNode, l));
        }
        for (group_outros(), k = p.length; k < m.length; k += 1)
          b(k);
        check_outros();
      }
    },
    i(y) {
      if (!f) {
        for (let v = 0; v < p.length; v += 1)
          transition_in(m[v]);
        f = !0;
      }
    },
    o(y) {
      m = m.filter(Boolean);
      for (let v = 0; v < m.length; v += 1)
        transition_out(m[v]);
      f = !1;
    },
    d(y) {
      y && detach(l), destroy_each(m, y);
    }
  };
}
function create_each_block_1(u) {
  let l, f;
  return l = new SettingsButton({
    props: {
      prop: (
        /*setting*/
        u[38].key
      ),
      value: (
        /*option*/
        u[41].value
      ),
      icon: (
        /*option*/
        u[41].barIcon
      ),
      title: (
        /*option*/
        u[41].barTitle || /*option*/
        u[41].label
      ),
      disabled: !!/*setting*/
      u[38].license,
      component: (
        /*component*/
        u[1]
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*settings*/
      16384 && (b.prop = /*setting*/
      p[38].key), m[0] & /*settings*/
      16384 && (b.value = /*option*/
      p[41].value), m[0] & /*settings*/
      16384 && (b.icon = /*option*/
      p[41].barIcon), m[0] & /*settings*/
      16384 && (b.title = /*option*/
      p[41].barTitle || /*option*/
      p[41].label), m[0] & /*settings*/
      16384 && (b.disabled = !!/*setting*/
      p[38].license), m[0] & /*component*/
      2 && (b.component = /*component*/
      p[1]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_2$3(u) {
  let l;
  return {
    c() {
      l = element("div"), attr(l, "class", "divider svelte-zwufuk");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_each_block$6(u) {
  let l, f, p, m, b;
  const y = [create_if_block_3$2, create_if_block_5$1, create_if_block_6$1], v = [];
  function k($, w) {
    return (
      /*setting*/
      $[38].type === "select" ? 0 : (
        /*setting*/
        $[38].type === "boolean" ? 1 : (
          /*setting*/
          $[38].type === "color" ? 2 : -1
        )
      )
    );
  }
  ~(l = k(u)) && (f = v[l] = y[l](u));
  let S = (
    /*setting*/
    u[38].barSeparator !== !1 && /*settings*/
    (u[14].length != /*idx*/
    u[40] + 1 || !/*isRoot*/
    u[13]) && create_if_block_2$3()
  );
  return {
    c() {
      f && f.c(), p = space(), S && S.c(), m = empty$1();
    },
    m($, w) {
      ~l && v[l].m($, w), insert($, p, w), S && S.m($, w), insert($, m, w), b = !0;
    },
    p($, w) {
      let T = l;
      l = k($), l === T ? ~l && v[l].p($, w) : (f && (group_outros(), transition_out(v[T], 1, 1, () => {
        v[T] = null;
      }), check_outros()), ~l ? (f = v[l], f ? f.p($, w) : (f = v[l] = y[l]($), f.c()), transition_in(f, 1), f.m(p.parentNode, p)) : f = null), /*setting*/
      $[38].barSeparator !== !1 && /*settings*/
      ($[14].length != /*idx*/
      $[40] + 1 || !/*isRoot*/
      $[13]) ? S || (S = create_if_block_2$3(), S.c(), S.m(m.parentNode, m)) : S && (S.d(1), S = null);
    },
    i($) {
      b || (transition_in(f), b = !0);
    },
    o($) {
      transition_out(f), b = !1;
    },
    d($) {
      $ && (detach(p), detach(m)), ~l && v[l].d($), S && S.d($);
    }
  };
}
function create_if_block_1$5(u) {
  let l, f, p, m;
  return l = new SettingsButton({
    props: {
      icon: "copy",
      title: "Duplicate component"
    }
  }), l.$on(
    "click",
    /*click_handler*/
    u[27]
  ), p = new SettingsButton({
    props: { icon: "trash", title: "Delete component" }
  }), p.$on(
    "click",
    /*click_handler_1*/
    u[28]
  ), {
    c() {
      create_component(l.$$.fragment), f = space(), create_component(p.$$.fragment);
    },
    m(b, y) {
      mount_component(l, b, y), insert(b, f, y), mount_component(p, b, y), m = !0;
    },
    p: noop$4,
    i(b) {
      m || (transition_in(l.$$.fragment, b), transition_in(p.$$.fragment, b), m = !0);
    },
    o(b) {
      transition_out(l.$$.fragment, b), transition_out(p.$$.fragment, b), m = !1;
    },
    d(b) {
      b && detach(f), destroy_component(l, b), destroy_component(p, b);
    }
  };
}
function create_fragment$k(u) {
  let l, f, p = (
    /*showBar*/
    u[9] && create_if_block$b(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, b) {
      /*showBar*/
      m[9] ? p ? (p.p(m, b), b[0] & /*showBar*/
      512 && transition_in(p, 1)) : (p = create_if_block$b(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
const verticalOffset = 36, horizontalOffset = 2;
function instance_1$1(u, l, f) {
  let p, m, b, y, v, k, S, $, w, T, E, R, O, P, L, M, B = noop$4, j = () => (B(), B = subscribe(v, (te) => f(23, M = te)), v), x, N, D = noop$4, V = () => (D(), D = subscribe(y, (te) => f(25, N = te)), y), W;
  component_subscribe(u, builderStore, (te) => f(2, L = te)), component_subscribe(u, dndIsDragging, (te) => f(24, x = te)), component_subscribe(u, componentStore, (te) => f(26, W = te)), u.$$.on_destroy.push(() => B()), u.$$.on_destroy.push(() => D());
  const F = getContext$1("context");
  component_subscribe(u, F, (te) => f(22, P = te));
  const U = new MutationObserver(() => ae());
  let Y = 0, q = 0, Q, z, H = !1, X = !1, Z = !1, oe, ee;
  const ie = () => {
    U.disconnect(), f(6, H = !1), X = !1, f(18, Z = !1);
  }, de = (te) => {
    U.observe(te, {
      attributes: !0,
      attributeFilter: ["style"]
    }), X = !0;
  }, pe = (te, ue) => {
    var fe;
    let J = [];
    return (fe = ue == null ? void 0 : ue.settings) == null || fe.forEach((_e) => {
      _e.section && shouldDisplaySetting(te, _e) ? J = J.concat(_e.settings || []) : J.push(_e);
    }), J.filter((_e) => _e.showInBar && !_e.hidden && shouldDisplaySetting(te, _e));
  }, ae = domDebounce(() => {
    var Ue;
    if (!k)
      return;
    let te = document.getElementsByClassName(p)[0];
    if (!te)
      return ie();
    const ue = te.dataset.insideGrid === "true";
    if (ue && !Z) {
      f(18, Z = !0);
      return;
    } else
      f(18, Z = ue);
    if (Z || (te = te.getElementsByClassName(`${p}-dom`)[0] || ((Ue = te.children) == null ? void 0 : Ue[0])), !te || !z)
      return ie();
    X || de(te);
    const fe = document.getElementById("clip-root").getBoundingClientRect(), _e = te.getBoundingClientRect(), ye = z.offsetWidth, ke = z.offsetHeight, { scrollX: we, scrollY: se, innerWidth: $e } = window;
    Z && (T ? (f(7, oe = te.dataset.gridMobileHAlign), f(8, ee = te.dataset.gridMobileVAlign)) : (f(7, oe = te.dataset.gridDesktopHAlign), f(8, ee = te.dataset.gridDesktopVAlign)));
    let Pe = _e.top + se - verticalOffset - ke;
    Pe < fe.top - 50 && (Pe = fe.top - 50), Pe < 0 && (Pe = 0);
    const De = fe.top + fe.height;
    Pe > De - 44 && (Pe = De - 44), _e.top < _e.height && _e.height < 80 && (Pe = _e.bottom + verticalOffset);
    let Ce = _e.left + we + _e.width / 2 - ye / 2;
    (Ce < 0 || Ce + ye > $e) && (Ce = _e.left + we - horizontalOffset, (Ce < 0 || Ce + ye > $e) && (Ce = _e.right + we - ye + horizontalOffset, (Ce < 0 || Ce + ye > $e) && (Ce = horizontalOffset))), Math.round(Pe) !== Math.round(Y) && f(3, Y = Pe), Math.round(Ce) !== Math.round(q) && f(4, q = Ce), f(6, H = !0);
  });
  onMount(() => {
    ae(), Q = setInterval(ae, 100), document.addEventListener("scroll", ae, !0);
  }), onDestroy(() => {
    clearInterval(Q), document.removeEventListener("scroll", ae, !0), ie();
  });
  const ne = () => {
    builderStore.actions.duplicateComponent(L.selectedComponentId);
  }, K = () => {
    builderStore.actions.deleteComponent(L.selectedComponentId);
  };
  function ce(te) {
    binding_callbacks[te ? "unshift" : "push"](() => {
      z = te, f(5, z);
    });
  }
  return u.$$.update = () => {
    var te, ue, J, fe;
    u.$$.dirty[0] & /*$builderStore*/
    4 && f(0, p = L.selectedComponentId), u.$$.dirty[0] & /*id*/
    1 && ie(), u.$$.dirty[0] & /*$componentStore*/
    67108864 && f(1, m = W.selectedComponent), u.$$.dirty[0] & /*$componentStore*/
    67108864 && f(21, b = W.selectedComponentDefinition), u.$$.dirty[0] & /*id*/
    1 && V(f(16, y = componentStore.actions.getComponentInstance(p))), u.$$.dirty[0] & /*$instance*/
    33554432 && j(f(15, v = N == null ? void 0 : N.state)), u.$$.dirty[0] & /*definition, $dndIsDragging, $state*/
    27262976 && f(9, k = (b == null ? void 0 : b.showSettingsBar) !== !1 && !x && b && !(M != null && M.errorState)), u.$$.dirty[0] & /*component, definition*/
    2097154 && f(14, S = pe(m, b)), u.$$.dirty[0] & /*id, $builderStore*/
    5 && f(13, $ = p === ((ue = (te = L.screen) == null ? void 0 : te.props) == null ? void 0 : ue._id)), u.$$.dirty[0] & /*insideGrid, definition*/
    2359296 && f(12, w = Z && (((J = b == null ? void 0 : b.grid) == null ? void 0 : J.hAlign) !== "stretch" || ((fe = b == null ? void 0 : b.grid) == null ? void 0 : fe.vAlign) !== "stretch")), u.$$.dirty[0] & /*$context*/
    4194304 && f(19, T = P.device.mobile), u.$$.dirty[0] & /*mobile*/
    524288 && f(20, E = T ? Devices.Mobile : Devices.Desktop), u.$$.dirty[0] & /*device*/
    1048576 && f(11, R = getGridVar(E, GridParams.HAlign)), u.$$.dirty[0] & /*device*/
    1048576 && f(10, O = getGridVar(E, GridParams.VAlign));
  }, [
    p,
    m,
    L,
    Y,
    q,
    z,
    H,
    oe,
    ee,
    k,
    O,
    R,
    w,
    $,
    S,
    v,
    y,
    F,
    Z,
    T,
    E,
    b,
    P,
    M,
    x,
    N,
    W,
    ne,
    K,
    ce
  ];
}
class SettingsBar extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance_1$1, create_fragment$k, safe_not_equal, {}, null, [-1, -1]);
  }
}
const Indicator_svelte_svelte_type_style_lang = "";
function get_each_context$5(u, l, f) {
  const p = u.slice();
  return p[16] = l[f], p;
}
function create_if_block_1$4(u) {
  let l, f, p, m = (
    /*icon*/
    u[5] && create_if_block_3$1(u)
  ), b = (
    /*text*/
    u[4] && create_if_block_2$2(u)
  );
  return {
    c() {
      l = element("div"), m && m.c(), f = space(), b && b.c(), attr(l, "class", "label svelte-1qt4i99"), attr(l, "draggable", "true"), attr(l, "data-indicator", "true"), attr(l, "data-drag-mode", GridDragMode.Move), attr(
        l,
        "data-id",
        /*componentId*/
        u[8]
      ), toggle_class(
        l,
        "flipped",
        /*flipped*/
        u[14]
      ), toggle_class(
        l,
        "line",
        /*line*/
        u[9]
      ), toggle_class(
        l,
        "right",
        /*alignRight*/
        u[10]
      );
    },
    m(y, v) {
      insert(y, l, v), m && m.m(l, null), append$1(l, f), b && b.m(l, null), p = !0;
    },
    p(y, v) {
      /*icon*/
      y[5] ? m ? (m.p(y, v), v & /*icon*/
      32 && transition_in(m, 1)) : (m = create_if_block_3$1(y), m.c(), transition_in(m, 1), m.m(l, f)) : m && (group_outros(), transition_out(m, 1, 1, () => {
        m = null;
      }), check_outros()), /*text*/
      y[4] ? b ? b.p(y, v) : (b = create_if_block_2$2(y), b.c(), b.m(l, null)) : b && (b.d(1), b = null), (!p || v & /*componentId*/
      256) && attr(
        l,
        "data-id",
        /*componentId*/
        y[8]
      ), (!p || v & /*flipped*/
      16384) && toggle_class(
        l,
        "flipped",
        /*flipped*/
        y[14]
      ), (!p || v & /*line*/
      512) && toggle_class(
        l,
        "line",
        /*line*/
        y[9]
      ), (!p || v & /*alignRight*/
      1024) && toggle_class(
        l,
        "right",
        /*alignRight*/
        y[10]
      );
    },
    i(y) {
      p || (transition_in(m), p = !0);
    },
    o(y) {
      transition_out(m), p = !1;
    },
    d(y) {
      y && detach(l), m && m.d(), b && b.d();
    }
  };
}
function create_if_block_3$1(u) {
  let l, f;
  return l = new Icon({
    props: {
      name: (
        /*icon*/
        u[5]
      ),
      size: "S",
      color: "white"
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*icon*/
      32 && (b.name = /*icon*/
      p[5]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_2$2(u) {
  let l, f;
  return {
    c() {
      l = element("div"), f = text$2(
        /*text*/
        u[4]
      ), attr(l, "class", "text svelte-1qt4i99");
    },
    m(p, m) {
      insert(p, l, m), append$1(l, f);
    },
    p(p, m) {
      m & /*text*/
      16 && set_data(
        f,
        /*text*/
        p[4]
      );
    },
    d(p) {
      p && detach(l);
    }
  };
}
function create_if_block$a(u) {
  let l, f = ensure_array_like(
    /*AnchorSides*/
    u[15]
  ), p = [];
  for (let m = 0; m < f.length; m += 1)
    p[m] = create_each_block$5(get_each_context$5(u, f, m));
  return {
    c() {
      for (let m = 0; m < p.length; m += 1)
        p[m].c();
      l = empty$1();
    },
    m(m, b) {
      for (let y = 0; y < p.length; y += 1)
        p[y] && p[y].m(m, b);
      insert(m, l, b);
    },
    p(m, b) {
      if (b & /*AnchorSides, componentId*/
      33024) {
        f = ensure_array_like(
          /*AnchorSides*/
          m[15]
        );
        let y;
        for (y = 0; y < f.length; y += 1) {
          const v = get_each_context$5(m, f, y);
          p[y] ? p[y].p(v, b) : (p[y] = create_each_block$5(v), p[y].c(), p[y].m(l.parentNode, l));
        }
        for (; y < p.length; y += 1)
          p[y].d(1);
        p.length = f.length;
      }
    },
    d(m) {
      m && detach(l), destroy_each(p, m);
    }
  };
}
function create_each_block$5(u) {
  let l, f, p;
  return {
    c() {
      l = element("div"), f = element("div"), p = space(), attr(f, "class", "anchor-inner svelte-1qt4i99"), attr(l, "class", "anchor " + /*side*/
      u[16] + " svelte-1qt4i99"), attr(l, "draggable", "true"), attr(l, "data-indicator", "true"), attr(l, "data-drag-mode", GridDragMode.Resize), attr(
        l,
        "data-side",
        /*side*/
        u[16]
      ), attr(
        l,
        "data-id",
        /*componentId*/
        u[8]
      );
    },
    m(m, b) {
      insert(m, l, b), append$1(l, f), append$1(l, p);
    },
    p(m, b) {
      b & /*componentId*/
      256 && attr(
        l,
        "data-id",
        /*componentId*/
        m[8]
      );
    },
    d(m) {
      m && detach(l);
    }
  };
}
function create_fragment$j(u) {
  let l, f, p, m = (
    /*text*/
    (u[4] || /*icon*/
    u[5]) && create_if_block_1$4(u)
  ), b = (
    /*showResizeAnchors*/
    u[11] && create_if_block$a(u)
  );
  return {
    c() {
      l = element("div"), m && m.c(), f = space(), b && b.c(), attr(l, "class", "indicator svelte-1qt4i99"), set_style(
        l,
        "top",
        /*top*/
        u[0] + "px"
      ), set_style(
        l,
        "left",
        /*left*/
        u[1] + "px"
      ), set_style(
        l,
        "width",
        /*width*/
        u[2] + "px"
      ), set_style(
        l,
        "height",
        /*height*/
        u[3] + "px"
      ), set_style(
        l,
        "--color",
        /*color*/
        u[6]
      ), set_style(
        l,
        "--zIndex",
        /*zIndex*/
        u[7]
      ), set_style(
        l,
        "--bg",
        /*background*/
        u[12] || "none"
      ), toggle_class(
        l,
        "flipped",
        /*flipped*/
        u[14]
      ), toggle_class(
        l,
        "line",
        /*line*/
        u[9]
      ), toggle_class(l, "withText", !!/*text*/
      u[4]), toggle_class(
        l,
        "vCompact",
        /*height*/
        u[3] < 40
      ), toggle_class(
        l,
        "hCompact",
        /*width*/
        u[2] < 40
      ), toggle_class(
        l,
        "animate",
        /*animate*/
        u[13]
      );
    },
    m(y, v) {
      insert(y, l, v), m && m.m(l, null), append$1(l, f), b && b.m(l, null), p = !0;
    },
    p(y, [v]) {
      /*text*/
      y[4] || /*icon*/
      y[5] ? m ? (m.p(y, v), v & /*text, icon*/
      48 && transition_in(m, 1)) : (m = create_if_block_1$4(y), m.c(), transition_in(m, 1), m.m(l, f)) : m && (group_outros(), transition_out(m, 1, 1, () => {
        m = null;
      }), check_outros()), /*showResizeAnchors*/
      y[11] ? b ? b.p(y, v) : (b = create_if_block$a(y), b.c(), b.m(l, null)) : b && (b.d(1), b = null), (!p || v & /*top*/
      1) && set_style(
        l,
        "top",
        /*top*/
        y[0] + "px"
      ), (!p || v & /*left*/
      2) && set_style(
        l,
        "left",
        /*left*/
        y[1] + "px"
      ), (!p || v & /*width*/
      4) && set_style(
        l,
        "width",
        /*width*/
        y[2] + "px"
      ), (!p || v & /*height*/
      8) && set_style(
        l,
        "height",
        /*height*/
        y[3] + "px"
      ), (!p || v & /*color*/
      64) && set_style(
        l,
        "--color",
        /*color*/
        y[6]
      ), (!p || v & /*zIndex*/
      128) && set_style(
        l,
        "--zIndex",
        /*zIndex*/
        y[7]
      ), (!p || v & /*background*/
      4096) && set_style(
        l,
        "--bg",
        /*background*/
        y[12] || "none"
      ), (!p || v & /*flipped*/
      16384) && toggle_class(
        l,
        "flipped",
        /*flipped*/
        y[14]
      ), (!p || v & /*line*/
      512) && toggle_class(
        l,
        "line",
        /*line*/
        y[9]
      ), (!p || v & /*text*/
      16) && toggle_class(l, "withText", !!/*text*/
      y[4]), (!p || v & /*height*/
      8) && toggle_class(
        l,
        "vCompact",
        /*height*/
        y[3] < 40
      ), (!p || v & /*width*/
      4) && toggle_class(
        l,
        "hCompact",
        /*width*/
        y[2] < 40
      ), (!p || v & /*animate*/
      8192) && toggle_class(
        l,
        "animate",
        /*animate*/
        y[13]
      );
    },
    i(y) {
      p || (transition_in(m), p = !0);
    },
    o(y) {
      transition_out(m), p = !1;
    },
    d(y) {
      y && detach(l), m && m.d(), b && b.d();
    }
  };
}
function instance$k(u, l, f) {
  let p, { top: m } = l, { left: b } = l, { width: y } = l, { height: v } = l, { text: k } = l, { icon: S } = l, { color: $ } = l, { zIndex: w } = l, { componentId: T } = l, { line: E = !1 } = l, { alignRight: R = !1 } = l, { showResizeAnchors: O = !1 } = l, { background: P } = l, { animate: L = !1 } = l;
  const M = [
    "right",
    "left",
    "top",
    "bottom",
    "bottom-right",
    "bottom-left",
    "top-right",
    "top-left"
  ];
  return u.$$set = (B) => {
    "top" in B && f(0, m = B.top), "left" in B && f(1, b = B.left), "width" in B && f(2, y = B.width), "height" in B && f(3, v = B.height), "text" in B && f(4, k = B.text), "icon" in B && f(5, S = B.icon), "color" in B && f(6, $ = B.color), "zIndex" in B && f(7, w = B.zIndex), "componentId" in B && f(8, T = B.componentId), "line" in B && f(9, E = B.line), "alignRight" in B && f(10, R = B.alignRight), "showResizeAnchors" in B && f(11, O = B.showResizeAnchors), "background" in B && f(12, P = B.background), "animate" in B && f(13, L = B.animate);
  }, u.$$.update = () => {
    u.$$.dirty & /*top*/
    1 && f(14, p = m < 24);
  }, [
    m,
    b,
    y,
    v,
    k,
    S,
    $,
    w,
    T,
    E,
    R,
    O,
    P,
    L,
    p,
    M
  ];
}
class Indicator extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$k, create_fragment$j, safe_not_equal, {
      top: 0,
      left: 1,
      width: 2,
      height: 3,
      text: 4,
      icon: 5,
      color: 6,
      zIndex: 7,
      componentId: 8,
      line: 9,
      alignRight: 10,
      showResizeAnchors: 11,
      background: 12,
      animate: 13
    });
  }
}
function get_each_context$4(u, l, f) {
  const p = u.slice();
  return p[30] = l[f], p[32] = f, p;
}
function create_each_block$4(u) {
  let l, f;
  return l = new Indicator({
    props: {
      top: (
        /*indicator*/
        u[30].top
      ),
      left: (
        /*indicator*/
        u[30].left
      ),
      width: (
        /*indicator*/
        u[30].width
      ),
      height: (
        /*indicator*/
        u[30].height
      ),
      text: (
        /*idx*/
        u[32] === 0 ? (
          /*state*/
          u[2].text
        ) : void 0
      ),
      icon: (
        /*idx*/
        u[32] === 0 ? (
          /*state*/
          u[2].icon
        ) : void 0
      ),
      showResizeAnchors: (
        /*state*/
        u[2].allowResizeAnchors && /*state*/
        u[2].insideGrid
      ),
      color: (
        /*state*/
        u[2].error ? errorColor : (
          /*state*/
          u[2].color
        )
      ),
      componentId: (
        /*state*/
        u[2].componentId
      ),
      zIndex: (
        /*state*/
        u[2].zIndex
      ),
      background: (
        /*background*/
        u[0]
      ),
      animate: (
        /*animate*/
        u[1]
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m[0] & /*visibleIndicators*/
      8 && (b.top = /*indicator*/
      p[30].top), m[0] & /*visibleIndicators*/
      8 && (b.left = /*indicator*/
      p[30].left), m[0] & /*visibleIndicators*/
      8 && (b.width = /*indicator*/
      p[30].width), m[0] & /*visibleIndicators*/
      8 && (b.height = /*indicator*/
      p[30].height), m[0] & /*state*/
      4 && (b.text = /*idx*/
      p[32] === 0 ? (
        /*state*/
        p[2].text
      ) : void 0), m[0] & /*state*/
      4 && (b.icon = /*idx*/
      p[32] === 0 ? (
        /*state*/
        p[2].icon
      ) : void 0), m[0] & /*state*/
      4 && (b.showResizeAnchors = /*state*/
      p[2].allowResizeAnchors && /*state*/
      p[2].insideGrid), m[0] & /*state*/
      4 && (b.color = /*state*/
      p[2].error ? errorColor : (
        /*state*/
        p[2].color
      )), m[0] & /*state*/
      4 && (b.componentId = /*state*/
      p[2].componentId), m[0] & /*state*/
      4 && (b.zIndex = /*state*/
      p[2].zIndex), m[0] & /*background*/
      1 && (b.background = /*background*/
      p[0]), m[0] & /*animate*/
      2 && (b.animate = /*animate*/
      p[1]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$i(u) {
  let l, f, p = ensure_array_like(
    /*visibleIndicators*/
    u[3]
  ), m = [];
  for (let y = 0; y < p.length; y += 1)
    m[y] = create_each_block$4(get_each_context$4(u, p, y));
  const b = (y) => transition_out(m[y], 1, 1, () => {
    m[y] = null;
  });
  return {
    c() {
      for (let y = 0; y < m.length; y += 1)
        m[y].c();
      l = empty$1();
    },
    m(y, v) {
      for (let k = 0; k < m.length; k += 1)
        m[k] && m[k].m(y, v);
      insert(y, l, v), f = !0;
    },
    p(y, v) {
      if (v[0] & /*visibleIndicators, state, background, animate*/
      15) {
        p = ensure_array_like(
          /*visibleIndicators*/
          y[3]
        );
        let k;
        for (k = 0; k < p.length; k += 1) {
          const S = get_each_context$4(y, p, k);
          m[k] ? (m[k].p(S, v), transition_in(m[k], 1)) : (m[k] = create_each_block$4(S), m[k].c(), transition_in(m[k], 1), m[k].m(l.parentNode, l));
        }
        for (group_outros(), k = p.length; k < m.length; k += 1)
          b(k);
        check_outros();
      }
    },
    i(y) {
      if (!f) {
        for (let v = 0; v < p.length; v += 1)
          transition_in(m[v]);
        f = !0;
      }
    },
    o(y) {
      m = m.filter(Boolean);
      for (let v = 0; v < m.length; v += 1)
        transition_out(m[v]);
      f = !1;
    },
    d(y) {
      y && detach(l), destroy_each(m, y);
    }
  };
}
const errorColor = "var(--spectrum-global-color-static-red-600)";
function instance$j(u, l, f) {
  let p, m, b, y;
  component_subscribe(u, builderStore, (H) => f(13, y = H));
  let { componentId: v } = l, { color: k } = l, { zIndex: S = 900 } = l, { prefix: $ = void 0 } = l, { allowResizeAnchors: w = !1 } = l, { background: T = void 0 } = l, { animate: E = !1 } = l, { text: R = void 0 } = l, { icon: O = void 0 } = l;
  const P = memo(l);
  component_subscribe(u, P, (H) => f(12, b = H));
  const L = new MutationObserver(() => z()), M = () => ({
    componentId: v,
    color: k,
    zIndex: S,
    prefix: $,
    allowResizeAnchors: w,
    indicators: [],
    text: R,
    icon: O,
    insideGrid: !1,
    error: !1
  });
  let B, j = M(), x = !1, N = !1, D = [], V = 0, W;
  const F = () => {
    L.disconnect(), x = !1, N = !1;
  }, U = (H) => [...document.getElementsByClassName(H)].filter((X) => X instanceof HTMLElement).slice(0, 100), Y = (H) => {
    L.observe(H, {
      attributes: !0,
      attributeFilter: ["style"]
    }), x = !0;
  }, q = (H) => (X) => {
    V >= D.length || (W.indicators[H].visible = W.indicators[H].insideModal || W.indicators[H].insideSidePanel || X[0].isIntersecting, ++V === D.length && (f(2, j = W), N = !1));
  }, z = domDebounce(() => {
    var de;
    if (N)
      return;
    let H = U(v);
    if (!H.length) {
      f(2, j = M());
      return;
    }
    N = !0, V = 0, D.forEach((pe) => pe.disconnect()), D = [], W = M(), x || Y(H[0]), W.insideGrid = ((de = H[0]) == null ? void 0 : de.dataset.insideGrid) === "true", R || (W.text = H[0].dataset.name, W.prefix && (W.text = `${W.prefix} ${W.text}`)), O || H[0].dataset.icon && (W.icon = H[0].dataset.icon), W.error = H[0].classList.contains("error");
    const X = window.scrollX, Z = window.scrollY;
    W.insideGrid || (H = U(`${v}-dom`));
    const oe = H.length > 1;
    if (!H.length) {
      f(2, j = M());
      return;
    }
    const ee = document.getElementById("app-root");
    if (!ee)
      throw "app-root node not found";
    const ie = ee.getBoundingClientRect();
    W.indicators = H.map((pe, le) => {
      const ae = pe.getBoundingClientRect();
      let ne = {
        top: Math.round(ae.top + Z - ie.top + m),
        left: Math.round(ae.left + X - ie.left + m),
        width: Math.round(ae.width + 2),
        height: Math.round(ae.height + 2),
        visible: !0,
        insideModal: !1,
        insideSidePanel: !1
      };
      if (oe) {
        const K = q(le), ce = new IntersectionObserver(K, { threshold: 1, root: ee });
        ce.observe(pe), D.push(ce), ne.visible = !1, ne.insideSidePanel = !!pe.closest(".side-panel"), ne.insideModal = !!pe.closest(".modal-content");
      }
      return ne;
    }), oe || (f(2, j = W), N = !1);
  });
  return onMount(() => {
    z(), B = setInterval(z, 100), document.addEventListener("scroll", z, !0);
  }), onDestroy(() => {
    L.disconnect(), clearInterval(B), document.removeEventListener("scroll", z, !0);
  }), u.$$set = (H) => {
    f(29, l = assign(assign({}, l), exclude_internal_props(H))), "componentId" in H && f(5, v = H.componentId), "color" in H && f(6, k = H.color), "zIndex" in H && f(7, S = H.zIndex), "prefix" in H && f(8, $ = H.prefix), "allowResizeAnchors" in H && f(9, w = H.allowResizeAnchors), "background" in H && f(0, T = H.background), "animate" in H && f(1, E = H.animate), "text" in H && f(10, R = H.text), "icon" in H && f(11, O = H.icon);
  }, u.$$.update = () => {
    u.$$.dirty[0] & /*componentId*/
    32 && F(), u.$$.dirty[0] & /*state*/
    4 && f(3, p = j.indicators.filter((H) => H.visible)), u.$$.dirty[0] & /*$builderStore*/
    8192 && (m = y.inBuilder ? 5 : -1), u.$$.dirty[0] & /*componentId, color, zIndex, prefix, allowResizeAnchors*/
    992 && P.set({
      componentId: v,
      color: k,
      zIndex: S,
      prefix: $,
      allowResizeAnchors: w
    }), u.$$.dirty[0] & /*$config*/
    4096 && z();
  }, l = exclude_internal_props(l), [
    T,
    E,
    j,
    p,
    P,
    v,
    k,
    S,
    $,
    w,
    R,
    O,
    b,
    y
  ];
}
class IndicatorSet extends SvelteComponent {
  constructor(l) {
    super(), init$1(
      this,
      l,
      instance$j,
      create_fragment$i,
      safe_not_equal,
      {
        componentId: 5,
        color: 6,
        zIndex: 7,
        prefix: 8,
        allowResizeAnchors: 9,
        background: 0,
        animate: 1,
        text: 10,
        icon: 11
      },
      null,
      [-1, -1]
    );
  }
}
function create_if_block$9(u) {
  let l, f;
  return l = new IndicatorSet({
    props: {
      componentId: (
        /*$builderStore*/
        u[0].selectedComponentId
      ),
      color: (
        /*color*/
        u[1]
      ),
      zIndex: 900,
      allowResizeAnchors: !0
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$builderStore*/
      1 && (b.componentId = /*$builderStore*/
      p[0].selectedComponentId), m & /*color*/
      2 && (b.color = /*color*/
      p[1]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$h(u) {
  let l, f, p = !/*$dndIsDragging*/
  u[2] && /*$builderStore*/
  u[0].selectedComponentId && create_if_block$9(u);
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, [b]) {
      !/*$dndIsDragging*/
      m[2] && /*$builderStore*/
      m[0].selectedComponentId ? p ? (p.p(m, b), b & /*$dndIsDragging, $builderStore*/
      5 && transition_in(p, 1)) : (p = create_if_block$9(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
function instance$i(u, l, f) {
  let p, m, b;
  return component_subscribe(u, builderStore, (y) => f(0, m = y)), component_subscribe(u, dndIsDragging, (y) => f(2, b = y)), u.$$.update = () => {
    u.$$.dirty & /*$builderStore*/
    1 && f(1, p = m.editMode ? "var(--spectrum-global-color-static-green-500)" : "var(--spectrum-global-color-static-blue-600)");
  }, [m, p, b];
}
class SelectionIndicator extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$i, create_fragment$h, safe_not_equal, {});
  }
}
function create_if_block$8(u) {
  let l, f;
  return l = new IndicatorSet({
    props: {
      componentId: (
        /*componentId*/
        u[0]
      ),
      color: "var(--spectrum-global-color-static-blue-200)",
      zIndex: (
        /*selected*/
        u[1] ? 890 : 910
      ),
      allowResizeAnchors: !0
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*componentId*/
      1 && (b.componentId = /*componentId*/
      p[0]), m & /*selected*/
      2 && (b.zIndex = /*selected*/
      p[1] ? 890 : 910), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$g(u) {
  let l, f, p = !/*$dndIsDragging*/
  u[2] && /*componentId*/
  u[0] && create_if_block$8(u);
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, [b]) {
      !/*$dndIsDragging*/
      m[2] && /*componentId*/
      m[0] ? p ? (p.p(m, b), b & /*$dndIsDragging, componentId*/
      5 && transition_in(p, 1)) : (p = create_if_block$8(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
function instance$h(u, l, f) {
  let p, m, b, y, v, k;
  component_subscribe(u, builderStore, (w) => f(4, y = w)), component_subscribe(u, hoverStore, (w) => f(5, v = w)), component_subscribe(u, dndIsDragging, (w) => f(2, k = w));
  const S = (w) => {
    var R;
    const T = w.target;
    if (w.buttons > 0)
      return;
    let E;
    if (T.classList.contains("anchor"))
      E = T.dataset.id;
    else {
      const O = T.closest(".interactive.component:not(.root)");
      O instanceof HTMLElement && (E = (R = O.dataset) == null ? void 0 : R.id);
    }
    E !== p && hoverStore.actions.hoverComponent(E);
  }, $ = () => {
    hoverStore.actions.hoverComponent(null);
  };
  return onMount(() => {
    document.addEventListener("mouseover", S), document.body.addEventListener("mouseleave", $);
  }), onDestroy(() => {
    document.removeEventListener("mouseover", S), document.body.removeEventListener("mouseleave", $);
  }), u.$$.update = () => {
    u.$$.dirty & /*$hoverStore*/
    32 && f(0, p = v.hoveredComponentId), u.$$.dirty & /*$builderStore*/
    16 && f(3, m = y.selectedComponentId), u.$$.dirty & /*componentId, selectedComponentId*/
    9 && f(1, b = p === m);
  }, [
    p,
    b,
    k,
    m,
    y,
    v
  ];
}
class HoverIndicator extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$h, create_fragment$g, safe_not_equal, {});
  }
}
const CustomThemeWrapper_svelte_svelte_type_style_lang = "";
function create_fragment$f(u) {
  let l, f, p;
  const m = (
    /*#slots*/
    u[4].default
  ), b = create_slot(
    m,
    u,
    /*$$scope*/
    u[3],
    null
  );
  return {
    c() {
      l = element("div"), b && b.c(), attr(l, "style", f = /*$themeStore*/
      u[0].customThemeCss), attr(
        l,
        "id",
        /*id*/
        u[1]
      ), attr(l, "class", "svelte-11fpj2n");
    },
    m(y, v) {
      insert(y, l, v), b && b.m(l, null), p = !0;
    },
    p(y, [v]) {
      b && b.p && (!p || v & /*$$scope*/
      8) && update_slot_base(
        b,
        m,
        y,
        /*$$scope*/
        y[3],
        p ? get_slot_changes(
          m,
          /*$$scope*/
          y[3],
          v,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          y[3]
        ),
        null
      ), (!p || v & /*$themeStore*/
      1 && f !== (f = /*$themeStore*/
      y[0].customThemeCss)) && attr(l, "style", f);
    },
    i(y) {
      p || (transition_in(b, y), p = !0);
    },
    o(y) {
      transition_out(b, y), p = !1;
    },
    d(y) {
      y && detach(l), b && b.d(y);
    }
  };
}
function instance$g(u, l, f) {
  let p;
  component_subscribe(u, themeStore, (k) => f(0, p = k));
  let { $$slots: m = {}, $$scope: b } = l, { popoverRoot: y = !0 } = l;
  const v = uuid();
  return y && setContext(Context$1.PopoverRoot, `#${v}`), u.$$set = (k) => {
    "popoverRoot" in k && f(2, y = k.popoverRoot), "$$scope" in k && f(3, b = k.$$scope);
  }, [p, v, y, b, m];
}
class CustomThemeWrapper extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$g, create_fragment$f, safe_not_equal, { popoverRoot: 2 });
  }
}
const ThrottleRate = 130;
function instance$f(u, l, f) {
  let p, m, b, y, v, k;
  component_subscribe(u, dndStore, (B) => f(0, v = B)), component_subscribe(u, isGridScreen, (B) => f(1, k = B));
  let S = !1;
  const $ = (B) => {
    const j = document.getElementsByClassName(`${B}-dom`)[0];
    return j instanceof HTMLElement ? j : void 0;
  }, w = (B) => {
    const j = B.reduce((N, D) => N + D, 0) / B.length;
    let x = 0;
    return B.forEach((N) => {
      const D = N - j;
      x += D * D;
    }), x / B.length;
  }, T = () => {
    if (!S) {
      if (p != null && p.id) {
        const B = document.getElementsByClassName(p == null ? void 0 : p.id)[0];
        B && B.removeEventListener("dragend", T);
      }
      dndStore.actions.reset();
    }
  }, E = (B) => {
    var W, F;
    if (isGridEvent(B) || !(B.target instanceof HTMLElement))
      return;
    const j = B.target.closest(".component");
    if (!(j instanceof HTMLElement) || !j.classList.contains("draggable"))
      return;
    (W = B.dataTransfer) == null || W.setDragImage(new Image(), 0, 0), j.addEventListener("dragend", T);
    const x = j.dataset.id, N = j.dataset.parent, D = findComponentById((F = get_store_value(screenStore).activeScreen) == null ? void 0 : F.props, N), V = D._children.findIndex((U) => U._id === x);
    dndStore.actions.startDraggingExistingComponent({
      id: x,
      bounds: j.children[0].getBoundingClientRect(),
      parent: N,
      index: V,
      name: j.dataset.name,
      icon: j.dataset.icon,
      type: D._children[V]._component
    }), builderStore.actions.selectComponent(x), setTimeout(
      () => {
        dndStore.actions.updateDrop({ parent: N, index: V });
      },
      0
    );
  }, R = throttle(
    (B, j) => {
      var Z;
      if (!m)
        return;
      let { id: x, parent: N, element: D, acceptsChildren: V, empty: W } = m;
      if (V || (x = N, W = !1, D = $(N)), W) {
        dndStore.actions.updateDrop({ parent: x, index: 0 });
        return;
      }
      const F = D == null ? void 0 : D.getElementsByClassName("component")[0];
      (F == null ? void 0 : F.parentNode) instanceof HTMLElement && (D = F.parentNode);
      let U;
      (D == null ? void 0 : D.children.length) === 1 && (U = document.createElement("div"), U.dataset.id = DNDPlaceholderID, D.appendChild(U));
      const Y = [...(D == null ? void 0 : D.children) || []].filter((oe) => oe instanceof HTMLElement).map((oe) => {
        var de;
        const ie = (((de = oe.children) == null ? void 0 : de[0]) || oe).getBoundingClientRect();
        return {
          placeholder: oe.dataset.id === DNDPlaceholderID,
          centerX: ie.left + ie.width / 2,
          centerY: ie.top + ie.height / 2,
          left: ie.left,
          right: ie.right,
          top: ie.top,
          bottom: ie.bottom
        };
      });
      U && (D == null || D.removeChild(U));
      const q = Object.keys(Y[0] || {}).filter((oe) => oe !== "placeholder").map((oe) => {
        const ee = oe, ie = Y.map((de) => de[ee]);
        return { variance: w(ie), side: oe };
      });
      q.sort((oe, ee) => oe.variance < ee.variance ? -1 : 1);
      const Q = ["centerX", "left", "right"].includes((Z = q[0]) == null ? void 0 : Z.side), z = Y.filter((oe) => !oe.placeholder).map((oe) => Q ? oe.centerY : oe.centerX), H = Q ? j : B;
      let X = 0;
      for (; X < z.length && z[X] < H; )
        X++;
      dndStore.actions.updateDrop({ parent: x, index: X });
    },
    ThrottleRate
  ), O = (B) => {
    B.preventDefault(), B.stopPropagation(), R(B.clientX, B.clientY);
  }, P = (B) => {
    !p || !m || y || O(B);
  }, L = async (B) => {
    var x, N;
    if (!p || y || !(B.target instanceof HTMLElement))
      return;
    let j = (N = (x = B.target).closest) == null ? void 0 : N.call(x, `.component:not(.block):not(.${p.id})`);
    j instanceof HTMLElement && j != null && j.classList.contains("droppable") && (dndStore.actions.updateTarget({
      id: j.dataset.id,
      parent: j.dataset.parent,
      element: $(j.dataset.id),
      empty: j.classList.contains("empty"),
      acceptsChildren: j.classList.contains("parent")
    }), O(B));
  }, M = async () => {
    var D, V, W, F, U;
    if (!p || !(b != null && b.parent) || (b == null ? void 0 : b.index) == null)
      return;
    if (p.isNew) {
      S = !0, builderStore.actions.dropNewComponent(p.type, b.parent, b.index, (D = v.meta) == null ? void 0 : D.props), S = !1, T();
      return;
    }
    let B, j;
    const x = findComponentById((V = get_store_value(screenStore).activeScreen) == null ? void 0 : V.props, b.parent);
    if (!x || p.parent === b.parent && p.index === b.index)
      return;
    const N = (W = x._children) == null ? void 0 : W.filter((Y) => Y._id !== DNDPlaceholderID && Y._id !== p.id);
    N != null && N.length ? b.index === 0 ? (B = (F = N[0]) == null ? void 0 : F._id, j = DropPosition.ABOVE) : (B = (U = N[b.index - 1]) == null ? void 0 : U._id, j = DropPosition.BELOW) : (B = x._id, j = DropPosition.INSIDE), B && j && p.id && (S = !0, await builderStore.actions.moveComponent(p.id, B, j), S = !1, T());
  };
  return onMount(() => {
    document.addEventListener("dragstart", E, !1), document.addEventListener("dragover", P, !1), document.addEventListener("dragenter", L, !1), document.addEventListener("drop", M, !1);
  }), onDestroy(() => {
    document.removeEventListener("dragstart", E, !1), document.removeEventListener("dragover", P, !1), document.removeEventListener("dragenter", L, !1), document.removeEventListener("drop", M, !1);
  }), u.$$.update = () => {
    u.$$.dirty & /*$dndStore*/
    1 && (p = v.source), u.$$.dirty & /*$dndStore*/
    1 && (m = v.target), u.$$.dirty & /*$dndStore*/
    1 && (b = v.drop), u.$$.dirty & /*$isGridScreen*/
    2 && (y = k);
  }, [v, k];
}
class DNDHandler extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$f, null, safe_not_equal, {});
  }
}
function instance_1(u, l, f) {
  let p, m, b, y, v, k, S, $, w, T = noop$4, E = () => (T(), T = subscribe(y, (q) => f(8, w = q)), y), R;
  component_subscribe(u, isGridScreen, (q) => f(13, k = q)), component_subscribe(u, dndSource, (q) => f(14, S = q)), component_subscribe(u, dndIsDragging, (q) => f(7, $ = q)), u.$$.on_destroy.push(() => T());
  const O = getContext$1("context");
  component_subscribe(u, O, (q) => f(9, R = q));
  const P = new Image(1, 1);
  P.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
  let L, M, B = memo();
  component_subscribe(u, B, (q) => f(6, v = q));
  const j = () => (L == null ? void 0 : L.scrollTop) || 0, x = async (q, Q) => {
    q == null || q.setEphemeralStyles(Q), S != null && S.isNew && Q && dndStore.actions.updateNewComponentProps({ _styles: { normal: Q } });
  }, N = (q, Q, z) => Math.min(z, Math.max(Q, q)), D = domDebounce((q, Q) => {
    if (!(M != null && M.grid))
      return;
    const { mode: z, grid: H, domGrid: X } = M, { startX: Z, startY: oe, rowStart: ee, rowEnd: ie, colStart: de, colEnd: pe } = H;
    if (!X)
      return;
    const le = parseInt(X.dataset.cols || ""), ae = parseInt(X.dataset.colSize || "");
    if (isNaN(le) || isNaN(ae))
      throw "DOM grid missing required dataset attributes";
    const ne = q - Z;
    let K = Math.round(ne / ae);
    const ce = Q - oe + j();
    let te = Math.round(ce / GridRowHeight);
    if (z === GridDragMode.Move) {
      K = N(K, 1 - de, le + 1 - pe), te = Math.max(te, 1 - ee);
      const ue = {
        [m.colStart]: de + K,
        [m.colEnd]: pe + K,
        [m.rowStart]: ee + te,
        [m.rowEnd]: ie + te
      };
      B.set(ue);
    } else if (z === GridDragMode.Resize) {
      const { side: ue } = M;
      let J = {};
      ue === "right" ? J[m.colEnd] = Math.max(pe + K, de + 1) : ue === "left" ? J[m.colStart] = Math.min(de + K, pe - 1) : ue === "top" ? J[m.rowStart] = Math.min(ee + te, ie - 1) : ue === "bottom" ? J[m.rowEnd] = Math.max(ie + te, ee + 1) : ue === "bottom-right" ? (J[m.colEnd] = Math.max(pe + K, de + 1), J[m.rowEnd] = Math.max(ie + te, ee + 1)) : ue === "bottom-left" ? (J[m.colStart] = Math.min(de + K, pe - 1), J[m.rowEnd] = Math.max(ie + te, ee + 1)) : ue === "top-right" ? (J[m.colEnd] = Math.max(pe + K, de + 1), J[m.rowStart] = Math.min(ee + te, ie - 1)) : ue === "top-left" && (J[m.colStart] = Math.min(de + K, pe - 1), J[m.rowStart] = Math.min(ee + te, ie - 1)), B.set(J);
    }
  }), V = (q) => {
    q.preventDefault(), q.stopPropagation(), D(q.clientX, q.clientY);
  }, W = () => {
    const q = document.getElementsByClassName(DNDPlaceholderID)[0], Q = q == null ? void 0 : q.closest(".grid");
    if (!(q instanceof HTMLElement) || !(Q instanceof HTMLElement))
      return;
    const z = getComputedStyle(q), H = q.getBoundingClientRect();
    q.classList.add("dragging"), Q.classList.add("highlight"), f(3, M = {
      domComponent: q,
      domGrid: Q,
      id: DNDPlaceholderID,
      gridId: Q.parentElement.dataset.id,
      mode: GridDragMode.Move,
      grid: {
        startX: H.left + H.width / 2,
        startY: H.top + H.height / 2 + j(),
        rowStart: parseInt(z.gridRowStart),
        rowEnd: parseInt(z.gridRowEnd),
        colStart: parseInt(z.gridColumnStart),
        colEnd: parseInt(z.gridColumnEnd)
      }
    });
  }, F = (q) => {
    if (!isGridEvent(q))
      return;
    q.dataTransfer.setDragImage(P, 0, 0);
    let Q, z, H;
    q.target.dataset.indicator === "true" ? (Q = q.target.dataset.dragMode, z = q.target.dataset.id, H = q.target.dataset.side) : (Q = GridDragMode.Move, z = q.target.closest(".component").dataset.id), Q === GridDragMode.Move && (q.ctrlKey || q.metaKey) && builderStore.actions.duplicateComponent(z, DropPosition.ABOVE, !1);
    const X = document.getElementsByClassName(z)[0], Z = X == null ? void 0 : X.closest(".grid");
    if (!(X instanceof HTMLElement) || !(Z instanceof HTMLElement))
      return;
    const oe = getComputedStyle(X);
    X.classList.add("dragging"), Z.classList.add("highlight"), builderStore.actions.selectComponent(z), f(3, M = {
      domTarget: q.target,
      domComponent: X,
      domGrid: Z,
      id: z,
      gridId: Z.parentElement.dataset.id,
      mode: Q,
      side: H,
      grid: {
        startX: q.clientX,
        startY: q.clientY + j(),
        rowStart: parseInt(oe.gridRowStart),
        rowEnd: parseInt(oe.gridRowEnd),
        colStart: parseInt(oe.gridColumnStart),
        colEnd: parseInt(oe.gridColumnEnd)
      }
    }), M.domTarget.addEventListener("dragend", Y, !1);
  }, U = (q) => {
    if (!M) {
      $ && (S != null && S.isNew) && k && W();
      return;
    }
    V(q);
  }, Y = async () => {
    if (!M)
      return;
    const { id: q, domTarget: Q, domGrid: z, domComponent: H } = M;
    H.classList.remove("dragging"), z.classList.remove("highlight"), Q == null || Q.removeEventListener("dragend", Y), v && builderStore.actions.updateStyles(v, q), f(3, M = void 0), B.set(void 0);
  };
  return onMount(() => {
    L = document.getElementsByClassName("screen-wrapper")[0], document.addEventListener("dragstart", F, !1), document.addEventListener("dragover", U, !1), document.addEventListener("scroll", D);
  }), onDestroy(() => {
    document.removeEventListener("dragstart", F, !1), document.removeEventListener("dragover", U, !1), document.removeEventListener("scroll", D);
  }), u.$$.update = () => {
    var q;
    u.$$.dirty & /*$context*/
    512 && f(5, p = (q = R.device) != null && q.mobile ? Devices.Mobile : Devices.Desktop), u.$$.dirty & /*device*/
    32 && (m = {
      colStart: getGridVar(p, GridParams.ColStart),
      colEnd: getGridVar(p, GridParams.ColEnd),
      rowStart: getGridVar(p, GridParams.RowStart),
      rowEnd: getGridVar(p, GridParams.RowEnd)
    }), u.$$.dirty & /*dragInfo*/
    8 && f(4, b = M == null ? void 0 : M.id), u.$$.dirty & /*id*/
    16 && E(f(0, y = componentStore.actions.getComponentInstance(b))), u.$$.dirty & /*$instance, $styles*/
    320 && x(w, v), u.$$.dirty & /*$dndIsDragging*/
    128 && !$ && Y();
  }, [
    y,
    O,
    B,
    M,
    b,
    p,
    v,
    $,
    w,
    R
  ];
}
class GridDNDHandler extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance_1, null, safe_not_equal, {});
  }
}
function instance$e(u) {
  onMount(() => {
    get_store_value(builderStore).inBuilder && document.addEventListener("keydown", l);
  }), onDestroy(() => {
    get_store_value(builderStore).inBuilder && document.removeEventListener("keydown", l);
  });
  const l = (f) => {
    var b;
    const p = get_store_value(builderStore);
    if (!p.inBuilder || p.editMode)
      return;
    const m = (b = document.activeElement) == null ? void 0 : b.tagName.toLowerCase();
    ["input", "textarea"].indexOf(m) === -1 && (f.ctrlKey && f.key === "d" && f.preventDefault(), builderStore.actions.keyDown(f.key, f.ctrlKey));
  };
  return [];
}
class KeyboardManager extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$e, null, safe_not_equal, {});
  }
}
const DevToolsHeader_svelte_svelte_type_style_lang = "";
function create_default_slot_3$4(u) {
  let l;
  return {
    c() {
      l = text$2("Preview");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_if_block_1$3(u) {
  let l, f;
  return l = new ActionButton({
    props: {
      quiet: !0,
      icon: "code",
      $$slots: { default: [create_default_slot_2$5] },
      $$scope: { ctx: u }
    }
  }), l.$on(
    "click",
    /*click_handler*/
    u[6]
  ), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope*/
      512 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_2$5(u) {
  let l;
  return {
    c() {
      l = text$2("DevTools");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_if_block$7(u) {
  let l, f, p, m;
  return l = new ActionButton({
    props: {
      quiet: !0,
      icon: "arrow-square-out",
      $$slots: { default: [create_default_slot_1$7] },
      $$scope: { ctx: u }
    }
  }), l.$on(
    "click",
    /*click_handler_1*/
    u[7]
  ), p = new ActionButton({
    props: {
      quiet: !0,
      icon: "x",
      $$slots: { default: [create_default_slot$b] },
      $$scope: { ctx: u }
    }
  }), p.$on(
    "click",
    /*click_handler_2*/
    u[8]
  ), {
    c() {
      create_component(l.$$.fragment), f = space(), create_component(p.$$.fragment);
    },
    m(b, y) {
      mount_component(l, b, y), insert(b, f, y), mount_component(p, b, y), m = !0;
    },
    p(b, y) {
      const v = {};
      y & /*$$scope*/
      512 && (v.$$scope = { dirty: y, ctx: b }), l.$set(v);
      const k = {};
      y & /*$$scope*/
      512 && (k.$$scope = { dirty: y, ctx: b }), p.$set(k);
    },
    i(b) {
      m || (transition_in(l.$$.fragment, b), transition_in(p.$$.fragment, b), m = !0);
    },
    o(b) {
      transition_out(l.$$.fragment, b), transition_out(p.$$.fragment, b), m = !1;
    },
    d(b) {
      b && detach(f), destroy_component(l, b), destroy_component(p, b);
    }
  };
}
function create_default_slot_1$7(u) {
  let l;
  return {
    c() {
      l = text$2("Fullscreen");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot$b(u) {
  let l;
  return {
    c() {
      l = text$2("Close");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_fragment$e(u) {
  let l, f, p, m, b, y, v;
  f = new Heading({
    props: {
      size: "XS",
      $$slots: { default: [create_default_slot_3$4] },
      $$scope: { ctx: u }
    }
  }), m = new Select_1({
    props: {
      quiet: !0,
      options: (
        /*previewOptions*/
        u[0]
      ),
      value: (
        /*$devToolsStore*/
        u[2].role || SELF_ROLE
      ),
      placeholder: null,
      autoWidth: !0
    }
  }), m.$on(
    "change",
    /*change_handler*/
    u[5]
  );
  let k = !/*$context*/
  u[1].device.mobile && create_if_block_1$3(u), S = window.parent.isBuilder && create_if_block$7(u);
  return {
    c() {
      l = element("div"), create_component(f.$$.fragment), p = space(), create_component(m.$$.fragment), b = space(), k && k.c(), y = space(), S && S.c(), attr(l, "class", "dev-preview-header svelte-14133vr"), toggle_class(
        l,
        "mobile",
        /*$context*/
        u[1].device.mobile
      );
    },
    m($, w) {
      insert($, l, w), mount_component(f, l, null), append$1(l, p), mount_component(m, l, null), append$1(l, b), k && k.m(l, null), append$1(l, y), S && S.m(l, null), v = !0;
    },
    p($, [w]) {
      const T = {};
      w & /*$$scope*/
      512 && (T.$$scope = { dirty: w, ctx: $ }), f.$set(T);
      const E = {};
      w & /*previewOptions*/
      1 && (E.options = /*previewOptions*/
      $[0]), w & /*$devToolsStore*/
      4 && (E.value = /*$devToolsStore*/
      $[2].role || SELF_ROLE), m.$set(E), /*$context*/
      $[1].device.mobile ? k && (group_outros(), transition_out(k, 1, 1, () => {
        k = null;
      }), check_outros()) : k ? (k.p($, w), w & /*$context*/
      2 && transition_in(k, 1)) : (k = create_if_block_1$3($), k.c(), transition_in(k, 1), k.m(l, y)), window.parent.isBuilder && S.p($, w), (!v || w & /*$context*/
      2) && toggle_class(
        l,
        "mobile",
        /*$context*/
        $[1].device.mobile
      );
    },
    i($) {
      v || (transition_in(f.$$.fragment, $), transition_in(m.$$.fragment, $), transition_in(k), transition_in(S), v = !0);
    },
    o($) {
      transition_out(f.$$.fragment, $), transition_out(m.$$.fragment, $), transition_out(k), transition_out(S), v = !1;
    },
    d($) {
      $ && detach(l), destroy_component(f), destroy_component(m), k && k.d(), S && S.d();
    }
  };
}
const SELF_ROLE = "self";
function buildRoleList(u) {
  var f;
  const l = [];
  if (l.push({
    label: "View as yourself",
    value: SELF_ROLE
  }), !u)
    return l;
  for (let p of u)
    l.push({
      label: `View as ${((f = p.uiMetadata) == null ? void 0 : f.displayName) || p.name}`,
      value: p._id
    });
  return l;
}
function instance$d(u, l, f) {
  let p, m, b;
  component_subscribe(u, devToolsStore, (T) => f(2, b = T));
  const y = getContext$1("context");
  component_subscribe(u, y, (T) => f(1, m = T));
  let v;
  onMount(async () => {
    await devToolsStore.actions.changeRole(SELF_ROLE), f(4, v = await API.getRoles());
  });
  const k = (T) => devToolsStore.actions.changeRole(T.detail), S = () => devToolsStore.actions.setVisible(!b.visible), $ = () => {
    var T, E;
    (E = (T = window.parent).closePreview) == null || E.call(T), window.open(window.parent.previewFullscreenUrl, "_blank");
  }, w = () => {
    var T, E;
    return (E = (T = window.parent).closePreview) == null ? void 0 : E.call(T);
  };
  return u.$$.update = () => {
    u.$$.dirty & /*roles*/
    16 && f(0, p = buildRoleList(v));
  }, [
    p,
    m,
    b,
    y,
    v,
    k,
    S,
    $,
    w
  ];
}
class DevToolsHeader extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$d, create_fragment$e, safe_not_equal, {});
  }
}
const DevToolsStat_svelte_svelte_type_style_lang = "";
function create_fragment$d(u) {
  let l, f, p, m, b, y, v, k;
  return {
    c() {
      l = element("div"), f = element("div"), p = text$2(
        /*prettyLabel*/
        u[3]
      ), m = space(), b = element("div"), y = text$2(
        /*prettyValue*/
        u[2]
      ), attr(f, "class", "stat-label svelte-da3g1f"), attr(
        f,
        "title",
        /*prettyLabel*/
        u[3]
      ), attr(b, "class", "stat-value svelte-da3g1f"), attr(
        b,
        "title",
        /*prettyValue*/
        u[2]
      ), toggle_class(
        b,
        "copyable",
        /*canCopy*/
        u[1]
      ), toggle_class(
        b,
        "empty",
        /*empty*/
        u[0]
      ), attr(l, "class", "stat svelte-da3g1f");
    },
    m(S, $) {
      insert(S, l, $), append$1(l, f), append$1(f, p), append$1(l, m), append$1(l, b), append$1(b, y), v || (k = listen(b, "click", function() {
        is_function(
          /*canCopy*/
          u[1] ? (
            /*copyValue*/
            u[4]
          ) : null
        ) && /*canCopy*/
        (u[1] ? (
          /*copyValue*/
          u[4]
        ) : null).apply(this, arguments);
      }), v = !0);
    },
    p(S, [$]) {
      u = S, $ & /*prettyLabel*/
      8 && set_data(
        p,
        /*prettyLabel*/
        u[3]
      ), $ & /*prettyLabel*/
      8 && attr(
        f,
        "title",
        /*prettyLabel*/
        u[3]
      ), $ & /*prettyValue*/
      4 && set_data(
        y,
        /*prettyValue*/
        u[2]
      ), $ & /*prettyValue*/
      4 && attr(
        b,
        "title",
        /*prettyValue*/
        u[2]
      ), $ & /*canCopy*/
      2 && toggle_class(
        b,
        "copyable",
        /*canCopy*/
        u[1]
      ), $ & /*empty*/
      1 && toggle_class(
        b,
        "empty",
        /*empty*/
        u[0]
      );
    },
    i: noop$4,
    o: noop$4,
    d(S) {
      S && detach(l), v = !1, k();
    }
  };
}
function instance$c(u, l, f) {
  let p, m, b, y, { label: v } = l, { value: k } = l, { copyable: S = !1 } = l;
  const $ = async () => {
    try {
      await copyToClipboard(k), notificationStore.actions.success("Copied to clipboard");
    } catch {
      notificationStore.actions.error("Failed to copy to clipboard. Check the dev console for the value."), console.warn("Failed to copy the value", k);
    }
  };
  return u.$$set = (w) => {
    "label" in w && f(5, v = w.label), "value" in w && f(6, k = w.value), "copyable" in w && f(7, S = w.copyable);
  }, u.$$.update = () => {
    u.$$.dirty & /*label*/
    32 && f(3, p = v ?? "-"), u.$$.dirty & /*value*/
    64 && f(2, m = k ?? "-"), u.$$.dirty & /*value*/
    64 && f(0, b = k == null), u.$$.dirty & /*copyable, empty*/
    129 && f(1, y = S && !b);
  }, [b, y, m, p, $, v, k, S];
}
class DevToolsStat extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$c, create_fragment$d, safe_not_equal, { label: 5, value: 6, copyable: 7 });
  }
}
function create_if_block$6(u) {
  let l, f;
  return l = new DevToolsStat({
    props: {
      label: "Client load time",
      value: `${/*$appStore*/
      u[0].clientLoadTime} ms`
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$appStore*/
      1 && (b.value = `${/*$appStore*/
      p[0].clientLoadTime} ms`), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot$a(u) {
  var B, j, x, N, D, V, W;
  let l, f, p, m, b, y, v, k, S, $, w, T, E, R, O, P, L;
  l = new DevToolsStat({
    props: {
      label: "squares-four",
      value: (
        /*$appStore*/
        (B = u[0].application) == null ? void 0 : B.name
      )
    }
  }), p = new DevToolsStat({
    props: {
      label: "Tenant",
      value: (
        /*$appStore*/
        (j = u[0].application) == null ? void 0 : j.tenantId
      )
    }
  }), b = new DevToolsStat({
    props: {
      label: "Version",
      value: (
        /*$appStore*/
        (x = u[0].application) == null ? void 0 : x.version
      )
    }
  });
  let M = (
    /*$appStore*/
    u[0].clientLoadTime && create_if_block$6(u)
  );
  return k = new DevToolsStat({
    props: {
      label: "App screens",
      value: (
        /*$screenStore*/
        ((N = u[1].screens) == null ? void 0 : N.length) || 0
      )
    }
  }), $ = new DevToolsStat({
    props: {
      label: "Active screen",
      value: (
        /*$screenStore*/
        (D = u[1].activeScreen) == null ? void 0 : D.routing.route
      )
    }
  }), T = new DevToolsStat({
    props: {
      label: "Components",
      value: (
        /*$componentStore*/
        u[2].mountedComponentCount
      )
    }
  }), R = new DevToolsStat({
    props: {
      label: "user",
      value: (
        /*$authStore*/
        (V = u[3]) == null ? void 0 : V.email
      )
    }
  }), P = new DevToolsStat({
    props: {
      label: "Role",
      value: (
        /*$authStore*/
        (W = u[3]) == null ? void 0 : W.roleId
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment), f = space(), create_component(p.$$.fragment), m = space(), create_component(b.$$.fragment), y = space(), M && M.c(), v = space(), create_component(k.$$.fragment), S = space(), create_component($.$$.fragment), w = space(), create_component(T.$$.fragment), E = space(), create_component(R.$$.fragment), O = space(), create_component(P.$$.fragment);
    },
    m(F, U) {
      mount_component(l, F, U), insert(F, f, U), mount_component(p, F, U), insert(F, m, U), mount_component(b, F, U), insert(F, y, U), M && M.m(F, U), insert(F, v, U), mount_component(k, F, U), insert(F, S, U), mount_component($, F, U), insert(F, w, U), mount_component(T, F, U), insert(F, E, U), mount_component(R, F, U), insert(F, O, U), mount_component(P, F, U), L = !0;
    },
    p(F, U) {
      var ee, ie, de, pe, le, ae, ne;
      const Y = {};
      U & /*$appStore*/
      1 && (Y.value = /*$appStore*/
      (ee = F[0].application) == null ? void 0 : ee.name), l.$set(Y);
      const q = {};
      U & /*$appStore*/
      1 && (q.value = /*$appStore*/
      (ie = F[0].application) == null ? void 0 : ie.tenantId), p.$set(q);
      const Q = {};
      U & /*$appStore*/
      1 && (Q.value = /*$appStore*/
      (de = F[0].application) == null ? void 0 : de.version), b.$set(Q), /*$appStore*/
      F[0].clientLoadTime ? M ? (M.p(F, U), U & /*$appStore*/
      1 && transition_in(M, 1)) : (M = create_if_block$6(F), M.c(), transition_in(M, 1), M.m(v.parentNode, v)) : M && (group_outros(), transition_out(M, 1, 1, () => {
        M = null;
      }), check_outros());
      const z = {};
      U & /*$screenStore*/
      2 && (z.value = /*$screenStore*/
      ((pe = F[1].screens) == null ? void 0 : pe.length) || 0), k.$set(z);
      const H = {};
      U & /*$screenStore*/
      2 && (H.value = /*$screenStore*/
      (le = F[1].activeScreen) == null ? void 0 : le.routing.route), $.$set(H);
      const X = {};
      U & /*$componentStore*/
      4 && (X.value = /*$componentStore*/
      F[2].mountedComponentCount), T.$set(X);
      const Z = {};
      U & /*$authStore*/
      8 && (Z.value = /*$authStore*/
      (ae = F[3]) == null ? void 0 : ae.email), R.$set(Z);
      const oe = {};
      U & /*$authStore*/
      8 && (oe.value = /*$authStore*/
      (ne = F[3]) == null ? void 0 : ne.roleId), P.$set(oe);
    },
    i(F) {
      L || (transition_in(l.$$.fragment, F), transition_in(p.$$.fragment, F), transition_in(b.$$.fragment, F), transition_in(M), transition_in(k.$$.fragment, F), transition_in($.$$.fragment, F), transition_in(T.$$.fragment, F), transition_in(R.$$.fragment, F), transition_in(P.$$.fragment, F), L = !0);
    },
    o(F) {
      transition_out(l.$$.fragment, F), transition_out(p.$$.fragment, F), transition_out(b.$$.fragment, F), transition_out(M), transition_out(k.$$.fragment, F), transition_out($.$$.fragment, F), transition_out(T.$$.fragment, F), transition_out(R.$$.fragment, F), transition_out(P.$$.fragment, F), L = !1;
    },
    d(F) {
      F && (detach(f), detach(m), detach(y), detach(v), detach(S), detach(w), detach(E), detach(O)), destroy_component(l, F), destroy_component(p, F), destroy_component(b, F), M && M.d(F), destroy_component(k, F), destroy_component($, F), destroy_component(T, F), destroy_component(R, F), destroy_component(P, F);
    }
  };
}
function create_fragment$c(u) {
  let l, f;
  return l = new Layout({
    props: {
      noPadding: !0,
      gap: "XS",
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*$$scope, $authStore, $componentStore, $screenStore, $appStore*/
      31 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$b(u, l, f) {
  let p, m, b, y;
  return component_subscribe(u, appStore, (v) => f(0, p = v)), component_subscribe(u, screenStore, (v) => f(1, m = v)), component_subscribe(u, componentStore, (v) => f(2, b = v)), component_subscribe(u, authStore, (v) => f(3, y = v)), [p, m, b, y];
}
class DevToolsStatsTab extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$b, create_fragment$c, safe_not_equal, {});
  }
}
function get_each_context$3(u, l, f) {
  const p = u.slice();
  return p[7] = l[f], p;
}
function create_each_block$3(u) {
  var p;
  let l, f;
  return l = new DevToolsStat({
    props: {
      copyable: !0,
      label: (
        /*setting*/
        u[7].label
      ),
      value: JSON.stringify(
        /*showEnrichedSettings*/
        (p = u[0] ? (
          /*settings*/
          u[1]
        ) : (
          /*rawSettings*/
          u[2]
        )) == null ? void 0 : p[
          /*setting*/
          u[7].key
        ]
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(m, b) {
      mount_component(l, m, b), f = !0;
    },
    p(m, b) {
      var v;
      const y = {};
      b & /*settingsDefinition*/
      8 && (y.label = /*setting*/
      m[7].label), b & /*showEnrichedSettings, settings, rawSettings, settingsDefinition*/
      15 && (y.value = JSON.stringify(
        /*showEnrichedSettings*/
        (v = m[0] ? (
          /*settings*/
          m[1]
        ) : (
          /*rawSettings*/
          m[2]
        )) == null ? void 0 : v[
          /*setting*/
          m[7].key
        ]
      )), l.$set(y);
    },
    i(m) {
      f || (transition_in(l.$$.fragment, m), f = !0);
    },
    o(m) {
      transition_out(l.$$.fragment, m), f = !1;
    },
    d(m) {
      destroy_component(l, m);
    }
  };
}
function create_default_slot_1$6(u) {
  let l, f, p = ensure_array_like(
    /*settingsDefinition*/
    u[3]
  ), m = [];
  for (let y = 0; y < p.length; y += 1)
    m[y] = create_each_block$3(get_each_context$3(u, p, y));
  const b = (y) => transition_out(m[y], 1, 1, () => {
    m[y] = null;
  });
  return {
    c() {
      for (let y = 0; y < m.length; y += 1)
        m[y].c();
      l = empty$1();
    },
    m(y, v) {
      for (let k = 0; k < m.length; k += 1)
        m[k] && m[k].m(y, v);
      insert(y, l, v), f = !0;
    },
    p(y, v) {
      if (v & /*settingsDefinition, JSON, showEnrichedSettings, settings, rawSettings*/
      15) {
        p = ensure_array_like(
          /*settingsDefinition*/
          y[3]
        );
        let k;
        for (k = 0; k < p.length; k += 1) {
          const S = get_each_context$3(y, p, k);
          m[k] ? (m[k].p(S, v), transition_in(m[k], 1)) : (m[k] = create_each_block$3(S), m[k].c(), transition_in(m[k], 1), m[k].m(l.parentNode, l));
        }
        for (group_outros(), k = p.length; k < m.length; k += 1)
          b(k);
        check_outros();
      }
    },
    i(y) {
      if (!f) {
        for (let v = 0; v < p.length; v += 1)
          transition_in(m[v]);
        f = !0;
      }
    },
    o(y) {
      m = m.filter(Boolean);
      for (let v = 0; v < m.length; v += 1)
        transition_out(m[v]);
      f = !1;
    },
    d(y) {
      y && detach(l), destroy_each(m, y);
    }
  };
}
function create_default_slot$9(u) {
  let l, f, p, m, b;
  function y(k) {
    u[6](k);
  }
  let v = { text: "Show enriched settings" };
  return (
    /*showEnrichedSettings*/
    u[0] !== void 0 && (v.value = /*showEnrichedSettings*/
    u[0]), l = new Toggle({ props: v }), binding_callbacks.push(() => bind(l, "value", y)), m = new Layout({
      props: {
        noPadding: !0,
        gap: "XS",
        $$slots: { default: [create_default_slot_1$6] },
        $$scope: { ctx: u }
      }
    }), {
      c() {
        create_component(l.$$.fragment), p = space(), create_component(m.$$.fragment);
      },
      m(k, S) {
        mount_component(l, k, S), insert(k, p, S), mount_component(m, k, S), b = !0;
      },
      p(k, S) {
        const $ = {};
        !f && S & /*showEnrichedSettings*/
        1 && (f = !0, $.value = /*showEnrichedSettings*/
        k[0], add_flush_callback(() => f = !1)), l.$set($);
        const w = {};
        S & /*$$scope, settingsDefinition, showEnrichedSettings, settings, rawSettings*/
        1039 && (w.$$scope = { dirty: S, ctx: k }), m.$set(w);
      },
      i(k) {
        b || (transition_in(l.$$.fragment, k), transition_in(m.$$.fragment, k), b = !0);
      },
      o(k) {
        transition_out(l.$$.fragment, k), transition_out(m.$$.fragment, k), b = !1;
      },
      d(k) {
        k && detach(p), destroy_component(l, k), destroy_component(m, k);
      }
    }
  );
}
function create_fragment$b(u) {
  let l, f;
  return l = new Layout({
    props: {
      noPadding: !0,
      gap: "S",
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*$$scope, settingsDefinition, showEnrichedSettings, settings, rawSettings*/
      1039 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$a(u, l, f) {
  let p, m, b, y, v;
  component_subscribe(u, componentStore, ($) => f(5, v = $));
  let k = !0;
  function S($) {
    k = $, f(0, k);
  }
  return u.$$.update = () => {
    u.$$.dirty & /*$componentStore*/
    32 && f(4, p = v.selectedComponentInstance), u.$$.dirty & /*$componentStore*/
    32 && f(3, m = getSettingsDefinition(v.selectedComponentDefinition)), u.$$.dirty & /*selectedInstance*/
    16 && f(2, b = p == null ? void 0 : p.getRawSettings()), u.$$.dirty & /*selectedInstance*/
    16 && f(1, y = p == null ? void 0 : p.getSettings());
  }, [
    k,
    y,
    b,
    m,
    p,
    v,
    S
  ];
}
class DevToolsComponentSettingsTab extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$a, create_fragment$b, safe_not_equal, {});
  }
}
function get_each_context$2(u, l, f) {
  const p = u.slice();
  return p[9] = l[f], p;
}
function create_default_slot_3$3(u) {
  let l;
  return {
    c() {
      l = text$2("Choose a category to see the value of all its available bindings.");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_if_block_1$2(u) {
  let l, f;
  return l = new Body({
    props: {
      size: "XS",
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope*/
      4096 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block$5(u) {
  let l, f;
  return l = new Layout({
    props: {
      noPadding: !0,
      gap: "XS",
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, bindings*/
      4098 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_2$4(u) {
  let l;
  return {
    c() {
      l = text$2("There aren't any bindings available in this category.");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_each_block$2(u) {
  let l, f;
  return l = new DevToolsStat({
    props: {
      copyable: !0,
      label: (
        /*binding*/
        u[9][0]
      ),
      value: JSON.stringify(
        /*binding*/
        u[9][1]
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*bindings*/
      2 && (b.label = /*binding*/
      p[9][0]), m & /*bindings*/
      2 && (b.value = JSON.stringify(
        /*binding*/
        p[9][1]
      )), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_1$5(u) {
  let l, f, p = ensure_array_like(
    /*bindings*/
    u[1]
  ), m = [];
  for (let y = 0; y < p.length; y += 1)
    m[y] = create_each_block$2(get_each_context$2(u, p, y));
  const b = (y) => transition_out(m[y], 1, 1, () => {
    m[y] = null;
  });
  return {
    c() {
      for (let y = 0; y < m.length; y += 1)
        m[y].c();
      l = empty$1();
    },
    m(y, v) {
      for (let k = 0; k < m.length; k += 1)
        m[k] && m[k].m(y, v);
      insert(y, l, v), f = !0;
    },
    p(y, v) {
      if (v & /*bindings, JSON*/
      2) {
        p = ensure_array_like(
          /*bindings*/
          y[1]
        );
        let k;
        for (k = 0; k < p.length; k += 1) {
          const S = get_each_context$2(y, p, k);
          m[k] ? (m[k].p(S, v), transition_in(m[k], 1)) : (m[k] = create_each_block$2(S), m[k].c(), transition_in(m[k], 1), m[k].m(l.parentNode, l));
        }
        for (group_outros(), k = p.length; k < m.length; k += 1)
          b(k);
        check_outros();
      }
    },
    i(y) {
      if (!f) {
        for (let v = 0; v < p.length; v += 1)
          transition_in(m[v]);
        f = !0;
      }
    },
    o(y) {
      m = m.filter(Boolean);
      for (let v = 0; v < m.length; v += 1)
        transition_out(m[v]);
      f = !1;
    },
    d(y) {
      y && detach(l), destroy_each(m, y);
    }
  };
}
function create_default_slot$8(u) {
  let l, f, p, m, b, y, v, k, S;
  l = new Body({
    props: {
      size: "S",
      $$slots: { default: [create_default_slot_3$3] },
      $$scope: { ctx: u }
    }
  });
  function $(O) {
    u[6](O);
  }
  let w = {
    label: "Category",
    options: (
      /*bindingCategories*/
      u[2]
    )
  };
  /*category*/
  u[0] !== void 0 && (w.value = /*category*/
  u[0]), p = new Select_1({ props: w }), binding_callbacks.push(() => bind(p, "value", $));
  const T = [create_if_block$5, create_if_block_1$2], E = [];
  function R(O, P) {
    var L;
    return (
      /*bindings*/
      (L = O[1]) != null && L.length ? 0 : (
        /*category*/
        O[0] ? 1 : -1
      )
    );
  }
  return ~(y = R(u)) && (v = E[y] = T[y](u)), {
    c() {
      create_component(l.$$.fragment), f = space(), create_component(p.$$.fragment), b = space(), v && v.c(), k = empty$1();
    },
    m(O, P) {
      mount_component(l, O, P), insert(O, f, P), mount_component(p, O, P), insert(O, b, P), ~y && E[y].m(O, P), insert(O, k, P), S = !0;
    },
    p(O, P) {
      const L = {};
      P & /*$$scope*/
      4096 && (L.$$scope = { dirty: P, ctx: O }), l.$set(L);
      const M = {};
      P & /*bindingCategories*/
      4 && (M.options = /*bindingCategories*/
      O[2]), !m && P & /*category*/
      1 && (m = !0, M.value = /*category*/
      O[0], add_flush_callback(() => m = !1)), p.$set(M);
      let B = y;
      y = R(O), y === B ? ~y && E[y].p(O, P) : (v && (group_outros(), transition_out(E[B], 1, 1, () => {
        E[B] = null;
      }), check_outros()), ~y ? (v = E[y], v ? v.p(O, P) : (v = E[y] = T[y](O), v.c()), transition_in(v, 1), v.m(k.parentNode, k)) : v = null);
    },
    i(O) {
      S || (transition_in(l.$$.fragment, O), transition_in(p.$$.fragment, O), transition_in(v), S = !0);
    },
    o(O) {
      transition_out(l.$$.fragment, O), transition_out(p.$$.fragment, O), transition_out(v), S = !1;
    },
    d(O) {
      O && (detach(f), detach(b), detach(k)), destroy_component(l, O), destroy_component(p, O), ~y && E[y].d(O);
    }
  };
}
function create_fragment$a(u) {
  let l, f;
  return l = new Layout({
    props: {
      noPadding: !0,
      gap: "S",
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*$$scope, bindings, category, bindingCategories*/
      4103 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$9(u, l, f) {
  let p, m, b, y, v;
  component_subscribe(u, componentStore, (T) => f(5, v = T));
  const k = {
    user: "Current user",
    state: "State",
    url: "URL",
    device: "Device",
    rowSelection: "Selected rows"
  };
  let S;
  const $ = (T) => {
    const E = { ...T };
    delete E.key, delete E.closestComponentId, delete E.user_RefreshDataSource;
    let R = [], O = [];
    return Object.keys(E).sort().forEach((P) => {
      let L = !1;
      for (let M of R)
        if (P.startsWith(`${M}_`)) {
          L = !0;
          break;
        }
      if (!L)
        if (R.push(P), k[P])
          O.push({
            label: k[P],
            value: P
          });
        else {
          const M = componentStore.actions.getComponentById(P);
          if (M)
            O.push({
              label: M._instanceName,
              value: P
            });
          else {
            if (P.includes("-")) {
              const B = P.split("-"), j = B[0], x = componentStore.actions.getComponentById(j);
              if (x) {
                O.push({
                  label: `${x._instanceName} (${B[1]})`,
                  value: P
                });
                return;
              }
            }
            O.push({
              label: "Unknown - " + P,
              value: P
            });
          }
        }
    }), O;
  };
  function w(T) {
    S = T, f(0, S);
  }
  return u.$$.update = () => {
    u.$$.dirty & /*$componentStore*/
    32 && f(4, p = v.selectedComponentInstance), u.$$.dirty & /*selectedInstance*/
    16 && f(3, m = p == null ? void 0 : p.getDataContext()), u.$$.dirty & /*context*/
    8 && f(2, b = $(m)), u.$$.dirty & /*context, category*/
    9 && f(1, y = Object.entries((m == null ? void 0 : m[S]) || {}));
  }, [
    S,
    y,
    b,
    m,
    p,
    v,
    w
  ];
}
class DevToolsComponentContextTab extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$9, create_fragment$a, safe_not_equal, {});
  }
}
const DevToolsComponentTab_svelte_svelte_type_style_lang = "";
function create_else_block$1(u) {
  let l, f;
  return l = new Layout({
    props: {
      noPadding: !0,
      gap: "S",
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, $componentStore*/
      33 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block$4(u) {
  let l, f;
  return l = new Layout({
    props: {
      noPadding: !0,
      gap: "S",
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope*/
      32 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_12$1(u) {
  var p;
  let l = (
    /*$componentStore*/
    ((p = u[0].selectedComponent) == null ? void 0 : p._instanceName) + ""
  ), f;
  return {
    c() {
      f = text$2(l);
    },
    m(m, b) {
      insert(m, f, b);
    },
    p(m, b) {
      var y;
      b & /*$componentStore*/
      1 && l !== (l = /*$componentStore*/
      ((y = m[0].selectedComponent) == null ? void 0 : y._instanceName) + "") && set_data(f, l);
    },
    d(m) {
      m && detach(f);
    }
  };
}
function create_default_slot_11$1(u) {
  var b, y;
  let l, f, p, m;
  return l = new DevToolsStat({
    props: {
      label: "Type",
      value: (
        /*$componentStore*/
        (b = u[0].selectedComponentDefinition) == null ? void 0 : b.name
      )
    }
  }), p = new DevToolsStat({
    props: {
      copyable: !0,
      label: "Component ID",
      value: (
        /*$componentStore*/
        (y = u[0].selectedComponent) == null ? void 0 : y._id
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment), f = space(), create_component(p.$$.fragment);
    },
    m(v, k) {
      mount_component(l, v, k), insert(v, f, k), mount_component(p, v, k), m = !0;
    },
    p(v, k) {
      var w, T;
      const S = {};
      k & /*$componentStore*/
      1 && (S.value = /*$componentStore*/
      (w = v[0].selectedComponentDefinition) == null ? void 0 : w.name), l.$set(S);
      const $ = {};
      k & /*$componentStore*/
      1 && ($.value = /*$componentStore*/
      (T = v[0].selectedComponent) == null ? void 0 : T._id), p.$set($);
    },
    i(v) {
      m || (transition_in(l.$$.fragment, v), transition_in(p.$$.fragment, v), m = !0);
    },
    o(v) {
      transition_out(l.$$.fragment, v), transition_out(p.$$.fragment, v), m = !1;
    },
    d(v) {
      v && detach(f), destroy_component(l, v), destroy_component(p, v);
    }
  };
}
function create_default_slot_10$1(u) {
  let l;
  return {
    c() {
      l = text$2("Change component");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot_9$1(u) {
  let l;
  return {
    c() {
      l = text$2("Reset");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot_8$1(u) {
  let l, f, p;
  return f = new DevToolsComponentSettingsTab({}), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "tab-content svelte-1rbkjdg");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p: noop$4,
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_default_slot_7$1(u) {
  let l, f, p;
  return f = new DevToolsComponentContextTab({}), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "tab-content svelte-1rbkjdg");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p: noop$4,
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_default_slot_6$1(u) {
  let l, f, p, m;
  return l = new Tab({
    props: {
      title: "Settings",
      $$slots: { default: [create_default_slot_8$1] },
      $$scope: { ctx: u }
    }
  }), p = new Tab({
    props: {
      title: "Bindings",
      $$slots: { default: [create_default_slot_7$1] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment), f = space(), create_component(p.$$.fragment);
    },
    m(b, y) {
      mount_component(l, b, y), insert(b, f, y), mount_component(p, b, y), m = !0;
    },
    p(b, y) {
      const v = {};
      y & /*$$scope*/
      32 && (v.$$scope = { dirty: y, ctx: b }), l.$set(v);
      const k = {};
      y & /*$$scope*/
      32 && (k.$$scope = { dirty: y, ctx: b }), p.$set(k);
    },
    i(b) {
      m || (transition_in(l.$$.fragment, b), transition_in(p.$$.fragment, b), m = !0);
    },
    o(b) {
      transition_out(l.$$.fragment, b), transition_out(p.$$.fragment, b), m = !1;
    },
    d(b) {
      b && detach(f), destroy_component(l, b), destroy_component(p, b);
    }
  };
}
function create_default_slot_5$1(u) {
  let l, f;
  return l = new Tabs({
    props: {
      selected: "Settings",
      $$slots: { default: [create_default_slot_6$1] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope*/
      32 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_4$2(u) {
  let l, f, p, m, b, y, v, k, S, $, w, T;
  return l = new Heading({
    props: {
      size: "XS",
      $$slots: { default: [create_default_slot_12$1] },
      $$scope: { ctx: u }
    }
  }), p = new Layout({
    props: {
      noPadding: !0,
      gap: "XS",
      $$slots: { default: [create_default_slot_11$1] },
      $$scope: { ctx: u }
    }
  }), y = new Button({
    props: {
      cta: !0,
      $$slots: { default: [create_default_slot_10$1] },
      $$scope: { ctx: u }
    }
  }), y.$on(
    "click",
    /*click_handler_1*/
    u[3]
  ), k = new Button({
    props: {
      quiet: !0,
      secondary: !0,
      $$slots: { default: [create_default_slot_9$1] },
      $$scope: { ctx: u }
    }
  }), k.$on(
    "click",
    /*click_handler_2*/
    u[4]
  ), w = new Layout({
    props: {
      noPadding: !0,
      gap: "XS",
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment), f = space(), create_component(p.$$.fragment), m = space(), b = element("div"), create_component(y.$$.fragment), v = space(), create_component(k.$$.fragment), S = space(), $ = element("div"), create_component(w.$$.fragment), attr(b, "class", "buttons svelte-1rbkjdg"), attr($, "class", "data svelte-1rbkjdg");
    },
    m(E, R) {
      mount_component(l, E, R), insert(E, f, R), mount_component(p, E, R), insert(E, m, R), insert(E, b, R), mount_component(y, b, null), append$1(b, v), mount_component(k, b, null), insert(E, S, R), insert(E, $, R), mount_component(w, $, null), T = !0;
    },
    p(E, R) {
      const O = {};
      R & /*$$scope, $componentStore*/
      33 && (O.$$scope = { dirty: R, ctx: E }), l.$set(O);
      const P = {};
      R & /*$$scope, $componentStore*/
      33 && (P.$$scope = { dirty: R, ctx: E }), p.$set(P);
      const L = {};
      R & /*$$scope*/
      32 && (L.$$scope = { dirty: R, ctx: E }), y.$set(L);
      const M = {};
      R & /*$$scope*/
      32 && (M.$$scope = { dirty: R, ctx: E }), k.$set(M);
      const B = {};
      R & /*$$scope*/
      32 && (B.$$scope = { dirty: R, ctx: E }), w.$set(B);
    },
    i(E) {
      T || (transition_in(l.$$.fragment, E), transition_in(p.$$.fragment, E), transition_in(y.$$.fragment, E), transition_in(k.$$.fragment, E), transition_in(w.$$.fragment, E), T = !0);
    },
    o(E) {
      transition_out(l.$$.fragment, E), transition_out(p.$$.fragment, E), transition_out(y.$$.fragment, E), transition_out(k.$$.fragment, E), transition_out(w.$$.fragment, E), T = !1;
    },
    d(E) {
      E && (detach(f), detach(m), detach(b), detach(S), detach($)), destroy_component(l, E), destroy_component(p, E), destroy_component(y), destroy_component(k), destroy_component(w);
    }
  };
}
function create_default_slot_3$2(u) {
  let l;
  return {
    c() {
      l = text$2("Please choose a component");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot_2$3(u) {
  let l;
  return {
    c() {
      l = text$2(`Press the button below to enable component selection, then click a
      component in your app to view its settings and available data bindings.`);
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot_1$4(u) {
  let l;
  return {
    c() {
      l = text$2("Choose component");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot$7(u) {
  let l, f, p, m, b, y, v;
  return l = new Heading({
    props: {
      size: "XS",
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx: u }
    }
  }), p = new Body({
    props: {
      size: "S",
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx: u }
    }
  }), y = new Button({
    props: {
      cta: !0,
      $$slots: { default: [create_default_slot_1$4] },
      $$scope: { ctx: u }
    }
  }), y.$on(
    "click",
    /*click_handler*/
    u[2]
  ), {
    c() {
      create_component(l.$$.fragment), f = space(), create_component(p.$$.fragment), m = space(), b = element("div"), create_component(y.$$.fragment);
    },
    m(k, S) {
      mount_component(l, k, S), insert(k, f, S), mount_component(p, k, S), insert(k, m, S), insert(k, b, S), mount_component(y, b, null), v = !0;
    },
    p(k, S) {
      const $ = {};
      S & /*$$scope*/
      32 && ($.$$scope = { dirty: S, ctx: k }), l.$set($);
      const w = {};
      S & /*$$scope*/
      32 && (w.$$scope = { dirty: S, ctx: k }), p.$set(w);
      const T = {};
      S & /*$$scope*/
      32 && (T.$$scope = { dirty: S, ctx: k }), y.$set(T);
    },
    i(k) {
      v || (transition_in(l.$$.fragment, k), transition_in(p.$$.fragment, k), transition_in(y.$$.fragment, k), v = !0);
    },
    o(k) {
      transition_out(l.$$.fragment, k), transition_out(p.$$.fragment, k), transition_out(y.$$.fragment, k), v = !1;
    },
    d(k) {
      k && (detach(f), detach(m), detach(b)), destroy_component(l, k), destroy_component(p, k), destroy_component(y);
    }
  };
}
function create_fragment$9(u) {
  let l, f, p, m;
  const b = [create_if_block$4, create_else_block$1], y = [];
  function v(k, S) {
    return (
      /*$builderStore*/
      k[1].selectedComponentId ? 1 : 0
    );
  }
  return l = v(u), f = y[l] = b[l](u), {
    c() {
      f.c(), p = empty$1();
    },
    m(k, S) {
      y[l].m(k, S), insert(k, p, S), m = !0;
    },
    p(k, [S]) {
      let $ = l;
      l = v(k), l === $ ? y[l].p(k, S) : (group_outros(), transition_out(y[$], 1, 1, () => {
        y[$] = null;
      }), check_outros(), f = y[l], f ? f.p(k, S) : (f = y[l] = b[l](k), f.c()), transition_in(f, 1), f.m(p.parentNode, p));
    },
    i(k) {
      m || (transition_in(f), m = !0);
    },
    o(k) {
      transition_out(f), m = !1;
    },
    d(k) {
      k && detach(p), y[l].d(k);
    }
  };
}
function instance$8(u, l, f) {
  let p, m;
  component_subscribe(u, componentStore, (k) => f(0, p = k)), component_subscribe(u, builderStore, (k) => f(1, m = k));
  const b = () => devToolsStore.actions.setAllowSelection(!0), y = () => devToolsStore.actions.setAllowSelection(!0), v = () => builderStore.actions.selectComponent(null);
  return u.$$.update = () => {
    u.$$.dirty & /*$componentStore*/
    1 && (p.selectedComponentInstance || builderStore.actions.selectComponent(null));
  }, [
    p,
    m,
    b,
    y,
    v
  ];
}
class DevToolsComponentTab extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$8, create_fragment$9, safe_not_equal, {});
  }
}
const DevTools_svelte_svelte_type_style_lang = "";
function create_if_block$3(u) {
  let l, f;
  return l = new Layout({
    props: {
      noPadding: !0,
      gap: "XS",
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_4$1(u) {
  let l;
  return {
    c() {
      l = text$2("Budibase DevTools");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot_3$1(u) {
  let l, f, p;
  return f = new DevToolsStatsTab({}), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "tab-content svelte-1aby6jg");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p: noop$4,
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_default_slot_2$2(u) {
  let l, f, p;
  return f = new DevToolsComponentTab({}), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "tab-content svelte-1aby6jg");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p: noop$4,
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_default_slot_1$3(u) {
  let l, f, p, m;
  return l = new Tab({
    props: {
      title: "Application",
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx: u }
    }
  }), p = new Tab({
    props: {
      title: "Components",
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment), f = space(), create_component(p.$$.fragment);
    },
    m(b, y) {
      mount_component(l, b, y), insert(b, f, y), mount_component(p, b, y), m = !0;
    },
    p(b, y) {
      const v = {};
      y & /*$$scope*/
      16 && (v.$$scope = { dirty: y, ctx: b }), l.$set(v);
      const k = {};
      y & /*$$scope*/
      16 && (k.$$scope = { dirty: y, ctx: b }), p.$set(k);
    },
    i(b) {
      m || (transition_in(l.$$.fragment, b), transition_in(p.$$.fragment, b), m = !0);
    },
    o(b) {
      transition_out(l.$$.fragment, b), transition_out(p.$$.fragment, b), m = !1;
    },
    d(b) {
      b && detach(f), destroy_component(l, b), destroy_component(p, b);
    }
  };
}
function create_default_slot$6(u) {
  let l, f, p, m, b, y, v;
  return f = new Heading({
    props: {
      size: "XS",
      $$slots: { default: [create_default_slot_4$1] },
      $$scope: { ctx: u }
    }
  }), m = new Icon({ props: { hoverable: !0, name: "x" } }), m.$on(
    "click",
    /*click_handler*/
    u[3]
  ), y = new Tabs({
    props: {
      selected: "Application",
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), p = space(), create_component(m.$$.fragment), b = space(), create_component(y.$$.fragment), attr(l, "class", "header svelte-1aby6jg");
    },
    m(k, S) {
      insert(k, l, S), mount_component(f, l, null), append$1(l, p), mount_component(m, l, null), insert(k, b, S), mount_component(y, k, S), v = !0;
    },
    p(k, S) {
      const $ = {};
      S & /*$$scope*/
      16 && ($.$$scope = { dirty: S, ctx: k }), f.$set($);
      const w = {};
      S & /*$$scope*/
      16 && (w.$$scope = { dirty: S, ctx: k }), y.$set(w);
    },
    i(k) {
      v || (transition_in(f.$$.fragment, k), transition_in(m.$$.fragment, k), transition_in(y.$$.fragment, k), v = !0);
    },
    o(k) {
      transition_out(f.$$.fragment, k), transition_out(m.$$.fragment, k), transition_out(y.$$.fragment, k), v = !1;
    },
    d(k) {
      k && (detach(l), detach(b)), destroy_component(f), destroy_component(m), destroy_component(y, k);
    }
  };
}
function create_fragment$8(u) {
  let l, f, p = (
    /*$devToolsStore*/
    u[0].visible && create_if_block$3(u)
  );
  return {
    c() {
      l = element("div"), p && p.c(), attr(l, "class", "devtools svelte-1aby6jg"), toggle_class(l, "hidden", !/*$devToolsStore*/
      u[0].visible), toggle_class(
        l,
        "mobile",
        /*$context*/
        u[1].device.mobile
      );
    },
    m(m, b) {
      insert(m, l, b), p && p.m(l, null), f = !0;
    },
    p(m, [b]) {
      /*$devToolsStore*/
      m[0].visible ? p ? b & /*$devToolsStore*/
      1 && transition_in(p, 1) : (p = create_if_block$3(m), p.c(), transition_in(p, 1), p.m(l, null)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros()), (!f || b & /*$devToolsStore*/
      1) && toggle_class(l, "hidden", !/*$devToolsStore*/
      m[0].visible), (!f || b & /*$context*/
      2) && toggle_class(
        l,
        "mobile",
        /*$context*/
        m[1].device.mobile
      );
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d();
    }
  };
}
function instance$7(u, l, f) {
  let p, m;
  component_subscribe(u, devToolsStore, (v) => f(0, p = v));
  const b = getContext$1("context");
  return component_subscribe(u, b, (v) => f(1, m = v)), [p, m, b, () => devToolsStore.actions.setVisible(!1)];
}
class DevTools extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$7, create_fragment$8, safe_not_equal, {});
  }
}
const FreeFooter_svelte_svelte_type_style_lang = "";
function create_default_slot$5(u) {
  let l, f;
  return {
    c() {
      l = text$2("Made with "), f = element("span"), f.textContent = "Budibase", attr(f, "class", "svelte-zvk6ne");
    },
    m(p, m) {
      insert(p, l, m), insert(p, f, m);
    },
    p: noop$4,
    d(p) {
      p && (detach(l), detach(f));
    }
  };
}
function create_fragment$7(u) {
  let l, f, p;
  return f = new Link({
    props: {
      href: "https://www.budibase.com/?utm_source=budibase-apps-public-screens&utm_medium=badge&utm_campaign=made-in-budibase",
      target: "_blank",
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "free-footer svelte-zvk6ne");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, [b]) {
      const y = {};
      b & /*$$scope*/
      1 && (y.$$scope = { dirty: b, ctx: m }), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
class FreeFooter extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, null, create_fragment$7, safe_not_equal, {});
  }
}
const MaintenanceScreen_svelte_svelte_type_style_lang = "";
function get_each_context$1(u, l, f) {
  const p = u.slice();
  return p[1] = l[f], p;
}
function create_if_block$2(u) {
  let l, f;
  return l = new Layout({
    props: {
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_2$1(u) {
  let l;
  return {
    c() {
      l = text$2("Budibase installation requires maintenance");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot_1$2(u) {
  let l;
  return {
    c() {
      l = text$2(`The administrator of this Budibase installation needs to take actions
          to update components that are out of date. Please contact them and
          show them this warning. More information will be available when they
          log into their account.`);
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot$4(u) {
  let l, f, p, m, b;
  return l = new Heading({
    props: {
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx: u }
    }
  }), p = new Body({
    props: {
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment), f = space(), create_component(p.$$.fragment), m = space();
    },
    m(y, v) {
      mount_component(l, y, v), insert(y, f, v), mount_component(p, y, v), insert(y, m, v), b = !0;
    },
    p(y, v) {
      const k = {};
      v & /*$$scope*/
      16 && (k.$$scope = { dirty: v, ctx: y }), l.$set(k);
      const S = {};
      v & /*$$scope*/
      16 && (S.$$scope = { dirty: v, ctx: y }), p.$set(S);
    },
    i(y) {
      b || (transition_in(l.$$.fragment, y), transition_in(p.$$.fragment, y), b = !0);
    },
    o(y) {
      transition_out(l.$$.fragment, y), transition_out(p.$$.fragment, y), b = !1;
    },
    d(y) {
      y && (detach(f), detach(m)), destroy_component(l, y), destroy_component(p, y);
    }
  };
}
function create_each_block$1(u) {
  let l, f, p = (
    /*maintenance*/
    u[1].type === MaintenanceType.SQS_MISSING && create_if_block$2(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, b) {
      /*maintenance*/
      m[1].type === MaintenanceType.SQS_MISSING ? p ? b & /*maintenanceList*/
      1 && transition_in(p, 1) : (p = create_if_block$2(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
function create_fragment$6(u) {
  let l, f, p = ensure_array_like(
    /*maintenanceList*/
    u[0]
  ), m = [];
  for (let y = 0; y < p.length; y += 1)
    m[y] = create_each_block$1(get_each_context$1(u, p, y));
  const b = (y) => transition_out(m[y], 1, 1, () => {
    m[y] = null;
  });
  return {
    c() {
      l = element("div");
      for (let y = 0; y < m.length; y += 1)
        m[y].c();
      attr(l, "class", "content svelte-vj0fu7");
    },
    m(y, v) {
      insert(y, l, v);
      for (let k = 0; k < m.length; k += 1)
        m[k] && m[k].m(l, null);
      f = !0;
    },
    p(y, [v]) {
      if (v & /*maintenanceList*/
      1) {
        p = ensure_array_like(
          /*maintenanceList*/
          y[0]
        );
        let k;
        for (k = 0; k < p.length; k += 1) {
          const S = get_each_context$1(y, p, k);
          m[k] ? (m[k].p(S, v), transition_in(m[k], 1)) : (m[k] = create_each_block$1(S), m[k].c(), transition_in(m[k], 1), m[k].m(l, null));
        }
        for (group_outros(), k = p.length; k < m.length; k += 1)
          b(k);
        check_outros();
      }
    },
    i(y) {
      if (!f) {
        for (let v = 0; v < p.length; v += 1)
          transition_in(m[v]);
        f = !0;
      }
    },
    o(y) {
      m = m.filter(Boolean);
      for (let v = 0; v < m.length; v += 1)
        transition_out(m[v]);
      f = !1;
    },
    d(y) {
      y && detach(l), destroy_each(m, y);
    }
  };
}
function instance$6(u, l, f) {
  let { maintenanceList: p } = l;
  return u.$$set = (m) => {
    "maintenanceList" in m && f(0, p = m.maintenanceList);
  }, [p];
}
class MaintenanceScreen extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$6, create_fragment$6, safe_not_equal, { maintenanceList: 0 });
  }
}
function create_default_slot$3(u) {
  let l;
  const f = (
    /*#slots*/
    u[1].default
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[2],
    null
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, b) {
      p && p.p && (!l || b & /*$$scope*/
      4) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[2],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[2],
          b,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[2]
        ),
        null
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function create_fragment$5(u) {
  let l, f;
  return l = new Provider({
    props: {
      key: "snippets",
      data: (
        /*$snippets*/
        u[0]
      ),
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*$snippets*/
      1 && (b.data = /*$snippets*/
      p[0]), m & /*$$scope*/
      4 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function instance$5(u, l, f) {
  let p;
  component_subscribe(u, snippets, (y) => f(0, p = y));
  let { $$slots: m = {}, $$scope: b } = l;
  return u.$$set = (y) => {
    "$$scope" in y && f(2, b = y.$$scope);
  }, [p, m, b];
}
class SnippetsProvider extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$5, create_fragment$5, safe_not_equal, {});
  }
}
function create_default_slot$2(u) {
  let l;
  const f = (
    /*#slots*/
    u[1].default
  ), p = create_slot(
    f,
    u,
    /*$$scope*/
    u[2],
    null
  );
  return {
    c() {
      p && p.c();
    },
    m(m, b) {
      p && p.m(m, b), l = !0;
    },
    p(m, b) {
      p && p.p && (!l || b & /*$$scope*/
      4) && update_slot_base(
        p,
        f,
        m,
        /*$$scope*/
        m[2],
        l ? get_slot_changes(
          f,
          /*$$scope*/
          m[2],
          b,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          m[2]
        ),
        null
      );
    },
    i(m) {
      l || (transition_in(p, m), l = !0);
    },
    o(m) {
      transition_out(p, m), l = !1;
    },
    d(m) {
      p && p.d(m);
    }
  };
}
function create_fragment$4(u) {
  let l, f;
  return l = new Provider({
    props: {
      key: "embed",
      data: (
        /*data*/
        u[0]
      ),
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, [m]) {
      const b = {};
      m & /*data*/
      1 && (b.data = /*data*/
      p[0]), m & /*$$scope*/
      4 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function extractDomainFromUrl(u) {
  const { hostname: l } = new URL(u);
  return l.split(".").slice(-2).join(".");
}
function instance$4(u, l, f) {
  let { $$slots: p = {}, $$scope: m } = l, b = {};
  function y(v) {
    var $;
    if ((($ = v.data) == null ? void 0 : $.type) !== "bb-parent-window-event")
      return;
    const k = extractDomainFromUrl(window.location.origin), S = extractDomainFromUrl(v.origin);
    k === S ? f(0, b = v.data) : console.error(`Embedded budibase app domain ${k} does not match origin of event ${S}.
        Top level domains must match`);
  }
  return onMount(() => (window.addEventListener("message", y), () => window.removeEventListener("message", y))), u.$$set = (v) => {
    "$$scope" in v && f(2, m = v.$$scope);
  }, [b, p, m];
}
class EmbedProvider extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$4, create_fragment$4, safe_not_equal, {});
  }
}
function create_if_block$1(u) {
  let l, f, p, m = !/*$isGridScreen*/
  u[0] && /*$dndParent*/
  u[3] && create_if_block_2$1(u), b = !/*waitingForGrid*/
  u[1] && create_if_block_1$1(u);
  return {
    c() {
      m && m.c(), l = space(), b && b.c(), f = empty$1();
    },
    m(y, v) {
      m && m.m(y, v), insert(y, l, v), b && b.m(y, v), insert(y, f, v), p = !0;
    },
    p(y, v) {
      !/*$isGridScreen*/
      y[0] && /*$dndParent*/
      y[3] ? m ? (m.p(y, v), v & /*$isGridScreen, $dndParent*/
      9 && transition_in(m, 1)) : (m = create_if_block_2$1(y), m.c(), transition_in(m, 1), m.m(l.parentNode, l)) : m && (group_outros(), transition_out(m, 1, 1, () => {
        m = null;
      }), check_outros()), /*waitingForGrid*/
      y[1] ? b && (group_outros(), transition_out(b, 1, 1, () => {
        b = null;
      }), check_outros()) : b ? (b.p(y, v), v & /*waitingForGrid*/
      2 && transition_in(b, 1)) : (b = create_if_block_1$1(y), b.c(), transition_in(b, 1), b.m(f.parentNode, f));
    },
    i(y) {
      p || (transition_in(m), transition_in(b), p = !0);
    },
    o(y) {
      transition_out(m), transition_out(b), p = !1;
    },
    d(y) {
      y && (detach(l), detach(f)), m && m.d(y), b && b.d(y);
    }
  };
}
function create_if_block_2$1(u) {
  let l, f;
  return l = new IndicatorSet({
    props: {
      componentId: (
        /*$dndParent*/
        u[3]
      ),
      color: "var(--spectrum-global-color-static-green-400)",
      zIndex: 920,
      prefix: "Inside"
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$dndParent*/
      8 && (b.componentId = /*$dndParent*/
      p[3]), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_1$1(u) {
  var p, m;
  let l, f;
  return l = new IndicatorSet({
    props: {
      componentId: DNDPlaceholderID,
      color: "var(--spectrum-global-color-static-green-500)",
      zIndex: 930,
      allowResizeAnchors: !1,
      background: "hsl(160, 64%, 90%)",
      animate: !/*$isGridScreen*/
      u[0],
      text: (
        /*$dndSource*/
        (p = u[4]) == null ? void 0 : p.name
      ),
      icon: (
        /*$dndSource*/
        (m = u[4]) == null ? void 0 : m.icon
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(b, y) {
      mount_component(l, b, y), f = !0;
    },
    p(b, y) {
      var k, S;
      const v = {};
      y & /*$isGridScreen*/
      1 && (v.animate = !/*$isGridScreen*/
      b[0]), y & /*$dndSource*/
      16 && (v.text = /*$dndSource*/
      (k = b[4]) == null ? void 0 : k.name), y & /*$dndSource*/
      16 && (v.icon = /*$dndSource*/
      (S = b[4]) == null ? void 0 : S.icon), l.$set(v);
    },
    i(b) {
      f || (transition_in(l.$$.fragment, b), f = !0);
    },
    o(b) {
      transition_out(l.$$.fragment, b), f = !1;
    },
    d(b) {
      destroy_component(l, b);
    }
  };
}
function create_fragment$3(u) {
  let l, f, p = (
    /*$dndIsDragging*/
    u[2] && create_if_block$1(u)
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, [b]) {
      /*$dndIsDragging*/
      m[2] ? p ? (p.p(m, b), b & /*$dndIsDragging*/
      4 && transition_in(p, 1)) : (p = create_if_block$1(m), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
function instance$3(u, l, f) {
  let p, m, b, y, v, k;
  return component_subscribe(u, dndStore, (S) => f(5, m = S)), component_subscribe(u, isGridScreen, (S) => f(0, b = S)), component_subscribe(u, dndIsDragging, (S) => f(2, y = S)), component_subscribe(u, dndParent, (S) => f(3, v = S)), component_subscribe(u, dndSource, (S) => f(4, k = S)), u.$$.update = () => {
    var S;
    u.$$.dirty & /*$isGridScreen, $dndStore*/
    33 && f(1, p = b && !((S = m.meta) != null && S.props));
  }, [
    b,
    p,
    y,
    v,
    k,
    m
  ];
}
class DNDSelectionIndicators extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$3, create_fragment$3, safe_not_equal, {});
  }
}
const RecaptchaV2_svelte_svelte_type_style_lang = "";
function create_default_slot_1$1(u) {
  let l;
  return {
    c() {
      l = text$2("Human verification step required to continue.");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot$1(u) {
  let l;
  return {
    c() {
      l = text$2("Submit");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_fragment$2(u) {
  let l, f, p, m, b, y, v, k;
  return f = new Body({
    props: {
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx: u }
    }
  }), v = new Button({
    props: {
      cta: !0,
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx: u }
    }
  }), v.$on(
    "click",
    /*handleSubmit*/
    u[0]
  ), {
    c() {
      l = element("div"), create_component(f.$$.fragment), p = space(), m = element("div"), b = space(), y = element("div"), create_component(v.$$.fragment), attr(m, "id", "recaptcha-container"), attr(l, "class", "wrapper svelte-hjse25");
    },
    m(S, $) {
      insert(S, l, $), mount_component(f, l, null), append$1(l, p), append$1(l, m), append$1(l, b), append$1(l, y), mount_component(v, y, null), k = !0;
    },
    p(S, [$]) {
      const w = {};
      $ & /*$$scope*/
      16 && (w.$$scope = { dirty: $, ctx: S }), f.$set(w);
      const T = {};
      $ & /*$$scope*/
      16 && (T.$$scope = { dirty: $, ctx: S }), v.$set(T);
    },
    i(S) {
      k || (transition_in(f.$$.fragment, S), transition_in(v.$$.fragment, S), k = !0);
    },
    o(S) {
      transition_out(f.$$.fragment, S), transition_out(v.$$.fragment, S), k = !1;
    },
    d(S) {
      S && detach(l), destroy_component(f), destroy_component(v);
    }
  };
}
function instance$2(u, l, f) {
  let p, m;
  component_subscribe(u, appStore, (v) => f(1, m = v));
  let b = "";
  onMount(() => {
    window.grecaptcha.render("recaptcha-container", {
      sitekey: p,
      callback: (k) => {
        b = k;
      }
    });
  });
  async function y(v) {
    if (v.preventDefault(), !b)
      throw new Error("No token provided");
    const { verified: k } = await API.recaptcha.verify(b);
    k ? location.reload() : notifications.error("Recaptcha verification failed, please try again");
  }
  return u.$$.update = () => {
    u.$$.dirty & /*$appStore*/
    2 && (p = m.recaptchaKey);
  }, [y, m];
}
class RecaptchaV2 extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$2, create_fragment$2, safe_not_equal, {});
  }
}
const ClientApp_svelte_svelte_type_style_lang = "", { document: document_1 } = globals$1;
function get_each_context(u, l, f) {
  const p = u.slice();
  return p[19] = l[f], p;
}
function create_if_block_13(u) {
  let l = [], f = /* @__PURE__ */ new Map(), p, m = ensure_array_like(
    /*$builderStore*/
    u[7].usedPlugins
  );
  const b = (y) => (
    /*plugin*/
    y[19].hash
  );
  for (let y = 0; y < m.length; y += 1) {
    let v = get_each_context(u, m, y), k = b(v);
    f.set(k, l[y] = create_each_block(k, v));
  }
  return {
    c() {
      for (let y = 0; y < l.length; y += 1)
        l[y].c();
      p = empty$1();
    },
    m(y, v) {
      for (let k = 0; k < l.length; k += 1)
        l[k] && l[k].m(y, v);
      insert(y, p, v);
    },
    p(y, v) {
      v & /*$builderStore*/
      128 && (m = ensure_array_like(
        /*$builderStore*/
        y[7].usedPlugins
      ), l = update_keyed_each(l, v, b, 1, y, m, f, p.parentNode, destroy_block, create_each_block, p, get_each_context));
    },
    d(y) {
      y && detach(p);
      for (let v = 0; v < l.length; v += 1)
        l[v].d(y);
    }
  };
}
function create_each_block(u, l) {
  let f, p;
  return {
    key: u,
    first: null,
    c() {
      f = element("script"), src_url_equal(f.src, p = `${/*plugin*/
      l[19].jsUrl}`) || attr(f, "src", p), this.first = f;
    },
    m(m, b) {
      insert(m, f, b);
    },
    p(m, b) {
      l = m, b & /*$builderStore*/
      128 && !src_url_equal(f.src, p = `${/*plugin*/
      l[19].jsUrl}`) && attr(f, "src", p);
    },
    d(m) {
      m && detach(f);
    }
  };
}
function create_if_block(u) {
  let l, f, p, m, b, y, v;
  const k = [create_if_block_1, create_if_block_2, create_else_block], S = [];
  function $(w, T) {
    return (
      /*$environmentStore*/
      w[9].maintenance.length > 0 ? 0 : (
        /*$featuresStore*/
        w[10].recaptchaEnabled && /*$appStore*/
        w[3].recaptchaKey && !/*$recaptchaStore*/
        w[11].verified && !/*$builderStore*/
        w[7].inBuilder ? 1 : 2
      )
    );
  }
  return f = $(u), p = S[f] = k[f](u), y = new KeyboardManager({}), {
    c() {
      l = element("div"), p.c(), b = space(), create_component(y.$$.fragment), attr(l, "id", "spectrum-root"), attr(l, "lang", "en"), attr(l, "dir", "ltr"), attr(l, "class", m = "spectrum spectrum--medium " + getThemeClassNames(
        /*$themeStore*/
        u[8].theme
      ) + " svelte-usa5gl"), toggle_class(
        l,
        "builder",
        /*$builderStore*/
        u[7].inBuilder
      ), toggle_class(
        l,
        "show",
        /*fontsLoaded*/
        u[1] && /*dataLoaded*/
        u[0]
      );
    },
    m(w, T) {
      insert(w, l, T), S[f].m(l, null), insert(w, b, T), mount_component(y, w, T), v = !0;
    },
    p(w, T) {
      let E = f;
      f = $(w), f === E ? S[f].p(w, T) : (group_outros(), transition_out(S[E], 1, 1, () => {
        S[E] = null;
      }), check_outros(), p = S[f], p ? p.p(w, T) : (p = S[f] = k[f](w), p.c()), transition_in(p, 1), p.m(l, null)), (!v || T & /*$themeStore*/
      256 && m !== (m = "spectrum spectrum--medium " + getThemeClassNames(
        /*$themeStore*/
        w[8].theme
      ) + " svelte-usa5gl")) && attr(l, "class", m), (!v || T & /*$themeStore, $builderStore*/
      384) && toggle_class(
        l,
        "builder",
        /*$builderStore*/
        w[7].inBuilder
      ), (!v || T & /*$themeStore, fontsLoaded, dataLoaded*/
      259) && toggle_class(
        l,
        "show",
        /*fontsLoaded*/
        w[1] && /*dataLoaded*/
        w[0]
      );
    },
    i(w) {
      v || (transition_in(p), transition_in(y.$$.fragment, w), v = !0);
    },
    o(w) {
      transition_out(p), transition_out(y.$$.fragment, w), v = !1;
    },
    d(w) {
      w && (detach(l), detach(b)), S[f].d(), destroy_component(y, w);
    }
  };
}
function create_else_block(u) {
  let l, f;
  return l = new EmbedProvider({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, $builderStore, $devToolsStore, $appStore, $featuresStore, showDevTools, permissionError, $screenStore, embedNoScreens*/
      4199676 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_2(u) {
  let l, f;
  return l = new RecaptchaV2({}), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p: noop$4,
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_1(u) {
  let l, f;
  return l = new MaintenanceScreen({
    props: {
      maintenanceList: (
        /*$environmentStore*/
        u[9].maintenance
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$environmentStore*/
      512 && (b.maintenanceList = /*$environmentStore*/
      p[9].maintenance), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_12(u) {
  let l, f;
  return l = new SettingsBar({}), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_key_block_1(u) {
  let l, f, p = (
    /*$builderStore*/
    u[7].inBuilder && create_if_block_12()
  );
  return {
    c() {
      p && p.c(), l = empty$1();
    },
    m(m, b) {
      p && p.m(m, b), insert(m, l, b), f = !0;
    },
    p(m, b) {
      /*$builderStore*/
      m[7].inBuilder ? p ? b & /*$builderStore*/
      128 && transition_in(p, 1) : (p = create_if_block_12(), p.c(), transition_in(p, 1), p.m(l.parentNode, l)) : p && (group_outros(), transition_out(p, 1, 1, () => {
        p = null;
      }), check_outros());
    },
    i(m) {
      f || (transition_in(p), f = !0);
    },
    o(m) {
      transition_out(p), f = !1;
    },
    d(m) {
      m && detach(l), p && p.d(m);
    }
  };
}
function create_if_block_11(u) {
  let l, f;
  return l = new DevToolsHeader({}), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_else_block_1(u) {
  let l, f;
  return l = new CustomThemeWrapper({
    props: {
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, $screenStore*/
      4194308 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_10(u) {
  let l, f, p;
  return f = new Layout({
    props: {
      justifyItems: "center",
      gap: "S",
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "error svelte-usa5gl");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b & /*$$scope*/
      4194304 && (y.$$scope = { dirty: b, ctx: m }), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block_9(u) {
  let l, f, p;
  return f = new Layout({
    props: {
      justifyItems: "center",
      gap: "S",
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "error svelte-usa5gl");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b & /*$$scope*/
      4194304 && (y.$$scope = { dirty: b, ctx: m }), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_if_block_8(u) {
  let l, f, p;
  return f = new Layout({
    props: {
      justifyItems: "center",
      gap: "S",
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "class", "error svelte-usa5gl");
    },
    m(m, b) {
      insert(m, l, b), mount_component(f, l, null), p = !0;
    },
    p(m, b) {
      const y = {};
      b & /*$$scope*/
      4194304 && (y.$$scope = { dirty: b, ctx: m }), f.$set(y);
    },
    i(m) {
      p || (transition_in(f.$$.fragment, m), p = !0);
    },
    o(m) {
      transition_out(f.$$.fragment, m), p = !1;
    },
    d(m) {
      m && detach(l), destroy_component(f);
    }
  };
}
function create_key_block(u) {
  let l, f;
  return l = new Component({
    props: {
      isLayout: !0,
      instance: (
        /*$screenStore*/
        u[2].activeLayout.props
      )
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$screenStore*/
      4 && (b.instance = /*$screenStore*/
      p[2].activeLayout.props), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_16(u) {
  let l = (
    /*$screenStore*/
    u[2].activeLayout._id
  ), f, p, m, b, y, v, k, S, $, w = create_key_block(u);
  return p = new NotificationDisplay({}), b = new ConfirmationDisplay({}), v = new PeekScreenDisplay({}), S = new InstallPrompt({}), {
    c() {
      w.c(), f = space(), create_component(p.$$.fragment), m = space(), create_component(b.$$.fragment), y = space(), create_component(v.$$.fragment), k = space(), create_component(S.$$.fragment);
    },
    m(T, E) {
      w.m(T, E), insert(T, f, E), mount_component(p, T, E), insert(T, m, E), mount_component(b, T, E), insert(T, y, E), mount_component(v, T, E), insert(T, k, E), mount_component(S, T, E), $ = !0;
    },
    p(T, E) {
      E & /*$screenStore*/
      4 && safe_not_equal(l, l = /*$screenStore*/
      T[2].activeLayout._id) ? (group_outros(), transition_out(w, 1, 1, noop$4), check_outros(), w = create_key_block(T), w.c(), transition_in(w, 1), w.m(f.parentNode, f)) : w.p(T, E);
    },
    i(T) {
      $ || (transition_in(w), transition_in(p.$$.fragment, T), transition_in(b.$$.fragment, T), transition_in(v.$$.fragment, T), transition_in(S.$$.fragment, T), $ = !0);
    },
    o(T) {
      transition_out(w), transition_out(p.$$.fragment, T), transition_out(b.$$.fragment, T), transition_out(v.$$.fragment, T), transition_out(S.$$.fragment, T), $ = !1;
    },
    d(T) {
      T && (detach(f), detach(m), detach(y), detach(k)), w.d(T), destroy_component(p, T), destroy_component(b, T), destroy_component(v, T), destroy_component(S, T);
    }
  };
}
function create_default_slot_15(u) {
  let l;
  return {
    c() {
      l = text$2("This Budibase app is not publicly accessible");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot_14(u) {
  let l, f, p, m;
  return p = new Heading({
    props: {
      size: "L",
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      l = new HtmlTag(!1), f = space(), create_component(p.$$.fragment), l.a = f;
    },
    m(b, y) {
      l.m(ErrorSVG, b, y), insert(b, f, y), mount_component(p, b, y), m = !0;
    },
    p(b, y) {
      const v = {};
      y & /*$$scope*/
      4194304 && (v.$$scope = { dirty: y, ctx: b }), p.$set(v);
    },
    i(b) {
      m || (transition_in(p.$$.fragment, b), m = !0);
    },
    o(b) {
      transition_out(p.$$.fragment, b), m = !1;
    },
    d(b) {
      b && (l.d(), detach(f)), destroy_component(p, b);
    }
  };
}
function create_default_slot_13(u) {
  let l;
  return {
    c() {
      l = text$2("Something went wrong rendering your app");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot_12(u) {
  let l;
  return {
    c() {
      l = text$2(`Get in touch with support if this issue
                                    persists`);
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot_11(u) {
  let l, f, p, m, b, y;
  return p = new Heading({
    props: {
      size: "L",
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx: u }
    }
  }), b = new Body({
    props: {
      size: "S",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      l = new HtmlTag(!1), f = space(), create_component(p.$$.fragment), m = space(), create_component(b.$$.fragment), l.a = f;
    },
    m(v, k) {
      l.m(ErrorSVG, v, k), insert(v, f, k), mount_component(p, v, k), insert(v, m, k), mount_component(b, v, k), y = !0;
    },
    p(v, k) {
      const S = {};
      k & /*$$scope*/
      4194304 && (S.$$scope = { dirty: k, ctx: v }), p.$set(S);
      const $ = {};
      k & /*$$scope*/
      4194304 && ($.$$scope = { dirty: k, ctx: v }), b.$set($);
    },
    i(v) {
      y || (transition_in(p.$$.fragment, v), transition_in(b.$$.fragment, v), y = !0);
    },
    o(v) {
      transition_out(p.$$.fragment, v), transition_out(b.$$.fragment, v), y = !1;
    },
    d(v) {
      v && (l.d(), detach(f), detach(m)), destroy_component(p, v), destroy_component(b, v);
    }
  };
}
function create_default_slot_10(u) {
  let l;
  return {
    c() {
      l = text$2("You don't have permission to use this app");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot_9(u) {
  let l;
  return {
    c() {
      l = text$2("Ask your administrator to grant you access");
    },
    m(f, p) {
      insert(f, l, p);
    },
    d(f) {
      f && detach(l);
    }
  };
}
function create_default_slot_8(u) {
  let l, f, p, m, b, y;
  return p = new Heading({
    props: {
      size: "L",
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx: u }
    }
  }), b = new Body({
    props: {
      size: "S",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      l = new HtmlTag(!1), f = space(), create_component(p.$$.fragment), m = space(), create_component(b.$$.fragment), l.a = f;
    },
    m(v, k) {
      l.m(ErrorSVG, v, k), insert(v, f, k), mount_component(p, v, k), insert(v, m, k), mount_component(b, v, k), y = !0;
    },
    p(v, k) {
      const S = {};
      k & /*$$scope*/
      4194304 && (S.$$scope = { dirty: k, ctx: v }), p.$set(S);
      const $ = {};
      k & /*$$scope*/
      4194304 && ($.$$scope = { dirty: k, ctx: v }), b.$set($);
    },
    i(v) {
      y || (transition_in(p.$$.fragment, v), transition_in(b.$$.fragment, v), y = !0);
    },
    o(v) {
      transition_out(p.$$.fragment, v), transition_out(b.$$.fragment, v), y = !1;
    },
    d(v) {
      v && (l.d(), detach(f), detach(m)), destroy_component(p, v), destroy_component(b, v);
    }
  };
}
function create_if_block_7(u) {
  let l, f;
  return l = new DevTools({}), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_6(u) {
  let l, f;
  return l = new FreeFooter({}), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_5(u) {
  let l, f;
  return l = new SelectionIndicator({}), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_4(u) {
  let l, f;
  return l = new HoverIndicator({}), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_if_block_3(u) {
  let l, f, p, m, b, y;
  return l = new DNDHandler({}), p = new GridDNDHandler({}), b = new DNDSelectionIndicators({}), {
    c() {
      create_component(l.$$.fragment), f = space(), create_component(p.$$.fragment), m = space(), create_component(b.$$.fragment);
    },
    m(v, k) {
      mount_component(l, v, k), insert(v, f, k), mount_component(p, v, k), insert(v, m, k), mount_component(b, v, k), y = !0;
    },
    i(v) {
      y || (transition_in(l.$$.fragment, v), transition_in(p.$$.fragment, v), transition_in(b.$$.fragment, v), y = !0);
    },
    o(v) {
      transition_out(l.$$.fragment, v), transition_out(p.$$.fragment, v), transition_out(b.$$.fragment, v), y = !1;
    },
    d(v) {
      v && (detach(f), detach(m)), destroy_component(l, v), destroy_component(p, v), destroy_component(b, v);
    }
  };
}
function create_default_slot_7(u) {
  let l = (
    /*$builderStore*/
    u[7].selectedComponentId
  ), f, p, m, b, y, v, k, S, $, w, T, E, R, O = create_key_block_1(u), P = (
    /*showDevTools*/
    u[6] && create_if_block_11()
  );
  const L = [create_if_block_8, create_if_block_9, create_if_block_10, create_else_block_1], M = [];
  function B(W, F) {
    return (
      /*permissionError*/
      W[4] ? 0 : (
        /*$screenStore*/
        W[2].activeLayout ? (
          /*embedNoScreens*/
          W[5] ? 2 : 3
        ) : 1
      )
    );
  }
  v = B(u), k = M[v] = L[v](u);
  let j = (
    /*showDevTools*/
    u[6] && create_if_block_7()
  ), x = !/*$builderStore*/
  u[7].inBuilder && /*$featuresStore*/
  u[10].logoEnabled && create_if_block_6(), N = (
    /*$appStore*/
    u[3].isDevApp && create_if_block_5()
  ), D = (
    /*$builderStore*/
    (u[7].inBuilder || /*$devToolsStore*/
    u[12].allowSelection) && create_if_block_4()
  ), V = (
    /*$builderStore*/
    u[7].inBuilder && create_if_block_3()
  );
  return {
    c() {
      O.c(), f = space(), p = element("div"), m = element("div"), P && P.c(), b = space(), y = element("div"), k.c(), S = space(), j && j.c(), $ = space(), x && x.c(), w = space(), N && N.c(), T = space(), D && D.c(), E = space(), V && V.c(), attr(y, "id", "app-body"), attr(y, "class", "svelte-usa5gl"), attr(m, "id", "app-root"), attr(m, "class", "svelte-usa5gl"), attr(p, "id", "clip-root"), attr(p, "class", "svelte-usa5gl"), toggle_class(
        p,
        "preview",
        /*$builderStore*/
        u[7].inBuilder
      ), toggle_class(
        p,
        "tablet-preview",
        /*$builderStore*/
        u[7].previewDevice === "tablet"
      ), toggle_class(
        p,
        "mobile-preview",
        /*$builderStore*/
        u[7].previewDevice === "mobile"
      );
    },
    m(W, F) {
      O.m(W, F), insert(W, f, F), insert(W, p, F), append$1(p, m), P && P.m(m, null), append$1(m, b), append$1(m, y), M[v].m(y, null), append$1(y, S), j && j.m(y, null), append$1(m, $), x && x.m(m, null), append$1(p, w), N && N.m(p, null), append$1(p, T), D && D.m(p, null), append$1(p, E), V && V.m(p, null), R = !0;
    },
    p(W, F) {
      F & /*$builderStore*/
      128 && safe_not_equal(l, l = /*$builderStore*/
      W[7].selectedComponentId) ? (group_outros(), transition_out(O, 1, 1, noop$4), check_outros(), O = create_key_block_1(W), O.c(), transition_in(O, 1), O.m(f.parentNode, f)) : O.p(W, F), /*showDevTools*/
      W[6] ? P ? F & /*showDevTools*/
      64 && transition_in(P, 1) : (P = create_if_block_11(), P.c(), transition_in(P, 1), P.m(m, b)) : P && (group_outros(), transition_out(P, 1, 1, () => {
        P = null;
      }), check_outros());
      let U = v;
      v = B(W), v === U ? M[v].p(W, F) : (group_outros(), transition_out(M[U], 1, 1, () => {
        M[U] = null;
      }), check_outros(), k = M[v], k ? k.p(W, F) : (k = M[v] = L[v](W), k.c()), transition_in(k, 1), k.m(y, S)), /*showDevTools*/
      W[6] ? j ? F & /*showDevTools*/
      64 && transition_in(j, 1) : (j = create_if_block_7(), j.c(), transition_in(j, 1), j.m(y, null)) : j && (group_outros(), transition_out(j, 1, 1, () => {
        j = null;
      }), check_outros()), !/*$builderStore*/
      W[7].inBuilder && /*$featuresStore*/
      W[10].logoEnabled ? x ? F & /*$builderStore, $featuresStore*/
      1152 && transition_in(x, 1) : (x = create_if_block_6(), x.c(), transition_in(x, 1), x.m(m, null)) : x && (group_outros(), transition_out(x, 1, 1, () => {
        x = null;
      }), check_outros()), /*$appStore*/
      W[3].isDevApp ? N ? F & /*$appStore*/
      8 && transition_in(N, 1) : (N = create_if_block_5(), N.c(), transition_in(N, 1), N.m(p, T)) : N && (group_outros(), transition_out(N, 1, 1, () => {
        N = null;
      }), check_outros()), /*$builderStore*/
      W[7].inBuilder || /*$devToolsStore*/
      W[12].allowSelection ? D ? F & /*$builderStore, $devToolsStore*/
      4224 && transition_in(D, 1) : (D = create_if_block_4(), D.c(), transition_in(D, 1), D.m(p, E)) : D && (group_outros(), transition_out(D, 1, 1, () => {
        D = null;
      }), check_outros()), /*$builderStore*/
      W[7].inBuilder ? V ? F & /*$builderStore*/
      128 && transition_in(V, 1) : (V = create_if_block_3(), V.c(), transition_in(V, 1), V.m(p, null)) : V && (group_outros(), transition_out(V, 1, 1, () => {
        V = null;
      }), check_outros()), (!R || F & /*$builderStore*/
      128) && toggle_class(
        p,
        "preview",
        /*$builderStore*/
        W[7].inBuilder
      ), (!R || F & /*$builderStore*/
      128) && toggle_class(
        p,
        "tablet-preview",
        /*$builderStore*/
        W[7].previewDevice === "tablet"
      ), (!R || F & /*$builderStore*/
      128) && toggle_class(
        p,
        "mobile-preview",
        /*$builderStore*/
        W[7].previewDevice === "mobile"
      );
    },
    i(W) {
      R || (transition_in(O), transition_in(P), transition_in(k), transition_in(j), transition_in(x), transition_in(N), transition_in(D), transition_in(V), R = !0);
    },
    o(W) {
      transition_out(O), transition_out(P), transition_out(k), transition_out(j), transition_out(x), transition_out(N), transition_out(D), transition_out(V), R = !1;
    },
    d(W) {
      W && (detach(f), detach(p)), O.d(W), P && P.d(), M[v].d(), j && j.d(), x && x.d(), N && N.d(), D && D.d(), V && V.d();
    }
  };
}
function create_default_slot_6(u) {
  let l, f;
  return l = new SnippetsProvider({
    props: {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, $builderStore, $devToolsStore, $appStore, $featuresStore, showDevTools, permissionError, $screenStore, embedNoScreens*/
      4199676 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_5(u) {
  let l, f;
  return l = new TestUrlBindingsProvider({
    props: {
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, $builderStore, $devToolsStore, $appStore, $featuresStore, showDevTools, permissionError, $screenStore, embedNoScreens*/
      4199676 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_4(u) {
  let l, f;
  return l = new QueryParamsProvider({
    props: {
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, $builderStore, $devToolsStore, $appStore, $featuresStore, showDevTools, permissionError, $screenStore, embedNoScreens*/
      4199676 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_3(u) {
  let l, f;
  return l = new RowSelectionProvider({
    props: {
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, $builderStore, $devToolsStore, $appStore, $featuresStore, showDevTools, permissionError, $screenStore, embedNoScreens*/
      4199676 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_2(u) {
  let l, f;
  return l = new StateBindingsProvider({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, $builderStore, $devToolsStore, $appStore, $featuresStore, showDevTools, permissionError, $screenStore, embedNoScreens*/
      4199676 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot_1(u) {
  let l, f;
  return l = new UserBindingsProvider({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, $builderStore, $devToolsStore, $appStore, $featuresStore, showDevTools, permissionError, $screenStore, embedNoScreens*/
      4199676 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_default_slot(u) {
  let l, f;
  return l = new DeviceBindingsProvider({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx: u }
    }
  }), {
    c() {
      create_component(l.$$.fragment);
    },
    m(p, m) {
      mount_component(l, p, m), f = !0;
    },
    p(p, m) {
      const b = {};
      m & /*$$scope, $builderStore, $devToolsStore, $appStore, $featuresStore, showDevTools, permissionError, $screenStore, embedNoScreens*/
      4199676 && (b.$$scope = { dirty: m, ctx: p }), l.$set(b);
    },
    i(p) {
      f || (transition_in(l.$$.fragment, p), f = !0);
    },
    o(p) {
      transition_out(l.$$.fragment, p), f = !1;
    },
    d(p) {
      destroy_component(l, p);
    }
  };
}
function create_fragment$1(u) {
  var v;
  let l, f, p, m, b = (
    /*$builderStore*/
    ((v = u[7].usedPlugins) == null ? void 0 : v.length) && create_if_block_13(u)
  ), y = (
    /*dataLoaded*/
    u[0] && create_if_block(u)
  );
  return {
    c() {
      b && b.c(), l = empty$1(), f = space(), y && y.c(), p = empty$1();
    },
    m(k, S) {
      b && b.m(document_1.head, null), append$1(document_1.head, l), insert(k, f, S), y && y.m(k, S), insert(k, p, S), m = !0;
    },
    p(k, [S]) {
      var $;
      /*$builderStore*/
      ($ = k[7].usedPlugins) != null && $.length ? b ? b.p(k, S) : (b = create_if_block_13(k), b.c(), b.m(l.parentNode, l)) : b && (b.d(1), b = null), /*dataLoaded*/
      k[0] ? y ? (y.p(k, S), S & /*dataLoaded*/
      1 && transition_in(y, 1)) : (y = create_if_block(k), y.c(), transition_in(y, 1), y.m(p.parentNode, p)) : y && (group_outros(), transition_out(y, 1, 1, () => {
        y = null;
      }), check_outros());
    },
    i(k) {
      m || (transition_in(y), m = !0);
    },
    o(k) {
      transition_out(y), m = !1;
    },
    d(k) {
      k && (detach(f), detach(p)), b && b.d(k), detach(l), y && y.d(k);
    }
  };
}
function instance$1(u, l, f) {
  let p, m, b, y, v, k, S, $, w, T, E, R, O, P;
  component_subscribe(u, screenStore, (N) => f(2, m = N)), component_subscribe(u, modalStore, (N) => f(16, b = N)), component_subscribe(u, sidePanelStore, (N) => f(17, y = N)), component_subscribe(u, appStore, (N) => f(3, v = N)), component_subscribe(u, authStore, (N) => f(13, k = N)), component_subscribe(u, routeStore, (N) => f(14, S = N)), component_subscribe(u, devToolsEnabled, (N) => f(15, $ = N)), component_subscribe(u, builderStore, (N) => f(7, w = N)), component_subscribe(u, themeStore, (N) => f(8, T = N)), component_subscribe(u, environmentStore, (N) => f(9, E = N)), component_subscribe(u, featuresStore, (N) => f(10, R = N)), component_subscribe(u, recaptchaStore, (N) => f(11, O = N)), component_subscribe(u, devToolsStore, (N) => f(12, P = N));
  const L = createContextStore();
  setContext("sdk", SDK), setContext("component", writable({ id: null, ancestors: [] })), setContext("context", L), L.actions.provideAction("all", ActionTypes.RefreshDatasource, () => {
    dataSourceStore.actions.refreshAll();
  });
  let M = !1, B = !1, j = !1, x = !1;
  return onMount(async () => {
    document.fonts.ready.then(() => {
      f(1, x = !0);
    }), await initialise(), await authStore.actions.fetchUser(), f(0, M = !0);
    const N = popNumSessionsInvalidated();
    N > 0 && notificationStore.actions.info(invalidationMessage(N), !0, 5e3), get_store_value(builderStore).inBuilder ? builderStore.actions.notifyLoaded() : builderStore.actions.analyticsPing({ embedded: !!v.embedded });
    const D = () => {
      var F, U;
      const { open: V } = y;
      V && !((F = m.activeScreen.onLoad) != null && F.some((Y) => Y["##eventHandlerType"] === "Open Side Panel")) && sidePanelStore.actions.close();
      const { open: W } = b;
      W && !((U = m.activeScreen.onLoad) != null && U.some((Y) => Y["##eventHandlerType"] === "Open Modal")) && modalStore.actions.close();
    };
    return window.addEventListener("hashchange", D), () => {
      window.removeEventListener("hashchange", D);
    };
  }), u.$$.update = () => {
    var N, D, V;
    if (u.$$.dirty & /*$devToolsEnabled, $routeStore*/
    49152 && f(6, p = $ && !((N = S.queryParams) != null && N.peek)), u.$$.dirty & /*dataLoaded, $routeStore, $screenStore, $authStore, $appStore*/
    24589 && M && S.routerLoaded && !S.activeRoute)
      if (m.screens.length) {
        const W = (D = m.screens[0].routing) == null ? void 0 : D.route;
        W ? (f(4, B = !1), routeStore.actions.navigate(W)) : (f(4, B = !0), console.error("No route found but screens exist"));
      } else if (k)
        f(4, B = !0);
      else if (v.embedded)
        f(5, j = !0);
      else {
        const W = `${window.location.pathname}${window.location.hash}`;
        setCookie(Cookies.ReturnUrl, W), window.location = "/builder/auth/login";
      }
    u.$$.dirty & /*dataLoaded, fontsLoaded*/
    3 && M && x && ((V = document.getElementById("clientAppSkeletonLoader")) == null || V.remove());
  }, [
    M,
    x,
    m,
    v,
    B,
    j,
    p,
    w,
    T,
    E,
    R,
    O,
    P,
    k,
    S,
    $
  ];
}
class ClientApp extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance$1, create_fragment$1, safe_not_equal, {});
  }
}
function create_fragment(u) {
  let l, f, p, m;
  return f = new Updating({
    props: {
      isMigrationDone: (
        /*isMigrationDone*/
        u[1]
      ),
      onMigrationDone
    }
  }), {
    c() {
      l = element("div"), create_component(f.$$.fragment), attr(l, "id", "spectrum-root"), attr(l, "lang", "en"), attr(l, "dir", "ltr"), attr(l, "class", p = "spectrum spectrum--medium " + getThemeClassNames(
        /*$themeStore*/
        u[0].theme
      ));
    },
    m(b, y) {
      insert(b, l, y), mount_component(f, l, null), m = !0;
    },
    p(b, [y]) {
      (!m || y & /*$themeStore*/
      1 && p !== (p = "spectrum spectrum--medium " + getThemeClassNames(
        /*$themeStore*/
        b[0].theme
      ))) && attr(l, "class", p);
    },
    i(b) {
      m || (transition_in(f.$$.fragment, b), m = !0);
    },
    o(b) {
      transition_out(f.$$.fragment, b), m = !1;
    },
    d(b) {
      b && detach(l), destroy_component(f);
    }
  };
}
async function onMigrationDone() {
  window.location.reload();
}
function instance(u, l, f) {
  let p;
  component_subscribe(u, themeStore, (b) => f(0, p = b));
  async function m() {
    return (await API.getMigrationStatus()).migrated;
  }
  return onMount(() => {
    var b;
    (b = document.getElementById("clientAppSkeletonLoader")) == null || b.remove();
  }), [p, m];
}
class UpdatingApp extends SvelteComponent {
  constructor(l) {
    super(), init$1(this, l, instance, create_fragment, safe_not_equal, {});
  }
}
let socket;
const initWebsocket = () => {
  const { inBuilder: u, location: l } = get_store_value(builderStore), { cloud: f } = get_store_value(environmentStore);
  !u || !l || f || socket || (socket = createWebsocket("/socket/client", {
    heartbeat: !1
  }), socket.on("plugin-update", (p) => {
    builderStore.actions.updateUsedPlugin(p.name, p.hash), notificationStore.actions.info(`"${p.name}" plugin reloaded`);
  }));
};
typeof window < "u" && window.addEventListener("beforeinstallprompt", (u) => {
  u.preventDefault(), window.deferredPwaPrompt = u;
});
window.svelte_internal = internal;
window.svelte = svelte;
let app;
const loadBudibase = async () => {
  var u;
  if (builderStore.set({
    ...get_store_value(builderStore),
    inBuilder: !!window["##BUDIBASE_IN_BUILDER##"],
    screen: window["##BUDIBASE_PREVIEW_SCREEN##"],
    selectedComponentId: window["##BUDIBASE_SELECTED_COMPONENT_ID##"],
    previewId: window["##BUDIBASE_PREVIEW_ID##"],
    theme: window["##BUDIBASE_PREVIEW_THEME##"],
    customTheme: window["##BUDIBASE_PREVIEW_CUSTOM_THEME##"],
    previewDevice: window["##BUDIBASE_PREVIEW_DEVICE##"],
    navigation: window["##BUDIBASE_PREVIEW_NAVIGATION##"],
    hiddenComponentIds: window["##BUDIBASE_HIDDEN_COMPONENT_IDS##"],
    usedPlugins: window["##BUDIBASE_USED_PLUGINS##"],
    snippets: window["##BUDIBASE_SNIPPETS##"],
    componentErrors: window["##BUDIBASE_COMPONENT_ERRORS##"]
  }), appStore.actions.setAppId(window["##BUDIBASE_APP_ID##"]), appStore.actions.setAppEmbedded(
    window["##BUDIBASE_APP_EMBEDDED##"] === "true"
  ), window.MIGRATING_APP) {
    app || (app = new UpdatingApp({
      target: window.document.body
    }));
    return;
  }
  (u = get_store_value(environmentStore)) != null && u.loaded || await environmentStore.actions.fetchEnvironment(), window.handleBuilderRuntimeEvent = (l, f) => {
    if (window["##BUDIBASE_IN_BUILDER##"]) {
      if (l === "event-completed")
        eventStore.actions.resolveEvent(f);
      else if (l === "eject-block") {
        const p = blockStore.actions.getBlock(f);
        p == null || p.eject();
      } else if (l === "dragging-new-component") {
        const { dragging: p, component: m } = f;
        p ? dndStore.actions.startDraggingNewComponent(m) : dndStore.actions.reset();
      } else if (l === "request-context") {
        const { selectedComponentInstance: p, screenslotInstance: m } = get_store_value(componentStore), b = p || m, y = b == null ? void 0 : b.getDataContext();
        let v = null;
        try {
          v = JSON.stringify(y);
        } catch {
        }
        eventStore.actions.dispatchEvent("provide-context", {
          context: v
        });
      } else if (l === "hover-component")
        hoverStore.actions.hoverComponent(f, !1);
      else if (l === "builder-meta")
        builderStore.actions.setMetadata(f);
      else if (l === "builder-state") {
        const [[p, m]] = Object.entries(f);
        stateStore.actions.setValue(p, m);
      } else if (l === "builder-url-test-data") {
        const { route: p, testValue: m } = f;
        routeStore.actions.setTestUrlParams(p, m);
      }
    }
  }, window["##BUDIBASE_CUSTOM_COMPONENTS##"] && window["##BUDIBASE_CUSTOM_COMPONENTS##"].forEach((l) => {
    componentStore.actions.registerCustomComponent(l);
  }), window.registerCustomComponent = componentStore.actions.registerCustomComponent, initWebsocket(), app || (app = new ClientApp({
    target: window.document.body
  }));
};
window.loadBudibase = loadBudibase;
export {
  Popover as $,
  check_outros as A,
  noop$4 as B,
  subscribe as C,
  fetchData as D,
  EmptyFilterOption as E,
  create_slot as F,
  update_slot_base as G,
  get_all_dirty_from_scope as H,
  Icon as I,
  get_slot_changes as J,
  Block as K,
  LogicalOperator as L,
  BlockComponent as M,
  ensure_array_like as N,
  destroy_each as O,
  ProgressCircle as P,
  add_render_callback as Q,
  create_bidirectional_transition as R,
  SvelteComponent as S,
  slide as T,
  onMount as U,
  bubble as V,
  binding_callbacks as W,
  setContext as X,
  createEventDispatcher as Y,
  create_in_transition as Z,
  fade as _,
  space as a,
  ArrayOperator as a$,
  bind as a0,
  add_flush_callback as a1,
  derived as a2,
  writable as a3,
  ModalContent as a4,
  Body as a5,
  notifications as a6,
  Input as a7,
  loc as a8,
  parse as a9,
  DefaultColumnWidth as aA,
  CellIDSeparator as aB,
  GeneratedIDPrefix as aC,
  MinColumnWidth as aD,
  getRelatedTableValues as aE,
  tick as aF,
  RowPageSize as aG,
  NewRowID as aH,
  sleep as aI,
  capitalise as aJ,
  FieldType as aK,
  VPadding as aL,
  FocusedCellMinOffset as aM,
  HPadding as aN,
  ScrollBarSize as aO,
  DefaultRowHeight as aP,
  LargeRowHeight as aQ,
  MediumRowHeight as aR,
  getUserColor as aS,
  getUserLabel as aT,
  copyToClipboard as aU,
  ViewV2Type as aV,
  derivedMemo as aW,
  memo as aX,
  SortOrder as aY,
  UILogicalOperator as aZ,
  BasicOperator as a_,
  screenStore as aa,
  builderStore as ab,
  Modal as ac,
  API as ad,
  src_url_equal as ae,
  clickOutside as af,
  Heading as ag,
  Roles as ah,
  getActiveConditions as ai,
  reduceConditionActions as aj,
  set_data_contenteditable as ak,
  set_style as al,
  null_to_empty as am,
  Select_1 as an,
  dayjs as ao,
  Button as ap,
  ClearButton as aq,
  commonjsGlobal$1 as ar,
  getDefaultExportFromCjs$1 as as,
  uuid as at,
  compute_slots as au,
  AbsTooltip as av,
  isDeprecatedSingleUserColumn as aw,
  TypeIconMap as ax,
  GutterWidth as ay,
  get_store_value as az,
  attr as b,
  SEPARATOR$1 as b$,
  getDatasourceSchema as b0,
  enrichSchemaWithRelColumns as b1,
  getDatasourceDefinition as b2,
  cloneDeep$3 as b3,
  Conditions as b4,
  self$1 as b5,
  domDebounce as b6,
  TextCell as b7,
  getCellRenderer as b8,
  construct_svelte_component as b9,
  parseDate as bA,
  Field as bB,
  PopoverAlignment as bC,
  cloneDeep$5 as bD,
  OperatorOptions as bE,
  FilterValueType as bF,
  stringifyDate as bG,
  RangeOperator as bH,
  getDateDisplayValue as bI,
  uiStateStore as bJ,
  componentStore as bK,
  ActionTypes as bL,
  getAction as bM,
  InternalTable as bN,
  getValidOperatorsForType as bO,
  GridColumns as bP,
  GridRowHeight as bQ,
  get_spread_update as bR,
  get_spread_object as bS,
  svg_element as bT,
  shortid as bU,
  makePropSafe as bV,
  buildFormBlockButtonConfig as bW,
  update_keyed_each as bX,
  outro_and_destroy_block as bY,
  set_data_maybe_contenteditable as bZ,
  DocumentType as b_,
  set_store_value as ba,
  BlankRowID as bb,
  GridPopover as bc,
  ValidColumnNameRegex as bd,
  FormulaType as be,
  debounce as bf,
  set_input_value as bg,
  TableNames as bh,
  TooltipType as bi,
  Checkbox_1 as bj,
  createWebsocket as bk,
  SocketEvent as bl,
  GridSocketEvent as bm,
  MaxCellRenderOverflow as bn,
  ControlsHeight as bo,
  createAPIClient as bp,
  Constants as bq,
  SmallRowHeight as br,
  assign as bs,
  exclude_internal_props as bt,
  featuresStore as bu,
  processStringSync as bv,
  readable as bw,
  TooltipPosition as bx,
  Avatar as by,
  getUserInitials as bz,
  create_component as c,
  getAugmentedNamespace as c0,
  marked as c1,
  init_binding_group as c2,
  DatePickerPopoverContents as c3,
  processSearchFilters as c4,
  Select as c5,
  Picker as c6,
  deepSet as c7,
  createValidatorFromConstraints as c8,
  deepGet as c9,
  OnEmptyFilter as ca,
  buildMultiStepFormBlockDefaultProps as cb,
  shortid$1 as cc,
  Portal as cd,
  ActionButton as ce,
  isJSBinding as cf,
  Constants$1 as cg,
  findHBSBlocks as ch,
  Layout as ci,
  FilterOperator as cj,
  BannedSearchTypes as ck,
  parseFilter as cl,
  hashString as cm,
  TextField as cn,
  Checkbox as co,
  Dropzone$1 as cp,
  compute_rest_props as cq,
  StatusLight as cr,
  SignatureModal as cs,
  Signature as ct,
  CustomThemeWrapper as cu,
  stringifyRow as cv,
  Link as cw,
  stop_propagation as cx,
  Provider as cy,
  toggle_class as d,
  element as e,
  insert as f,
  append$1 as g,
  is_function as h,
  init$1 as i,
  set_data as j,
  transition_in as k,
  listen as l,
  mount_component as m,
  transition_out as n,
  detach as o,
  destroy_component as p,
  action_destroyer as q,
  run_all as r,
  safe_not_equal as s,
  text$2 as t,
  getContext$1 as u,
  component_subscribe as v,
  onDestroy as w,
  buildQuery$1 as x,
  empty$1 as y,
  group_outros as z
};
